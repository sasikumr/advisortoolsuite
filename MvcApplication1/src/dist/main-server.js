(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 154);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var Context = (function () {
    function Context(params, logger) {
        this.beans = {};
        this.componentsMappedByName = {};
        this.destroyed = false;
        if (!params || !params.beans) {
            return;
        }
        this.contextParams = params;
        this.logger = logger;
        this.logger.log('>> creating ag-Application Context');
        this.setupComponents();
        this.createBeans();
        var beans = utils_1.Utils.mapObject(this.beans, function (beanEntry) { return beanEntry.beanInstance; });
        this.wireBeans(beans);
        this.logger.log('>> ag-Application Context ready - component is alive');
    }
    Context.prototype.setupComponents = function () {
        var _this = this;
        if (this.contextParams.components) {
            this.contextParams.components.forEach(function (componentMeta) { return _this.addComponent(componentMeta); });
        }
    };
    Context.prototype.addComponent = function (componentMeta) {
        // get name of the class as a string
        // let className = _.getNameOfClass(ComponentClass);
        // insert a dash after every capital letter
        // let classEscaped = className.replace(/([A-Z])/g, "-$1").toLowerCase();
        var classEscaped = componentMeta.componentName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        // put all to upper case
        var classUpperCase = classEscaped.toUpperCase();
        // finally store
        this.componentsMappedByName[classUpperCase] = componentMeta.theClass;
    };
    Context.prototype.createComponent = function (element) {
        var key = element.nodeName;
        if (this.componentsMappedByName && this.componentsMappedByName[key]) {
            var newComponent = new this.componentsMappedByName[key];
            this.wireBean(newComponent);
            this.copyAttributesFromNode(element, newComponent.getGui());
            newComponent.attributesSet();
            return newComponent;
        }
        else {
            return null;
        }
    };
    Context.prototype.copyAttributesFromNode = function (fromNode, toNode) {
        if (fromNode.attributes) {
            var count = fromNode.attributes.length;
            for (var i = 0; i < count; i++) {
                var attr = fromNode.attributes[i];
                toNode.setAttribute(attr.name, attr.value);
            }
        }
    };
    Context.prototype.wireBean = function (bean) {
        if (!bean)
            throw Error("Can't wire to bean since it is null");
        this.wireBeans([bean]);
    };
    Context.prototype.wireBeans = function (beans) {
        this.autoWireBeans(beans);
        this.methodWireBeans(beans);
        this.preConstruct(beans);
        this.postConstruct(beans);
    };
    Context.prototype.createBeans = function () {
        var _this = this;
        // register all normal beans
        this.contextParams.beans.forEach(this.createBeanEntry.bind(this));
        // register override beans, these will overwrite beans above of same name
        if (this.contextParams.overrideBeans) {
            this.contextParams.overrideBeans.forEach(this.createBeanEntry.bind(this));
        }
        // instantiate all beans - overridden beans will be left out
        utils_1.Utils.iterateObject(this.beans, function (key, beanEntry) {
            var constructorParamsMeta;
            if (beanEntry.bean.__agBeanMetaData
                && beanEntry.bean.__agBeanMetaData.autowireMethods
                && beanEntry.bean.__agBeanMetaData.autowireMethods.agConstructor) {
                constructorParamsMeta = beanEntry.bean.__agBeanMetaData.autowireMethods.agConstructor;
            }
            var constructorParams = _this.getBeansForParameters(constructorParamsMeta, beanEntry.bean.name);
            var newInstance = applyToConstructor(beanEntry.bean, constructorParams);
            beanEntry.beanInstance = newInstance;
            _this.logger.log('bean ' + _this.getBeanName(newInstance) + ' created');
        });
    };
    Context.prototype.createBeanEntry = function (Bean) {
        var metaData = Bean.__agBeanMetaData;
        if (!metaData) {
            var beanName = void 0;
            if (Bean.prototype.constructor) {
                beanName = Bean.prototype.constructor.name;
            }
            else {
                beanName = '' + Bean;
            }
            console.error('context item ' + beanName + ' is not a bean');
            return;
        }
        var beanEntry = {
            bean: Bean,
            beanInstance: null,
            beanName: metaData.beanName
        };
        this.beans[metaData.beanName] = beanEntry;
    };
    Context.prototype.autoWireBeans = function (beans) {
        var _this = this;
        beans.forEach(function (bean) { return _this.autoWireBean(bean); });
    };
    Context.prototype.methodWireBeans = function (beans) {
        var _this = this;
        beans.forEach(function (bean) {
            if (!bean)
                throw Error("Can't wire to bean since it is null");
            return _this.methodWireBean(bean);
        });
    };
    Context.prototype.autoWireBean = function (bean) {
        var _this = this;
        var currentBean = bean;
        var _loop_1 = function () {
            var currentConstructor = currentBean.constructor;
            if (currentConstructor.__agBeanMetaData
                && currentConstructor.__agBeanMetaData.agClassAttributes) {
                var attributes = currentConstructor.__agBeanMetaData.agClassAttributes;
                if (!attributes) {
                    return { value: void 0 };
                }
                var beanName_1 = this_1.getBeanName(currentConstructor);
                attributes.forEach(function (attribute) {
                    var otherBean = _this.lookupBeanInstance(beanName_1, attribute.beanName, attribute.optional);
                    bean[attribute.attributeName] = otherBean;
                });
            }
            currentBean = Object.getPrototypeOf(currentBean) ? Object.getPrototypeOf(currentBean) : null;
        };
        var this_1 = this;
        while (currentBean != null) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
    };
    Context.prototype.getBeanName = function (constructor) {
        if (constructor.__agBeanMetaData && constructor.__agBeanMetaData.beanName) {
            return constructor.__agBeanMetaData.beanName;
        }
        var constructorString = constructor.toString();
        var beanName = constructorString.substring(9, constructorString.indexOf('('));
        return beanName;
    };
    Context.prototype.methodWireBean = function (bean) {
        var _this = this;
        var autowiredMethods;
        if (bean.constructor.__agBeanMetaData && bean.constructor.__agBeanMetaData.autowireMethods) {
            autowiredMethods = bean.constructor.__agBeanMetaData.autowireMethods;
        }
        utils_1.Utils.iterateObject(autowiredMethods, function (methodName, wireParams) {
            // skip constructor, as this is dealt with elsewhere
            if (methodName === 'agConstructor') {
                return;
            }
            var beanName = _this.getBeanName(bean.constructor);
            var initParams = _this.getBeansForParameters(wireParams, beanName);
            bean[methodName].apply(bean, initParams);
        });
    };
    Context.prototype.getBeansForParameters = function (parameters, beanName) {
        var _this = this;
        var beansList = [];
        if (parameters) {
            utils_1.Utils.iterateObject(parameters, function (paramIndex, otherBeanName) {
                var otherBean = _this.lookupBeanInstance(beanName, otherBeanName);
                beansList[Number(paramIndex)] = otherBean;
            });
        }
        return beansList;
    };
    Context.prototype.lookupBeanInstance = function (wiringBean, beanName, optional) {
        if (optional === void 0) { optional = false; }
        if (beanName === 'context') {
            return this;
        }
        else if (this.contextParams.seed && this.contextParams.seed.hasOwnProperty(beanName)) {
            return this.contextParams.seed[beanName];
        }
        else {
            var beanEntry = this.beans[beanName];
            if (beanEntry) {
                return beanEntry.beanInstance;
            }
            if (!optional) {
                console.error('ag-Grid: unable to find bean reference ' + beanName + ' while initialising ' + wiringBean);
            }
            return null;
        }
    };
    Context.prototype.postConstruct = function (beans) {
        beans.forEach(function (bean) {
            // try calling init methods
            if (bean.constructor.__agBeanMetaData && bean.constructor.__agBeanMetaData.postConstructMethods) {
                bean.constructor.__agBeanMetaData && bean.constructor.__agBeanMetaData.postConstructMethods.forEach(function (methodName) { return bean[methodName](); });
            }
        });
    };
    Context.prototype.preConstruct = function (beans) {
        beans.forEach(function (bean) {
            // try calling init methods
            if (bean.constructor.__agBeanMetaData && bean.constructor.__agBeanMetaData.preConstructMethods) {
                bean.constructor.__agBeanMetaData.preConstructMethods.forEach(function (methodName) { return bean[methodName](); });
            }
        });
    };
    Context.prototype.getBean = function (name) {
        return this.lookupBeanInstance('getBean', name, true);
    };
    Context.prototype.destroy = function () {
        // should only be able to destroy once
        if (this.destroyed) {
            return;
        }
        this.logger.log('>> Shutting down ag-Application Context');
        // try calling destroy methods
        utils_1.Utils.iterateObject(this.beans, function (key, beanEntry) {
            var bean = beanEntry.beanInstance;
            if (bean.constructor.__agBeanMetaData && bean.constructor.__agBeanMetaData.preDestroyMethods) {
                bean.constructor.__agBeanMetaData.preDestroyMethods.forEach(function (methodName) { return bean[methodName](); });
            }
        });
        this.destroyed = true;
        this.logger.log('>> ag-Application Context shut down - component is dead');
    };
    return Context;
}());
exports.Context = Context;
// taken from: http://stackoverflow.com/questions/3362471/how-can-i-call-a-javascript-constructor-using-call-or-apply
// allows calling 'apply' on a constructor
function applyToConstructor(constructor, argArray) {
    var args = [null].concat(argArray);
    var factoryFunction = constructor.bind.apply(constructor, args);
    return new factoryFunction();
}
function PreConstruct(target, methodName, descriptor) {
    var props = getOrCreateProps(target.constructor);
    if (!props.postConstructMethods) {
        props.preConstructMethods = [];
    }
    props.preConstructMethods.push(methodName);
}
exports.PreConstruct = PreConstruct;
function PostConstruct(target, methodName, descriptor) {
    var props = getOrCreateProps(target.constructor);
    if (!props.postConstructMethods) {
        props.postConstructMethods = [];
    }
    props.postConstructMethods.push(methodName);
}
exports.PostConstruct = PostConstruct;
function PreDestroy(target, methodName, descriptor) {
    var props = getOrCreateProps(target.constructor);
    if (!props.preDestroyMethods) {
        props.preDestroyMethods = [];
    }
    props.preDestroyMethods.push(methodName);
}
exports.PreDestroy = PreDestroy;
function Bean(beanName) {
    return function (classConstructor) {
        var props = getOrCreateProps(classConstructor);
        props.beanName = beanName;
    };
}
exports.Bean = Bean;
function Autowired(name) {
    return function (target, propertyKey, descriptor) {
        autowiredFunc(target, name, false, target, propertyKey, null);
    };
}
exports.Autowired = Autowired;
function Optional(name) {
    return function (target, propertyKey, descriptor) {
        autowiredFunc(target, name, true, target, propertyKey, null);
    };
}
exports.Optional = Optional;
function autowiredFunc(target, name, optional, classPrototype, methodOrAttributeName, index) {
    if (name === null) {
        console.error('ag-Grid: Autowired name should not be null');
        return;
    }
    if (typeof index === 'number') {
        console.error('ag-Grid: Autowired should be on an attribute');
        return;
    }
    // it's an attribute on the class
    var props = getOrCreateProps(target.constructor);
    if (!props.agClassAttributes) {
        props.agClassAttributes = [];
    }
    props.agClassAttributes.push({
        attributeName: methodOrAttributeName,
        beanName: name,
        optional: optional
    });
}
function Qualifier(name) {
    return function (classPrototype, methodOrAttributeName, index) {
        var constructor = (typeof classPrototype == 'function') ? classPrototype : classPrototype.constructor;
        var props;
        if (typeof index === 'number') {
            // it's a parameter on a method
            var methodName = void 0;
            if (methodOrAttributeName) {
                props = getOrCreateProps(constructor);
                methodName = methodOrAttributeName;
            }
            else {
                props = getOrCreateProps(constructor);
                methodName = 'agConstructor';
            }
            if (!props.autowireMethods) {
                props.autowireMethods = {};
            }
            if (!props.autowireMethods[methodName]) {
                props.autowireMethods[methodName] = {};
            }
            props.autowireMethods[methodName][index] = name;
        }
    };
}
exports.Qualifier = Qualifier;
function getOrCreateProps(target) {
    if (!target.hasOwnProperty('__agBeanMetaData')) {
        target.__agBeanMetaData = {};
    }
    return target.__agBeanMetaData;
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var FUNCTION_STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var FUNCTION_ARGUMENT_NAMES = /([^\s,]+)/g;
// util class, only used when debugging, for printing time to console
var Timer = (function () {
    function Timer() {
        this.timestamp = new Date().getTime();
    }
    Timer.prototype.print = function (msg) {
        var duration = (new Date().getTime()) - this.timestamp;
        console.log(msg + " = " + duration);
        this.timestamp = new Date().getTime();
    };
    return Timer;
}());
exports.Timer = Timer;
/** HTML Escapes. */
var HTML_ESCAPES = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
};
var reUnescapedHtml = /[&<>"']/g;
var Utils = (function () {
    function Utils() {
    }
    Utils.mimicAsync = function (callback) {
        callback();
    };
    // returns true if the event is close to the original event by X pixels either vertically or horizontally.
    // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
    Utils.areEventsNear = function (e1, e2, pixelCount) {
        // by default, we wait 4 pixels before starting the drag
        if (pixelCount === 0) {
            return false;
        }
        var diffX = Math.abs(e1.clientX - e2.clientX);
        var diffY = Math.abs(e1.clientY - e2.clientY);
        return Math.max(diffX, diffY) <= pixelCount;
    };
    Utils.shallowCompare = function (arr1, arr2) {
        // if both are missing, then they are the same
        if (this.missing(arr1) && this.missing(arr2)) {
            return true;
        }
        // if one is present, but other is missing, then then are different
        if (this.missing(arr1) || this.missing(arr2)) {
            return false;
        }
        if (arr1.length !== arr2.length) {
            return false;
        }
        for (var i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        return true;
    };
    Utils.getNameOfClass = function (TheClass) {
        var funcNameRegex = /function (.{1,})\(/;
        var funcAsString = TheClass.toString();
        var results = (funcNameRegex).exec(funcAsString);
        return (results && results.length > 1) ? results[1] : "";
    };
    Utils.values = function (object) {
        var result = [];
        this.iterateObject(object, function (key, value) {
            result.push(value);
        });
        return result;
    };
    Utils.getValueUsingField = function (data, field, fieldContainsDots) {
        if (!field || !data) {
            return;
        }
        // if no '.', then it's not a deep value
        if (!fieldContainsDots) {
            return data[field];
        }
        else {
            // otherwise it is a deep value, so need to dig for it
            var fields = field.split('.');
            var currentObject = data;
            for (var i = 0; i < fields.length; i++) {
                currentObject = currentObject[fields[i]];
                if (this.missing(currentObject)) {
                    return null;
                }
            }
            return currentObject;
        }
    };
    Utils.getScrollLeft = function (element, rtl) {
        var scrollLeft = element.scrollLeft;
        if (rtl) {
            // Absolute value - for FF that reports RTL scrolls in negative numbers
            scrollLeft = Math.abs(scrollLeft);
            // Get Chrome and Safari to return the same value as well
            if (this.isBrowserSafari() || this.isBrowserChrome()) {
                scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;
            }
        }
        return scrollLeft;
    };
    Utils.cleanNumber = function (value) {
        if (typeof value === 'string') {
            value = parseInt(value);
        }
        if (typeof value === 'number') {
            value = Math.floor(value);
        }
        else {
            value = null;
        }
        return value;
    };
    Utils.setScrollLeft = function (element, value, rtl) {
        if (rtl) {
            // Chrome and Safari when doing RTL have the END position of the scroll as zero, not the start
            if (this.isBrowserSafari() || this.isBrowserChrome()) {
                value = element.scrollWidth - element.clientWidth - value;
            }
            // Firefox uses negative numbers when doing RTL scrolling
            if (this.isBrowserFirefox()) {
                value *= -1;
            }
        }
        element.scrollLeft = value;
    };
    Utils.iterateObject = function (object, callback) {
        if (this.missing(object)) {
            return;
        }
        var keys = Object.keys(object);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = object[key];
            callback(key, value);
        }
    };
    Utils.cloneObject = function (object) {
        var copy = {};
        var keys = Object.keys(object);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = object[key];
            copy[key] = value;
        }
        return copy;
    };
    Utils.map = function (array, callback) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
            var item = array[i];
            var mappedItem = callback(item);
            result.push(mappedItem);
        }
        return result;
    };
    Utils.mapObject = function (object, callback) {
        var result = [];
        Utils.iterateObject(object, function (key, value) {
            result.push(callback(value));
        });
        return result;
    };
    Utils.forEach = function (array, callback) {
        if (!array) {
            return;
        }
        for (var i = 0; i < array.length; i++) {
            var value = array[i];
            callback(value, i);
        }
    };
    Utils.filter = function (array, callback) {
        var result = [];
        array.forEach(function (item) {
            if (callback(item)) {
                result.push(item);
            }
        });
        return result;
    };
    Utils.getAllKeysInObjects = function (objects) {
        var allValues = {};
        objects.forEach(function (obj) {
            if (obj) {
                Object.keys(obj).forEach(function (key) { return allValues[key] = null; });
            }
        });
        return Object.keys(allValues);
    };
    Utils.mergeDeep = function (dest, source) {
        if (this.exists(source)) {
            this.iterateObject(source, function (key, newValue) {
                var oldValue = dest[key];
                if (oldValue === newValue) {
                    return;
                }
                if (typeof oldValue === 'object' && typeof newValue === 'object') {
                    Utils.mergeDeep(oldValue, newValue);
                }
                else {
                    dest[key] = newValue;
                }
            });
        }
    };
    Utils.assign = function (object) {
        var _this = this;
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) {
            if (_this.exists(source)) {
                _this.iterateObject(source, function (key, value) {
                    object[key] = value;
                });
            }
        });
        return object;
    };
    Utils.parseYyyyMmDdToDate = function (yyyyMmDd, separator) {
        try {
            if (!yyyyMmDd)
                return null;
            if (yyyyMmDd.indexOf(separator) === -1)
                return null;
            var fields = yyyyMmDd.split(separator);
            if (fields.length != 3)
                return null;
            return new Date(Number(fields[0]), Number(fields[1]) - 1, Number(fields[2]));
        }
        catch (e) {
            return null;
        }
    };
    Utils.serializeDateToYyyyMmDd = function (date, separator) {
        if (!date)
            return null;
        return date.getFullYear() + separator + Utils.pad(date.getMonth() + 1, 2) + separator + Utils.pad(date.getDate(), 2);
    };
    Utils.pad = function (num, totalStringSize) {
        var asString = num + "";
        while (asString.length < totalStringSize)
            asString = "0" + asString;
        return asString;
    };
    Utils.pushAll = function (target, source) {
        if (this.missing(source) || this.missing(target)) {
            return;
        }
        source.forEach(function (func) { return target.push(func); });
    };
    Utils.createArrayOfNumbers = function (first, last) {
        var result = [];
        for (var i = first; i <= last; i++) {
            result.push(i);
        }
        return result;
    };
    Utils.getFunctionParameters = function (func) {
        var fnStr = func.toString().replace(FUNCTION_STRIP_COMMENTS, '');
        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(FUNCTION_ARGUMENT_NAMES);
        if (result === null) {
            return [];
        }
        else {
            return result;
        }
    };
    Utils.find = function (collection, predicate, value) {
        if (collection === null || collection === undefined) {
            return null;
        }
        if (!Array.isArray(collection)) {
            var objToArray = this.values(collection);
            return this.find(objToArray, predicate, value);
        }
        var collectionAsArray = collection;
        var firstMatchingItem;
        for (var i = 0; i < collectionAsArray.length; i++) {
            var item = collectionAsArray[i];
            if (typeof predicate === 'string') {
                if (item[predicate] === value) {
                    firstMatchingItem = item;
                    break;
                }
            }
            else {
                var callback = predicate;
                if (callback(item)) {
                    firstMatchingItem = item;
                    break;
                }
            }
        }
        return firstMatchingItem;
    };
    Utils.toStrings = function (array) {
        return this.map(array, function (item) {
            if (item === undefined || item === null || !item.toString) {
                return null;
            }
            else {
                return item.toString();
            }
        });
    };
    Utils.iterateArray = function (array, callback) {
        for (var index = 0; index < array.length; index++) {
            var value = array[index];
            callback(value, index);
        }
    };
    //Returns true if it is a DOM node
    //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
    Utils.isNode = function (o) {
        return (typeof Node === "function" ? o instanceof Node :
            o && typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string");
    };
    //Returns true if it is a DOM element
    //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
    Utils.isElement = function (o) {
        return (typeof HTMLElement === "function" ? o instanceof HTMLElement :
            o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string");
    };
    Utils.isNodeOrElement = function (o) {
        return this.isNode(o) || this.isElement(o);
    };
    Utils.isEventFromPrintableCharacter = function (event) {
        var pressedChar = String.fromCharCode(event.charCode);
        if (exports._.exists(event.key)) {
            // modern browser will implement key, so we return if key is length 1, eg if it is 'a' for the
            // a key, or '2' for the '2' key. non-printable characters have names, eg 'Enter' or 'Backspace'.
            return event.key.length === 1;
        }
        else {
            // otherwise, for older browsers, we test against a list of characters, which doesn't include
            // accents for non-English, but don't care much, as most users are on modern browsers
            return Utils.PRINTABLE_CHARACTERS.indexOf(pressedChar) >= 0;
        }
    };
    //adds all type of change listeners to an element, intended to be a text field
    Utils.addChangeListener = function (element, listener) {
        element.addEventListener("changed", listener);
        element.addEventListener("paste", listener);
        element.addEventListener("input", listener);
        // IE doesn't fire changed for special keys (eg delete, backspace), so need to
        // listen for this further ones
        element.addEventListener("keydown", listener);
        element.addEventListener("keyup", listener);
    };
    //if value is undefined, null or blank, returns null, otherwise returns the value
    Utils.makeNull = function (value) {
        if (value === null || value === undefined || value === "") {
            return null;
        }
        else {
            return value;
        }
    };
    Utils.missing = function (value) {
        return !this.exists(value);
    };
    Utils.missingOrEmpty = function (value) {
        return this.missing(value) || value.length === 0;
    };
    Utils.missingOrEmptyObject = function (value) {
        return this.missing(value) || Object.keys(value).length === 0;
    };
    Utils.exists = function (value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        else {
            return true;
        }
    };
    Utils.firstExistingValue = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        for (var i = 0; i < values.length; i++) {
            var value = values[i];
            if (exports._.exists(value))
                return value;
        }
        return null;
    };
    Utils.anyExists = function (values) {
        if (values) {
            for (var i = 0; i < values.length; i++) {
                if (this.exists(values[i])) {
                    return true;
                }
            }
        }
        return false;
    };
    Utils.existsAndNotEmpty = function (value) {
        return this.exists(value) && value.length > 0;
    };
    Utils.removeAllChildren = function (node) {
        if (node) {
            while (node.hasChildNodes()) {
                node.removeChild(node.lastChild);
            }
        }
    };
    Utils.removeElement = function (parent, cssSelector) {
        this.removeFromParent(parent.querySelector(cssSelector));
    };
    Utils.removeFromParent = function (node) {
        if (node && node.parentNode) {
            node.parentNode.removeChild(node);
        }
    };
    Utils.isVisible = function (element) {
        return (element.offsetParent !== null);
    };
    /**
     * loads the template and returns it as an element. makes up for no simple way in
     * the dom api to load html directly, eg we cannot do this: document.createElement(template)
     */
    Utils.loadTemplate = function (template) {
        var tempDiv = document.createElement("div");
        tempDiv.innerHTML = template;
        return tempDiv.firstChild;
    };
    Utils.appendHtml = function (eContainer, htmlTemplate) {
        if (eContainer.lastChild) {
            // https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML
            // we put the items at the start, so new items appear underneath old items,
            // so when expanding/collapsing groups, the new rows don't go on top of the
            // rows below that are moving our of the way
            eContainer.insertAdjacentHTML('afterbegin', htmlTemplate);
        }
        else {
            eContainer.innerHTML = htmlTemplate;
        }
    };
    Utils.addOrRemoveCssClass = function (element, className, addOrRemove) {
        if (addOrRemove) {
            this.addCssClass(element, className);
        }
        else {
            this.removeCssClass(element, className);
        }
    };
    Utils.callIfPresent = function (func) {
        if (func) {
            func();
        }
    };
    Utils.addCssClass = function (element, className) {
        var _this = this;
        if (!className || className.length === 0) {
            return;
        }
        if (className.indexOf(' ') >= 0) {
            className.split(' ').forEach(function (value) { return _this.addCssClass(element, value); });
            return;
        }
        if (element.classList) {
            element.classList.add(className);
        }
        else {
            if (element.className && element.className.length > 0) {
                var cssClasses = element.className.split(' ');
                if (cssClasses.indexOf(className) < 0) {
                    cssClasses.push(className);
                    element.className = cssClasses.join(' ');
                }
            }
            else {
                element.className = className;
            }
        }
    };
    Utils.containsClass = function (element, className) {
        if (element.classList) {
            // for modern browsers
            return element.classList.contains(className);
        }
        else if (element.className) {
            // for older browsers, check against the string of class names
            // if only one class, can check for exact match
            var onlyClass = element.className === className;
            // if many classes, check for class name, we have to pad with ' ' to stop other
            // class names that are a substring of this class
            var contains = element.className.indexOf(' ' + className + ' ') >= 0;
            // the padding above then breaks when it's the first or last class names
            var startsWithClass = element.className.indexOf(className + ' ') === 0;
            var endsWithClass = element.className.lastIndexOf(' ' + className) === (element.className.length - className.length - 1);
            return onlyClass || contains || startsWithClass || endsWithClass;
        }
        else {
            // if item is not a node
            return false;
        }
    };
    Utils.getElementAttribute = function (element, attributeName) {
        if (element.attributes) {
            if (element.attributes[attributeName]) {
                var attribute = element.attributes[attributeName];
                return attribute.value;
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    };
    Utils.offsetHeight = function (element) {
        return element && element.clientHeight ? element.clientHeight : 0;
    };
    Utils.offsetWidth = function (element) {
        return element && element.clientWidth ? element.clientWidth : 0;
    };
    Utils.sortNumberArray = function (numberArray) {
        numberArray.sort(function (a, b) { return a - b; });
    };
    Utils.removeCssClass = function (element, className) {
        if (element.classList) {
            element.classList.remove(className);
        }
        else {
            if (element.className && element.className.length > 0) {
                var cssClasses = element.className.split(' ');
                if (cssClasses.indexOf(className) >= 0) {
                    // remove all instances of the item, not just the first, in case it's in more than once
                    while (cssClasses.indexOf(className) >= 0) {
                        cssClasses.splice(cssClasses.indexOf(className), 1);
                    }
                    element.className = cssClasses.join(' ');
                }
            }
        }
    };
    Utils.removeRepeatsFromArray = function (array, object) {
        if (!array) {
            return;
        }
        for (var index = array.length - 2; index >= 0; index--) {
            var thisOneMatches = array[index] === object;
            var nextOneMatches = array[index + 1] === object;
            if (thisOneMatches && nextOneMatches) {
                array.splice(index + 1, 1);
            }
        }
    };
    Utils.removeFromArray = function (array, object) {
        if (array.indexOf(object) >= 0) {
            array.splice(array.indexOf(object), 1);
        }
    };
    Utils.removeAllFromArray = function (array, toRemove) {
        toRemove.forEach(function (item) {
            if (array.indexOf(item) >= 0) {
                array.splice(array.indexOf(item), 1);
            }
        });
    };
    Utils.insertIntoArray = function (array, object, toIndex) {
        array.splice(toIndex, 0, object);
    };
    Utils.insertArrayIntoArray = function (dest, src, toIndex) {
        if (this.missing(dest) || this.missing(src)) {
            return;
        }
        // put items in backwards, otherwise inserted items end up in reverse order
        for (var i = src.length - 1; i >= 0; i--) {
            var item = src[i];
            this.insertIntoArray(dest, item, toIndex);
        }
    };
    Utils.moveInArray = function (array, objectsToMove, toIndex) {
        var _this = this;
        // first take out it items from the array
        objectsToMove.forEach(function (obj) {
            _this.removeFromArray(array, obj);
        });
        // now add the objects, in same order as provided to us, that means we start at the end
        // as the objects will be pushed to the right as they are inserted
        objectsToMove.slice().reverse().forEach(function (obj) {
            _this.insertIntoArray(array, obj, toIndex);
        });
    };
    Utils.defaultComparator = function (valueA, valueB, accentedCompare) {
        if (accentedCompare === void 0) { accentedCompare = false; }
        var valueAMissing = valueA === null || valueA === undefined;
        var valueBMissing = valueB === null || valueB === undefined;
        // this is for aggregations sum and avg, where the result can be a number that is wrapped.
        // if we didn't do this, then the toString() value would be used, which would result in
        // the strings getting used instead of the numbers.
        if (valueA && valueA.toNumber) {
            valueA = valueA.toNumber();
        }
        if (valueB && valueB.toNumber) {
            valueB = valueB.toNumber();
        }
        if (valueAMissing && valueBMissing) {
            return 0;
        }
        if (valueAMissing) {
            return -1;
        }
        if (valueBMissing) {
            return 1;
        }
        if (typeof valueA === "string") {
            if (!accentedCompare) {
                return doQuickCompare(valueA, valueB);
            }
            else {
                try {
                    // using local compare also allows chinese comparisons
                    return valueA.localeCompare(valueB);
                }
                catch (e) {
                    // if something wrong with localeCompare, eg not supported
                    // by browser, then just continue with the quick one
                    return doQuickCompare(valueA, valueB);
                }
            }
        }
        if (valueA < valueB) {
            return -1;
        }
        else if (valueA > valueB) {
            return 1;
        }
        else {
            return 0;
        }
        function doQuickCompare(a, b) {
            return (a > b ? 1 : (a < b ? -1 : 0));
        }
    };
    Utils.compareArrays = function (array1, array2) {
        if (this.missing(array1) && this.missing(array2)) {
            return true;
        }
        if (this.missing(array1) || this.missing(array2)) {
            return false;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        for (var i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
                return false;
            }
        }
        return true;
    };
    Utils.ensureDomOrder = function (eContainer, eChild, eChildBefore) {
        // if already in right order, do nothing
        if (eChildBefore && eChildBefore.nextSibling === eChild) {
            return;
        }
        if (eChildBefore) {
            if (eChildBefore.nextSibling) {
                // insert between the eRowBefore and the row after it
                eContainer.insertBefore(eChild, eChildBefore.nextSibling);
            }
            else {
                // if nextSibling is missing, means other row is at end, so just append new row at the end
                eContainer.appendChild(eChild);
            }
        }
        else {
            // otherwise put at start
            if (eContainer.firstChild) {
                // insert it at the first location
                eContainer.insertBefore(eChild, eContainer.firstChild);
            }
        }
    };
    Utils.insertWithDomOrder = function (eContainer, eChild, eChildBefore) {
        if (eChildBefore) {
            if (eChildBefore.nextSibling) {
                // insert between the eRowBefore and the row after it
                eContainer.insertBefore(eChild, eChildBefore.nextSibling);
            }
            else {
                // if nextSibling is missing, means other row is at end, so just append new row at the end
                eContainer.appendChild(eChild);
            }
        }
        else {
            if (eContainer.firstChild) {
                // insert it at the first location
                eContainer.insertBefore(eChild, eContainer.firstChild);
            }
            else {
                // otherwise eContainer is empty, so just append it
                eContainer.appendChild(eChild);
            }
        }
    };
    Utils.insertTemplateWithDomOrder = function (eContainer, htmlTemplate, eChildBefore) {
        var res;
        if (eChildBefore) {
            // if previous element exists, just slot in after the previous element
            eChildBefore.insertAdjacentHTML('afterend', htmlTemplate);
            res = eChildBefore.nextSibling;
        }
        else {
            if (eContainer.firstChild) {
                // insert it at the first location
                eContainer.insertAdjacentHTML('afterbegin', htmlTemplate);
            }
            else {
                // otherwise eContainer is empty, so just append it
                eContainer.innerHTML = htmlTemplate;
            }
            res = eContainer.firstChild;
        }
        return res;
    };
    Utils.toStringOrNull = function (value) {
        if (this.exists(value) && value.toString) {
            return value.toString();
        }
        else {
            return null;
        }
    };
    Utils.formatWidth = function (width) {
        if (typeof width === "number") {
            return width + "px";
        }
        else {
            return width;
        }
    };
    Utils.formatNumberTwoDecimalPlacesAndCommas = function (value) {
        if (typeof value !== 'number') {
            return '';
        }
        // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript
        return (Math.round(value * 100) / 100).toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
    };
    // the native method number.toLocaleString(undefined, {minimumFractionDigits: 0}) puts in decimal places in IE,
    // so we use this method instead
    Utils.formatNumberCommas = function (value) {
        if (typeof value !== 'number') {
            return '';
        }
        // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript
        return value.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
    };
    Utils.prependDC = function (parent, documentFragment) {
        if (this.exists(parent.firstChild)) {
            parent.insertBefore(documentFragment, parent.firstChild);
        }
        else {
            parent.appendChild(documentFragment);
        }
    };
    /**
     * If icon provided, use this (either a string, or a function callback).
     * if not, then use the default icon from the theme
     */
    Utils.createIcon = function (iconName, gridOptionsWrapper, column) {
        var iconContents = this.createIconNoSpan(iconName, gridOptionsWrapper, column);
        if (iconContents.className.indexOf('ag-icon') > -1) {
            return iconContents;
        }
        else {
            var eResult = document.createElement('span');
            eResult.appendChild(iconContents);
            return eResult;
        }
    };
    Utils.createIconNoSpan = function (iconName, gridOptionsWrapper, column) {
        var userProvidedIcon;
        // check col for icon first
        if (column && column.getColDef().icons) {
            userProvidedIcon = column.getColDef().icons[iconName];
        }
        // it not in col, try grid options
        if (!userProvidedIcon && gridOptionsWrapper.getIcons()) {
            userProvidedIcon = gridOptionsWrapper.getIcons()[iconName];
        }
        // now if user provided, use it
        if (userProvidedIcon) {
            var rendererResult = void 0;
            if (typeof userProvidedIcon === 'function') {
                rendererResult = userProvidedIcon();
            }
            else if (typeof userProvidedIcon === 'string') {
                rendererResult = userProvidedIcon;
            }
            else {
                throw 'icon from grid options needs to be a string or a function';
            }
            if (typeof rendererResult === 'string') {
                return this.loadTemplate(rendererResult);
            }
            else if (this.isNodeOrElement(rendererResult)) {
                return rendererResult;
            }
            else {
                throw 'iconRenderer should return back a string or a dom object';
            }
        }
        else {
            var span = document.createElement('span');
            var cssClass = this.iconNameClassMap[iconName];
            if (!cssClass) {
                throw new Error(iconName + " did not find class");
            }
            span.setAttribute("class", "ag-icon ag-icon-" + cssClass);
            return span;
        }
    };
    Utils.addStylesToElement = function (eElement, styles) {
        var _this = this;
        if (!styles) {
            return;
        }
        Object.keys(styles).forEach(function (key) {
            var keyCamelCase = _this.hyphenToCamelCase(key);
            eElement.style[keyCamelCase] = styles[key];
        });
    };
    Utils.isHorizontalScrollShowing = function (element) {
        return element.clientWidth < element.scrollWidth;
    };
    Utils.isVerticalScrollShowing = function (element) {
        return element.clientHeight < element.scrollHeight;
    };
    Utils.getScrollbarWidth = function () {
        var outer = document.createElement("div");
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps
        document.body.appendChild(outer);
        var widthNoScroll = outer.offsetWidth;
        // force scrollbars
        outer.style.overflow = "scroll";
        // add innerdiv
        var inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        var widthWithScroll = inner.offsetWidth;
        // remove divs
        outer.parentNode.removeChild(outer);
        return widthNoScroll - widthWithScroll;
    };
    Utils.isKeyPressed = function (event, keyToCheck) {
        var pressedKey = event.which || event.keyCode;
        return pressedKey === keyToCheck;
    };
    Utils.setVisible = function (element, visible) {
        this.addOrRemoveCssClass(element, 'ag-hidden', !visible);
    };
    Utils.setHidden = function (element, hidden) {
        this.addOrRemoveCssClass(element, 'ag-visibility-hidden', hidden);
    };
    Utils.isBrowserIE = function () {
        if (this.isIE === undefined) {
            this.isIE = false || !!document.documentMode; // At least IE6
        }
        return this.isIE;
    };
    Utils.isBrowserEdge = function () {
        if (this.isEdge === undefined) {
            this.isEdge = !this.isBrowserIE() && !!window.StyleMedia;
        }
        return this.isEdge;
    };
    Utils.isBrowserSafari = function () {
        if (this.isSafari === undefined) {
            var anyWindow = window;
            // taken from https://github.com/ag-grid/ag-grid/issues/550
            this.isSafari = Object.prototype.toString.call(anyWindow.HTMLElement).indexOf('Constructor') > 0
                || (function (p) {
                    return p.toString() === "[object SafariRemoteNotification]";
                })(!anyWindow.safari || anyWindow.safari.pushNotification);
        }
        return this.isSafari;
    };
    Utils.isBrowserChrome = function () {
        if (this.isChrome === undefined) {
            var anyWindow = window;
            this.isChrome = !!anyWindow.chrome && !!anyWindow.chrome.webstore;
        }
        return this.isChrome;
    };
    Utils.isBrowserFirefox = function () {
        if (this.isFirefox === undefined) {
            var anyWindow = window;
            this.isFirefox = typeof anyWindow.InstallTrigger !== 'undefined';
        }
        return this.isFirefox;
    };
    // srcElement is only available in IE. In all other browsers it is target
    // http://stackoverflow.com/questions/5301643/how-can-i-make-event-srcelement-work-in-firefox-and-what-does-it-mean
    Utils.getTarget = function (event) {
        var eventNoType = event;
        return eventNoType.target || eventNoType.srcElement;
    };
    Utils.isElementInEventPath = function (element, event) {
        if (!event || !element) {
            return false;
        }
        var path = exports._.getEventPath(event);
        return path.indexOf(element) >= 0;
    };
    Utils.createEventPath = function (event) {
        var res = [];
        var pointer = exports._.getTarget(event);
        while (pointer) {
            res.push(pointer);
            pointer = pointer.parentElement;
        }
        return res;
    };
    // firefox doesn't have event.path set, or any alternative to it, so we hack
    // it in. this is needed as it's to late to work out the path when the item is
    // removed from the dom
    Utils.addAgGridEventPath = function (event) {
        event.__agGridEventPath = this.getEventPath(event);
    };
    Utils.getEventPath = function (event) {
        // https://stackoverflow.com/questions/39245488/event-path-undefined-with-firefox-and-vue-js
        // https://developer.mozilla.org/en-US/docs/Web/API/Event
        var eventNoType = event;
        if (event.deepPath) {
            // IE supports deep path
            return event.deepPath();
        }
        else if (eventNoType.path) {
            // Chrome supports path
            return eventNoType.path;
        }
        else if (eventNoType.composedPath) {
            // Firefox supports composePath
            return eventNoType.composedPath();
        }
        else if (eventNoType.__agGridEventPath) {
            // Firefox supports composePath
            return eventNoType.__agGridEventPath;
        }
        else {
            // and finally, if none of the above worked,
            // we create the path ourselves
            return this.createEventPath(event);
        }
    };
    Utils.forEachSnapshotFirst = function (list, callback) {
        if (list) {
            var arrayCopy = list.slice(0);
            arrayCopy.forEach(callback);
        }
    };
    // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code
    Utils.getBodyWidth = function () {
        if (document.body) {
            return document.body.clientWidth;
        }
        if (window.innerHeight) {
            return window.innerWidth;
        }
        if (document.documentElement && document.documentElement.clientWidth) {
            return document.documentElement.clientWidth;
        }
        return -1;
    };
    // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code
    Utils.getBodyHeight = function () {
        if (document.body) {
            return document.body.clientHeight;
        }
        if (window.innerHeight) {
            return window.innerHeight;
        }
        if (document.documentElement && document.documentElement.clientHeight) {
            return document.documentElement.clientHeight;
        }
        return -1;
    };
    Utils.setCheckboxState = function (eCheckbox, state) {
        if (typeof state === 'boolean') {
            eCheckbox.checked = state;
            eCheckbox.indeterminate = false;
        }
        else {
            // isNodeSelected returns back undefined if it's a group and the children
            // are a mix of selected and unselected
            eCheckbox.indeterminate = true;
        }
    };
    Utils.traverseNodesWithKey = function (nodes, callback) {
        var keyParts = [];
        recursiveSearchNodes(nodes);
        function recursiveSearchNodes(nodes) {
            nodes.forEach(function (node) {
                if (node.group) {
                    keyParts.push(node.key);
                    var key = keyParts.join('|');
                    callback(node, key);
                    recursiveSearchNodes(node.childrenAfterGroup);
                    keyParts.pop();
                }
            });
        }
    };
    // from https://gist.github.com/youssman/745578062609e8acac9f
    Utils.camelCaseToHyphen = function (str) {
        if (str === null || str === undefined) {
            return null;
        }
        return str.replace(/([A-Z])/g, function (g) { return '-' + g[0].toLowerCase(); });
    };
    // from https://stackoverflow.com/questions/6660977/convert-hyphens-to-camel-case-camelcase
    Utils.hyphenToCamelCase = function (str) {
        if (str === null || str === undefined) {
            return null;
        }
        return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
    };
    // pas in an object eg: {color: 'black', top: '25px'} and it returns "color: black; top: 25px;" for html
    Utils.cssStyleObjectToMarkup = function (stylesToUse) {
        var _this = this;
        if (!stylesToUse) {
            return '';
        }
        var resParts = [];
        this.iterateObject(stylesToUse, function (styleKey, styleValue) {
            var styleKeyDashed = _this.camelCaseToHyphen(styleKey);
            resParts.push(styleKeyDashed + ": " + styleValue + ";");
        });
        return resParts.join(' ');
    };
    /**
     * From http://stackoverflow.com/questions/9716468/is-there-any-function-like-isnumeric-in-javascript-to-validate-numbers
     */
    Utils.isNumeric = function (value) {
        if (value === '')
            return false;
        return !isNaN(parseFloat(value)) && isFinite(value);
    };
    Utils.escape = function (toEscape) {
        if (toEscape === null || toEscape === undefined || !toEscape.replace) {
            return toEscape;
        }
        return toEscape.replace(reUnescapedHtml, function (chr) { return HTML_ESCAPES[chr]; });
    };
    // Taken from here: https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
    /**
     * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
     * complicated, thus this doc is long and (hopefully) detailed enough to answer
     * your questions.
     *
     * If you need to react to the mouse wheel in a predictable way, this code is
     * like your bestest friend. * hugs *
     *
     * As of today, there are 4 DOM event types you can listen to:
     *
     *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
     *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
     *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
     *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
     *
     * So what to do?  The is the best:
     *
     *   normalizeWheel.getEventType();
     *
     * In your event callback, use this code to get sane interpretation of the
     * deltas.  This code will return an object with properties:
     *
     *   spinX   -- normalized spin speed (use for zoom) - x plane
     *   spinY   -- " - y plane
     *   pixelX  -- normalized distance (to pixels) - x plane
     *   pixelY  -- " - y plane
     *
     * Wheel values are provided by the browser assuming you are using the wheel to
     * scroll a web page by a number of lines or pixels (or pages).  Values can vary
     * significantly on different platforms and browsers, forgetting that you can
     * scroll at different speeds.  Some devices (like trackpads) emit more events
     * at smaller increments with fine granularity, and some emit massive jumps with
     * linear speed or acceleration.
     *
     * This code does its best to normalize the deltas for you:
     *
     *   - spin is trying to normalize how far the wheel was spun (or trackpad
     *     dragged).  This is super useful for zoom support where you want to
     *     throw away the chunky scroll steps on the PC and make those equal to
     *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
     *     resolve a single slow step on a wheel to 1.
     *
     *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
     *     get the crazy differences between browsers, but at least it'll be in
     *     pixels!
     *
     *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
     *     should translate to positive value zooming IN, negative zooming OUT.
     *     This matches the newer 'wheel' event.
     *
     * Why are there spinX, spinY (or pixels)?
     *
     *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
     *     with a mouse.  It results in side-scrolling in the browser by default.
     *
     *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
     *
     *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
     *     probably is by browsers in conjunction with fancy 3D controllers .. but
     *     you know.
     *
     * Implementation info:
     *
     * Examples of 'wheel' event if you scroll slowly (down) by one step with an
     * average mouse:
     *
     *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
     *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
     *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
     *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
     *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
     *
     * On the trackpad:
     *
     *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
     *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
     *
     * On other/older browsers.. it's more complicated as there can be multiple and
     * also missing delta values.
     *
     * The 'wheel' event is more standard:
     *
     * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
     *
     * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
     * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
     * backward compatibility with older events.  Those other values help us
     * better normalize spin speed.  Example of what the browsers provide:
     *
     *                          | event.wheelDelta | event.detail
     *        ------------------+------------------+--------------
     *          Safari v5/OS X  |       -120       |       0
     *          Safari v5/Win7  |       -120       |       0
     *         Chrome v17/OS X  |       -120       |       0
     *         Chrome v17/Win7  |       -120       |       0
     *                IE9/Win7  |       -120       |   undefined
     *         Firefox v4/OS X  |     undefined    |       1
     *         Firefox v4/Win7  |     undefined    |       3
     *
     */
    Utils.normalizeWheel = function (event) {
        var PIXEL_STEP = 10;
        var LINE_HEIGHT = 40;
        var PAGE_HEIGHT = 800;
        // spinX, spinY
        var sX = 0;
        var sY = 0;
        // pixelX, pixelY
        var pX = 0;
        var pY = 0;
        // Legacy
        if ('detail' in event) {
            sY = event.detail;
        }
        if ('wheelDelta' in event) {
            sY = -event.wheelDelta / 120;
        }
        if ('wheelDeltaY' in event) {
            sY = -event.wheelDeltaY / 120;
        }
        if ('wheelDeltaX' in event) {
            sX = -event.wheelDeltaX / 120;
        }
        // side scrolling on FF with DOMMouseScroll
        if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
            sX = sY;
            sY = 0;
        }
        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;
        if ('deltaY' in event) {
            pY = event.deltaY;
        }
        if ('deltaX' in event) {
            pX = event.deltaX;
        }
        if ((pX || pY) && event.deltaMode) {
            if (event.deltaMode == 1) {
                pX *= LINE_HEIGHT;
                pY *= LINE_HEIGHT;
            }
            else {
                pX *= PAGE_HEIGHT;
                pY *= PAGE_HEIGHT;
            }
        }
        // Fall-back if spin cannot be determined
        if (pX && !sX) {
            sX = (pX < 1) ? -1 : 1;
        }
        if (pY && !sY) {
            sY = (pY < 1) ? -1 : 1;
        }
        return {
            spinX: sX,
            spinY: sY,
            pixelX: pX,
            pixelY: pY
        };
    };
    /**
     * https://stackoverflow.com/questions/24004791/can-someone-explain-the-debounce-function-in-javascript
     */
    Utils.debounce = function (func, wait, immediate) {
        if (immediate === void 0) { immediate = false; }
        // 'private' variable for instance
        // The returned function will be able to reference this due to closure.
        // Each call to the returned function will share this common timer.
        var timeout;
        // Calling debounce returns a new anonymous function
        return function () {
            // reference the context and args for the setTimeout function
            var context = this, args = arguments;
            // Should the function be called now? If immediate is true
            //   and not already in a timeout then the answer is: Yes
            var callNow = immediate && !timeout;
            // This is the basic debounce behaviour where you can call this
            //   function several times, but it will only execute once
            //   [before or after imposing a delay].
            //   Each time the returned function is called, the timer starts over.
            clearTimeout(timeout);
            // Set the new timeout
            timeout = setTimeout(function () {
                // Inside the timeout function, clear the timeout variable
                // which will let the next execution run when in 'immediate' mode
                timeout = null;
                // Check if the function already ran with the immediate flag
                if (!immediate) {
                    // Call the original function with apply
                    // apply lets you define the 'this' object as well as the arguments
                    //    (both captured before setTimeout)
                    func.apply(context, args);
                }
            }, wait);
            // Immediate mode and no wait timer? Execute the function..
            if (callNow)
                func.apply(context, args);
        };
    };
    ;
    Utils.executeInAWhile = function (funcs) {
        this.executeAfter(funcs, 400);
    };
    Utils.executeNextVMTurn = function (funcs) {
        this.executeAfter(funcs, 0);
    };
    Utils.executeAfter = function (funcs, millis) {
        if (funcs.length > 0) {
            setTimeout(function () {
                funcs.forEach(function (func) { return func(); });
            }, millis);
        }
    };
    Utils.referenceCompare = function (left, right) {
        if (left == null && right == null)
            return true;
        if (left == null && right)
            return false;
        if (left && right == null)
            return false;
        return left === right;
    };
    Utils.get = function (source, expression, defaultValue) {
        if (source == null)
            return defaultValue;
        if (expression.indexOf('.') > -1) {
            var fields = expression.split('.');
            var thisKey = fields[0];
            var nextValue = source[thisKey];
            if (nextValue != null) {
                return Utils.get(nextValue, fields.slice(1, fields.length).join('.'), defaultValue);
            }
            else {
                return defaultValue;
            }
        }
        else {
            var nextValue = source[expression];
            return nextValue != null ? nextValue : defaultValue;
        }
    };
    Utils.addSafePassiveEventListener = function (eElement, event, listener) {
        eElement.addEventListener(event, listener, (Utils.passiveEvents.indexOf(event) > -1 ? { passive: true } : null));
    };
    Utils.camelCaseToHumanText = function (camelCase) {
        if (camelCase == null)
            return null;
        // Who needs to learn how to code when you have stack overflow!
        // from: https://stackoverflow.com/questions/15369566/putting-space-in-camel-case-string-using-regular-expression
        var rex = /([A-Z])([A-Z])([a-z])|([a-z])([A-Z])/g;
        var words = camelCase.replace(rex, '$1$4 $2$3$5').replace('.', ' ').split(' ');
        return words.map(function (word) { return word.substring(0, 1).toUpperCase() + ((word.length > 1) ? word.substring(1, word.length) : ''); }).join(' ');
    };
    Utils.sortRowNodesByOrder = function (rowNodes, rowNodeOrder) {
        if (!rowNodes) {
            return;
        }
        rowNodes.sort(function (nodeA, nodeB) {
            var positionA = rowNodeOrder[nodeA.id];
            var positionB = rowNodeOrder[nodeB.id];
            return positionA - positionB;
        });
    };
    Utils.PRINTABLE_CHARACTERS = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890!"£$%^&*()_+-=[];\'#,./\|<>?:@~{}';
    // static prepend(parent: HTMLElement, child: HTMLElement): void {
    //     if (this.exists(parent.firstChild)) {
    //         parent.insertBefore(child, parent.firstChild);
    //     } else {
    //         parent.appendChild(child);
    //     }
    // }
    Utils.iconNameClassMap = {
        'columnMovePin': 'pin',
        'columnMoveAdd': 'plus',
        'columnMoveHide': 'eye-slash',
        'columnMoveMove': 'arrows',
        'columnMoveLeft': 'left',
        'columnMoveRight': 'right',
        'columnMoveGroup': 'group',
        'columnMoveValue': 'aggregation',
        'columnMovePivot': 'pivot',
        'dropNotAllowed': 'not-allowed',
        'groupContracted': 'expanded',
        'groupExpanded': 'contracted',
        'checkboxChecked': 'checkbox-checked',
        'checkboxUnchecked': 'checkbox-unchecked',
        'checkboxIndeterminate': 'checkbox-indeterminate',
        'checkboxCheckedReadOnly': 'checkbox-checked-readonly',
        'checkboxUncheckedReadOnly': 'checkbox-unchecked-readonly',
        'checkboxIndeterminateReadOnly': 'checkbox-indeterminate-readonly',
        'groupLoading': 'loading',
        'menu': 'menu',
        'filter': 'filter',
        'columns': 'columns',
        'menuPin': 'pin',
        'menuValue': 'aggregation',
        'menuAddRowGroup': 'group',
        'menuRemoveRowGroup': 'group',
        'clipboardCopy': 'copy',
        'clipboardCut': 'cut',
        'clipboardPaste': 'paste',
        'pivotPanel': 'pivot',
        'rowGroupPanel': 'group',
        'valuePanel': 'aggregation',
        'columnGroupOpened': 'expanded',
        'columnGroupClosed': 'contracted',
        'columnSelectClosed': 'tree-closed',
        'columnSelectOpen': 'tree-open',
        // from deprecated header, remove at some point
        'sortAscending': 'asc',
        'sortDescending': 'desc',
        'sortUnSort': 'none'
    };
    Utils.passiveEvents = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];
    return Utils;
}());
exports.Utils = Utils;
var NumberSequence = (function () {
    function NumberSequence(initValue, step) {
        if (initValue === void 0) { initValue = 0; }
        if (step === void 0) { step = 1; }
        this.nextValue = initValue;
        this.step = step;
    }
    NumberSequence.prototype.next = function () {
        var valToReturn = this.nextValue;
        this.nextValue += this.step;
        return valToReturn;
    };
    NumberSequence.prototype.peek = function () {
        return this.nextValue;
    };
    NumberSequence.prototype.skip = function (count) {
        this.nextValue += count;
    };
    return NumberSequence;
}());
exports.NumberSequence = NumberSequence;
exports._ = Utils;
var PromiseStatus;
(function (PromiseStatus) {
    PromiseStatus[PromiseStatus["IN_PROGRESS"] = 0] = "IN_PROGRESS";
    PromiseStatus[PromiseStatus["RESOLVED"] = 1] = "RESOLVED";
})(PromiseStatus = exports.PromiseStatus || (exports.PromiseStatus = {}));
var Promise = (function () {
    function Promise(callback) {
        this.status = PromiseStatus.IN_PROGRESS;
        this.resolution = null;
        this.listOfWaiters = [];
        callback(this.onDone.bind(this), this.onReject.bind(this));
    }
    Promise.all = function (toCombine) {
        return new Promise(function (resolve) {
            var combinedValues = [];
            var remainingToResolve = toCombine.length;
            toCombine.forEach(function (source, index) {
                source.then(function (sourceResolved) {
                    remainingToResolve--;
                    combinedValues[index] = sourceResolved;
                    if (remainingToResolve == 0) {
                        resolve(combinedValues);
                    }
                });
                combinedValues.push(null);
            });
        });
    };
    Promise.resolve = function (value) {
        return new Promise(function (resolve) { return resolve(value); });
    };
    Promise.external = function () {
        var capture;
        var promise = new Promise(function (resolve) {
            capture = resolve;
        });
        return {
            promise: promise,
            resolve: function (value) {
                capture(value);
            }
        };
    };
    Promise.prototype.then = function (func) {
        if (this.status === PromiseStatus.IN_PROGRESS) {
            this.listOfWaiters.push(func);
        }
        else {
            func(this.resolution);
        }
    };
    Promise.prototype.map = function (adapter) {
        var _this = this;
        return new Promise(function (resolve) {
            _this.then(function (unmapped) {
                resolve(adapter(unmapped));
            });
        });
    };
    Promise.prototype.resolveNow = function (ifNotResolvedValue, ifResolved) {
        if (this.status == PromiseStatus.IN_PROGRESS)
            return ifNotResolvedValue;
        return ifResolved(this.resolution);
    };
    Promise.prototype.onDone = function (value) {
        this.status = PromiseStatus.RESOLVED;
        this.resolution = value;
        this.listOfWaiters.forEach(function (waiter) { return waiter(value); });
    };
    Promise.prototype.onReject = function (params) {
        console.warn('TBI');
    };
    return Promise;
}());
exports.Promise = Promise;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var eventService_1 = __webpack_require__(4);
var constants_1 = __webpack_require__(7);
var componentUtil_1 = __webpack_require__(66);
var gridApi_1 = __webpack_require__(6);
var context_1 = __webpack_require__(0);
var columnController_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(1);
var environment_1 = __webpack_require__(51);
var DEFAULT_ROW_HEIGHT = 25;
var DEFAULT_VIEWPORT_ROW_MODEL_PAGE_SIZE = 5;
var DEFAULT_VIEWPORT_ROW_MODEL_BUFFER_SIZE = 5;
function isTrue(value) {
    return value === true || value === 'true';
}
function zeroOrGreater(value, defaultValue) {
    if (value >= 0) {
        return value;
    }
    else {
        // zero gets returned if number is missing or the wrong type
        return defaultValue;
    }
}
function oneOrGreater(value, defaultValue) {
    if (value > 0) {
        return value;
    }
    else {
        // zero gets returned if number is missing or the wrong type
        return defaultValue;
    }
}
var GridOptionsWrapper = (function () {
    function GridOptionsWrapper() {
        this.propertyEventService = new eventService_1.EventService();
        this.domDataKey = '__AG_' + Math.random().toString();
    }
    GridOptionsWrapper_1 = GridOptionsWrapper;
    GridOptionsWrapper.prototype.agWire = function (gridApi, columnApi) {
        this.gridOptions.api = gridApi;
        this.gridOptions.columnApi = columnApi;
        this.checkForDeprecated();
    };
    GridOptionsWrapper.prototype.destroy = function () {
        // need to remove these, as we don't own the lifecycle of the gridOptions, we need to
        // remove the references in case the user keeps the grid options, we want the rest
        // of the grid to be picked up by the garbage collector
        this.gridOptions.api = null;
        this.gridOptions.columnApi = null;
    };
    GridOptionsWrapper.prototype.init = function () {
        var async = this.useAsyncEvents();
        this.eventService.addGlobalListener(this.globalEventHandler.bind(this), async);
        if (this.isGroupSelectsChildren() && this.isSuppressParentsInRowNodes()) {
            console.warn('ag-Grid: groupSelectsChildren does not work wth suppressParentsInRowNodes, this selection method needs the part in rowNode to work');
        }
        if (this.isGroupSelectsChildren()) {
            if (!this.isRowSelectionMulti()) {
                console.warn("ag-Grid: rowSelection must be 'multiple' for groupSelectsChildren to make sense");
            }
            if (this.isRowModelEnterprise()) {
                console.warn('ag-Grid: group selects children is NOT support for Enterprise Row Model. ' +
                    'This is because the rows are lazy loaded, so selecting a group is not possible as' +
                    'the grid has no way of knowing what the children are.');
            }
        }
        if (this.isGroupRemoveSingleChildren() && this.isGroupHideOpenParents()) {
            console.warn('ag-Grid: groupRemoveSingleChildren and groupHideOpenParents do not work with each other, you need to pick one. And don\'t ask us how to us these together on our support forum either you will get the same answer!');
        }
    };
    // returns the dom data, or undefined if not found
    GridOptionsWrapper.prototype.getDomData = function (element, key) {
        var domData = element[this.domDataKey];
        if (domData) {
            return domData[key];
        }
        else {
            return undefined;
        }
    };
    GridOptionsWrapper.prototype.setDomData = function (element, key, value) {
        var domData = element[this.domDataKey];
        if (utils_1.Utils.missing(domData)) {
            domData = {};
            element[this.domDataKey] = domData;
        }
        domData[key] = value;
    };
    GridOptionsWrapper.prototype.isEnterprise = function () { return this.enterprise; };
    GridOptionsWrapper.prototype.isRowSelection = function () { return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple"; };
    GridOptionsWrapper.prototype.isRowDeselection = function () { return isTrue(this.gridOptions.rowDeselection); };
    GridOptionsWrapper.prototype.isRowSelectionMulti = function () { return this.gridOptions.rowSelection === 'multiple'; };
    GridOptionsWrapper.prototype.getContext = function () { return this.gridOptions.context; };
    GridOptionsWrapper.prototype.isPivotMode = function () { return isTrue(this.gridOptions.pivotMode); };
    GridOptionsWrapper.prototype.isPivotTotals = function () { return isTrue(this.gridOptions.pivotTotals); };
    GridOptionsWrapper.prototype.isRowModelInfinite = function () { return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_INFINITE; };
    GridOptionsWrapper.prototype.isRowModelViewport = function () { return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_VIEWPORT; };
    GridOptionsWrapper.prototype.isRowModelEnterprise = function () { return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_ENTERPRISE; };
    GridOptionsWrapper.prototype.isRowModelDefault = function () {
        return utils_1.Utils.missing(this.gridOptions.rowModelType) ||
            this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY ||
            this.gridOptions.rowModelType === constants_1.Constants.DEPRECATED_ROW_MODEL_TYPE_NORMAL;
    };
    GridOptionsWrapper.prototype.isFullRowEdit = function () { return this.gridOptions.editType === 'fullRow'; };
    GridOptionsWrapper.prototype.isSuppressFocusAfterRefresh = function () { return isTrue(this.gridOptions.suppressFocusAfterRefresh); };
    GridOptionsWrapper.prototype.isShowToolPanel = function () { return isTrue(this.gridOptions.showToolPanel); };
    GridOptionsWrapper.prototype.isToolPanelSuppressValues = function () { return isTrue(this.gridOptions.toolPanelSuppressValues); };
    GridOptionsWrapper.prototype.isToolPanelSuppressPivots = function () {
        // we don't allow pivots when doing tree data
        return isTrue(this.gridOptions.toolPanelSuppressPivots) || this.isTreeData();
    };
    GridOptionsWrapper.prototype.isToolPanelSuppressRowGroups = function () {
        // we don't allow row grouping when doing tree data
        return isTrue(this.gridOptions.toolPanelSuppressRowGroups) || this.isTreeData();
    };
    GridOptionsWrapper.prototype.isToolPanelSuppressPivotMode = function () {
        return isTrue(this.gridOptions.toolPanelSuppressPivotMode) || this.isTreeData();
    };
    GridOptionsWrapper.prototype.isSuppressTouch = function () { return isTrue(this.gridOptions.suppressTouch); };
    GridOptionsWrapper.prototype.useAsyncEvents = function () { return !isTrue(this.gridOptions.suppressAsyncEvents); };
    GridOptionsWrapper.prototype.isEnableCellChangeFlash = function () { return isTrue(this.gridOptions.enableCellChangeFlash); };
    GridOptionsWrapper.prototype.isGroupSelectsChildren = function () {
        var result = isTrue(this.gridOptions.groupSelectsChildren);
        if (result && this.isTreeData()) {
            console.warn('ag-Grid: groupSelectsChildren does not work with tree data');
            return false;
        }
        else {
            return result;
        }
    };
    GridOptionsWrapper.prototype.isGroupSelectsFiltered = function () { return isTrue(this.gridOptions.groupSelectsFiltered); };
    GridOptionsWrapper.prototype.isGroupHideOpenParents = function () { return isTrue(this.gridOptions.groupHideOpenParents); };
    // if we are doing hideOpenParents, then we always have groupMultiAutoColumn, otherwise hideOpenParents would not work
    GridOptionsWrapper.prototype.isGroupMultiAutoColumn = function () { return isTrue(this.gridOptions.groupMultiAutoColumn) || isTrue(this.gridOptions.groupHideOpenParents); };
    GridOptionsWrapper.prototype.isGroupRemoveSingleChildren = function () { return isTrue(this.gridOptions.groupRemoveSingleChildren); };
    GridOptionsWrapper.prototype.isGroupRemoveLowestSingleChildren = function () { return isTrue(this.gridOptions.groupRemoveLowestSingleChildren); };
    GridOptionsWrapper.prototype.isGroupIncludeFooter = function () { return isTrue(this.gridOptions.groupIncludeFooter); };
    GridOptionsWrapper.prototype.isGroupSuppressBlankHeader = function () { return isTrue(this.gridOptions.groupSuppressBlankHeader); };
    GridOptionsWrapper.prototype.isSuppressRowClickSelection = function () { return isTrue(this.gridOptions.suppressRowClickSelection); };
    GridOptionsWrapper.prototype.isSuppressCellSelection = function () { return isTrue(this.gridOptions.suppressCellSelection); };
    GridOptionsWrapper.prototype.isSuppressMultiSort = function () { return isTrue(this.gridOptions.suppressMultiSort); };
    GridOptionsWrapper.prototype.isGroupSuppressAutoColumn = function () { return isTrue(this.gridOptions.groupSuppressAutoColumn); };
    GridOptionsWrapper.prototype.isSuppressDragLeaveHidesColumns = function () { return isTrue(this.gridOptions.suppressDragLeaveHidesColumns); };
    GridOptionsWrapper.prototype.isSuppressScrollOnNewData = function () { return isTrue(this.gridOptions.suppressScrollOnNewData); };
    GridOptionsWrapper.prototype.isForPrint = function () { return this.gridOptions.domLayout === 'forPrint'; };
    GridOptionsWrapper.prototype.isAutoHeight = function () { return this.gridOptions.domLayout === 'autoHeight'; };
    GridOptionsWrapper.prototype.isSuppressHorizontalScroll = function () { return isTrue(this.gridOptions.suppressHorizontalScroll); };
    GridOptionsWrapper.prototype.isSuppressLoadingOverlay = function () { return isTrue(this.gridOptions.suppressLoadingOverlay); };
    GridOptionsWrapper.prototype.isSuppressNoRowsOverlay = function () { return isTrue(this.gridOptions.suppressNoRowsOverlay); };
    GridOptionsWrapper.prototype.isSuppressFieldDotNotation = function () { return isTrue(this.gridOptions.suppressFieldDotNotation); };
    GridOptionsWrapper.prototype.getPinnedTopRowData = function () { return this.gridOptions.pinnedTopRowData; };
    GridOptionsWrapper.prototype.getPinnedBottomRowData = function () { return this.gridOptions.pinnedBottomRowData; };
    GridOptionsWrapper.prototype.isFunctionsPassive = function () { return isTrue(this.gridOptions.functionsPassive); };
    GridOptionsWrapper.prototype.isSuppressTabbing = function () { return isTrue(this.gridOptions.suppressTabbing); };
    GridOptionsWrapper.prototype.isSuppressChangeDetection = function () { return isTrue(this.gridOptions.suppressChangeDetection); };
    GridOptionsWrapper.prototype.isSuppressAnimationFrame = function () { return isTrue(this.gridOptions.suppressAnimationFrame); };
    GridOptionsWrapper.prototype.getQuickFilterText = function () { return this.gridOptions.quickFilterText; };
    GridOptionsWrapper.prototype.isCacheQuickFilter = function () { return isTrue(this.gridOptions.cacheQuickFilter); };
    GridOptionsWrapper.prototype.isUnSortIcon = function () { return isTrue(this.gridOptions.unSortIcon); };
    GridOptionsWrapper.prototype.isSuppressMenuHide = function () { return isTrue(this.gridOptions.suppressMenuHide); };
    GridOptionsWrapper.prototype.getRowStyle = function () { return this.gridOptions.rowStyle; };
    GridOptionsWrapper.prototype.getRowClass = function () { return this.gridOptions.rowClass; };
    GridOptionsWrapper.prototype.getRowStyleFunc = function () { return this.gridOptions.getRowStyle; };
    GridOptionsWrapper.prototype.getRowClassFunc = function () { return this.gridOptions.getRowClass; };
    GridOptionsWrapper.prototype.rowClassRules = function () { return this.gridOptions.rowClassRules; };
    GridOptionsWrapper.prototype.getPostProcessPopupFunc = function () { return this.gridOptions.postProcessPopup; };
    GridOptionsWrapper.prototype.getDoesDataFlowerFunc = function () { return this.gridOptions.doesDataFlower; };
    GridOptionsWrapper.prototype.getPaginationNumberFormatterFunc = function () { return this.gridOptions.paginationNumberFormatter; };
    GridOptionsWrapper.prototype.getChildCountFunc = function () { return this.gridOptions.getChildCount; };
    GridOptionsWrapper.prototype.getIsFullWidthCellFunc = function () { return this.gridOptions.isFullWidthCell; };
    GridOptionsWrapper.prototype.getFullWidthCellRendererParams = function () { return this.gridOptions.fullWidthCellRendererParams; };
    GridOptionsWrapper.prototype.isEmbedFullWidthRows = function () {
        // if autoHeight, we always embed fullWidth rows, otherwise we let the user decide
        return this.isAutoHeight() || isTrue(this.gridOptions.embedFullWidthRows);
    };
    GridOptionsWrapper.prototype.getBusinessKeyForNodeFunc = function () { return this.gridOptions.getBusinessKeyForNode; };
    GridOptionsWrapper.prototype.getHeaderCellRenderer = function () { return this.gridOptions.headerCellRenderer; };
    GridOptionsWrapper.prototype.getApi = function () { return this.gridOptions.api; };
    GridOptionsWrapper.prototype.getColumnApi = function () { return this.gridOptions.columnApi; };
    GridOptionsWrapper.prototype.isDeltaRowDataMode = function () { return isTrue(this.gridOptions.deltaRowDataMode); };
    GridOptionsWrapper.prototype.isEnsureDomOrder = function () { return isTrue(this.gridOptions.ensureDomOrder); };
    GridOptionsWrapper.prototype.isEnableColResize = function () { return isTrue(this.gridOptions.enableColResize); };
    GridOptionsWrapper.prototype.isSingleClickEdit = function () { return isTrue(this.gridOptions.singleClickEdit); };
    GridOptionsWrapper.prototype.isSuppressClickEdit = function () { return isTrue(this.gridOptions.suppressClickEdit); };
    GridOptionsWrapper.prototype.isStopEditingWhenGridLosesFocus = function () { return isTrue(this.gridOptions.stopEditingWhenGridLosesFocus); };
    GridOptionsWrapper.prototype.getGroupDefaultExpanded = function () { return this.gridOptions.groupDefaultExpanded; };
    GridOptionsWrapper.prototype.getMaxConcurrentDatasourceRequests = function () { return this.gridOptions.maxConcurrentDatasourceRequests; };
    GridOptionsWrapper.prototype.getMaxBlocksInCache = function () { return this.gridOptions.maxBlocksInCache; };
    GridOptionsWrapper.prototype.getCacheOverflowSize = function () { return this.gridOptions.cacheOverflowSize; };
    GridOptionsWrapper.prototype.getPaginationPageSize = function () { return this.gridOptions.paginationPageSize; };
    GridOptionsWrapper.prototype.getCacheBlockSize = function () { return this.gridOptions.cacheBlockSize; };
    GridOptionsWrapper.prototype.getInfiniteInitialRowCount = function () { return this.gridOptions.infiniteInitialRowCount; };
    GridOptionsWrapper.prototype.isPurgeClosedRowNodes = function () { return isTrue(this.gridOptions.purgeClosedRowNodes); };
    GridOptionsWrapper.prototype.isSuppressPaginationPanel = function () { return isTrue(this.gridOptions.suppressPaginationPanel); };
    GridOptionsWrapper.prototype.getRowData = function () { return this.gridOptions.rowData; };
    GridOptionsWrapper.prototype.isGroupUseEntireRow = function () { return isTrue(this.gridOptions.groupUseEntireRow); };
    GridOptionsWrapper.prototype.isEnableRtl = function () { return isTrue(this.gridOptions.enableRtl); };
    GridOptionsWrapper.prototype.getAutoGroupColumnDef = function () { return this.gridOptions.autoGroupColumnDef; };
    GridOptionsWrapper.prototype.isGroupSuppressRow = function () { return isTrue(this.gridOptions.groupSuppressRow); };
    GridOptionsWrapper.prototype.getRowGroupPanelShow = function () { return this.gridOptions.rowGroupPanelShow; };
    GridOptionsWrapper.prototype.getPivotPanelShow = function () { return this.gridOptions.pivotPanelShow; };
    GridOptionsWrapper.prototype.isAngularCompileRows = function () { return isTrue(this.gridOptions.angularCompileRows); };
    GridOptionsWrapper.prototype.isAngularCompileFilters = function () { return isTrue(this.gridOptions.angularCompileFilters); };
    GridOptionsWrapper.prototype.isAngularCompileHeaders = function () { return isTrue(this.gridOptions.angularCompileHeaders); };
    GridOptionsWrapper.prototype.isDebug = function () { return isTrue(this.gridOptions.debug); };
    GridOptionsWrapper.prototype.getColumnDefs = function () { return this.gridOptions.columnDefs; };
    GridOptionsWrapper.prototype.getColumnTypes = function () { return this.gridOptions.columnTypes; };
    GridOptionsWrapper.prototype.getDatasource = function () { return this.gridOptions.datasource; };
    GridOptionsWrapper.prototype.getViewportDatasource = function () { return this.gridOptions.viewportDatasource; };
    GridOptionsWrapper.prototype.getEnterpriseDatasource = function () { return this.gridOptions.enterpriseDatasource; };
    GridOptionsWrapper.prototype.isEnableSorting = function () { return isTrue(this.gridOptions.enableSorting) || isTrue(this.gridOptions.enableServerSideSorting); };
    GridOptionsWrapper.prototype.isAccentedSort = function () { return isTrue(this.gridOptions.accentedSort); };
    GridOptionsWrapper.prototype.isEnableCellExpressions = function () { return isTrue(this.gridOptions.enableCellExpressions); };
    GridOptionsWrapper.prototype.isEnableGroupEdit = function () { return isTrue(this.gridOptions.enableGroupEdit); };
    GridOptionsWrapper.prototype.isSuppressMiddleClickScrolls = function () { return isTrue(this.gridOptions.suppressMiddleClickScrolls); };
    GridOptionsWrapper.prototype.isSuppressPreventDefaultOnMouseWheel = function () { return isTrue(this.gridOptions.suppressPreventDefaultOnMouseWheel); };
    GridOptionsWrapper.prototype.isSuppressColumnVirtualisation = function () { return isTrue(this.gridOptions.suppressColumnVirtualisation); };
    GridOptionsWrapper.prototype.isSuppressContextMenu = function () { return isTrue(this.gridOptions.suppressContextMenu); };
    GridOptionsWrapper.prototype.isAllowContextMenuWithControlKey = function () { return isTrue(this.gridOptions.allowContextMenuWithControlKey); };
    GridOptionsWrapper.prototype.isSuppressCopyRowsToClipboard = function () { return isTrue(this.gridOptions.suppressCopyRowsToClipboard); };
    GridOptionsWrapper.prototype.isEnableFilter = function () { return isTrue(this.gridOptions.enableFilter) || isTrue(this.gridOptions.enableServerSideFilter); };
    GridOptionsWrapper.prototype.isPagination = function () { return isTrue(this.gridOptions.pagination); };
    // these are deprecated, should remove them when we take out server side pagination
    GridOptionsWrapper.prototype.isEnableServerSideFilter = function () { return this.gridOptions.enableServerSideFilter; };
    GridOptionsWrapper.prototype.isEnableServerSideSorting = function () { return isTrue(this.gridOptions.enableServerSideSorting); };
    GridOptionsWrapper.prototype.isSuppressMovableColumns = function () { return isTrue(this.gridOptions.suppressMovableColumns); };
    GridOptionsWrapper.prototype.isAnimateRows = function () {
        // never allow animating if enforcing the row order
        if (this.isEnsureDomOrder()) {
            return false;
        }
        return isTrue(this.gridOptions.animateRows);
    };
    GridOptionsWrapper.prototype.isSuppressColumnMoveAnimation = function () { return isTrue(this.gridOptions.suppressColumnMoveAnimation); };
    GridOptionsWrapper.prototype.isSuppressAggFuncInHeader = function () { return isTrue(this.gridOptions.suppressAggFuncInHeader); };
    GridOptionsWrapper.prototype.isSuppressAggAtRootLevel = function () { return isTrue(this.gridOptions.suppressAggAtRootLevel); };
    GridOptionsWrapper.prototype.isEnableRangeSelection = function () { return isTrue(this.gridOptions.enableRangeSelection); };
    GridOptionsWrapper.prototype.isPaginationAutoPageSize = function () { return isTrue(this.gridOptions.paginationAutoPageSize); };
    GridOptionsWrapper.prototype.isRememberGroupStateWhenNewData = function () { return isTrue(this.gridOptions.rememberGroupStateWhenNewData); };
    GridOptionsWrapper.prototype.getIcons = function () { return this.gridOptions.icons; };
    GridOptionsWrapper.prototype.getAggFuncs = function () { return this.gridOptions.aggFuncs; };
    GridOptionsWrapper.prototype.getSortingOrder = function () { return this.gridOptions.sortingOrder; };
    GridOptionsWrapper.prototype.getAlignedGrids = function () { return this.gridOptions.alignedGrids; };
    GridOptionsWrapper.prototype.getGroupRowRendererParams = function () { return this.gridOptions.groupRowRendererParams; };
    GridOptionsWrapper.prototype.getOverlayLoadingTemplate = function () { return this.gridOptions.overlayLoadingTemplate; };
    GridOptionsWrapper.prototype.getOverlayNoRowsTemplate = function () { return this.gridOptions.overlayNoRowsTemplate; };
    GridOptionsWrapper.prototype.isSuppressAutoSize = function () { return isTrue(this.gridOptions.suppressAutoSize); };
    GridOptionsWrapper.prototype.isSuppressParentsInRowNodes = function () { return isTrue(this.gridOptions.suppressParentsInRowNodes); };
    GridOptionsWrapper.prototype.isEnableStatusBar = function () { return isTrue(this.gridOptions.enableStatusBar); };
    GridOptionsWrapper.prototype.isAlwaysShowStatusBar = function () { return isTrue(this.gridOptions.alwaysShowStatusBar); };
    GridOptionsWrapper.prototype.isFunctionsReadOnly = function () { return isTrue(this.gridOptions.functionsReadOnly); };
    GridOptionsWrapper.prototype.isFloatingFilter = function () { return this.gridOptions.floatingFilter; };
    // public isFloatingFilter(): boolean { return true; }
    GridOptionsWrapper.prototype.getDefaultColDef = function () { return this.gridOptions.defaultColDef; };
    GridOptionsWrapper.prototype.getDefaultColGroupDef = function () { return this.gridOptions.defaultColGroupDef; };
    GridOptionsWrapper.prototype.getDefaultExportParams = function () { return this.gridOptions.defaultExportParams; };
    GridOptionsWrapper.prototype.isSuppressCsvExport = function () { return isTrue(this.gridOptions.suppressCsvExport); };
    GridOptionsWrapper.prototype.isSuppressExcelExport = function () { return isTrue(this.gridOptions.suppressExcelExport); };
    GridOptionsWrapper.prototype.getHeaderCellTemplate = function () { return this.gridOptions.headerCellTemplate; };
    GridOptionsWrapper.prototype.getHeaderCellTemplateFunc = function () { return this.gridOptions.getHeaderCellTemplate; };
    GridOptionsWrapper.prototype.getNodeChildDetailsFunc = function () { return this.gridOptions.getNodeChildDetails; };
    GridOptionsWrapper.prototype.getDataPathFunc = function () { return this.gridOptions.getDataPath; };
    // public getIsGroupFunc(): ((dataItem: any) => boolean) { return this.gridOptions.isGroup }
    GridOptionsWrapper.prototype.getGroupRowAggNodesFunc = function () { return this.gridOptions.groupRowAggNodes; };
    GridOptionsWrapper.prototype.getContextMenuItemsFunc = function () { return this.gridOptions.getContextMenuItems; };
    GridOptionsWrapper.prototype.getMainMenuItemsFunc = function () { return this.gridOptions.getMainMenuItems; };
    GridOptionsWrapper.prototype.getRowNodeIdFunc = function () { return this.gridOptions.getRowNodeId; };
    GridOptionsWrapper.prototype.getNavigateToNextCellFunc = function () { return this.gridOptions.navigateToNextCell; };
    GridOptionsWrapper.prototype.getTabToNextCellFunc = function () { return this.gridOptions.tabToNextCell; };
    GridOptionsWrapper.prototype.isTreeData = function () { return isTrue(this.gridOptions.treeData); };
    GridOptionsWrapper.prototype.isValueCache = function () { return isTrue(this.gridOptions.valueCache); };
    GridOptionsWrapper.prototype.isValueCacheNeverExpires = function () { return isTrue(this.gridOptions.valueCacheNeverExpires); };
    GridOptionsWrapper.prototype.isAggregateOnlyChangedColumns = function () { return isTrue(this.gridOptions.aggregateOnlyChangedColumns); };
    GridOptionsWrapper.prototype.getProcessSecondaryColDefFunc = function () { return this.gridOptions.processSecondaryColDef; };
    GridOptionsWrapper.prototype.getProcessSecondaryColGroupDefFunc = function () { return this.gridOptions.processSecondaryColGroupDef; };
    GridOptionsWrapper.prototype.getSendToClipboardFunc = function () { return this.gridOptions.sendToClipboard; };
    GridOptionsWrapper.prototype.getProcessRowPostCreateFunc = function () { return this.gridOptions.processRowPostCreate; };
    GridOptionsWrapper.prototype.getProcessCellForClipboardFunc = function () { return this.gridOptions.processCellForClipboard; };
    GridOptionsWrapper.prototype.getProcessCellFromClipboardFunc = function () { return this.gridOptions.processCellFromClipboard; };
    GridOptionsWrapper.prototype.getViewportRowModelPageSize = function () { return oneOrGreater(this.gridOptions.viewportRowModelPageSize, DEFAULT_VIEWPORT_ROW_MODEL_PAGE_SIZE); };
    GridOptionsWrapper.prototype.getViewportRowModelBufferSize = function () { return zeroOrGreater(this.gridOptions.viewportRowModelBufferSize, DEFAULT_VIEWPORT_ROW_MODEL_BUFFER_SIZE); };
    // public getCellRenderers(): {[key: string]: {new(): ICellRenderer} | ICellRendererFunc} { return this.gridOptions.cellRenderers; }
    // public getCellEditors(): {[key: string]: {new(): ICellEditor}} { return this.gridOptions.cellEditors; }
    GridOptionsWrapper.prototype.getClipboardDeliminator = function () {
        return utils_1.Utils.exists(this.gridOptions.clipboardDeliminator) ? this.gridOptions.clipboardDeliminator : '\t';
    };
    GridOptionsWrapper.prototype.setProperty = function (key, value) {
        var gridOptionsNoType = this.gridOptions;
        var previousValue = gridOptionsNoType[key];
        if (previousValue !== value) {
            gridOptionsNoType[key] = value;
            var event_1 = {
                type: key,
                currentValue: value,
                previousValue: previousValue
            };
            this.propertyEventService.dispatchEvent(event_1);
        }
    };
    GridOptionsWrapper.prototype.addEventListener = function (key, listener) {
        this.propertyEventService.addEventListener(key, listener);
    };
    GridOptionsWrapper.prototype.removeEventListener = function (key, listener) {
        this.propertyEventService.removeEventListener(key, listener);
    };
    GridOptionsWrapper.prototype.getAutoSizePadding = function () {
        var padding = this.gridOptions.autoSizePadding;
        if (typeof padding === 'number' && padding > 0) {
            return padding;
        }
        else {
            return this.specialForNewMaterial(4, 8 * 3);
        }
    };
    // properties
    GridOptionsWrapper.prototype.getHeaderHeight = function () {
        if (typeof this.gridOptions.headerHeight === 'number') {
            return this.gridOptions.headerHeight;
        }
        else {
            return this.specialForNewMaterial(25, 8 * 7);
        }
    };
    GridOptionsWrapper.prototype.getFloatingFiltersHeight = function () {
        if (typeof this.gridOptions.floatingFiltersHeight === 'number') {
            return this.gridOptions.floatingFiltersHeight;
        }
        else {
            return this.specialForNewMaterial(25, 8 * 7);
        }
    };
    GridOptionsWrapper.prototype.getGroupPaddingSize = function () {
        return this.specialForNewMaterial(10, 18 + 8 * 3);
    };
    GridOptionsWrapper.prototype.getFooterPaddingAddition = function () {
        return this.specialForNewMaterial(15, 32);
    };
    GridOptionsWrapper.prototype.getLeafNodePaddingAddition = function () {
        return this.specialForNewMaterial(10, 24);
    };
    GridOptionsWrapper.prototype.getGroupHeaderHeight = function () {
        if (typeof this.gridOptions.groupHeaderHeight === 'number') {
            return this.gridOptions.groupHeaderHeight;
        }
        else {
            return this.getHeaderHeight();
        }
    };
    GridOptionsWrapper.prototype.getPivotHeaderHeight = function () {
        if (typeof this.gridOptions.pivotHeaderHeight === 'number') {
            return this.gridOptions.pivotHeaderHeight;
        }
        else {
            return this.getHeaderHeight();
        }
    };
    GridOptionsWrapper.prototype.getPivotGroupHeaderHeight = function () {
        if (typeof this.gridOptions.pivotGroupHeaderHeight === 'number') {
            return this.gridOptions.pivotGroupHeaderHeight;
        }
        else {
            return this.getGroupHeaderHeight();
        }
    };
    GridOptionsWrapper.prototype.isExternalFilterPresent = function () {
        if (typeof this.gridOptions.isExternalFilterPresent === 'function') {
            return this.gridOptions.isExternalFilterPresent();
        }
        else {
            return false;
        }
    };
    GridOptionsWrapper.prototype.doesExternalFilterPass = function (node) {
        if (typeof this.gridOptions.doesExternalFilterPass === 'function') {
            return this.gridOptions.doesExternalFilterPass(node);
        }
        else {
            return false;
        }
    };
    GridOptionsWrapper.prototype.getDocument = function () {
        // if user is providing document, we use the users one,
        // otherwise we use the document on the global namespace.
        var result;
        if (utils_1.Utils.exists(this.gridOptions.getDocument)) {
            result = this.gridOptions.getDocument();
        }
        if (utils_1.Utils.exists(result)) {
            return result;
        }
        else {
            return document;
        }
    };
    GridOptionsWrapper.prototype.getLayoutInterval = function () {
        if (typeof this.gridOptions.layoutInterval === 'number') {
            return this.gridOptions.layoutInterval;
        }
        else {
            return constants_1.Constants.LAYOUT_INTERVAL;
        }
    };
    GridOptionsWrapper.prototype.getMinColWidth = function () {
        if (this.gridOptions.minColWidth > GridOptionsWrapper_1.MIN_COL_WIDTH) {
            return this.gridOptions.minColWidth;
        }
        else {
            return GridOptionsWrapper_1.MIN_COL_WIDTH;
        }
    };
    GridOptionsWrapper.prototype.getMaxColWidth = function () {
        if (this.gridOptions.maxColWidth > GridOptionsWrapper_1.MIN_COL_WIDTH) {
            return this.gridOptions.maxColWidth;
        }
        else {
            return null;
        }
    };
    GridOptionsWrapper.prototype.getColWidth = function () {
        if (typeof this.gridOptions.colWidth !== 'number' || this.gridOptions.colWidth < GridOptionsWrapper_1.MIN_COL_WIDTH) {
            return 200;
        }
        else {
            return this.gridOptions.colWidth;
        }
    };
    GridOptionsWrapper.prototype.getRowBuffer = function () {
        if (typeof this.gridOptions.rowBuffer === 'number') {
            if (this.gridOptions.rowBuffer < 0) {
                console.warn('ag-Grid: rowBuffer should not be negative');
            }
            return this.gridOptions.rowBuffer;
        }
        else {
            return constants_1.Constants.ROW_BUFFER_SIZE;
        }
    };
    // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
    // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
    // allow the user to provide the scroll width before we work it out.
    GridOptionsWrapper.prototype.getScrollbarWidth = function () {
        var scrollbarWidth = this.gridOptions.scrollbarWidth;
        if (typeof scrollbarWidth !== 'number' || scrollbarWidth < 0) {
            scrollbarWidth = utils_1.Utils.getScrollbarWidth();
        }
        return scrollbarWidth;
    };
    GridOptionsWrapper.prototype.checkForDeprecated = function () {
        // casting to generic object, so typescript compiles even though
        // we are looking for attributes that don't exist
        var options = this.gridOptions;
        if (options.suppressUnSort) {
            console.warn('ag-grid: as of v1.12.4 suppressUnSort is not used. Please use sortingOrder instead.');
        }
        if (options.suppressDescSort) {
            console.warn('ag-grid: as of v1.12.4 suppressDescSort is not used. Please use sortingOrder instead.');
        }
        if (options.groupAggFields) {
            console.warn('ag-grid: as of v3 groupAggFields is not used. Please add appropriate agg fields to your columns.');
        }
        if (options.groupHidePivotColumns) {
            console.warn('ag-grid: as of v3 groupHidePivotColumns is not used as pivot columns are now called rowGroup columns. Please refer to the documentation');
        }
        if (options.groupKeys) {
            console.warn('ag-grid: as of v3 groupKeys is not used. You need to set rowGroupIndex on the columns to group. Please refer to the documentation');
        }
        if (typeof options.groupDefaultExpanded === 'boolean') {
            console.warn('ag-grid: groupDefaultExpanded can no longer be boolean. for groupDefaultExpanded=true, use groupDefaultExpanded=9999 instead, to expand all the groups');
        }
        if (options.onRowDeselected || options.rowDeselected) {
            console.warn('ag-grid: since version 3.4 event rowDeselected no longer exists, please check the docs');
        }
        if (options.rowsAlreadyGrouped) {
            console.warn('ag-grid: since version 3.4 rowsAlreadyGrouped no longer exists, please use getNodeChildDetails() instead');
        }
        if (options.groupAggFunction) {
            console.warn('ag-grid: since version 4.3.x groupAggFunction is now called groupRowAggNodes');
        }
        if (options.checkboxSelection) {
            console.warn('ag-grid: since version 8.0.x checkboxSelection is not supported as a grid option. ' +
                'If you want this on all columns, use defaultColDef instead and set it there');
        }
        if (options.paginationInitialRowCount) {
            console.warn('ag-grid: since version 9.0.x paginationInitialRowCount is now called infiniteInitialRowCount');
        }
        if (options.infinitePageSize) {
            console.warn('ag-grid: since version 9.0.x infinitePageSize is now called cacheBlockSize');
        }
        if (options.infiniteBlockSize) {
            console.warn('ag-grid: since version 10.0.x infiniteBlockSize is now called cacheBlockSize');
        }
        if (options.maxPagesInCache) {
            console.warn('ag-grid: since version 10.0.x maxPagesInCache is now called maxBlocksInCache');
        }
        if (options.paginationOverflowSize) {
            console.warn('ag-grid: since version 10.0.x paginationOverflowSize is now called cacheOverflowSize');
        }
        if (options.forPrint) {
            console.warn('ag-grid: since version 10.1.x, use property domLayout="forPrint" instead of forPrint=true');
        }
        if (options.suppressMenuFilterPanel) {
            console.warn("ag-grid: since version 11.0.x, use property colDef.menuTabs=['generalMenuTab','columnsMenuTab'] instead of suppressMenuFilterPanel=true");
        }
        if (options.suppressMenuMainPanel) {
            console.warn("ag-grid: since version 11.0.x, use property colDef.menuTabs=['filterMenuTab','columnsMenuTab'] instead of suppressMenuMainPanel=true");
        }
        if (options.suppressMenuColumnPanel) {
            console.warn("ag-grid: since version 11.0.x, use property colDef.menuTabs=['generalMenuTab','filterMenuTab'] instead of suppressMenuColumnPanel=true");
        }
        if (options.suppressUseColIdForGroups) {
            console.warn("ag-grid: since version 11.0.x, this is not in use anymore. You should be able to remove it from your definition");
        }
        if (options.groupColumnDef) {
            console.warn("ag-grid: since version 11.0.x, groupColumnDef has been renamed, this property is now called autoGroupColumnDef. Please change your configuration accordingly");
        }
        if (options.slaveGrids) {
            console.warn("ag-grid: since version 12.x, slaveGrids has been renamed, this property is now called alignedGrids. Please change your configuration accordingly");
        }
        if (options.floatingTopRowData) {
            console.warn("ag-grid: since version 12.x, floatingTopRowData is now called pinnedTopRowData");
        }
        if (options.floatingBottomRowData) {
            console.warn("ag-grid: since version 12.x, floatingBottomRowData is now called pinnedBottomRowData");
        }
        if (options.paginationStartPage) {
            console.warn("ag-grid: since version 12.x, paginationStartPage is gone, please call api.paginationGoToPage(" + options.paginationStartPage + ") instead.");
        }
    };
    GridOptionsWrapper.prototype.getLocaleTextFunc = function () {
        if (this.gridOptions.localeTextFunc) {
            return this.gridOptions.localeTextFunc;
        }
        var that = this;
        return function (key, defaultValue) {
            var localeText = that.gridOptions.localeText;
            if (localeText && localeText[key]) {
                return localeText[key];
            }
            else {
                return defaultValue;
            }
        };
    };
    // responsible for calling the onXXX functions on gridOptions
    GridOptionsWrapper.prototype.globalEventHandler = function (eventName, event) {
        var callbackMethodName = componentUtil_1.ComponentUtil.getCallbackForEvent(eventName);
        if (typeof this.gridOptions[callbackMethodName] === 'function') {
            this.gridOptions[callbackMethodName](event);
        }
    };
    // we don't allow dynamic row height for virtual paging
    GridOptionsWrapper.prototype.getRowHeightAsNumber = function () {
        var rowHeight = this.gridOptions.rowHeight;
        if (utils_1.Utils.missing(rowHeight)) {
            return this.getDefaultRowHeight();
        }
        else if (this.isNumeric(this.gridOptions.rowHeight)) {
            return this.gridOptions.rowHeight;
        }
        else {
            console.warn('ag-Grid row height must be a number if not using standard row model');
            return this.getDefaultRowHeight();
        }
    };
    GridOptionsWrapper.prototype.getRowHeightForNode = function (rowNode) {
        // check the function first, in case use set both function and
        // number, when using virtual pagination then function can be
        // used for pinned rows and the number for the body rows.
        if (typeof this.gridOptions.getRowHeight === 'function') {
            var params = {
                node: rowNode,
                data: rowNode.data,
                api: this.gridOptions.api,
                context: this.gridOptions.context
            };
            return this.gridOptions.getRowHeight(params);
        }
        else if (this.isNumeric(this.gridOptions.rowHeight)) {
            return this.gridOptions.rowHeight;
        }
        else {
            return this.getDefaultRowHeight();
        }
    };
    GridOptionsWrapper.prototype.isDynamicRowHeight = function () {
        return typeof this.gridOptions.getRowHeight === 'function';
    };
    GridOptionsWrapper.prototype.getVirtualItemHeight = function () {
        return this.specialForNewMaterial(20, 8 * 5);
    };
    GridOptionsWrapper.prototype.getAggFuncPopupHeight = function () {
        return this.specialForNewMaterial(100, 8 * 5 * 3.5); // 3.5 cuts the last item in half, hinting that you can scroll
    };
    GridOptionsWrapper.prototype.getCheckboxIndentWidth = function () {
        return this.specialForNewMaterial(10, 18 + 8); // icon size + grid size
    };
    GridOptionsWrapper.prototype.isNumeric = function (value) {
        return !isNaN(value) && typeof value === 'number';
    };
    // Material data table has strict guidelines about whitespace, and these values are different than the ones 
    // ag-grid uses by default. We override the default ones for the sake of making it better out of the box
    GridOptionsWrapper.prototype.specialForNewMaterial = function (defaultValue, materialValue) {
        if (this.environment.getTheme() == "ag-theme-material") {
            return materialValue;
        }
        else {
            return defaultValue;
        }
    };
    GridOptionsWrapper.prototype.getDefaultRowHeight = function () {
        return this.specialForNewMaterial(DEFAULT_ROW_HEIGHT, 8 * 6);
    };
    GridOptionsWrapper.MIN_COL_WIDTH = 10;
    GridOptionsWrapper.PROP_HEADER_HEIGHT = 'headerHeight';
    GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN = 'groupRemoveSingleChildren';
    GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN = 'groupRemoveLowestSingleChildren';
    GridOptionsWrapper.PROP_PIVOT_HEADER_HEIGHT = 'pivotHeaderHeight';
    GridOptionsWrapper.PROP_GROUP_HEADER_HEIGHT = 'groupHeaderHeight';
    GridOptionsWrapper.PROP_PIVOT_GROUP_HEADER_HEIGHT = 'pivotGroupHeaderHeight';
    GridOptionsWrapper.PROP_FLOATING_FILTERS_HEIGHT = 'floatingFiltersHeight';
    __decorate([
        context_1.Autowired('gridOptions'),
        __metadata("design:type", Object)
    ], GridOptionsWrapper.prototype, "gridOptions", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], GridOptionsWrapper.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], GridOptionsWrapper.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('enterprise'),
        __metadata("design:type", Boolean)
    ], GridOptionsWrapper.prototype, "enterprise", void 0);
    __decorate([
        context_1.Autowired('frameworkFactory'),
        __metadata("design:type", Object)
    ], GridOptionsWrapper.prototype, "frameworkFactory", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], GridOptionsWrapper.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], GridOptionsWrapper.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('environment'),
        __metadata("design:type", environment_1.Environment)
    ], GridOptionsWrapper.prototype, "environment", void 0);
    __decorate([
        __param(0, context_1.Qualifier('gridApi')), __param(1, context_1.Qualifier('columnApi')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [gridApi_1.GridApi, columnController_1.ColumnApi]),
        __metadata("design:returntype", void 0)
    ], GridOptionsWrapper.prototype, "agWire", null);
    __decorate([
        context_1.PreDestroy,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], GridOptionsWrapper.prototype, "destroy", null);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], GridOptionsWrapper.prototype, "init", null);
    GridOptionsWrapper = GridOptionsWrapper_1 = __decorate([
        context_1.Bean('gridOptionsWrapper')
    ], GridOptionsWrapper);
    return GridOptionsWrapper;
    var GridOptionsWrapper_1;
}());
exports.GridOptionsWrapper = GridOptionsWrapper;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var columnGroup_1 = __webpack_require__(28);
var column_1 = __webpack_require__(9);
var gridOptionsWrapper_1 = __webpack_require__(2);
var expressionService_1 = __webpack_require__(19);
var balancedColumnTreeBuilder_1 = __webpack_require__(46);
var displayedGroupCreator_1 = __webpack_require__(47);
var autoWidthCalculator_1 = __webpack_require__(77);
var eventService_1 = __webpack_require__(4);
var columnUtils_1 = __webpack_require__(31);
var logger_1 = __webpack_require__(11);
var events_1 = __webpack_require__(5);
var originalColumnGroup_1 = __webpack_require__(32);
var groupInstanceIdCreator_1 = __webpack_require__(65);
var context_1 = __webpack_require__(0);
var gridPanel_1 = __webpack_require__(10);
var columnAnimationService_1 = __webpack_require__(85);
var autoGroupColService_1 = __webpack_require__(94);
var valueCache_1 = __webpack_require__(36);
var gridApi_1 = __webpack_require__(6);
var ColumnApi = (function () {
    function ColumnApi() {
    }
    ColumnApi.prototype.sizeColumnsToFit = function (gridWidth) { this._columnController.sizeColumnsToFit(gridWidth); };
    ColumnApi.prototype.setColumnGroupOpened = function (group, newValue) { this._columnController.setColumnGroupOpened(group, newValue); };
    ColumnApi.prototype.getColumnGroup = function (name, instanceId) { return this._columnController.getColumnGroup(name, instanceId); };
    ColumnApi.prototype.getOriginalColumnGroup = function (name) { return this._columnController.getOriginalColumnGroup(name); };
    ColumnApi.prototype.getDisplayNameForColumn = function (column, location) { return this._columnController.getDisplayNameForColumn(column, location); };
    ColumnApi.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) { return this._columnController.getDisplayNameForColumnGroup(columnGroup, location); };
    ColumnApi.prototype.getColumn = function (key) { return this._columnController.getPrimaryColumn(key); };
    ColumnApi.prototype.setColumnState = function (columnState) { return this._columnController.setColumnState(columnState); };
    ColumnApi.prototype.getColumnState = function () { return this._columnController.getColumnState(); };
    ColumnApi.prototype.resetColumnState = function () { this._columnController.resetColumnState(); };
    ColumnApi.prototype.getColumnGroupState = function () { return this._columnController.getColumnGroupState(); };
    ColumnApi.prototype.setColumnGroupState = function (stateItems) { this._columnController.setColumnGroupState(stateItems); };
    ColumnApi.prototype.resetColumnGroupState = function () { this._columnController.resetColumnGroupState(); };
    ColumnApi.prototype.isPinning = function () { return this._columnController.isPinningLeft() || this._columnController.isPinningRight(); };
    ColumnApi.prototype.isPinningLeft = function () { return this._columnController.isPinningLeft(); };
    ColumnApi.prototype.isPinningRight = function () { return this._columnController.isPinningRight(); };
    ColumnApi.prototype.getDisplayedColAfter = function (col) { return this._columnController.getDisplayedColAfter(col); };
    ColumnApi.prototype.getDisplayedColBefore = function (col) { return this._columnController.getDisplayedColBefore(col); };
    ColumnApi.prototype.setColumnVisible = function (key, visible) { this._columnController.setColumnVisible(key, visible); };
    ColumnApi.prototype.setColumnsVisible = function (keys, visible) { this._columnController.setColumnsVisible(keys, visible); };
    ColumnApi.prototype.setColumnPinned = function (key, pinned) { this._columnController.setColumnPinned(key, pinned); };
    ColumnApi.prototype.setColumnsPinned = function (keys, pinned) { this._columnController.setColumnsPinned(keys, pinned); };
    ColumnApi.prototype.getAllColumns = function () { return this._columnController.getAllPrimaryColumns(); };
    ColumnApi.prototype.getAllGridColumns = function () { return this._columnController.getAllGridColumns(); };
    ColumnApi.prototype.getDisplayedLeftColumns = function () { return this._columnController.getDisplayedLeftColumns(); };
    ColumnApi.prototype.getDisplayedCenterColumns = function () { return this._columnController.getDisplayedCenterColumns(); };
    ColumnApi.prototype.getDisplayedRightColumns = function () { return this._columnController.getDisplayedRightColumns(); };
    ColumnApi.prototype.getAllDisplayedColumns = function () { return this._columnController.getAllDisplayedColumns(); };
    ColumnApi.prototype.getAllDisplayedVirtualColumns = function () { return this._columnController.getAllDisplayedVirtualColumns(); };
    ColumnApi.prototype.moveColumn = function (key, toIndex) {
        if (typeof key === 'number') {
            // moveColumn used to take indexes, so this is advising user who hasn't moved to new method name
            console.log('ag-Grid: you are using moveColumn(fromIndex, toIndex) - moveColumn takes a column key and a destination index, not two indexes, to move with indexes use moveColumnByIndex(from,to) instead');
            this._columnController.moveColumnByIndex(key, toIndex);
        }
        else {
            this._columnController.moveColumn(key, toIndex);
        }
    };
    ColumnApi.prototype.moveColumnByIndex = function (fromIndex, toIndex) { this._columnController.moveColumnByIndex(fromIndex, toIndex); };
    ColumnApi.prototype.moveColumns = function (columnsToMoveKeys, toIndex) { this._columnController.moveColumns(columnsToMoveKeys, toIndex); };
    ColumnApi.prototype.moveRowGroupColumn = function (fromIndex, toIndex) { this._columnController.moveRowGroupColumn(fromIndex, toIndex); };
    ColumnApi.prototype.setColumnAggFunc = function (column, aggFunc) { this._columnController.setColumnAggFunc(column, aggFunc); };
    ColumnApi.prototype.setColumnWidth = function (key, newWidth, finished) {
        if (finished === void 0) { finished = true; }
        this._columnController.setColumnWidth(key, newWidth, finished);
    };
    ColumnApi.prototype.setPivotMode = function (pivotMode) { this._columnController.setPivotMode(pivotMode); };
    ColumnApi.prototype.isPivotMode = function () { return this._columnController.isPivotMode(); };
    ColumnApi.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) { return this._columnController.getSecondaryPivotColumn(pivotKeys, valueColKey); };
    ColumnApi.prototype.setValueColumns = function (colKeys) { this._columnController.setValueColumns(colKeys); };
    ColumnApi.prototype.getValueColumns = function () { return this._columnController.getValueColumns(); };
    ColumnApi.prototype.removeValueColumn = function (colKey) { this._columnController.removeValueColumn(colKey); };
    ColumnApi.prototype.removeValueColumns = function (colKeys) { this._columnController.removeValueColumns(colKeys); };
    ColumnApi.prototype.addValueColumn = function (colKey) { this._columnController.addValueColumn(colKey); };
    ColumnApi.prototype.addValueColumns = function (colKeys) { this._columnController.addValueColumns(colKeys); };
    ColumnApi.prototype.setRowGroupColumns = function (colKeys) { this._columnController.setRowGroupColumns(colKeys); };
    ColumnApi.prototype.removeRowGroupColumn = function (colKey) { this._columnController.removeRowGroupColumn(colKey); };
    ColumnApi.prototype.removeRowGroupColumns = function (colKeys) { this._columnController.removeRowGroupColumns(colKeys); };
    ColumnApi.prototype.addRowGroupColumn = function (colKey) { this._columnController.addRowGroupColumn(colKey); };
    ColumnApi.prototype.addRowGroupColumns = function (colKeys) { this._columnController.addRowGroupColumns(colKeys); };
    ColumnApi.prototype.getRowGroupColumns = function () { return this._columnController.getRowGroupColumns(); };
    ColumnApi.prototype.setPivotColumns = function (colKeys) { this._columnController.setPivotColumns(colKeys); };
    ColumnApi.prototype.removePivotColumn = function (colKey) { this._columnController.removePivotColumn(colKey); };
    ColumnApi.prototype.removePivotColumns = function (colKeys) { this._columnController.removePivotColumns(colKeys); };
    ColumnApi.prototype.addPivotColumn = function (colKey) { this._columnController.addPivotColumn(colKey); };
    ColumnApi.prototype.addPivotColumns = function (colKeys) { this._columnController.addPivotColumns(colKeys); };
    ColumnApi.prototype.getPivotColumns = function () { return this._columnController.getPivotColumns(); };
    ColumnApi.prototype.getLeftDisplayedColumnGroups = function () { return this._columnController.getLeftDisplayedColumnGroups(); };
    ColumnApi.prototype.getCenterDisplayedColumnGroups = function () { return this._columnController.getCenterDisplayedColumnGroups(); };
    ColumnApi.prototype.getRightDisplayedColumnGroups = function () { return this._columnController.getRightDisplayedColumnGroups(); };
    ColumnApi.prototype.getAllDisplayedColumnGroups = function () { return this._columnController.getAllDisplayedColumnGroups(); };
    ColumnApi.prototype.autoSizeColumn = function (key) { return this._columnController.autoSizeColumn(key); };
    ColumnApi.prototype.autoSizeColumns = function (keys) { return this._columnController.autoSizeColumns(keys); };
    ColumnApi.prototype.autoSizeAllColumns = function () { this._columnController.autoSizeAllColumns(); };
    ColumnApi.prototype.setSecondaryColumns = function (colDefs) { this._columnController.setSecondaryColumns(colDefs); };
    // below goes through deprecated items, prints message to user, then calls the new version of the same method
    ColumnApi.prototype.columnGroupOpened = function (group, newValue) {
        console.error('ag-Grid: columnGroupOpened no longer exists, use setColumnGroupOpened');
        this.setColumnGroupOpened(group, newValue);
    };
    ColumnApi.prototype.hideColumns = function (colIds, hide) {
        console.error('ag-Grid: hideColumns is deprecated, use setColumnsVisible');
        this._columnController.setColumnsVisible(colIds, !hide);
    };
    ColumnApi.prototype.hideColumn = function (colId, hide) {
        console.error('ag-Grid: hideColumn is deprecated, use setColumnVisible');
        this._columnController.setColumnVisible(colId, !hide);
    };
    ColumnApi.prototype.setState = function (columnState) {
        console.error('ag-Grid: setState is deprecated, use setColumnState');
        return this.setColumnState(columnState);
    };
    ColumnApi.prototype.getState = function () {
        console.error('ag-Grid: getState is deprecated, use getColumnState');
        return this.getColumnState();
    };
    ColumnApi.prototype.resetState = function () {
        console.error('ag-Grid: resetState is deprecated, use resetColumnState');
        this.resetColumnState();
    };
    ColumnApi.prototype.getAggregationColumns = function () {
        console.error('ag-Grid: getAggregationColumns is deprecated, use getValueColumns');
        return this._columnController.getValueColumns();
    };
    ColumnApi.prototype.removeAggregationColumn = function (colKey) {
        console.error('ag-Grid: removeAggregationColumn is deprecated, use removeValueColumn');
        this._columnController.removeValueColumn(colKey);
    };
    ColumnApi.prototype.removeAggregationColumns = function (colKeys) {
        console.error('ag-Grid: removeAggregationColumns is deprecated, use removeValueColumns');
        this._columnController.removeValueColumns(colKeys);
    };
    ColumnApi.prototype.addAggregationColumn = function (colKey) {
        console.error('ag-Grid: addAggregationColumn is deprecated, use addValueColumn');
        this._columnController.addValueColumn(colKey);
    };
    ColumnApi.prototype.addAggregationColumns = function (colKeys) {
        console.error('ag-Grid: addAggregationColumns is deprecated, use addValueColumns');
        this._columnController.addValueColumns(colKeys);
    };
    ColumnApi.prototype.setColumnAggFunction = function (column, aggFunc) {
        console.error('ag-Grid: setColumnAggFunction is deprecated, use setColumnAggFunc');
        this._columnController.setColumnAggFunc(column, aggFunc);
    };
    ColumnApi.prototype.getDisplayNameForCol = function (column) {
        console.error('ag-Grid: getDisplayNameForCol is deprecated, use getDisplayNameForColumn');
        return this.getDisplayNameForColumn(column, null);
    };
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", ColumnController)
    ], ColumnApi.prototype, "_columnController", void 0);
    ColumnApi = __decorate([
        context_1.Bean('columnApi')
    ], ColumnApi);
    return ColumnApi;
}());
exports.ColumnApi = ColumnApi;
var ColumnController = (function () {
    function ColumnController() {
        // header row count, based on user provided columns
        this.primaryHeaderRowCount = 0;
        this.secondaryHeaderRowCount = 0;
        this.secondaryColumnsPresent = false;
        // header row count, either above, or based on pivoting if we are pivoting
        this.gridHeaderRowCount = 0;
        // these are the lists used by the rowRenderer to render nodes. almost the leaf nodes of the above
        // displayed trees, however it also takes into account if the groups are open or not.
        this.displayedLeftColumns = [];
        this.displayedRightColumns = [];
        this.displayedCenterColumns = [];
        // all three lists above combined
        this.allDisplayedColumns = [];
        // same as above, except trimmed down to only columns within the viewport
        this.allDisplayedVirtualColumns = [];
        this.allDisplayedCenterVirtualColumns = [];
        this.rowGroupColumns = [];
        this.valueColumns = [];
        this.pivotColumns = [];
        this.ready = false;
        this.autoGroupsNeedBuilding = false;
        this.pivotMode = false;
        this.bodyWidth = 0;
        this.leftWidth = 0;
        this.rightWidth = 0;
        this.bodyWidthDirty = true;
    }
    ColumnController.prototype.init = function () {
        var pivotMode = this.gridOptionsWrapper.isPivotMode();
        if (this.isPivotSettingAllowed(pivotMode)) {
            this.pivotMode = pivotMode;
        }
        this.usingTreeData = this.gridOptionsWrapper.isTreeData();
    };
    ColumnController.prototype.setVirtualViewportLeftAndRight = function () {
        if (this.gridOptionsWrapper.isEnableRtl()) {
            this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;
            this.viewportRight = this.bodyWidth - this.scrollPosition;
        }
        else {
            this.viewportLeft = this.scrollPosition;
            this.viewportRight = this.scrollWidth + this.scrollPosition;
        }
    };
    // used by clipboard service, to know what columns to paste into
    ColumnController.prototype.getDisplayedColumnsStartingAt = function (column) {
        var currentColumn = column;
        var result = [];
        while (utils_1.Utils.exists(currentColumn)) {
            result.push(currentColumn);
            currentColumn = this.getDisplayedColAfter(currentColumn);
        }
        return result;
    };
    // checks what columns are currently displayed due to column virtualisation. fires an event
    // if the list of columns has changed.
    // + setColumnWidth(), setVirtualViewportPosition(), setColumnDefs(), sizeColumnsToFit()
    ColumnController.prototype.checkDisplayedVirtualColumns = function () {
        // check displayCenterColumnTree exists first, as it won't exist when grid is initialising
        if (utils_1.Utils.exists(this.displayedCenterColumns)) {
            var hashBefore = this.allDisplayedVirtualColumns.map(function (column) { return column.getId(); }).join('#');
            this.updateVirtualSets();
            var hashAfter = this.allDisplayedVirtualColumns.map(function (column) { return column.getId(); }).join('#');
            if (hashBefore !== hashAfter) {
                var event_1 = {
                    type: events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED,
                    api: this.gridApi,
                    columnApi: this.columnApi
                };
                this.eventService.dispatchEvent(event_1);
            }
        }
    };
    ColumnController.prototype.setVirtualViewportPosition = function (scrollWidth, scrollPosition) {
        if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {
            this.scrollWidth = scrollWidth;
            this.scrollPosition = scrollPosition;
            // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,
            // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the
            // virtual columns again
            this.bodyWidthDirty = true;
            this.setVirtualViewportLeftAndRight();
            if (this.ready) {
                this.checkDisplayedVirtualColumns();
            }
        }
    };
    ColumnController.prototype.isPivotMode = function () {
        return this.pivotMode;
    };
    ColumnController.prototype.isPivotSettingAllowed = function (pivot) {
        if (pivot) {
            if (this.gridOptionsWrapper.isTreeData()) {
                console.warn("ag-Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'");
                return false;
            }
            else {
                return true;
            }
        }
        else {
            return true;
        }
    };
    ColumnController.prototype.setPivotMode = function (pivotMode) {
        if (pivotMode === this.pivotMode) {
            return;
        }
        if (!this.isPivotSettingAllowed(this.pivotMode)) {
            return;
        }
        this.pivotMode = pivotMode;
        this.updateDisplayedColumns();
        var event = {
            type: events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    ColumnController.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {
        if (!this.secondaryColumnsPresent) {
            return null;
        }
        var valueColumnToFind = this.getPrimaryColumn(valueColKey);
        var foundColumn = null;
        this.secondaryColumns.forEach(function (column) {
            var thisPivotKeys = column.getColDef().pivotKeys;
            var pivotValueColumn = column.getColDef().pivotValueColumn;
            var pivotKeyMatches = utils_1.Utils.compareArrays(thisPivotKeys, pivotKeys);
            var pivotValueMatches = pivotValueColumn === valueColumnToFind;
            if (pivotKeyMatches && pivotValueMatches) {
                foundColumn = column;
            }
        });
        return foundColumn;
    };
    ColumnController.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('ColumnController');
    };
    ColumnController.prototype.setFirstRightAndLastLeftPinned = function () {
        var lastLeft;
        var firstRight;
        if (this.gridOptionsWrapper.isEnableRtl()) {
            lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[0] : null;
            firstRight = this.displayedRightColumns ? this.displayedRightColumns[this.displayedRightColumns.length - 1] : null;
        }
        else {
            lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[this.displayedLeftColumns.length - 1] : null;
            firstRight = this.displayedRightColumns ? this.displayedRightColumns[0] : null;
        }
        this.gridColumns.forEach(function (column) {
            column.setLastLeftPinned(column === lastLeft);
            column.setFirstRightPinned(column === firstRight);
        });
    };
    ColumnController.prototype.autoSizeColumns = function (keys) {
        // because of column virtualisation, we can only do this function on columns that are
        // actually rendered, as non-rendered columns (outside the viewport and not rendered
        // due to column virtualisation) are not present. this can result in all rendered columns
        // getting narrowed, which in turn introduces more rendered columns on the RHS which
        // did not get autosized in the original run, leaving the visible grid with columns on
        // the LHS sized, but RHS no. so we keep looping through teh visible columns until
        // no more cols are available (rendered) to be resized
        var _this = this;
        // keep track of which cols we have resized in here
        var columnsAutosized = [];
        // initialise with anything except 0 so that while loop executs at least once
        var changesThisTimeAround = -1;
        while (changesThisTimeAround !== 0) {
            changesThisTimeAround = 0;
            this.actionOnGridColumns(keys, function (column) {
                // if already autosized, skip it
                if (columnsAutosized.indexOf(column) >= 0) {
                    return;
                }
                // get how wide this col should be
                var preferredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column);
                // preferredWidth = -1 if this col is not on the screen
                if (preferredWidth > 0) {
                    var newWidth = _this.normaliseColumnWidth(column, preferredWidth);
                    column.setActualWidth(newWidth);
                    columnsAutosized.push(column);
                    changesThisTimeAround++;
                }
                return true;
            });
        }
        if (columnsAutosized.length > 0) {
            var event_2 = {
                type: events_1.Events.EVENT_COLUMN_RESIZED,
                columns: columnsAutosized,
                column: columnsAutosized.length === 1 ? columnsAutosized[0] : null,
                finished: true,
                api: this.gridApi,
                columnApi: this.columnApi
            };
            this.eventService.dispatchEvent(event_2);
        }
    };
    ColumnController.prototype.autoSizeColumn = function (key) {
        this.autoSizeColumns([key]);
    };
    ColumnController.prototype.autoSizeAllColumns = function () {
        var allDisplayedColumns = this.getAllDisplayedColumns();
        this.autoSizeColumns(allDisplayedColumns);
    };
    ColumnController.prototype.getColumnsFromTree = function (rootColumns) {
        var result = [];
        recursiveFindColumns(rootColumns);
        return result;
        function recursiveFindColumns(childColumns) {
            for (var i = 0; i < childColumns.length; i++) {
                var child = childColumns[i];
                if (child instanceof column_1.Column) {
                    result.push(child);
                }
                else if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                    recursiveFindColumns(child.getChildren());
                }
            }
        }
    };
    ColumnController.prototype.getAllDisplayedColumnGroups = function () {
        if (this.displayedLeftColumnTree && this.displayedRightColumnTree && this.displayedCentreColumnTree) {
            return this.displayedLeftColumnTree
                .concat(this.displayedCentreColumnTree)
                .concat(this.displayedRightColumnTree);
        }
        else {
            return null;
        }
    };
    // + columnSelectPanel
    ColumnController.prototype.getPrimaryColumnTree = function () {
        return this.primaryBalancedTree;
    };
    // + gridPanel -> for resizing the body and setting top margin
    ColumnController.prototype.getHeaderRowCount = function () {
        return this.gridHeaderRowCount;
    };
    // + headerRenderer -> setting pinned body width
    ColumnController.prototype.getLeftDisplayedColumnGroups = function () {
        return this.displayedLeftColumnTree;
    };
    // + headerRenderer -> setting pinned body width
    ColumnController.prototype.getRightDisplayedColumnGroups = function () {
        return this.displayedRightColumnTree;
    };
    // + headerRenderer -> setting pinned body width
    ColumnController.prototype.getCenterDisplayedColumnGroups = function () {
        return this.displayedCentreColumnTree;
    };
    ColumnController.prototype.getDisplayedColumnGroups = function (type) {
        switch (type) {
            case column_1.Column.PINNED_LEFT: return this.getLeftDisplayedColumnGroups();
            case column_1.Column.PINNED_RIGHT: return this.getRightDisplayedColumnGroups();
            default: return this.getCenterDisplayedColumnGroups();
        }
    };
    // gridPanel -> ensureColumnVisible
    ColumnController.prototype.isColumnDisplayed = function (column) {
        return this.getAllDisplayedColumns().indexOf(column) >= 0;
    };
    // + csvCreator
    ColumnController.prototype.getAllDisplayedColumns = function () {
        return this.allDisplayedColumns;
    };
    ColumnController.prototype.getAllDisplayedVirtualColumns = function () {
        return this.allDisplayedVirtualColumns;
    };
    ColumnController.prototype.getDisplayedLeftColumnsForRow = function (rowNode) {
        if (!this.colSpanActive) {
            return this.displayedLeftColumns;
        }
        else {
            return this.getDisplayedColumnsForRow(rowNode, this.displayedLeftColumns);
        }
    };
    ColumnController.prototype.getDisplayedRightColumnsForRow = function (rowNode) {
        if (!this.colSpanActive) {
            return this.displayedRightColumns;
        }
        else {
            return this.getDisplayedColumnsForRow(rowNode, this.displayedRightColumns);
        }
    };
    ColumnController.prototype.getDisplayedColumnsForRow = function (rowNode, displayedColumns, filterCallback, gapBeforeCallback) {
        var result = [];
        var lastConsideredCol = null;
        for (var i = 0; i < displayedColumns.length; i++) {
            var col = displayedColumns[i];
            var colSpan = col.getColSpan(rowNode);
            if (colSpan > 1) {
                var colsToRemove = colSpan - 1;
                i += colsToRemove;
            }
            var filterPasses = filterCallback ? filterCallback(col) : true;
            if (filterPasses) {
                var gapBeforeColumn = gapBeforeCallback ? gapBeforeCallback(col) : false;
                var addInPreviousColumn = result.length === 0 && gapBeforeColumn && lastConsideredCol;
                if (addInPreviousColumn) {
                    result.push(lastConsideredCol);
                }
                result.push(col);
            }
            lastConsideredCol = col;
        }
        return result;
    };
    // + rowRenderer
    // if we are not column spanning, this just returns back the virtual centre columns,
    // however if we are column spanning, then different rows can have different virtual
    // columns, so we have to work out the list for each individual row.
    ColumnController.prototype.getAllDisplayedCenterVirtualColumnsForRow = function (rowNode) {
        var _this = this;
        if (!this.colSpanActive) {
            return this.allDisplayedCenterVirtualColumns;
        }
        var gapBeforeCallback = function (col) { return col.getLeft() > _this.viewportLeft; };
        return this.getDisplayedColumnsForRow(rowNode, this.displayedCenterColumns, this.isColumnInViewport.bind(this), gapBeforeCallback);
    };
    ColumnController.prototype.isColumnInViewport = function (col) {
        var columnLeft = col.getLeft();
        var columnRight = col.getLeft() + col.getActualWidth();
        var columnToMuchLeft = columnLeft < this.viewportLeft && columnRight < this.viewportLeft;
        var columnToMuchRight = columnLeft > this.viewportRight && columnRight > this.viewportRight;
        return !columnToMuchLeft && !columnToMuchRight;
    };
    // used by:
    // + angularGrid -> setting pinned body width
    // todo: this needs to be cached
    ColumnController.prototype.getPinnedLeftContainerWidth = function () {
        return this.getWidthOfColsInList(this.displayedLeftColumns);
    };
    // todo: this needs to be cached
    ColumnController.prototype.getPinnedRightContainerWidth = function () {
        return this.getWidthOfColsInList(this.displayedRightColumns);
    };
    ColumnController.prototype.updatePrimaryColumnList = function (keys, masterList, actionIsAdd, columnCallback, eventType) {
        var _this = this;
        if (utils_1.Utils.missingOrEmpty(keys)) {
            return;
        }
        var atLeastOne = false;
        keys.forEach(function (key) {
            var columnToAdd = _this.getPrimaryColumn(key);
            if (!columnToAdd) {
                return;
            }
            if (actionIsAdd) {
                if (masterList.indexOf(columnToAdd) >= 0) {
                    return;
                }
                masterList.push(columnToAdd);
            }
            else {
                if (masterList.indexOf(columnToAdd) < 0) {
                    return;
                }
                utils_1.Utils.removeFromArray(masterList, columnToAdd);
            }
            columnCallback(columnToAdd);
            atLeastOne = true;
        });
        if (!atLeastOne) {
            return;
        }
        this.updateDisplayedColumns();
        var event = {
            type: eventType,
            columns: masterList,
            column: masterList.length === 1 ? masterList[0] : null,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    ColumnController.prototype.setRowGroupColumns = function (colKeys) {
        this.autoGroupsNeedBuilding = true;
        this.setPrimaryColumnList(colKeys, this.rowGroupColumns, events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this));
    };
    ColumnController.prototype.setRowGroupActive = function (active, column) {
        if (active === column.isRowGroupActive()) {
            return;
        }
        column.setRowGroupActive(active);
        if (!active) {
            column.setVisible(true);
        }
    };
    ColumnController.prototype.addRowGroupColumn = function (key) {
        this.addRowGroupColumns([key]);
    };
    ColumnController.prototype.addRowGroupColumns = function (keys) {
        this.autoGroupsNeedBuilding = true;
        this.updatePrimaryColumnList(keys, this.rowGroupColumns, true, this.setRowGroupActive.bind(this, true), events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
    };
    ColumnController.prototype.removeRowGroupColumns = function (keys) {
        this.autoGroupsNeedBuilding = true;
        this.updatePrimaryColumnList(keys, this.rowGroupColumns, false, this.setRowGroupActive.bind(this, false), events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
    };
    ColumnController.prototype.removeRowGroupColumn = function (key) {
        this.removeRowGroupColumns([key]);
    };
    ColumnController.prototype.addPivotColumns = function (keys) {
        this.updatePrimaryColumnList(keys, this.pivotColumns, true, function (column) { return column.setPivotActive(true); }, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED);
    };
    ColumnController.prototype.setPivotColumns = function (colKeys) {
        this.setPrimaryColumnList(colKeys, this.pivotColumns, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, function (added, column) {
            column.setPivotActive(added);
        });
    };
    ColumnController.prototype.addPivotColumn = function (key) {
        this.addPivotColumns([key]);
    };
    ColumnController.prototype.removePivotColumns = function (keys) {
        this.updatePrimaryColumnList(keys, this.pivotColumns, false, function (column) { return column.setPivotActive(false); }, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED);
    };
    ColumnController.prototype.removePivotColumn = function (key) {
        this.removePivotColumns([key]);
    };
    ColumnController.prototype.setPrimaryColumnList = function (colKeys, masterList, eventName, columnCallback) {
        var _this = this;
        masterList.length = 0;
        if (utils_1.Utils.exists(colKeys)) {
            colKeys.forEach(function (key) {
                var column = _this.getPrimaryColumn(key);
                masterList.push(column);
            });
        }
        this.primaryColumns.forEach(function (column) {
            var added = masterList.indexOf(column) >= 0;
            columnCallback(added, column);
        });
        this.updateDisplayedColumns();
        var event = {
            type: eventName,
            columns: masterList,
            column: masterList.length === 1 ? masterList[0] : null,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    ColumnController.prototype.setValueColumns = function (colKeys) {
        this.setPrimaryColumnList(colKeys, this.valueColumns, events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this));
    };
    ColumnController.prototype.setValueActive = function (active, column) {
        if (active === column.isValueActive()) {
            return;
        }
        column.setValueActive(active);
        if (active && !column.getAggFunc()) {
            var defaultAggFunc = this.aggFuncService.getDefaultAggFunc(column);
            column.setAggFunc(defaultAggFunc);
        }
    };
    ColumnController.prototype.addValueColumns = function (keys) {
        this.updatePrimaryColumnList(keys, this.valueColumns, true, this.setValueActive.bind(this, true), events_1.Events.EVENT_COLUMN_VALUE_CHANGED);
    };
    ColumnController.prototype.addValueColumn = function (colKey) {
        this.addValueColumns([colKey]);
    };
    ColumnController.prototype.removeValueColumn = function (colKey) {
        this.removeValueColumns([colKey]);
    };
    ColumnController.prototype.removeValueColumns = function (keys) {
        this.updatePrimaryColumnList(keys, this.valueColumns, false, this.setValueActive.bind(this, false), events_1.Events.EVENT_COLUMN_VALUE_CHANGED);
    };
    // returns the width we can set to this col, taking into consideration min and max widths
    ColumnController.prototype.normaliseColumnWidth = function (column, newWidth) {
        if (newWidth < column.getMinWidth()) {
            newWidth = column.getMinWidth();
        }
        if (column.isGreaterThanMax(newWidth)) {
            newWidth = column.getMaxWidth();
        }
        return newWidth;
    };
    ColumnController.prototype.getPrimaryOrGridColumn = function (key) {
        var column = this.getPrimaryColumn(key);
        if (column) {
            return column;
        }
        else {
            return this.getGridColumn(key);
        }
    };
    ColumnController.prototype.setColumnWidth = function (key, newWidth, finished) {
        var column = this.getPrimaryOrGridColumn(key);
        if (!column) {
            return;
        }
        newWidth = this.normaliseColumnWidth(column, newWidth);
        var widthChanged = column.getActualWidth() !== newWidth;
        if (widthChanged) {
            column.setActualWidth(newWidth);
            this.setLeftValues();
        }
        this.updateBodyWidths();
        this.checkDisplayedVirtualColumns();
        // check for change first, to avoid unnecessary firing of events
        // however we always fire 'finished' events. this is important
        // when groups are resized, as if the group is changing slowly,
        // eg 1 pixel at a time, then each change will fire change events
        // in all the columns in the group, but only one with get the pixel.
        if (finished || widthChanged) {
            var event_3 = {
                type: events_1.Events.EVENT_COLUMN_RESIZED,
                columns: [column],
                column: column,
                finished: finished,
                api: this.gridApi,
                columnApi: this.columnApi
            };
            this.eventService.dispatchEvent(event_3);
        }
    };
    ColumnController.prototype.setColumnAggFunc = function (column, aggFunc) {
        column.setAggFunc(aggFunc);
        var event = {
            type: events_1.Events.EVENT_COLUMN_VALUE_CHANGED,
            columns: [column],
            column: column,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    ColumnController.prototype.moveRowGroupColumn = function (fromIndex, toIndex) {
        var column = this.rowGroupColumns[fromIndex];
        this.rowGroupColumns.splice(fromIndex, 1);
        this.rowGroupColumns.splice(toIndex, 0, column);
        var event = {
            type: events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED,
            columns: this.rowGroupColumns,
            column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    ColumnController.prototype.moveColumns = function (columnsToMoveKeys, toIndex) {
        this.columnAnimationService.start();
        if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {
            console.warn('ag-Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);
            console.warn('ag-Grid: remember that you should not count the moving columns when calculating the new index');
            return;
        }
        // we want to pull all the columns out first and put them into an ordered list
        var columnsToMove = this.getGridColumns(columnsToMoveKeys);
        var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);
        if (failedRules) {
            return;
        }
        utils_1.Utils.moveInArray(this.gridColumns, columnsToMove, toIndex);
        this.updateDisplayedColumns();
        var event = {
            type: events_1.Events.EVENT_COLUMN_MOVED,
            columns: columnsToMove,
            column: columnsToMove.length === 1 ? columnsToMove[0] : null,
            toIndex: toIndex,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
        this.columnAnimationService.finish();
    };
    ColumnController.prototype.doesMovePassRules = function (columnsToMove, toIndex) {
        var allColumnsCopy = this.gridColumns.slice();
        utils_1.Utils.moveInArray(allColumnsCopy, columnsToMove, toIndex);
        var rulesPass = true;
        this.columnUtils.depthFirstOriginalTreeSearch(this.gridBalancedTree, function (child) {
            if (!(child instanceof originalColumnGroup_1.OriginalColumnGroup)) {
                return;
            }
            var columnGroup = child;
            var marryChildren = columnGroup.getColGroupDef() && columnGroup.getColGroupDef().marryChildren;
            if (!marryChildren) {
                return;
            }
            var newIndexes = [];
            columnGroup.getLeafColumns().forEach(function (col) {
                var newColIndex = allColumnsCopy.indexOf(col);
                newIndexes.push(newColIndex);
            });
            var maxIndex = Math.max.apply(Math, newIndexes);
            var minIndex = Math.min.apply(Math, newIndexes);
            // width is how far the first column in this group is away from the last column
            var spread = maxIndex - minIndex;
            var maxSpread = columnGroup.getLeafColumns().length - 1;
            // if the columns
            if (spread > maxSpread) {
                rulesPass = false;
            }
            // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)
            // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));
        });
        return rulesPass;
    };
    ColumnController.prototype.moveColumn = function (key, toIndex) {
        this.moveColumns([key], toIndex);
    };
    ColumnController.prototype.moveColumnByIndex = function (fromIndex, toIndex) {
        var column = this.gridColumns[fromIndex];
        this.moveColumn(column, toIndex);
    };
    // used by:
    // + angularGrid -> for setting body width
    // + rowController -> setting main row widths (when inserting and resizing)
    // need to cache this
    ColumnController.prototype.getBodyContainerWidth = function () {
        return this.bodyWidth;
    };
    ColumnController.prototype.getContainerWidth = function (pinned) {
        switch (pinned) {
            case column_1.Column.PINNED_LEFT: return this.leftWidth;
            case column_1.Column.PINNED_RIGHT: return this.rightWidth;
            default: return this.bodyWidth;
        }
    };
    // after setColumnWidth or updateGroupsAndDisplayedColumns
    ColumnController.prototype.updateBodyWidths = function () {
        var newBodyWidth = this.getWidthOfColsInList(this.displayedCenterColumns);
        var newLeftWidth = this.getWidthOfColsInList(this.displayedLeftColumns);
        var newRightWidth = this.getWidthOfColsInList(this.displayedRightColumns);
        // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed
        // columns, due to RTL inverting the y coordinates
        this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;
        var atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;
        if (atLeastOneChanged) {
            this.bodyWidth = newBodyWidth;
            this.leftWidth = newLeftWidth;
            this.rightWidth = newRightWidth;
            // when this fires, it is picked up by the gridPanel, which ends up in
            // gridPanel calling setWidthAndScrollPosition(), which in turn calls setVirtualViewportPosition()
            var event_4 = {
                type: events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,
                api: this.gridApi,
                columnApi: this.columnApi
            };
            this.eventService.dispatchEvent(event_4);
        }
    };
    // + rowController
    ColumnController.prototype.getValueColumns = function () {
        return this.valueColumns ? this.valueColumns : [];
    };
    // + rowController
    ColumnController.prototype.getPivotColumns = function () {
        return this.pivotColumns ? this.pivotColumns : [];
    };
    // + inMemoryRowModel
    ColumnController.prototype.isPivotActive = function () {
        return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;
    };
    // + toolPanel
    ColumnController.prototype.getRowGroupColumns = function () {
        return this.rowGroupColumns ? this.rowGroupColumns : [];
    };
    // + rowController -> while inserting rows
    ColumnController.prototype.getDisplayedCenterColumns = function () {
        return this.displayedCenterColumns;
    };
    // + rowController -> while inserting rows
    ColumnController.prototype.getDisplayedLeftColumns = function () {
        return this.displayedLeftColumns;
    };
    ColumnController.prototype.getDisplayedRightColumns = function () {
        return this.displayedRightColumns;
    };
    ColumnController.prototype.getDisplayedColumns = function (type) {
        switch (type) {
            case column_1.Column.PINNED_LEFT: return this.getDisplayedLeftColumns();
            case column_1.Column.PINNED_RIGHT: return this.getDisplayedRightColumns();
            default: return this.getDisplayedCenterColumns();
        }
    };
    // used by:
    // + inMemoryRowController -> sorting, building quick filter text
    // + headerRenderer -> sorting (clearing icon)
    ColumnController.prototype.getAllPrimaryColumns = function () {
        return this.primaryColumns;
    };
    // + moveColumnController
    ColumnController.prototype.getAllGridColumns = function () {
        return this.gridColumns;
    };
    ColumnController.prototype.isEmpty = function () {
        return utils_1.Utils.missingOrEmpty(this.gridColumns);
    };
    ColumnController.prototype.isRowGroupEmpty = function () {
        return utils_1.Utils.missingOrEmpty(this.rowGroupColumns);
    };
    ColumnController.prototype.setColumnVisible = function (key, visible) {
        this.setColumnsVisible([key], visible);
    };
    ColumnController.prototype.setColumnsVisible = function (keys, visible) {
        var _this = this;
        this.columnAnimationService.start();
        this.actionOnGridColumns(keys, function (column) {
            column.setVisible(visible);
            return true;
        }, function () {
            var event = {
                type: events_1.Events.EVENT_COLUMN_VISIBLE,
                visible: visible,
                column: null,
                columns: null,
                api: _this.gridApi,
                columnApi: _this.columnApi
            };
            return event;
        });
        this.columnAnimationService.finish();
    };
    ColumnController.prototype.setColumnPinned = function (key, pinned) {
        this.setColumnsPinned([key], pinned);
    };
    ColumnController.prototype.setColumnsPinned = function (keys, pinned) {
        var _this = this;
        this.columnAnimationService.start();
        var actualPinned;
        if (pinned === true || pinned === column_1.Column.PINNED_LEFT) {
            actualPinned = column_1.Column.PINNED_LEFT;
        }
        else if (pinned === column_1.Column.PINNED_RIGHT) {
            actualPinned = column_1.Column.PINNED_RIGHT;
        }
        else {
            actualPinned = null;
        }
        this.actionOnGridColumns(keys, function (column) {
            column.setPinned(actualPinned);
            return true;
        }, function () {
            var event = {
                type: events_1.Events.EVENT_COLUMN_PINNED,
                pinned: actualPinned,
                column: null,
                columns: null,
                api: _this.gridApi,
                columnApi: _this.columnApi
            };
            return event;
        });
        this.columnAnimationService.finish();
    };
    // does an action on a set of columns. provides common functionality for looking up the
    // columns based on key, getting a list of effected columns, and then updated the event
    // with either one column (if it was just one col) or a list of columns
    // used by: autoResize, setVisible, setPinned
    ColumnController.prototype.actionOnGridColumns = function (// the column keys this action will be on
        keys, 
        // the action to do - if this returns false, the column was skipped
        // and won't be included in the event
        action, 
        // should return back a column event of the right type
        createEvent) {
        var _this = this;
        if (utils_1.Utils.missingOrEmpty(keys)) {
            return;
        }
        var updatedColumns = [];
        keys.forEach(function (key) {
            var column = _this.getGridColumn(key);
            if (!column) {
                return;
            }
            // need to check for false with type (ie !== instead of !=)
            // as not returning anything (undefined) would also be false
            var resultOfAction = action(column);
            if (resultOfAction !== false) {
                updatedColumns.push(column);
            }
        });
        if (updatedColumns.length === 0) {
            return;
        }
        this.updateDisplayedColumns();
        if (utils_1.Utils.exists(createEvent)) {
            var event_5 = createEvent();
            event_5.columns = updatedColumns;
            event_5.column = updatedColumns.length === 1 ? updatedColumns[0] : null;
            this.eventService.dispatchEvent(event_5);
        }
    };
    ColumnController.prototype.getDisplayedColBefore = function (col) {
        var allDisplayedColumns = this.getAllDisplayedColumns();
        var oldIndex = allDisplayedColumns.indexOf(col);
        if (oldIndex > 0) {
            return allDisplayedColumns[oldIndex - 1];
        }
        else {
            return null;
        }
    };
    // used by:
    // + rowRenderer -> for navigation
    ColumnController.prototype.getDisplayedColAfter = function (col) {
        var allDisplayedColumns = this.getAllDisplayedColumns();
        var oldIndex = allDisplayedColumns.indexOf(col);
        if (oldIndex < (allDisplayedColumns.length - 1)) {
            return allDisplayedColumns[oldIndex + 1];
        }
        else {
            return null;
        }
    };
    ColumnController.prototype.isPinningLeft = function () {
        return this.displayedLeftColumns.length > 0;
    };
    ColumnController.prototype.isPinningRight = function () {
        return this.displayedRightColumns.length > 0;
    };
    ColumnController.prototype.getPrimaryAndSecondaryAndAutoColumns = function () {
        var result = this.primaryColumns ? this.primaryColumns.slice(0) : [];
        if (utils_1.Utils.exists(this.groupAutoColumns)) {
            this.groupAutoColumns.forEach(function (col) { return result.push(col); });
        }
        if (this.secondaryColumnsPresent) {
            this.secondaryColumns.forEach(function (column) { return result.push(column); });
        }
        return result;
    };
    ColumnController.prototype.createStateItemFromColumn = function (column) {
        var rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;
        var pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;
        var aggFunc = column.isValueActive() ? column.getAggFunc() : null;
        var resultItem = {
            colId: column.getColId(),
            hide: !column.isVisible(),
            aggFunc: aggFunc,
            width: column.getActualWidth(),
            pivotIndex: pivotIndex,
            pinned: column.getPinned(),
            rowGroupIndex: rowGroupIndex
        };
        return resultItem;
    };
    ColumnController.prototype.getColumnState = function () {
        if (utils_1.Utils.missing(this.primaryColumns)) {
            return [];
        }
        var columnStateList = this.primaryColumns.map(this.createStateItemFromColumn.bind(this));
        if (!this.pivotMode) {
            this.orderColumnStateList(columnStateList);
        }
        return columnStateList;
    };
    ColumnController.prototype.orderColumnStateList = function (columnStateList) {
        var gridColumnIds = this.gridColumns.map(function (column) { return column.getColId(); });
        columnStateList.sort(function (itemA, itemB) {
            var posA = gridColumnIds.indexOf(itemA.colId);
            var posB = gridColumnIds.indexOf(itemB.colId);
            return posA - posB;
        });
    };
    ColumnController.prototype.resetColumnState = function () {
        // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list
        var primaryColumns = this.getColumnsFromTree(this.primaryBalancedTree);
        var state = [];
        if (primaryColumns) {
            primaryColumns.forEach(function (column) {
                state.push({
                    colId: column.getColId(),
                    aggFunc: column.getColDef().aggFunc,
                    hide: column.getColDef().hide,
                    pinned: column.getColDef().pinned,
                    rowGroupIndex: column.getColDef().rowGroupIndex,
                    pivotIndex: column.getColDef().pivotIndex,
                    width: column.getColDef().width
                });
            });
        }
        this.setColumnState(state);
    };
    ColumnController.prototype.setColumnState = function (columnState) {
        var _this = this;
        if (utils_1.Utils.missingOrEmpty(this.primaryColumns)) {
            return false;
        }
        this.autoGroupsNeedBuilding = true;
        // at the end below, this list will have all columns we got no state for
        var columnsWithNoState = this.primaryColumns.slice();
        this.rowGroupColumns = [];
        this.valueColumns = [];
        this.pivotColumns = [];
        var success = true;
        var rowGroupIndexes = {};
        var pivotIndexes = {};
        if (columnState) {
            columnState.forEach(function (stateItem) {
                var column = _this.getPrimaryColumn(stateItem.colId);
                if (!column) {
                    console.warn('ag-grid: column ' + stateItem.colId + ' not found');
                    success = false;
                }
                else {
                    _this.syncColumnWithStateItem(column, stateItem, rowGroupIndexes, pivotIndexes);
                    utils_1.Utils.removeFromArray(columnsWithNoState, column);
                }
            });
        }
        // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden
        columnsWithNoState.forEach(this.syncColumnWithNoState.bind(this));
        // sort the lists according to the indexes that were provided
        this.rowGroupColumns.sort(this.sortColumnListUsingIndexes.bind(this, rowGroupIndexes));
        this.pivotColumns.sort(this.sortColumnListUsingIndexes.bind(this, pivotIndexes));
        this.copyDownGridColumns();
        var orderOfColIds = columnState.map(function (stateItem) { return stateItem.colId; });
        this.gridColumns.sort(function (colA, colB) {
            var indexA = orderOfColIds.indexOf(colA.getId());
            var indexB = orderOfColIds.indexOf(colB.getId());
            return indexA - indexB;
        });
        this.updateDisplayedColumns();
        var event = {
            type: events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
        return success;
    };
    ColumnController.prototype.sortColumnListUsingIndexes = function (indexes, colA, colB) {
        var indexA = indexes[colA.getId()];
        var indexB = indexes[colB.getId()];
        return indexA - indexB;
    };
    ColumnController.prototype.syncColumnWithNoState = function (column) {
        column.setVisible(false);
        column.setAggFunc(null);
        column.setPinned(null);
        column.setRowGroupActive(false);
        column.setPivotActive(false);
        column.setValueActive(false);
    };
    ColumnController.prototype.syncColumnWithStateItem = function (column, stateItem, rowGroupIndexes, pivotIndexes) {
        // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true
        column.setVisible(!stateItem.hide);
        // sets pinned to 'left' or 'right'
        column.setPinned(stateItem.pinned);
        // if width provided and valid, use it, otherwise stick with the old width
        if (stateItem.width >= this.gridOptionsWrapper.getMinColWidth()) {
            column.setActualWidth(stateItem.width);
        }
        if (typeof stateItem.aggFunc === 'string') {
            column.setAggFunc(stateItem.aggFunc);
            column.setValueActive(true);
            this.valueColumns.push(column);
        }
        else {
            if (utils_1.Utils.exists(stateItem.aggFunc)) {
                console.warn('ag-Grid: stateItem.aggFunc must be a string. if using your own aggregation ' +
                    'functions, register the functions first before using them in get/set state. This is because it is' +
                    'intended for the column state to be stored and retrieved as simple JSON.');
            }
            column.setAggFunc(null);
            column.setValueActive(false);
        }
        if (typeof stateItem.rowGroupIndex === 'number') {
            this.rowGroupColumns.push(column);
            column.setRowGroupActive(true);
            rowGroupIndexes[column.getId()] = stateItem.rowGroupIndex;
        }
        else {
            column.setRowGroupActive(false);
        }
        if (typeof stateItem.pivotIndex === 'number') {
            this.pivotColumns.push(column);
            column.setPivotActive(true);
            pivotIndexes[column.getId()] = stateItem.pivotIndex;
        }
        else {
            column.setPivotActive(false);
        }
    };
    ColumnController.prototype.getGridColumns = function (keys) {
        return this.getColumns(keys, this.getGridColumn.bind(this));
    };
    ColumnController.prototype.getColumns = function (keys, columnLookupCallback) {
        var foundColumns = [];
        if (keys) {
            keys.forEach(function (key) {
                var column = columnLookupCallback(key);
                if (column) {
                    foundColumns.push(column);
                }
            });
        }
        return foundColumns;
    };
    // used by growGroupPanel
    ColumnController.prototype.getColumnWithValidation = function (key) {
        var column = this.getPrimaryColumn(key);
        if (!column) {
            console.warn('ag-Grid: could not find column ' + column);
        }
        return column;
    };
    ColumnController.prototype.getPrimaryColumn = function (key) {
        return this.getColumn(key, this.primaryColumns);
    };
    ColumnController.prototype.getGridColumn = function (key) {
        return this.getColumn(key, this.gridColumns);
    };
    ColumnController.prototype.getColumn = function (key, columnList) {
        if (!key) {
            return null;
        }
        for (var i = 0; i < columnList.length; i++) {
            if (this.columnsMatch(columnList[i], key)) {
                return columnList[i];
            }
        }
        return this.getAutoColumn(key);
    };
    ColumnController.prototype.getAutoColumn = function (key) {
        var _this = this;
        if (!utils_1.Utils.exists(this.groupAutoColumns) || utils_1.Utils.missing(this.groupAutoColumns)) {
            return null;
        }
        return utils_1.Utils.find(this.groupAutoColumns, function (groupCol) {
            return _this.columnsMatch(groupCol, key);
        });
    };
    ColumnController.prototype.columnsMatch = function (column, key) {
        var columnMatches = column === key;
        var colDefMatches = column.getColDef() === key;
        var idMatches = column.getColId() == key;
        return columnMatches || colDefMatches || idMatches;
    };
    ColumnController.prototype.getDisplayNameForColumn = function (column, location, includeAggFunc) {
        if (includeAggFunc === void 0) { includeAggFunc = false; }
        var headerName = this.getHeaderName(column.getColDef(), column, null, location);
        if (includeAggFunc) {
            return this.wrapHeaderNameWithAggFunc(column, headerName);
        }
        else {
            return headerName;
        }
    };
    ColumnController.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) {
        var colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();
        if (colGroupDef) {
            return this.getHeaderName(colGroupDef, null, columnGroup, location);
        }
        else {
            return null;
        }
    };
    // location is where the column is going to appear, ie who is calling us
    ColumnController.prototype.getHeaderName = function (colDef, column, columnGroup, location) {
        var headerValueGetter = colDef.headerValueGetter;
        if (headerValueGetter) {
            var params = {
                colDef: colDef,
                column: column,
                columnGroup: columnGroup,
                location: location,
                api: this.gridOptionsWrapper.getApi(),
                context: this.gridOptionsWrapper.getContext()
            };
            if (typeof headerValueGetter === 'function') {
                // valueGetter is a function, so just call it
                return headerValueGetter(params);
            }
            else if (typeof headerValueGetter === 'string') {
                // valueGetter is an expression, so execute the expression
                return this.expressionService.evaluate(headerValueGetter, params);
            }
            else {
                console.warn('ag-grid: headerValueGetter must be a function or a string');
                return '';
            }
        }
        else if (colDef.headerName != null) {
            return colDef.headerName;
        }
        else if (colDef.field) {
            return utils_1.Utils.camelCaseToHumanText(colDef.field);
        }
        else {
            return '';
        }
    };
    /*
        private getHeaderGroupName(columnGroup: ColumnGroup): string {
            let colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();
            let headerValueGetter = colGroupDef.headerValueGetter;

            if (headerValueGetter) {
                let params = {
                    columnGroup: columnGroup,
                    colDef: colGroupDef,
                    api: this.gridOptionsWrapper.getApi(),
                    context: this.gridOptionsWrapper.getContext()
                };

                if (typeof headerValueGetter === 'function') {
                    // valueGetter is a function, so just call it
                    return headerValueGetter(params);
                } else if (typeof headerValueGetter === 'string') {
                    // valueGetter is an expression, so execute the expression
                    return this.expressionService.evaluate(headerValueGetter, params);
                } else {
                    console.warn('ag-grid: headerValueGetter must be a function or a string');
                    return '';
                }
            } else {
                return colGroupDef.headerName;
            }
        }
    */
    ColumnController.prototype.wrapHeaderNameWithAggFunc = function (column, headerName) {
        if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) {
            return headerName;
        }
        // only columns with aggregation active can have aggregations
        var pivotValueColumn = column.getColDef().pivotValueColumn;
        var pivotActiveOnThisColumn = utils_1.Utils.exists(pivotValueColumn);
        var aggFunc = null;
        var aggFuncFound;
        // otherwise we have a measure that is active, and we are doing aggregation on it
        if (pivotActiveOnThisColumn) {
            aggFunc = pivotValueColumn.getAggFunc();
            aggFuncFound = true;
        }
        else {
            var measureActive = column.isValueActive();
            var aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();
            if (measureActive && aggregationPresent) {
                aggFunc = column.getAggFunc();
                aggFuncFound = true;
            }
            else {
                aggFuncFound = false;
            }
        }
        if (aggFuncFound) {
            var aggFuncString = (typeof aggFunc === 'string') ? aggFunc : 'func';
            var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
            var aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);
            return aggFuncStringTranslated + "(" + headerName + ")";
        }
        else {
            return headerName;
        }
    };
    // returns the group with matching colId and instanceId. If instanceId is missing,
    // matches only on the colId.
    ColumnController.prototype.getColumnGroup = function (colId, instanceId) {
        if (!colId) {
            return null;
        }
        if (colId instanceof columnGroup_1.ColumnGroup) {
            return colId;
        }
        var allColumnGroups = this.getAllDisplayedColumnGroups();
        var checkInstanceId = typeof instanceId === 'number';
        var result = null;
        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                var columnGroup = child;
                var matched = void 0;
                if (checkInstanceId) {
                    matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();
                }
                else {
                    matched = colId === columnGroup.getGroupId();
                }
                if (matched) {
                    result = columnGroup;
                }
            }
        });
        return result;
    };
    ColumnController.prototype.setColumnDefs = function (columnDefs) {
        // always invalidate cache on changing columns, as the column id's for the new columns
        // could overlap with the old id's, so the cache would return old values for new columns.
        this.valueCache.expire();
        // NOTE ==================
        // we should be destroying the existing columns and groups if they exist, for example, the original column
        // group adds a listener to the columns, it should be also removing the listeners
        this.autoGroupsNeedBuilding = true;
        var balancedTreeResult = this.balancedColumnTreeBuilder.createBalancedColumnGroups(columnDefs, true);
        this.primaryBalancedTree = balancedTreeResult.balancedTree;
        this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;
        this.primaryColumns = this.getColumnsFromTree(this.primaryBalancedTree);
        this.extractRowGroupColumns();
        this.extractPivotColumns();
        this.createValueColumns();
        this.copyDownGridColumns();
        this.updateDisplayedColumns();
        this.checkDisplayedVirtualColumns();
        this.ready = true;
        var eventEverythingChanged = {
            type: events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(eventEverythingChanged);
        var newColumnsLoadedEvent = {
            type: events_1.Events.EVENT_NEW_COLUMNS_LOADED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(newColumnsLoadedEvent);
    };
    ColumnController.prototype.isReady = function () {
        return this.ready;
    };
    ColumnController.prototype.extractRowGroupColumns = function () {
        var _this = this;
        this.rowGroupColumns.forEach(function (column) { return column.setRowGroupActive(false); });
        this.rowGroupColumns = [];
        // pull out items with rowGroupIndex
        this.primaryColumns.forEach(function (column) {
            if (typeof column.getColDef().rowGroupIndex === 'number') {
                _this.rowGroupColumns.push(column);
                column.setRowGroupActive(true);
            }
        });
        // then sort them
        this.rowGroupColumns.sort(function (colA, colB) {
            return colA.getColDef().rowGroupIndex - colB.getColDef().rowGroupIndex;
        });
        // now just pull out items rowGroup, they will be added at the end
        // after the indexed ones, but in the order the columns appear
        this.primaryColumns.forEach(function (column) {
            if (column.getColDef().rowGroup) {
                // if user already specified rowGroupIndex then we skip it as this col already included
                if (_this.rowGroupColumns.indexOf(column) >= 0) {
                    return;
                }
                _this.rowGroupColumns.push(column);
                column.setRowGroupActive(true);
            }
        });
    };
    ColumnController.prototype.extractPivotColumns = function () {
        var _this = this;
        this.pivotColumns.forEach(function (column) { return column.setPivotActive(false); });
        this.pivotColumns = [];
        // pull out items with pivotIndex
        this.primaryColumns.forEach(function (column) {
            if (typeof column.getColDef().pivotIndex === 'number') {
                _this.pivotColumns.push(column);
                column.setPivotActive(true);
            }
        });
        // then sort them
        this.pivotColumns.sort(function (colA, colB) {
            return colA.getColDef().pivotIndex - colB.getColDef().pivotIndex;
        });
        // now check the boolean equivalent
        this.primaryColumns.forEach(function (column) {
            if (column.getColDef().pivot) {
                // if user already specified pivotIndex then we skip it as this col already included
                if (_this.pivotColumns.indexOf(column) >= 0) {
                    return;
                }
                _this.pivotColumns.push(column);
                column.setPivotActive(true);
            }
        });
    };
    ColumnController.prototype.resetColumnGroupState = function () {
        var stateItems = [];
        this.columnUtils.depthFirstOriginalTreeSearch(this.primaryBalancedTree, function (child) {
            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                var groupState = {
                    groupId: child.getGroupId(),
                    open: child.getColGroupDef().openByDefault
                };
                stateItems.push(groupState);
            }
        });
        this.setColumnGroupState(stateItems);
    };
    ColumnController.prototype.getColumnGroupState = function () {
        var columnGroupState = [];
        this.columnUtils.depthFirstOriginalTreeSearch(this.gridBalancedTree, function (node) {
            if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
                var originalColumnGroup = node;
                columnGroupState.push({
                    groupId: originalColumnGroup.getGroupId(),
                    open: originalColumnGroup.isExpanded()
                });
            }
        });
        return columnGroupState;
    };
    ColumnController.prototype.setColumnGroupState = function (stateItems) {
        var _this = this;
        this.columnAnimationService.start();
        var impactedGroups = [];
        stateItems.forEach(function (stateItem) {
            var groupKey = stateItem.groupId;
            var newValue = stateItem.open;
            var originalColumnGroup = _this.getOriginalColumnGroup(groupKey);
            if (!originalColumnGroup) {
                return;
            }
            if (originalColumnGroup.isExpanded() === newValue) {
                return;
            }
            _this.logger.log('columnGroupOpened(' + originalColumnGroup.getGroupId() + ',' + newValue + ')');
            originalColumnGroup.setExpanded(newValue);
            impactedGroups.push(originalColumnGroup);
        });
        this.updateGroupsAndDisplayedColumns();
        impactedGroups.forEach(function (originalColumnGroup) {
            var event = {
                type: events_1.Events.EVENT_COLUMN_GROUP_OPENED,
                columnGroup: originalColumnGroup,
                api: _this.gridApi,
                columnApi: _this.columnApi
            };
            _this.eventService.dispatchEvent(event);
        });
        this.columnAnimationService.finish();
    };
    // called by headerRenderer - when a header is opened or closed
    ColumnController.prototype.setColumnGroupOpened = function (key, newValue) {
        var keyAsString;
        if (key instanceof originalColumnGroup_1.OriginalColumnGroup) {
            keyAsString = key.getId();
        }
        else {
            keyAsString = key;
        }
        this.setColumnGroupState([{ groupId: keyAsString, open: newValue }]);
    };
    ColumnController.prototype.getOriginalColumnGroup = function (key) {
        if (key instanceof originalColumnGroup_1.OriginalColumnGroup) {
            return key;
        }
        if (typeof key !== 'string') {
            console.error('ag-Grid: group key must be a string');
        }
        // otherwise, search for the column group by id
        var res = null;
        this.columnUtils.depthFirstOriginalTreeSearch(this.gridBalancedTree, function (node) {
            if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
                var originalColumnGroup = node;
                if (originalColumnGroup.getId() === key) {
                    res = originalColumnGroup;
                }
            }
        });
        return res;
    };
    ColumnController.prototype.calculateColumnsForDisplay = function () {
        var columnsForDisplay;
        if (this.pivotMode && !this.secondaryColumnsPresent) {
            // pivot mode is on, but we are not pivoting, so we only
            // show columns we are aggregating on
            columnsForDisplay = this.createColumnsToDisplayFromValueColumns();
        }
        else {
            // otherwise continue as normal. this can be working on the primary
            // or secondary columns, whatever the gridColumns are set to
            columnsForDisplay = utils_1.Utils.filter(this.gridColumns, function (column) { return column.isVisible(); });
        }
        this.createGroupAutoColumnsIfNeeded();
        if (utils_1.Utils.exists(this.groupAutoColumns)) {
            columnsForDisplay = this.groupAutoColumns.concat(columnsForDisplay);
        }
        return columnsForDisplay;
    };
    ColumnController.prototype.checkColSpanActiveInCols = function (columns) {
        var result = false;
        columns.forEach(function (col) {
            if (utils_1.Utils.exists(col.getColDef().colSpan)) {
                result = true;
            }
        });
        return result;
    };
    ColumnController.prototype.calculateColumnsForGroupDisplay = function () {
        var _this = this;
        this.groupDisplayColumns = [];
        var checkFunc = function (col) {
            var colDef = col.getColDef();
            if (colDef && utils_1.Utils.exists(colDef.showRowGroup)) {
                _this.groupDisplayColumns.push(col);
            }
        };
        this.gridColumns.forEach(checkFunc);
        if (this.groupAutoColumns) {
            this.groupAutoColumns.forEach(checkFunc);
        }
    };
    ColumnController.prototype.getGroupDisplayColumns = function () {
        return this.groupDisplayColumns;
    };
    ColumnController.prototype.createColumnsToDisplayFromValueColumns = function () {
        var _this = this;
        // make a copy of the value columns, so we have to side effects
        var result = this.valueColumns.slice();
        // order the columns as per the grid columns. having the order is
        // important as without it, reordering of columns would have no impact
        result.sort(function (colA, colB) {
            return _this.gridColumns.indexOf(colA) - _this.gridColumns.indexOf(colB);
        });
        return result;
    };
    ColumnController.prototype.updateDisplayedColumns = function () {
        var columnsForDisplay = this.calculateColumnsForDisplay();
        this.buildDisplayedTrees(columnsForDisplay);
        this.calculateColumnsForGroupDisplay();
        // this is also called when a group is opened or closed
        this.updateGroupsAndDisplayedColumns();
        this.setFirstRightAndLastLeftPinned();
    };
    ColumnController.prototype.isSecondaryColumnsPresent = function () {
        return this.secondaryColumnsPresent;
    };
    ColumnController.prototype.setSecondaryColumns = function (colDefs) {
        var newColsPresent = colDefs && colDefs.length > 0;
        // if not cols passed, and we had to cols anyway, then do nothing
        if (!newColsPresent && !this.secondaryColumnsPresent) {
            return;
        }
        if (newColsPresent) {
            this.processSecondaryColumnDefinitions(colDefs);
            var balancedTreeResult = this.balancedColumnTreeBuilder.createBalancedColumnGroups(colDefs, false);
            this.secondaryBalancedTree = balancedTreeResult.balancedTree;
            this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;
            this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);
            this.secondaryColumnsPresent = true;
        }
        else {
            this.secondaryBalancedTree = null;
            this.secondaryHeaderRowCount = -1;
            this.secondaryColumns = null;
            this.secondaryColumnsPresent = false;
        }
        this.copyDownGridColumns();
        this.updateDisplayedColumns();
    };
    ColumnController.prototype.processSecondaryColumnDefinitions = function (colDefs) {
        var columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();
        var groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();
        if (!columnCallback && !groupCallback) {
            return;
        }
        searchForColDefs(colDefs);
        function searchForColDefs(colDefs2) {
            colDefs2.forEach(function (abstractColDef) {
                var isGroup = utils_1.Utils.exists(abstractColDef.children);
                if (isGroup) {
                    var colGroupDef = abstractColDef;
                    if (groupCallback) {
                        groupCallback(colGroupDef);
                    }
                    searchForColDefs(colGroupDef.children);
                }
                else {
                    var colDef = abstractColDef;
                    if (columnCallback) {
                        columnCallback(colDef);
                    }
                }
            });
        }
    };
    // called from: setColumnState, setColumnDefs, setAlternativeColumnDefs
    ColumnController.prototype.copyDownGridColumns = function () {
        if (this.secondaryColumns) {
            this.gridBalancedTree = this.secondaryBalancedTree.slice();
            this.gridHeaderRowCount = this.secondaryHeaderRowCount;
            this.gridColumns = this.secondaryColumns.slice();
        }
        else {
            this.gridBalancedTree = this.primaryBalancedTree.slice();
            this.gridHeaderRowCount = this.primaryHeaderRowCount;
            this.gridColumns = this.primaryColumns.slice();
        }
        this.clearDisplayedColumns();
        this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);
        var event = {
            type: events_1.Events.EVENT_GRID_COLUMNS_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    // gets called after we copy down grid columns, to make sure any part of the gui
    // that tries to draw, eg the header, it will get empty lists of columns rather
    // than stale columns. for example, the header will received gridColumnsChanged
    // event, so will try and draw, but it will draw successfully when it acts on the
    // virtualColumnsChanged event
    ColumnController.prototype.clearDisplayedColumns = function () {
        this.displayedLeftColumnTree = [];
        this.displayedRightColumnTree = [];
        this.displayedCentreColumnTree = [];
        this.displayedLeftHeaderRows = {};
        this.displayedRightHeaderRows = {};
        this.displayedCentreHeaderRows = {};
        this.displayedLeftColumns = [];
        this.displayedRightColumns = [];
        this.displayedCenterColumns = [];
        this.allDisplayedColumns = [];
        this.allDisplayedVirtualColumns = [];
    };
    ColumnController.prototype.updateGroupsAndDisplayedColumns = function () {
        this.updateGroups();
        this.updateDisplayedColumnsFromTrees();
        this.updateVirtualSets();
        this.updateBodyWidths();
        // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display
        var event = {
            type: events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    ColumnController.prototype.updateDisplayedColumnsFromTrees = function () {
        this.addToDisplayedColumns(this.displayedLeftColumnTree, this.displayedLeftColumns);
        this.addToDisplayedColumns(this.displayedCentreColumnTree, this.displayedCenterColumns);
        this.addToDisplayedColumns(this.displayedRightColumnTree, this.displayedRightColumns);
        this.setupAllDisplayedColumns();
        this.setLeftValues();
    };
    ColumnController.prototype.setupAllDisplayedColumns = function () {
        if (this.gridOptionsWrapper.isEnableRtl()) {
            this.allDisplayedColumns = this.displayedRightColumns
                .concat(this.displayedCenterColumns)
                .concat(this.displayedLeftColumns);
        }
        else {
            this.allDisplayedColumns = this.displayedLeftColumns
                .concat(this.displayedCenterColumns)
                .concat(this.displayedRightColumns);
        }
    };
    // sets the left pixel position of each column
    ColumnController.prototype.setLeftValues = function () {
        this.setLeftValuesOfColumns();
        this.setLeftValuesOfGroups();
    };
    ColumnController.prototype.setLeftValuesOfColumns = function () {
        var _this = this;
        // go through each list of displayed columns
        var allColumns = this.primaryColumns.slice(0);
        // let totalColumnWidth = this.getWidthOfColsInList()
        var doingRtl = this.gridOptionsWrapper.isEnableRtl();
        [this.displayedLeftColumns, this.displayedRightColumns, this.displayedCenterColumns].forEach(function (columns) {
            if (doingRtl) {
                // when doing RTL, we start at the top most pixel (ie RHS) and work backwards
                var left_1 = _this.getWidthOfColsInList(columns);
                columns.forEach(function (column) {
                    left_1 -= column.getActualWidth();
                    column.setLeft(left_1);
                });
            }
            else {
                // otherwise normal LTR, we start at zero
                var left_2 = 0;
                columns.forEach(function (column) {
                    column.setLeft(left_2);
                    left_2 += column.getActualWidth();
                });
            }
            utils_1.Utils.removeAllFromArray(allColumns, columns);
        });
        // items left in allColumns are columns not displayed, so remove the left position. this is
        // important for the rows, as if a col is made visible, then taken out, then made visible again,
        // we don't want the animation of the cell floating in from the old position, whatever that was.
        allColumns.forEach(function (column) {
            column.setLeft(null);
        });
    };
    ColumnController.prototype.setLeftValuesOfGroups = function () {
        // a groups left value is the lest left value of it's children
        [this.displayedLeftColumnTree, this.displayedRightColumnTree, this.displayedCentreColumnTree].forEach(function (columns) {
            columns.forEach(function (column) {
                if (column instanceof columnGroup_1.ColumnGroup) {
                    var columnGroup = column;
                    columnGroup.checkLeft();
                }
            });
        });
    };
    ColumnController.prototype.addToDisplayedColumns = function (displayedColumnTree, displayedColumns) {
        displayedColumns.length = 0;
        this.columnUtils.depthFirstDisplayedColumnTreeSearch(displayedColumnTree, function (child) {
            if (child instanceof column_1.Column) {
                displayedColumns.push(child);
            }
        });
    };
    ColumnController.prototype.updateDisplayedCenterVirtualColumns = function () {
        var skipVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation() || this.gridOptionsWrapper.isForPrint();
        if (skipVirtualisation) {
            // no virtualisation, so don't filter
            this.allDisplayedCenterVirtualColumns = this.displayedCenterColumns;
        }
        else {
            // filter out what should be visible
            this.allDisplayedCenterVirtualColumns = this.filterOutColumnsWithinViewport();
        }
        this.allDisplayedVirtualColumns = this.allDisplayedCenterVirtualColumns
            .concat(this.displayedLeftColumns)
            .concat(this.displayedRightColumns);
        // return map of virtual col id's, for easy lookup when building the groups.
        // the map will be colId=>true, ie col id's mapping to 'true'.
        var result = {};
        this.allDisplayedVirtualColumns.forEach(function (col) {
            result[col.getId()] = true;
        });
        return result;
    };
    ColumnController.prototype.getVirtualHeaderGroupRow = function (type, dept) {
        var result;
        switch (type) {
            case column_1.Column.PINNED_LEFT:
                result = this.displayedLeftHeaderRows[dept];
                break;
            case column_1.Column.PINNED_RIGHT:
                result = this.displayedRightHeaderRows[dept];
                break;
            default:
                result = this.displayedCentreHeaderRows[dept];
                break;
        }
        if (utils_1.Utils.missing(result)) {
            result = [];
        }
        return result;
    };
    ColumnController.prototype.updateDisplayedVirtualGroups = function (virtualColIds) {
        // go through each group, see if any of it's cols are displayed, and if yes,
        // then this group is included
        this.displayedLeftHeaderRows = {};
        this.displayedRightHeaderRows = {};
        this.displayedCentreHeaderRows = {};
        testGroup(this.displayedLeftColumnTree, this.displayedLeftHeaderRows, 0);
        testGroup(this.displayedRightColumnTree, this.displayedRightHeaderRows, 0);
        testGroup(this.displayedCentreColumnTree, this.displayedCentreHeaderRows, 0);
        function testGroup(children, result, dept) {
            var returnValue = false;
            for (var i = 0; i < children.length; i++) {
                // see if this item is within viewport
                var child = children[i];
                var addThisItem = void 0;
                if (child instanceof column_1.Column) {
                    // for column, test if column is included
                    addThisItem = virtualColIds[child.getId()] === true;
                }
                else {
                    // if group, base decision on children
                    var columnGroup = child;
                    addThisItem = testGroup(columnGroup.getDisplayedChildren(), result, dept + 1);
                }
                if (addThisItem) {
                    returnValue = true;
                    if (!result[dept]) {
                        result[dept] = [];
                    }
                    result[dept].push(child);
                }
            }
            return returnValue;
        }
    };
    ColumnController.prototype.updateVirtualSets = function () {
        var virtualColIds = this.updateDisplayedCenterVirtualColumns();
        this.updateDisplayedVirtualGroups(virtualColIds);
    };
    ColumnController.prototype.filterOutColumnsWithinViewport = function () {
        return utils_1.Utils.filter(this.displayedCenterColumns, this.isColumnInViewport.bind(this));
    };
    // called from api
    ColumnController.prototype.sizeColumnsToFit = function (gridWidth) {
        var _this = this;
        // avoid divide by zero
        var allDisplayedColumns = this.getAllDisplayedColumns();
        if (gridWidth <= 0 || allDisplayedColumns.length === 0) {
            return;
        }
        var colsToNotSpread = utils_1.Utils.filter(allDisplayedColumns, function (column) {
            return column.getColDef().suppressSizeToFit === true;
        });
        var colsToSpread = utils_1.Utils.filter(allDisplayedColumns, function (column) {
            return column.getColDef().suppressSizeToFit !== true;
        });
        // make a copy of the cols that are going to be resized
        var colsToFireEventFor = colsToSpread.slice(0);
        var finishedResizing = false;
        while (!finishedResizing) {
            finishedResizing = true;
            var availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);
            if (availablePixels <= 0) {
                // no width, set everything to minimum
                colsToSpread.forEach(function (column) {
                    column.setMinimum();
                });
            }
            else {
                var scale = availablePixels / this.getWidthOfColsInList(colsToSpread);
                // we set the pixels for the last col based on what's left, as otherwise
                // we could be a pixel or two short or extra because of rounding errors.
                var pixelsForLastCol = availablePixels;
                // backwards through loop, as we are removing items as we go
                for (var i = colsToSpread.length - 1; i >= 0; i--) {
                    var column = colsToSpread[i];
                    var newWidth = Math.round(column.getActualWidth() * scale);
                    if (newWidth < column.getMinWidth()) {
                        column.setMinimum();
                        moveToNotSpread(column);
                        finishedResizing = false;
                    }
                    else if (column.isGreaterThanMax(newWidth)) {
                        column.setActualWidth(column.getMaxWidth());
                        moveToNotSpread(column);
                        finishedResizing = false;
                    }
                    else {
                        var onLastCol = i === 0;
                        if (onLastCol) {
                            column.setActualWidth(pixelsForLastCol);
                        }
                        else {
                            column.setActualWidth(newWidth);
                        }
                    }
                    pixelsForLastCol -= newWidth;
                }
            }
        }
        this.setLeftValues();
        this.updateBodyWidths();
        colsToFireEventFor.forEach(function (column) {
            var event = {
                type: events_1.Events.EVENT_COLUMN_RESIZED,
                column: column,
                columns: [column],
                finished: true,
                api: _this.gridApi,
                columnApi: _this.columnApi
            };
            _this.eventService.dispatchEvent(event);
        });
        function moveToNotSpread(column) {
            utils_1.Utils.removeFromArray(colsToSpread, column);
            colsToNotSpread.push(column);
        }
    };
    ColumnController.prototype.buildDisplayedTrees = function (visibleColumns) {
        var leftVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
            return column.getPinned() === 'left';
        });
        var rightVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
            return column.getPinned() === 'right';
        });
        var centerVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
            return column.getPinned() !== 'left' && column.getPinned() !== 'right';
        });
        var groupInstanceIdCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();
        this.displayedLeftColumnTree = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, this.displayedLeftColumnTree);
        this.displayedRightColumnTree = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, this.displayedRightColumnTree);
        this.displayedCentreColumnTree = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, this.displayedCentreColumnTree);
    };
    ColumnController.prototype.updateGroups = function () {
        var allGroups = this.getAllDisplayedColumnGroups();
        this.columnUtils.depthFirstAllColumnTreeSearch(allGroups, function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                var group = child;
                group.calculateDisplayedColumns();
            }
        });
    };
    ColumnController.prototype.getGroupAutoColumns = function () {
        return this.groupAutoColumns;
    };
    ColumnController.prototype.createGroupAutoColumnsIfNeeded = function () {
        if (!this.autoGroupsNeedBuilding) {
            return;
        }
        this.autoGroupsNeedBuilding = false;
        // see if we need to insert the default grouping column
        var needAutoColumns = (this.rowGroupColumns.length > 0 || this.usingTreeData)
            && !this.gridOptionsWrapper.isGroupSuppressAutoColumn()
            && !this.gridOptionsWrapper.isGroupUseEntireRow()
            && !this.gridOptionsWrapper.isGroupSuppressRow();
        if (needAutoColumns) {
            this.groupAutoColumns = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);
        }
        else {
            this.groupAutoColumns = null;
        }
    };
    ColumnController.prototype.createValueColumns = function () {
        this.valueColumns.forEach(function (column) { return column.setValueActive(false); });
        this.valueColumns = [];
        // override with columns that have the aggFunc specified explicitly
        for (var i = 0; i < this.primaryColumns.length; i++) {
            var column = this.primaryColumns[i];
            if (column.getColDef().aggFunc) {
                column.setAggFunc(column.getColDef().aggFunc);
                this.valueColumns.push(column);
                column.setValueActive(true);
            }
        }
    };
    ColumnController.prototype.getWidthOfColsInList = function (columnList) {
        var result = 0;
        for (var i = 0; i < columnList.length; i++) {
            result += columnList[i].getActualWidth();
        }
        return result;
    };
    ColumnController.prototype.getGridBalancedTree = function () {
        return this.gridBalancedTree;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ColumnController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'),
        __metadata("design:type", expressionService_1.ExpressionService)
    ], ColumnController.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('balancedColumnTreeBuilder'),
        __metadata("design:type", balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder)
    ], ColumnController.prototype, "balancedColumnTreeBuilder", void 0);
    __decorate([
        context_1.Autowired('displayedGroupCreator'),
        __metadata("design:type", displayedGroupCreator_1.DisplayedGroupCreator)
    ], ColumnController.prototype, "displayedGroupCreator", void 0);
    __decorate([
        context_1.Autowired('autoWidthCalculator'),
        __metadata("design:type", autoWidthCalculator_1.AutoWidthCalculator)
    ], ColumnController.prototype, "autoWidthCalculator", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], ColumnController.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('columnUtils'),
        __metadata("design:type", columnUtils_1.ColumnUtils)
    ], ColumnController.prototype, "columnUtils", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], ColumnController.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], ColumnController.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnAnimationService'),
        __metadata("design:type", columnAnimationService_1.ColumnAnimationService)
    ], ColumnController.prototype, "columnAnimationService", void 0);
    __decorate([
        context_1.Autowired('autoGroupColService'),
        __metadata("design:type", autoGroupColService_1.AutoGroupColService)
    ], ColumnController.prototype, "autoGroupColService", void 0);
    __decorate([
        context_1.Optional('aggFuncService'),
        __metadata("design:type", Object)
    ], ColumnController.prototype, "aggFuncService", void 0);
    __decorate([
        context_1.Optional('valueCache'),
        __metadata("design:type", valueCache_1.ValueCache)
    ], ColumnController.prototype, "valueCache", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", ColumnApi)
    ], ColumnController.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], ColumnController.prototype, "gridApi", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ColumnController.prototype, "init", null);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], ColumnController.prototype, "setBeans", null);
    ColumnController = __decorate([
        context_1.Bean('columnController')
    ], ColumnController);
    return ColumnController;
}());
exports.ColumnController = ColumnController;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(11);
var utils_1 = __webpack_require__(1);
var context_1 = __webpack_require__(0);
var context_2 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var EventService = (function () {
    function EventService() {
        this.allSyncListeners = {};
        this.allAsyncListeners = {};
        this.globalSyncListeners = [];
        this.globalAsyncListeners = [];
        this.asyncFunctionsQueue = [];
        this.scheduled = false;
    }
    EventService_1 = EventService;
    // because this class is used both inside the context and outside the context, we do not
    // use autowired attributes, as that would be confusing, as sometimes the attributes
    // would be wired, and sometimes not.
    //
    // the global event servers used by ag-Grid is autowired by the context once, and this
    // setBeans method gets called once.
    //
    // the times when this class is used outside of the context (eg RowNode has an instance of this
    // class) then it is not a bean, and this setBeans method is not called.
    EventService.prototype.setBeans = function (loggerFactory, gridOptionsWrapper, globalEventListener) {
        if (globalEventListener === void 0) { globalEventListener = null; }
        this.logger = loggerFactory.create('EventService');
        if (globalEventListener) {
            var async = gridOptionsWrapper.useAsyncEvents();
            this.addGlobalListener(globalEventListener, async);
        }
    };
    EventService.prototype.getListenerList = function (eventType, async) {
        var listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
        var listenerList = listenerMap[eventType];
        if (!listenerList) {
            listenerList = [];
            listenerMap[eventType] = listenerList;
        }
        return listenerList;
    };
    EventService.prototype.addEventListener = function (eventType, listener, async) {
        if (async === void 0) { async = false; }
        if (!this.assertNotDeprecated(eventType))
            return;
        var listenerList = this.getListenerList(eventType, async);
        if (listenerList.indexOf(listener) < 0) {
            listenerList.push(listener);
        }
    };
    EventService.prototype.assertNotDeprecated = function (eventType) {
        if (eventType === 'floatingRowDataChanged') {
            console.warn('ag-Grid: floatingRowDataChanged is now called pinnedRowDataChanged');
            return false;
        }
        else {
            return true;
        }
    };
    // for some events, it's important that the model gets to hear about them before the view,
    // as the model may need to update before the view works on the info. if you register
    // via this method, you get notified before the view parts
    EventService.prototype.addModalPriorityEventListener = function (eventType, listener, async) {
        if (async === void 0) { async = false; }
        if (!this.assertNotDeprecated(eventType))
            return;
        this.addEventListener(eventType + EventService_1.PRIORITY, listener, async);
    };
    EventService.prototype.addGlobalListener = function (listener, async) {
        if (async === void 0) { async = false; }
        if (async) {
            this.globalAsyncListeners.push(listener);
        }
        else {
            this.globalSyncListeners.push(listener);
        }
    };
    EventService.prototype.removeEventListener = function (eventType, listener, async) {
        if (async === void 0) { async = false; }
        var listenerList = this.getListenerList(eventType, async);
        utils_1.Utils.removeFromArray(listenerList, listener);
    };
    EventService.prototype.removeGlobalListener = function (listener) {
        utils_1.Utils.removeFromArray(this.globalSyncListeners, listener);
    };
    // why do we pass the type here? the type is in ColumnChangeEvent, so unless the
    // type is not in other types of events???
    EventService.prototype.dispatchEvent = function (event) {
        // console.log(`dispatching ${eventType}: ${event}`);
        this.dispatchToListeners(event, true);
        this.dispatchToListeners(event, false);
    };
    EventService.prototype.dispatchToListeners = function (event, async) {
        var _this = this;
        var globalListeners = async ? this.globalAsyncListeners : this.globalSyncListeners;
        var eventType = event.type;
        // this allows the columnController to get events before anyone else
        var p1ListenerList = this.getListenerList(eventType + EventService_1.PRIORITY, async);
        utils_1.Utils.forEachSnapshotFirst(p1ListenerList, function (listener) {
            if (async) {
                _this.dispatchAsync(function () { return listener(event); });
            }
            else {
                listener(event);
            }
        });
        var listenerList = this.getListenerList(eventType, async);
        utils_1.Utils.forEachSnapshotFirst(listenerList, function (listener) {
            if (async) {
                _this.dispatchAsync(function () { return listener(event); });
            }
            else {
                listener(event);
            }
        });
        utils_1.Utils.forEachSnapshotFirst(globalListeners, function (listener) {
            if (async) {
                _this.dispatchAsync(function () { return listener(eventType, event); });
            }
            else {
                listener(eventType, event);
            }
        });
    };
    // this gets called inside the grid's thread, for each event that it
    // wants to set async. the grid then batches the events into one setTimeout()
    // because setTimeout() is an expensive operation. ideally we would have
    // each event in it's own setTimeout(), but we batch for performance.
    EventService.prototype.dispatchAsync = function (func) {
        // add to the queue for executing later in the next VM turn
        this.asyncFunctionsQueue.push(func);
        // check if timeout is already scheduled. the first time the grid calls
        // this within it's thread turn, this should be false, so it will schedule
        // the 'flush queue' method the first time it comes here. then the flag is
        // set to 'true' so it will know it's already scheduled for subsequent calls.
        if (!this.scheduled) {
            // if not scheduled, schedule one
            setTimeout(this.flushAsyncQueue.bind(this), 0);
            // mark that it is scheduled
            this.scheduled = true;
        }
    };
    // this happens in the next VM turn only, and empties the queue of events
    EventService.prototype.flushAsyncQueue = function () {
        this.scheduled = false;
        // we take a copy, because the event listener could be using
        // the grid, which would cause more events, which would be potentially
        // added to the queue, so safe to take a copy, the new events will
        // get executed in a later VM turn rather than risk updating the
        // queue as we are flushing it.
        var queueCopy = this.asyncFunctionsQueue.slice();
        this.asyncFunctionsQueue = [];
        // execute the queue
        queueCopy.forEach(function (func) { return func(); });
    };
    // this is an old idea niall had, should really take it out, was to do with ordering who gets to process
    // events first, to give model and service objects preference over the view
    EventService.PRIORITY = '-P1';
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')),
        __param(1, context_2.Qualifier('gridOptionsWrapper')),
        __param(2, context_2.Qualifier('globalEventListener')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory,
            gridOptionsWrapper_1.GridOptionsWrapper,
            Function]),
        __metadata("design:returntype", void 0)
    ], EventService.prototype, "setBeans", null);
    EventService = EventService_1 = __decorate([
        context_1.Bean('eventService')
    ], EventService);
    return EventService;
    var EventService_1;
}());
exports.EventService = EventService;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var eventKeys_1 = __webpack_require__(135);
exports.Events = eventKeys_1.Events;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var csvCreator_1 = __webpack_require__(49);
var rowRenderer_1 = __webpack_require__(18);
var headerRenderer_1 = __webpack_require__(54);
var filterManager_1 = __webpack_require__(16);
var columnController_1 = __webpack_require__(3);
var selectionController_1 = __webpack_require__(17);
var gridOptionsWrapper_1 = __webpack_require__(2);
var gridPanel_1 = __webpack_require__(10);
var valueService_1 = __webpack_require__(20);
var eventService_1 = __webpack_require__(4);
var constants_1 = __webpack_require__(7);
var context_1 = __webpack_require__(0);
var gridCore_1 = __webpack_require__(33);
var sortController_1 = __webpack_require__(25);
var focusedCellController_1 = __webpack_require__(24);
var gridCell_1 = __webpack_require__(23);
var utils_1 = __webpack_require__(1);
var cellRendererFactory_1 = __webpack_require__(56);
var cellEditorFactory_1 = __webpack_require__(55);
var paginationProxy_1 = __webpack_require__(29);
var immutableService_1 = __webpack_require__(113);
var valueCache_1 = __webpack_require__(36);
var alignedGridsService_1 = __webpack_require__(45);
var pinnedRowModel_1 = __webpack_require__(30);
var GridApi = (function () {
    function GridApi() {
    }
    GridApi.prototype.init = function () {
        switch (this.rowModel.getType()) {
            case constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY:
                this.inMemoryRowModel = this.rowModel;
                break;
            case constants_1.Constants.ROW_MODEL_TYPE_INFINITE:
                this.infinitePageRowModel = this.rowModel;
                break;
            case constants_1.Constants.ROW_MODEL_TYPE_ENTERPRISE:
                this.enterpriseRowModel = this.rowModel;
                break;
        }
    };
    /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
    GridApi.prototype.__getAlignedGridService = function () {
        return this.alignedGridsService;
    };
    GridApi.prototype.getDataAsCsv = function (params) {
        return this.csvCreator.getDataAsCsv(params);
    };
    GridApi.prototype.exportDataAsCsv = function (params) {
        this.csvCreator.exportDataAsCsv(params);
    };
    GridApi.prototype.getDataAsExcel = function (params) {
        if (!this.excelCreator) {
            console.warn('ag-Grid: Excel export is only available in ag-Grid Enterprise');
        }
        return this.excelCreator.getDataAsExcelXml(params);
    };
    GridApi.prototype.exportDataAsExcel = function (params) {
        if (!this.excelCreator) {
            console.warn('ag-Grid: Excel export is only available in ag-Grid Enterprise');
        }
        this.excelCreator.exportDataAsExcel(params);
    };
    GridApi.prototype.setEnterpriseDatasource = function (datasource) {
        if (this.gridOptionsWrapper.isRowModelEnterprise()) {
            // should really have an IEnterpriseRowModel interface, so we are not casting to any
            this.rowModel.setDatasource(datasource);
        }
        else {
            console.warn("ag-Grid: you can only use an enterprise datasource when gridOptions.rowModelType is '" + constants_1.Constants.ROW_MODEL_TYPE_ENTERPRISE + "'");
        }
    };
    GridApi.prototype.setDatasource = function (datasource) {
        if (this.gridOptionsWrapper.isRowModelInfinite()) {
            this.rowModel.setDatasource(datasource);
        }
        else {
            console.warn("ag-Grid: you can only use a datasource when gridOptions.rowModelType is '" + constants_1.Constants.ROW_MODEL_TYPE_INFINITE + "'");
        }
    };
    GridApi.prototype.setViewportDatasource = function (viewportDatasource) {
        if (this.gridOptionsWrapper.isRowModelViewport()) {
            // this is bad coding, because it's using an interface that's exposed in the enterprise.
            // really we should create an interface in the core for viewportDatasource and let
            // the enterprise implement it, rather than casting to 'any' here
            this.rowModel.setViewportDatasource(viewportDatasource);
        }
        else {
            console.warn("ag-Grid: you can only use a viewport datasource when gridOptions.rowModelType is '" + constants_1.Constants.ROW_MODEL_TYPE_VIEWPORT + "'");
        }
    };
    GridApi.prototype.setRowData = function (rowData) {
        if (this.gridOptionsWrapper.isRowModelDefault()) {
            if (this.gridOptionsWrapper.isDeltaRowDataMode()) {
                var _a = this.immutableService.createTransactionForRowData(rowData), transaction = _a[0], orderIdMap = _a[1];
                this.inMemoryRowModel.updateRowData(transaction, orderIdMap);
            }
            else {
                this.selectionController.reset();
                this.inMemoryRowModel.setRowData(rowData);
            }
        }
        else {
            console.log('cannot call setRowData unless using normal row model');
        }
    };
    // DEPRECATED
    GridApi.prototype.setFloatingTopRowData = function (rows) {
        console.warn('ag-Grid: since v12, api.setFloatingTopRowData() is now api.setPinnedTopRowData()');
        this.setPinnedTopRowData(rows);
    };
    // DEPRECATED
    GridApi.prototype.setFloatingBottomRowData = function (rows) {
        console.warn('ag-Grid: since v12, api.setFloatingBottomRowData() is now api.setPinnedBottomRowData()');
        this.setPinnedBottomRowData(rows);
    };
    // DEPRECATED
    GridApi.prototype.getFloatingTopRowCount = function () {
        console.warn('ag-Grid: since v12, api.getFloatingTopRowCount() is now api.getPinnedTopRowCount()');
        return this.getPinnedTopRowCount();
    };
    // DEPRECATED
    GridApi.prototype.getFloatingBottomRowCount = function () {
        console.warn('ag-Grid: since v12, api.getFloatingBottomRowCount() is now api.getPinnedBottomRowCount()');
        return this.getPinnedBottomRowCount();
    };
    // DEPRECATED
    GridApi.prototype.getFloatingTopRow = function (index) {
        console.warn('ag-Grid: since v12, api.getFloatingTopRow() is now api.getPinnedTopRow()');
        return this.getPinnedTopRow(index);
    };
    // DEPRECATED
    GridApi.prototype.getFloatingBottomRow = function (index) {
        console.warn('ag-Grid: since v12, api.getFloatingBottomRow() is now api.getPinnedBottomRow()');
        return this.getPinnedBottomRow(index);
    };
    GridApi.prototype.setPinnedTopRowData = function (rows) {
        this.pinnedRowModel.setPinnedTopRowData(rows);
    };
    GridApi.prototype.setPinnedBottomRowData = function (rows) {
        this.pinnedRowModel.setPinnedBottomRowData(rows);
    };
    GridApi.prototype.getPinnedTopRowCount = function () {
        return this.pinnedRowModel.getPinnedTopRowCount();
    };
    GridApi.prototype.getPinnedBottomRowCount = function () {
        return this.pinnedRowModel.getPinnedBottomRowCount();
    };
    GridApi.prototype.getPinnedTopRow = function (index) {
        return this.pinnedRowModel.getPinnedTopRow(index);
    };
    GridApi.prototype.getPinnedBottomRow = function (index) {
        return this.pinnedRowModel.getPinnedBottomRow(index);
    };
    GridApi.prototype.setColumnDefs = function (colDefs) {
        this.columnController.setColumnDefs(colDefs);
    };
    GridApi.prototype.expireValueCache = function () {
        this.valueCache.expire();
    };
    GridApi.prototype.getVerticalPixelRange = function () {
        return this.gridPanel.getVerticalPixelRange();
    };
    GridApi.prototype.refreshToolPanel = function () {
        if (this.toolPanel) {
            this.toolPanel.refresh();
        }
    };
    GridApi.prototype.refreshCells = function (params) {
        if (params === void 0) { params = {}; }
        if (Array.isArray(params)) {
            // the old version of refreshCells() took an array of rowNodes for the first argument
            console.warn('since ag-Grid v11.1, refreshCells() now takes parameters, please see the documentation.');
            return;
        }
        this.rowRenderer.refreshCells(params);
    };
    GridApi.prototype.redrawRows = function (params) {
        if (params === void 0) { params = {}; }
        if (params && params.rowNodes) {
            this.rowRenderer.redrawRows(params.rowNodes);
        }
        else {
            this.rowRenderer.redrawAfterModelUpdate();
        }
    };
    GridApi.prototype.timeFullRedraw = function (count) {
        if (count === void 0) { count = 1; }
        var iterationCount = 0;
        var totalProcessing = 0;
        var totalReflow = 0;
        var that = this;
        doOneIteration();
        function doOneIteration() {
            var start = (new Date()).getTime();
            that.rowRenderer.redrawAfterModelUpdate();
            var endProcessing = (new Date()).getTime();
            setTimeout(function () {
                var endReflow = (new Date()).getTime();
                var durationProcessing = endProcessing - start;
                var durationReflow = endReflow - endProcessing;
                console.log('duration:  processing = ' + durationProcessing + 'ms, reflow = ' + durationReflow + 'ms');
                iterationCount++;
                totalProcessing += durationProcessing;
                totalReflow += durationReflow;
                if (iterationCount < count) {
                    // wait for 1s between tests
                    setTimeout(doOneIteration, 1000);
                }
                else {
                    finish();
                }
            }, 0);
        }
        function finish() {
            console.log('tests complete. iteration count = ' + iterationCount);
            console.log('average processing = ' + (totalProcessing / iterationCount) + 'ms');
            console.log('average reflow = ' + (totalReflow / iterationCount) + 'ms');
        }
    };
    // *** deprecated
    GridApi.prototype.refreshView = function () {
        console.warn('ag-Grid: since v11.1, refreshView() is deprecated, please call redrawRows() instead');
        this.redrawRows();
    };
    // *** deprecated
    GridApi.prototype.refreshRows = function (rowNodes) {
        console.warn('since ag-Grid v11.1, refreshRows() is deprecated, please use refreshCells({rowNodes: rows}) or redrawRows({rowNodes: rows}) instead');
        this.refreshCells({ rowNodes: rowNodes });
    };
    // *** deprecated
    GridApi.prototype.rowDataChanged = function (rows) {
        console.log('ag-Grid: rowDataChanged is deprecated, either call refreshView() to refresh everything, or call rowNode.setRowData(newData) to set value on a particular node');
        this.redrawRows();
    };
    // *** deprecated
    GridApi.prototype.softRefreshView = function () {
        console.warn('ag-Grid: since v11.1, softRefreshView() is deprecated, call refreshCells(params) instead.');
        this.refreshCells({ volatile: true });
    };
    // *** deprecated
    GridApi.prototype.refreshGroupRows = function () {
        console.warn('ag-Grid: since v11.1, refreshGroupRows() is no longer supported, call refreshCells() instead. ' +
            'Because refreshCells() now does dirty checking, it will only refresh cells that have changed, so it should ' +
            'not be necessary to only refresh the group rows.');
        this.refreshCells();
    };
    GridApi.prototype.setFunctionsReadOnly = function (readOnly) {
        this.gridOptionsWrapper.setProperty('functionsReadOnly', readOnly);
    };
    GridApi.prototype.refreshHeader = function () {
        this.headerRenderer.refreshHeader();
    };
    GridApi.prototype.isAnyFilterPresent = function () {
        return this.filterManager.isAnyFilterPresent();
    };
    GridApi.prototype.isAdvancedFilterPresent = function () {
        return this.filterManager.isAdvancedFilterPresent();
    };
    GridApi.prototype.isQuickFilterPresent = function () {
        return this.filterManager.isQuickFilterPresent();
    };
    GridApi.prototype.getModel = function () {
        return this.rowModel;
    };
    GridApi.prototype.onGroupExpandedOrCollapsed = function (deprecated_refreshFromIndex) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('ag-Grid: cannot call onGroupExpandedOrCollapsed unless using normal row model');
        }
        if (utils_1.Utils.exists(deprecated_refreshFromIndex)) {
            console.log('ag-Grid: api.onGroupExpandedOrCollapsed - refreshFromIndex parameter is not longer used, the grid will refresh all rows');
        }
        // we don't really want the user calling this if one one rowNode was expanded, instead they should be
        // calling rowNode.setExpanded(boolean) - this way we do a 'keepRenderedRows=false' so that the whole
        // grid gets refreshed again - otherwise the row with the rowNodes that were changed won't get updated,
        // and thus the expand icon in the group cell won't get 'opened' or 'closed'.
        this.inMemoryRowModel.refreshModel({ step: constants_1.Constants.STEP_MAP });
    };
    GridApi.prototype.refreshInMemoryRowModel = function (step) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call refreshInMemoryRowModel unless using normal row model');
        }
        var paramsStep = constants_1.Constants.STEP_EVERYTHING;
        var stepsMapped = {
            group: constants_1.Constants.STEP_EVERYTHING,
            filter: constants_1.Constants.STEP_FILTER,
            map: constants_1.Constants.STEP_MAP,
            aggregate: constants_1.Constants.STEP_AGGREGATE,
            sort: constants_1.Constants.STEP_SORT,
            pivot: constants_1.Constants.STEP_PIVOT
        };
        if (utils_1.Utils.exists(step)) {
            paramsStep = stepsMapped[step];
        }
        if (utils_1.Utils.missing(paramsStep)) {
            console.error("ag-Grid: invalid step " + step + ", available steps are " + Object.keys(stepsMapped).join(', '));
            return;
        }
        var modelParams = {
            step: paramsStep,
            keepRenderedRows: true,
            animate: true,
            keepEditingRows: true
        };
        this.inMemoryRowModel.refreshModel(modelParams);
    };
    GridApi.prototype.getRowNode = function (id) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.warn('ag-Grid: cannot call getRowNode unless using normal row model');
            return;
        }
        return this.inMemoryRowModel.getRowNode(id);
    };
    GridApi.prototype.expandAll = function () {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.warn('ag-Grid: cannot call expandAll unless using normal row model');
            return;
        }
        this.inMemoryRowModel.expandOrCollapseAll(true);
    };
    GridApi.prototype.collapseAll = function () {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.warn('ag-Grid: cannot call collapseAll unless using normal row model');
            return;
        }
        this.inMemoryRowModel.expandOrCollapseAll(false);
    };
    GridApi.prototype.addVirtualRowListener = function (eventName, rowIndex, callback) {
        if (typeof eventName !== 'string') {
            console.log('ag-Grid: addVirtualRowListener is deprecated, please use addRenderedRowListener.');
        }
        this.addRenderedRowListener(eventName, rowIndex, callback);
    };
    GridApi.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {
        if (eventName === 'virtualRowSelected') {
            console.log('ag-Grid: event virtualRowSelected is deprecated, to register for individual row ' +
                'selection events, add a listener directly to the row node.');
        }
        this.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
    };
    GridApi.prototype.setQuickFilter = function (newFilter) {
        this.filterManager.setQuickFilter(newFilter);
    };
    GridApi.prototype.selectIndex = function (index, tryMulti, suppressEvents) {
        console.log('ag-Grid: do not use api for selection, call node.setSelected(value) instead');
        if (suppressEvents) {
            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
        }
        this.selectionController.selectIndex(index, tryMulti);
    };
    GridApi.prototype.deselectIndex = function (index, suppressEvents) {
        if (suppressEvents === void 0) { suppressEvents = false; }
        console.log('ag-Grid: do not use api for selection, call node.setSelected(value) instead');
        if (suppressEvents) {
            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
        }
        this.selectionController.deselectIndex(index);
    };
    GridApi.prototype.selectNode = function (node, tryMulti, suppressEvents) {
        if (tryMulti === void 0) { tryMulti = false; }
        if (suppressEvents === void 0) { suppressEvents = false; }
        console.log('ag-Grid: API for selection is deprecated, call node.setSelected(value) instead');
        if (suppressEvents) {
            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
        }
        node.setSelectedParams({ newValue: true, clearSelection: !tryMulti });
    };
    GridApi.prototype.deselectNode = function (node, suppressEvents) {
        if (suppressEvents === void 0) { suppressEvents = false; }
        console.log('ag-Grid: API for selection is deprecated, call node.setSelected(value) instead');
        if (suppressEvents) {
            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
        }
        node.setSelectedParams({ newValue: false });
    };
    GridApi.prototype.selectAll = function () {
        this.selectionController.selectAllRowNodes();
    };
    GridApi.prototype.deselectAll = function () {
        this.selectionController.deselectAllRowNodes();
    };
    GridApi.prototype.selectAllFiltered = function () {
        this.selectionController.selectAllRowNodes(true);
    };
    GridApi.prototype.deselectAllFiltered = function () {
        this.selectionController.deselectAllRowNodes(true);
    };
    GridApi.prototype.recomputeAggregates = function () {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call recomputeAggregates unless using normal row model');
        }
        this.inMemoryRowModel.refreshModel({ step: constants_1.Constants.STEP_AGGREGATE });
    };
    GridApi.prototype.sizeColumnsToFit = function () {
        if (this.gridOptionsWrapper.isForPrint()) {
            console.warn('ag-grid: sizeColumnsToFit does not work when forPrint=true');
            return;
        }
        this.gridPanel.sizeColumnsToFit();
    };
    GridApi.prototype.showLoadingOverlay = function () {
        this.gridPanel.showLoadingOverlay();
    };
    GridApi.prototype.showNoRowsOverlay = function () {
        this.gridPanel.showNoRowsOverlay();
    };
    GridApi.prototype.hideOverlay = function () {
        this.gridPanel.hideOverlay();
    };
    GridApi.prototype.isNodeSelected = function (node) {
        console.log('ag-Grid: no need to call api.isNodeSelected(), just call node.isSelected() instead');
        return node.isSelected();
    };
    GridApi.prototype.getSelectedNodesById = function () {
        console.error('ag-Grid: since version 3.4, getSelectedNodesById no longer exists, use getSelectedNodes() instead');
        return null;
    };
    GridApi.prototype.getSelectedNodes = function () {
        return this.selectionController.getSelectedNodes();
    };
    GridApi.prototype.getSelectedRows = function () {
        return this.selectionController.getSelectedRows();
    };
    GridApi.prototype.getBestCostNodeSelection = function () {
        return this.selectionController.getBestCostNodeSelection();
    };
    GridApi.prototype.getRenderedNodes = function () {
        return this.rowRenderer.getRenderedNodes();
    };
    GridApi.prototype.ensureColIndexVisible = function (index) {
        console.warn('ag-Grid: ensureColIndexVisible(index) no longer supported, use ensureColumnVisible(colKey) instead.');
    };
    GridApi.prototype.ensureColumnVisible = function (key) {
        this.gridPanel.ensureColumnVisible(key);
    };
    // Valid values for position are bottom, middle and top
    GridApi.prototype.ensureIndexVisible = function (index, position) {
        if (position === void 0) { position = 'top'; }
        this.gridPanel.ensureIndexVisible(index, position);
    };
    // Valid values for position are bottom, middle and top
    GridApi.prototype.ensureNodeVisible = function (comparator, position) {
        if (position === void 0) { position = 'top'; }
        this.gridCore.ensureNodeVisible(comparator, position);
    };
    GridApi.prototype.forEachLeafNode = function (callback) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call forEachNode unless using normal row model');
        }
        this.inMemoryRowModel.forEachLeafNode(callback);
    };
    GridApi.prototype.forEachNode = function (callback) {
        this.rowModel.forEachNode(callback);
    };
    GridApi.prototype.forEachNodeAfterFilter = function (callback) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call forEachNodeAfterFilter unless using normal row model');
        }
        this.inMemoryRowModel.forEachNodeAfterFilter(callback);
    };
    GridApi.prototype.forEachNodeAfterFilterAndSort = function (callback) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call forEachNodeAfterFilterAndSort unless using normal row model');
        }
        this.inMemoryRowModel.forEachNodeAfterFilterAndSort(callback);
    };
    GridApi.prototype.getFilterApiForColDef = function (colDef) {
        console.warn('ag-grid API method getFilterApiForColDef deprecated, use getFilterApi instead');
        return this.getFilterInstance(colDef);
    };
    GridApi.prototype.getFilterInstance = function (key) {
        var column = this.columnController.getPrimaryColumn(key);
        if (column) {
            return this.filterManager.getFilterComponent(column).resolveNow(null, function (filterComp) { return filterComp; });
        }
    };
    GridApi.prototype.getFilterApi = function (key) {
        console.warn('ag-Grid: getFilterApi is deprecated, use getFilterInstance instead');
        return this.getFilterInstance(key);
    };
    GridApi.prototype.destroyFilter = function (key) {
        var column = this.columnController.getPrimaryColumn(key);
        if (column) {
            return this.filterManager.destroyFilter(column);
        }
    };
    GridApi.prototype.getColumnDef = function (key) {
        var column = this.columnController.getPrimaryColumn(key);
        if (column) {
            return column.getColDef();
        }
        else {
            return null;
        }
    };
    GridApi.prototype.onFilterChanged = function () {
        this.filterManager.onFilterChanged();
    };
    GridApi.prototype.onSortChanged = function () {
        this.sortController.onSortChanged();
    };
    GridApi.prototype.setSortModel = function (sortModel) {
        this.sortController.setSortModel(sortModel);
    };
    GridApi.prototype.getSortModel = function () {
        return this.sortController.getSortModel();
    };
    GridApi.prototype.setFilterModel = function (model) {
        this.filterManager.setFilterModel(model);
    };
    GridApi.prototype.getFilterModel = function () {
        return this.filterManager.getFilterModel();
    };
    GridApi.prototype.getFocusedCell = function () {
        return this.focusedCellController.getFocusedCell();
    };
    GridApi.prototype.clearFocusedCell = function () {
        return this.focusedCellController.clearFocusedCell();
    };
    GridApi.prototype.setFocusedCell = function (rowIndex, colKey, floating) {
        this.focusedCellController.setFocusedCell(rowIndex, colKey, floating, true);
    };
    GridApi.prototype.setHeaderHeight = function (headerHeight) {
        this.gridOptionsWrapper.setProperty(gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, headerHeight);
        this.doLayout();
    };
    GridApi.prototype.setGroupHeaderHeight = function (headerHeight) {
        this.gridOptionsWrapper.setProperty(gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_HEADER_HEIGHT, headerHeight);
        this.doLayout();
    };
    GridApi.prototype.setFloatingFiltersHeight = function (headerHeight) {
        this.gridOptionsWrapper.setProperty(gridOptionsWrapper_1.GridOptionsWrapper.PROP_FLOATING_FILTERS_HEIGHT, headerHeight);
        this.doLayout();
    };
    GridApi.prototype.setPivotGroupHeaderHeight = function (headerHeight) {
        this.gridOptionsWrapper.setProperty(gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_GROUP_HEADER_HEIGHT, headerHeight);
        this.doLayout();
    };
    GridApi.prototype.setPivotHeaderHeight = function (headerHeight) {
        this.gridOptionsWrapper.setProperty(gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_HEADER_HEIGHT, headerHeight);
        this.doLayout();
    };
    GridApi.prototype.showToolPanel = function (show) {
        this.gridCore.showToolPanel(show);
    };
    GridApi.prototype.isToolPanelShowing = function () {
        return this.gridCore.isToolPanelShowing();
    };
    GridApi.prototype.doLayout = function () {
        this.gridCore.doLayout();
    };
    GridApi.prototype.resetRowHeights = function () {
        if (utils_1.Utils.exists(this.inMemoryRowModel)) {
            this.inMemoryRowModel.resetRowHeights();
        }
    };
    GridApi.prototype.setGroupRemoveSingleChildren = function (value) {
        this.gridOptionsWrapper.setProperty(gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN, value);
    };
    GridApi.prototype.setGroupRemoveLowestSingleChildren = function (value) {
        this.gridOptionsWrapper.setProperty(gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, value);
    };
    GridApi.prototype.onRowHeightChanged = function () {
        if (utils_1.Utils.exists(this.inMemoryRowModel)) {
            this.inMemoryRowModel.onRowHeightChanged();
        }
    };
    GridApi.prototype.getValue = function (colKey, rowNode) {
        var column = this.columnController.getPrimaryColumn(colKey);
        if (utils_1.Utils.missing(column)) {
            column = this.columnController.getGridColumn(colKey);
        }
        if (utils_1.Utils.missing(column)) {
            return null;
        }
        else {
            return this.valueService.getValue(column, rowNode);
        }
    };
    GridApi.prototype.addEventListener = function (eventType, listener) {
        var async = this.gridOptionsWrapper.useAsyncEvents();
        this.eventService.addEventListener(eventType, listener, async);
    };
    GridApi.prototype.addGlobalListener = function (listener) {
        var async = this.gridOptionsWrapper.useAsyncEvents();
        this.eventService.addGlobalListener(listener, async);
    };
    GridApi.prototype.removeEventListener = function (eventType, listener) {
        this.eventService.removeEventListener(eventType, listener);
    };
    GridApi.prototype.removeGlobalListener = function (listener) {
        this.eventService.removeGlobalListener(listener);
    };
    GridApi.prototype.dispatchEvent = function (event) {
        this.eventService.dispatchEvent(event);
    };
    GridApi.prototype.destroy = function () {
        this.context.destroy();
    };
    GridApi.prototype.resetQuickFilter = function () {
        this.rowModel.forEachNode(function (node) { return node.quickFilterAggregateText = null; });
    };
    GridApi.prototype.getRangeSelections = function () {
        if (this.rangeController) {
            return this.rangeController.getCellRanges();
        }
        else {
            console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
            return null;
        }
    };
    GridApi.prototype.camelCaseToHumanReadable = function (camelCase) {
        return utils_1.Utils.camelCaseToHumanText(camelCase);
    };
    GridApi.prototype.addRangeSelection = function (rangeSelection) {
        if (!this.rangeController) {
            console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
        }
        this.rangeController.addRange(rangeSelection);
    };
    GridApi.prototype.clearRangeSelection = function () {
        if (!this.rangeController) {
            console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
        }
        this.rangeController.clearSelection();
    };
    GridApi.prototype.copySelectedRowsToClipboard = function (includeHeader, columnKeys) {
        if (!this.clipboardService) {
            console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
        }
        this.clipboardService.copySelectedRowsToClipboard(includeHeader, columnKeys);
    };
    GridApi.prototype.copySelectedRangeToClipboard = function (includeHeader) {
        if (!this.clipboardService) {
            console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
        }
        this.clipboardService.copySelectedRangeToClipboard(includeHeader);
    };
    GridApi.prototype.copySelectedRangeDown = function () {
        if (!this.clipboardService) {
            console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
        }
        this.clipboardService.copyRangeDown();
    };
    GridApi.prototype.showColumnMenuAfterButtonClick = function (colKey, buttonElement) {
        var column = this.columnController.getPrimaryColumn(colKey);
        this.menuFactory.showMenuAfterButtonClick(column, buttonElement);
    };
    GridApi.prototype.showColumnMenuAfterMouseClick = function (colKey, mouseEvent) {
        var column = this.columnController.getPrimaryColumn(colKey);
        this.menuFactory.showMenuAfterMouseEvent(column, mouseEvent);
    };
    GridApi.prototype.tabToNextCell = function () {
        return this.rowRenderer.tabToNextCell(false);
    };
    GridApi.prototype.tabToPreviousCell = function () {
        return this.rowRenderer.tabToNextCell(true);
    };
    GridApi.prototype.stopEditing = function (cancel) {
        if (cancel === void 0) { cancel = false; }
        this.rowRenderer.stopEditing(cancel);
    };
    GridApi.prototype.startEditingCell = function (params) {
        var column = this.columnController.getGridColumn(params.colKey);
        if (!column) {
            console.warn("ag-Grid: no column found for " + params.colKey);
            return;
        }
        var gridCellDef = { rowIndex: params.rowIndex, floating: null, column: column };
        var gridCell = new gridCell_1.GridCell(gridCellDef);
        this.gridPanel.ensureIndexVisible(params.rowIndex);
        this.rowRenderer.startEditingCell(gridCell, params.keyPress, params.charPress);
    };
    GridApi.prototype.addAggFunc = function (key, aggFunc) {
        if (this.aggFuncService) {
            this.aggFuncService.addAggFunc(key, aggFunc);
        }
    };
    GridApi.prototype.addAggFuncs = function (aggFuncs) {
        if (this.aggFuncService) {
            this.aggFuncService.addAggFuncs(aggFuncs);
        }
    };
    GridApi.prototype.clearAggFuncs = function () {
        if (this.aggFuncService) {
            this.aggFuncService.clear();
        }
    };
    GridApi.prototype.updateRowData = function (rowDataTransaction) {
        var res = null;
        if (this.inMemoryRowModel) {
            res = this.inMemoryRowModel.updateRowData(rowDataTransaction);
        }
        else if (this.infinitePageRowModel) {
            this.infinitePageRowModel.updateRowData(rowDataTransaction);
        }
        else {
            console.error('ag-Grid: updateRowData() only works with InMemoryRowModel and InfiniteRowModel.');
        }
        // do change detection for all present cells
        if (!this.gridOptionsWrapper.isSuppressChangeDetection()) {
            this.rowRenderer.refreshCells();
        }
        return res;
    };
    GridApi.prototype.insertItemsAtIndex = function (index, items, skipRefresh) {
        if (skipRefresh === void 0) { skipRefresh = false; }
        console.warn('ag-Grid: insertItemsAtIndex() is deprecated, use updateRowData(transaction) instead.');
        this.updateRowData({ add: items, addIndex: index, update: null, remove: null });
    };
    GridApi.prototype.removeItems = function (rowNodes, skipRefresh) {
        if (skipRefresh === void 0) { skipRefresh = false; }
        console.warn('ag-Grid: removeItems() is deprecated, use updateRowData(transaction) instead.');
        var dataToRemove = rowNodes.map(function (rowNode) { return rowNode.data; });
        this.updateRowData({ add: null, addIndex: null, update: null, remove: dataToRemove });
    };
    GridApi.prototype.addItems = function (items, skipRefresh) {
        if (skipRefresh === void 0) { skipRefresh = false; }
        console.warn('ag-Grid: addItems() is deprecated, use updateRowData(transaction) instead.');
        this.updateRowData({ add: items, addIndex: null, update: null, remove: null });
    };
    GridApi.prototype.refreshVirtualPageCache = function () {
        console.warn('ag-Grid: refreshVirtualPageCache() is now called refreshInfiniteCache(), please call refreshInfiniteCache() instead');
        this.refreshInfiniteCache();
    };
    GridApi.prototype.refreshInfinitePageCache = function () {
        console.warn('ag-Grid: refreshInfinitePageCache() is now called refreshInfiniteCache(), please call refreshInfiniteCache() instead');
        this.refreshInfiniteCache();
    };
    GridApi.prototype.refreshInfiniteCache = function () {
        if (this.infinitePageRowModel) {
            this.infinitePageRowModel.refreshCache();
        }
        else {
            console.warn("ag-Grid: api.refreshInfiniteCache is only available when rowModelType='infinite'.");
        }
    };
    GridApi.prototype.purgeVirtualPageCache = function () {
        console.warn('ag-Grid: purgeVirtualPageCache() is now called purgeInfiniteCache(), please call purgeInfiniteCache() instead');
        this.purgeInfinitePageCache();
    };
    GridApi.prototype.purgeInfinitePageCache = function () {
        console.warn('ag-Grid: purgeInfinitePageCache() is now called purgeInfiniteCache(), please call purgeInfiniteCache() instead');
        this.purgeInfiniteCache();
    };
    GridApi.prototype.purgeInfiniteCache = function () {
        if (this.infinitePageRowModel) {
            this.infinitePageRowModel.purgeCache();
        }
        else {
            console.warn("ag-Grid: api.purgeInfiniteCache is only available when rowModelType='infinite'.");
        }
    };
    GridApi.prototype.purgeEnterpriseCache = function (route) {
        if (this.enterpriseRowModel) {
            this.enterpriseRowModel.purgeCache(route);
        }
        else {
            console.warn("ag-Grid: api.purgeEnterpriseCache is only available when rowModelType='enterprise'.");
        }
    };
    GridApi.prototype.getVirtualRowCount = function () {
        console.warn('ag-Grid: getVirtualRowCount() is now called getInfiniteRowCount(), please call getInfiniteRowCount() instead');
        return this.getInfiniteRowCount();
    };
    GridApi.prototype.getInfiniteRowCount = function () {
        if (this.infinitePageRowModel) {
            return this.infinitePageRowModel.getVirtualRowCount();
        }
        else {
            console.warn("ag-Grid: api.getVirtualRowCount is only available when rowModelType='virtual'.");
        }
    };
    GridApi.prototype.isMaxRowFound = function () {
        if (this.infinitePageRowModel) {
            return this.infinitePageRowModel.isMaxRowFound();
        }
        else {
            console.warn("ag-Grid: api.isMaxRowFound is only available when rowModelType='virtual'.");
        }
    };
    GridApi.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {
        console.warn('ag-Grid: setVirtualRowCount() is now called setInfiniteRowCount(), please call setInfiniteRowCount() instead');
        this.setInfiniteRowCount(rowCount, maxRowFound);
    };
    GridApi.prototype.setInfiniteRowCount = function (rowCount, maxRowFound) {
        if (this.infinitePageRowModel) {
            this.infinitePageRowModel.setVirtualRowCount(rowCount, maxRowFound);
        }
        else {
            console.warn("ag-Grid: api.setVirtualRowCount is only available when rowModelType='virtual'.");
        }
    };
    GridApi.prototype.getVirtualPageState = function () {
        console.warn('ag-Grid: getVirtualPageState() is now called getCacheBlockState(), please call getCacheBlockState() instead');
        return this.getCacheBlockState();
    };
    GridApi.prototype.getInfinitePageState = function () {
        console.warn('ag-Grid: getInfinitePageState() is now called getCacheBlockState(), please call getCacheBlockState() instead');
        return this.getCacheBlockState();
    };
    GridApi.prototype.getCacheBlockState = function () {
        if (this.infinitePageRowModel) {
            return this.infinitePageRowModel.getBlockState();
        }
        else if (this.enterpriseRowModel) {
            return this.enterpriseRowModel.getBlockState();
        }
        else {
            console.warn("ag-Grid: api.getCacheBlockState() is only available when rowModelType='infinite' or rowModelType='enterprise'.");
        }
    };
    GridApi.prototype.checkGridSize = function () {
        this.gridPanel.setBodyAndHeaderHeights();
    };
    GridApi.prototype.getFirstRenderedRow = function () {
        console.log('in ag-Grid v12, getFirstRenderedRow() was renamed to getFirstDisplayedRow()');
        return this.getFirstDisplayedRow();
    };
    GridApi.prototype.getFirstDisplayedRow = function () {
        return this.rowRenderer.getFirstVirtualRenderedRow();
    };
    GridApi.prototype.getLastRenderedRow = function () {
        console.log('in ag-Grid v12, getLastRenderedRow() was renamed to getLastDisplayedRow()');
        return this.getLastDisplayedRow();
    };
    GridApi.prototype.getLastDisplayedRow = function () {
        return this.rowRenderer.getLastVirtualRenderedRow();
    };
    GridApi.prototype.getDisplayedRowAtIndex = function (index) {
        return this.rowModel.getRow(index);
    };
    GridApi.prototype.getDisplayedRowCount = function () {
        return this.rowModel.getRowCount();
    };
    GridApi.prototype.paginationIsLastPageFound = function () {
        return this.paginationProxy.isLastPageFound();
    };
    GridApi.prototype.paginationGetPageSize = function () {
        return this.paginationProxy.getPageSize();
    };
    GridApi.prototype.paginationSetPageSize = function (size) {
        this.gridOptionsWrapper.setProperty('paginationPageSize', size);
    };
    GridApi.prototype.paginationGetCurrentPage = function () {
        return this.paginationProxy.getCurrentPage();
    };
    GridApi.prototype.paginationGetTotalPages = function () {
        return this.paginationProxy.getTotalPages();
    };
    GridApi.prototype.paginationGetRowCount = function () {
        return this.paginationProxy.getTotalRowCount();
    };
    GridApi.prototype.paginationGoToNextPage = function () {
        this.paginationProxy.goToNextPage();
    };
    GridApi.prototype.paginationGoToPreviousPage = function () {
        this.paginationProxy.goToPreviousPage();
    };
    GridApi.prototype.paginationGoToFirstPage = function () {
        this.paginationProxy.goToFirstPage();
    };
    GridApi.prototype.paginationGoToLastPage = function () {
        this.paginationProxy.goToLastPage();
    };
    GridApi.prototype.paginationGoToPage = function (page) {
        this.paginationProxy.goToPage(page);
    };
    __decorate([
        context_1.Autowired('immutableService'),
        __metadata("design:type", immutableService_1.ImmutableService)
    ], GridApi.prototype, "immutableService", void 0);
    __decorate([
        context_1.Autowired('csvCreator'),
        __metadata("design:type", csvCreator_1.CsvCreator)
    ], GridApi.prototype, "csvCreator", void 0);
    __decorate([
        context_1.Optional('excelCreator'),
        __metadata("design:type", Object)
    ], GridApi.prototype, "excelCreator", void 0);
    __decorate([
        context_1.Autowired('gridCore'),
        __metadata("design:type", gridCore_1.GridCore)
    ], GridApi.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'),
        __metadata("design:type", rowRenderer_1.RowRenderer)
    ], GridApi.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('headerRenderer'),
        __metadata("design:type", headerRenderer_1.HeaderRenderer)
    ], GridApi.prototype, "headerRenderer", void 0);
    __decorate([
        context_1.Autowired('filterManager'),
        __metadata("design:type", filterManager_1.FilterManager)
    ], GridApi.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], GridApi.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('selectionController'),
        __metadata("design:type", selectionController_1.SelectionController)
    ], GridApi.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], GridApi.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], GridApi.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('valueService'),
        __metadata("design:type", valueService_1.ValueService)
    ], GridApi.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('alignedGridsService'),
        __metadata("design:type", alignedGridsService_1.AlignedGridsService)
    ], GridApi.prototype, "alignedGridsService", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], GridApi.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('pinnedRowModel'),
        __metadata("design:type", pinnedRowModel_1.PinnedRowModel)
    ], GridApi.prototype, "pinnedRowModel", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], GridApi.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], GridApi.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('sortController'),
        __metadata("design:type", sortController_1.SortController)
    ], GridApi.prototype, "sortController", void 0);
    __decorate([
        context_1.Autowired('paginationProxy'),
        __metadata("design:type", paginationProxy_1.PaginationProxy)
    ], GridApi.prototype, "paginationProxy", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'),
        __metadata("design:type", focusedCellController_1.FocusedCellController)
    ], GridApi.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Optional('rangeController'),
        __metadata("design:type", Object)
    ], GridApi.prototype, "rangeController", void 0);
    __decorate([
        context_1.Optional('clipboardService'),
        __metadata("design:type", Object)
    ], GridApi.prototype, "clipboardService", void 0);
    __decorate([
        context_1.Optional('aggFuncService'),
        __metadata("design:type", Object)
    ], GridApi.prototype, "aggFuncService", void 0);
    __decorate([
        context_1.Autowired('menuFactory'),
        __metadata("design:type", Object)
    ], GridApi.prototype, "menuFactory", void 0);
    __decorate([
        context_1.Autowired('cellRendererFactory'),
        __metadata("design:type", cellRendererFactory_1.CellRendererFactory)
    ], GridApi.prototype, "cellRendererFactory", void 0);
    __decorate([
        context_1.Autowired('cellEditorFactory'),
        __metadata("design:type", cellEditorFactory_1.CellEditorFactory)
    ], GridApi.prototype, "cellEditorFactory", void 0);
    __decorate([
        context_1.Autowired('valueCache'),
        __metadata("design:type", valueCache_1.ValueCache)
    ], GridApi.prototype, "valueCache", void 0);
    __decorate([
        context_1.Optional('toolPanel'),
        __metadata("design:type", Object)
    ], GridApi.prototype, "toolPanel", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], GridApi.prototype, "init", null);
    GridApi = __decorate([
        context_1.Bean('gridApi')
    ], GridApi);
    return GridApi;
}());
exports.GridApi = GridApi;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var Constants = (function () {
    function Constants() {
    }
    Constants.STEP_EVERYTHING = 0;
    Constants.STEP_FILTER = 1;
    Constants.STEP_SORT = 2;
    Constants.STEP_MAP = 3;
    Constants.STEP_AGGREGATE = 4;
    Constants.STEP_PIVOT = 5;
    Constants.ROW_BUFFER_SIZE = 10;
    Constants.LAYOUT_INTERVAL = 500;
    Constants.EXPORT_TYPE_DRAG_COPY = 'dragCopy';
    Constants.EXPORT_TYPE_CLIPBOARD = 'clipboard';
    Constants.EXPORT_TYPE_EXCEL = 'excel';
    Constants.EXPORT_TYPE_CSV = 'csv';
    Constants.KEY_BACKSPACE = 8;
    Constants.KEY_TAB = 9;
    Constants.KEY_ENTER = 13;
    Constants.KEY_SHIFT = 16;
    Constants.KEY_ESCAPE = 27;
    Constants.KEY_SPACE = 32;
    Constants.KEY_LEFT = 37;
    Constants.KEY_UP = 38;
    Constants.KEY_RIGHT = 39;
    Constants.KEY_DOWN = 40;
    Constants.KEY_DELETE = 46;
    Constants.KEY_A = 65;
    Constants.KEY_C = 67;
    Constants.KEY_V = 86;
    Constants.KEY_D = 68;
    Constants.KEY_F2 = 113;
    Constants.KEY_PAGE_UP = 33;
    Constants.KEY_PAGE_DOWN = 34;
    Constants.KEY_PAGE_HOME = 36;
    Constants.KEY_PAGE_END = 35;
    Constants.ROW_MODEL_TYPE_INFINITE = 'infinite';
    Constants.ROW_MODEL_TYPE_VIEWPORT = 'viewport';
    Constants.ROW_MODEL_TYPE_IN_MEMORY = 'inMemory';
    Constants.ROW_MODEL_TYPE_ENTERPRISE = 'enterprise';
    Constants.DEPRECATED_ROW_MODEL_TYPE_NORMAL = 'normal';
    Constants.ALWAYS = 'always';
    Constants.ONLY_WHEN_GROUPING = 'onlyWhenGrouping';
    Constants.PINNED_TOP = 'top';
    Constants.PINNED_BOTTOM = 'bottom';
    return Constants;
}());
exports.Constants = Constants;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var beanStub_1 = __webpack_require__(13);
var compIdSequence = new utils_1.NumberSequence();
var Component = (function (_super) {
    __extends(Component, _super);
    function Component(template) {
        var _this = _super.call(this) || this;
        _this.childComponents = [];
        _this.annotatedEventListeners = [];
        _this.visible = true;
        // unique id for this row component. this is used for getting a reference to the HTML dom.
        // we cannot use the RowNode id as this is not unique (due to animation, old rows can be lying
        // around as we create a new rowComp instance for the same row node).
        _this.compId = compIdSequence.next();
        if (template) {
            _this.setTemplate(template);
        }
        return _this;
    }
    Component.prototype.getCompId = function () {
        return this.compId;
    };
    Component.prototype.instantiate = function (context) {
        this.instantiateRecurse(this.getGui(), context);
    };
    Component.prototype.instantiateRecurse = function (parentNode, context) {
        var childCount = parentNode.childNodes ? parentNode.childNodes.length : 0;
        for (var i = 0; i < childCount; i++) {
            var childNode = parentNode.childNodes[i];
            var newComponent = context.createComponent(childNode);
            if (newComponent) {
                this.swapComponentForNode(newComponent, parentNode, childNode);
            }
            else {
                if (childNode.childNodes) {
                    this.instantiateRecurse(childNode, context);
                }
            }
        }
    };
    Component.prototype.swapComponentForNode = function (newComponent, parentNode, childNode) {
        parentNode.replaceChild(newComponent.getGui(), childNode);
        this.childComponents.push(newComponent);
        this.swapInComponentForQuerySelectors(newComponent, childNode);
    };
    Component.prototype.swapInComponentForQuerySelectors = function (newComponent, childNode) {
        var thisProto = Object.getPrototypeOf(this);
        var thisNoType = this;
        while (thisProto != null) {
            var metaData = thisProto.__agComponentMetaData;
            var currentProtoName = (thisProto.constructor).name;
            if (metaData && metaData[currentProtoName] && metaData[currentProtoName].querySelectors) {
                metaData[currentProtoName].querySelectors.forEach(function (querySelector) {
                    if (thisNoType[querySelector.attributeName] === childNode) {
                        thisNoType[querySelector.attributeName] = newComponent;
                    }
                });
            }
            thisProto = Object.getPrototypeOf(thisProto);
        }
    };
    Component.prototype.setTemplate = function (template) {
        var eGui = utils_1.Utils.loadTemplate(template);
        this.setTemplateFromElement(eGui);
    };
    Component.prototype.setTemplateFromElement = function (element) {
        this.eGui = element;
        this.eGui.__agComponent = this;
        this.addAnnotatedEventListeners();
        this.wireQuerySelectors();
    };
    Component.prototype.attributesSet = function () {
    };
    Component.prototype.wireQuerySelectors = function () {
        var _this = this;
        if (!this.eGui) {
            return;
        }
        var thisProto = Object.getPrototypeOf(this);
        var _loop_1 = function () {
            var metaData = thisProto.__agComponentMetaData;
            var currentProtoName = (thisProto.constructor).name;
            if (metaData && metaData[currentProtoName] && metaData[currentProtoName].querySelectors) {
                var thisNoType_1 = this_1;
                metaData[currentProtoName].querySelectors.forEach(function (querySelector) {
                    var resultOfQuery = _this.eGui.querySelector(querySelector.querySelector);
                    if (resultOfQuery) {
                        var backingComponent = resultOfQuery.__agComponent;
                        if (backingComponent) {
                            thisNoType_1[querySelector.attributeName] = backingComponent;
                        }
                        else {
                            thisNoType_1[querySelector.attributeName] = resultOfQuery;
                        }
                    }
                    else {
                        // put debug msg in here if query selector fails???
                    }
                });
            }
            thisProto = Object.getPrototypeOf(thisProto);
        };
        var this_1 = this;
        while (thisProto != null) {
            _loop_1();
        }
    };
    Component.prototype.addAnnotatedEventListeners = function () {
        var _this = this;
        this.removeAnnotatedEventListeners();
        if (!this.eGui) {
            return;
        }
        var thisProto = Object.getPrototypeOf(this);
        while (thisProto != null) {
            var metaData = thisProto.__agComponentMetaData;
            var currentProtoName = (thisProto.constructor).name;
            if (metaData && metaData[currentProtoName] && metaData[currentProtoName].listenerMethods) {
                if (!this.annotatedEventListeners) {
                    this.annotatedEventListeners = [];
                }
                metaData[currentProtoName].listenerMethods.forEach(function (eventListener) {
                    var listener = _this[eventListener.methodName].bind(_this);
                    _this.eGui.addEventListener(eventListener.eventName, listener);
                    _this.annotatedEventListeners.push({ eventName: eventListener.eventName, listener: listener });
                });
            }
            thisProto = Object.getPrototypeOf(thisProto);
        }
    };
    Component.prototype.removeAnnotatedEventListeners = function () {
        var _this = this;
        if (!this.annotatedEventListeners) {
            return;
        }
        if (!this.eGui) {
            return;
        }
        this.annotatedEventListeners.forEach(function (eventListener) {
            _this.eGui.removeEventListener(eventListener.eventName, eventListener.listener);
        });
        this.annotatedEventListeners = null;
    };
    Component.prototype.getGui = function () {
        return this.eGui;
    };
    // this method is for older code, that wants to provide the gui element,
    // it is not intended for this to be in ag-Stack
    Component.prototype.setGui = function (eGui) {
        this.eGui = eGui;
    };
    Component.prototype.queryForHtmlElement = function (cssSelector) {
        return this.eGui.querySelector(cssSelector);
    };
    Component.prototype.queryForHtmlInputElement = function (cssSelector) {
        return this.eGui.querySelector(cssSelector);
    };
    Component.prototype.appendChild = function (newChild) {
        if (utils_1.Utils.isNodeOrElement(newChild)) {
            this.eGui.appendChild(newChild);
        }
        else {
            var childComponent = newChild;
            this.eGui.appendChild(childComponent.getGui());
            this.childComponents.push(childComponent);
        }
    };
    Component.prototype.addFeature = function (context, feature) {
        context.wireBean(feature);
        if (feature.destroy) {
            this.addDestroyFunc(feature.destroy.bind(feature));
        }
    };
    Component.prototype.isVisible = function () {
        return this.visible;
    };
    Component.prototype.setVisible = function (visible) {
        if (visible !== this.visible) {
            this.visible = visible;
            utils_1.Utils.addOrRemoveCssClass(this.eGui, 'ag-hidden', !visible);
            var event_1 = {
                type: Component.EVENT_VISIBLE_CHANGED,
                visible: this.visible
            };
            this.dispatchEvent(event_1);
        }
    };
    Component.prototype.addOrRemoveCssClass = function (className, addOrRemove) {
        utils_1.Utils.addOrRemoveCssClass(this.eGui, className, addOrRemove);
    };
    Component.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.childComponents.forEach(function (childComponent) { return childComponent.destroy(); });
        this.childComponents.length = 0;
        this.removeAnnotatedEventListeners();
    };
    Component.prototype.addGuiEventListener = function (event, listener) {
        var _this = this;
        this.getGui().addEventListener(event, listener);
        this.addDestroyFunc(function () { return _this.getGui().removeEventListener(event, listener); });
    };
    Component.prototype.addCssClass = function (className) {
        utils_1.Utils.addCssClass(this.getGui(), className);
    };
    Component.prototype.removeCssClass = function (className) {
        utils_1.Utils.removeCssClass(this.getGui(), className);
    };
    Component.prototype.getAttribute = function (key) {
        var eGui = this.getGui();
        if (eGui) {
            return eGui.getAttribute(key);
        }
        else {
            return null;
        }
    };
    Component.prototype.getRefElement = function (refName) {
        return this.queryForHtmlElement('[ref="' + refName + '"]');
    };
    Component.EVENT_VISIBLE_CHANGED = 'visibleChanged';
    return Component;
}(beanStub_1.BeanStub));
exports.Component = Component;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var eventService_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(1);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnUtils_1 = __webpack_require__(31);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
// Wrapper around a user provide column definition. The grid treats the column definition as ready only.
// This class contains all the runtime information about a column, plus some logic (the definition has no logic).
// This class implements both interfaces ColumnGroupChild and OriginalColumnGroupChild as the class can
// appear as a child of either the original tree or the displayed tree. However the relevant group classes
// for each type only implements one, as each group can only appear in it's associated tree (eg OriginalColumnGroup
// can only appear in OriginalColumn tree).
var Column = (function () {
    function Column(colDef, colId, primary) {
        this.moving = false;
        this.menuVisible = false;
        this.filterActive = false;
        this.eventService = new eventService_1.EventService();
        this.rowGroupActive = false;
        this.pivotActive = false;
        this.aggregationActive = false;
        this.colDef = colDef;
        this.visible = !colDef.hide;
        this.sort = colDef.sort;
        this.sortedAt = colDef.sortedAt;
        this.colId = colId;
        this.primary = primary;
    }
    Column.prototype.setParent = function (parent) {
        this.parent = parent;
    };
    Column.prototype.getParent = function () {
        return this.parent;
    };
    // this is done after constructor as it uses gridOptionsWrapper
    Column.prototype.initialise = function () {
        this.setPinned(this.colDef.pinned);
        var minColWidth = this.gridOptionsWrapper.getMinColWidth();
        var maxColWidth = this.gridOptionsWrapper.getMaxColWidth();
        if (this.colDef.minWidth) {
            this.minWidth = this.colDef.minWidth;
        }
        else {
            this.minWidth = minColWidth;
        }
        if (this.colDef.maxWidth) {
            this.maxWidth = this.colDef.maxWidth;
        }
        else {
            this.maxWidth = maxColWidth;
        }
        this.actualWidth = this.columnUtils.calculateColInitialWidth(this.colDef);
        var suppressDotNotation = this.gridOptionsWrapper.isSuppressFieldDotNotation();
        this.fieldContainsDots = utils_1.Utils.exists(this.colDef.field) && this.colDef.field.indexOf('.') >= 0 && !suppressDotNotation;
        this.tooltipFieldContainsDots = utils_1.Utils.exists(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf('.') >= 0 && !suppressDotNotation;
        this.validate();
    };
    Column.prototype.isEmptyGroup = function () {
        return false;
    };
    Column.prototype.isRowGroupDisplayed = function (colId) {
        if (utils_1.Utils.missing(this.colDef) || utils_1.Utils.missing(this.colDef.showRowGroup)) {
            return false;
        }
        var showingAllGroups = this.colDef.showRowGroup === true;
        var showingThisGroup = this.colDef.showRowGroup === colId;
        return showingAllGroups || showingThisGroup;
    };
    Column.prototype.getUniqueId = function () {
        return this.getId();
    };
    Column.prototype.isPrimary = function () {
        return this.primary;
    };
    Column.prototype.isFilterAllowed = function () {
        return this.primary && !this.colDef.suppressFilter;
    };
    Column.prototype.isFieldContainsDots = function () {
        return this.fieldContainsDots;
    };
    Column.prototype.isTooltipFieldContainsDots = function () {
        return this.tooltipFieldContainsDots;
    };
    Column.prototype.validate = function () {
        var colDefAny = this.colDef;
        if (!this.gridOptionsWrapper.isEnterprise()) {
            var itemsNotAllowedWithoutEnterprise = ['enableRowGroup', 'rowGroup', 'rowGroupIndex', 'enablePivot', 'pivot', 'pivotIndex', 'aggFunc'];
            itemsNotAllowedWithoutEnterprise.forEach(function (item) {
                if (utils_1.Utils.exists(colDefAny[item])) {
                    console.warn("ag-Grid: " + item + " is only valid in ag-Grid-Enterprise, your column definition should not have " + item);
                }
            });
        }
        if (this.gridOptionsWrapper.isTreeData()) {
            var itemsNotAllowedWithTreeData = ['enableRowGroup', 'rowGroup', 'rowGroupIndex', 'enablePivot', 'pivot', 'pivotIndex'];
            itemsNotAllowedWithTreeData.forEach(function (item) {
                if (utils_1.Utils.exists(colDefAny[item])) {
                    console.warn("ag-Grid: " + item + " is not possible when doing tree data, your column definition should not have " + item);
                }
            });
        }
        if (utils_1.Utils.exists(this.colDef.width) && typeof this.colDef.width !== 'number') {
            console.warn('ag-Grid: colDef.width should be a number, not ' + typeof this.colDef.width);
        }
        if (utils_1.Utils.get(this, 'colDef.cellRendererParams.restrictToOneGroup', null)) {
            console.warn('ag-Grid: Since ag-grid 11.0.0 cellRendererParams.restrictToOneGroup is deprecated. You should use showRowGroup');
        }
        if (utils_1.Utils.get(this, 'colDef.cellRendererParams.keyMap', null)) {
            console.warn('ag-Grid: Since ag-grid 11.0.0 cellRendererParams.keyMap is deprecated. You should use colDef.keyCreator');
        }
        if (utils_1.Utils.get(this, 'colDef.cellRendererParams.keyMap', null)) {
            console.warn('ag-Grid: Since ag-grid 11.0.0 cellRendererParams.keyMap is deprecated. You should use colDef.keyCreator');
        }
        if (colDefAny.floatingCellRenderer) {
            console.warn('ag-Grid: since v11, floatingCellRenderer is now pinnedRowCellRenderer');
            this.colDef.pinnedRowCellRenderer = colDefAny.floatingCellRenderer;
        }
        if (colDefAny.floatingRendererFramework) {
            console.warn('ag-Grid: since v11, floatingRendererFramework is now pinnedRowCellRendererFramework');
            this.colDef.pinnedRowCellRendererFramework = colDefAny.floatingRendererFramework;
        }
        if (colDefAny.floatingRendererParams) {
            console.warn('ag-Grid: since v11, floatingRendererParams is now pinnedRowCellRendererParams');
            this.colDef.pinnedRowCellRendererParams = colDefAny.floatingRendererParams;
        }
        if (colDefAny.floatingValueFormatter) {
            console.warn('ag-Grid: since v11, floatingValueFormatter is now pinnedRowValueFormatter');
            this.colDef.pinnedRowValueFormatter = colDefAny.floatingValueFormatter;
        }
        if (colDefAny.cellFormatter) {
            console.warn('ag-Grid: since v12, cellFormatter is now valueFormatter');
            if (utils_1.Utils.missing(this.colDef.valueFormatter)) {
                this.colDef.valueFormatter = colDefAny.cellFormatter;
            }
        }
    };
    Column.prototype.addEventListener = function (eventType, listener) {
        this.eventService.addEventListener(eventType, listener);
    };
    Column.prototype.removeEventListener = function (eventType, listener) {
        this.eventService.removeEventListener(eventType, listener);
    };
    Column.prototype.createIsColumnFuncParams = function (rowNode) {
        return {
            node: rowNode,
            column: this,
            colDef: this.colDef,
            context: this.gridOptionsWrapper.getContext(),
            api: this.gridOptionsWrapper.getApi(),
            columnApi: this.gridOptionsWrapper.getColumnApi()
        };
    };
    Column.prototype.isSuppressNavigable = function (rowNode) {
        // if boolean set, then just use it
        if (typeof this.colDef.suppressNavigable === 'boolean') {
            return this.colDef.suppressNavigable;
        }
        // if function, then call the function to find out
        if (typeof this.colDef.suppressNavigable === 'function') {
            var params = this.createIsColumnFuncParams(rowNode);
            var userFunc = this.colDef.suppressNavigable;
            return userFunc(params);
        }
        return false;
    };
    Column.prototype.isCellEditable = function (rowNode) {
        // only allow editing of groups if the user has this option enabled
        if (rowNode.group && !this.gridOptionsWrapper.isEnableGroupEdit()) {
            return false;
        }
        return this.isColumnFunc(rowNode, this.colDef.editable);
    };
    Column.prototype.isSuppressPaste = function (rowNode) {
        return this.isColumnFunc(rowNode, this.colDef ? this.colDef.suppressPaste : null);
    };
    Column.prototype.isResizable = function () {
        var enableColResize = this.gridOptionsWrapper.isEnableColResize();
        var suppressResize = this.colDef && this.colDef.suppressResize;
        return enableColResize && !suppressResize;
    };
    Column.prototype.isColumnFunc = function (rowNode, value) {
        // if boolean set, then just use it
        if (typeof value === 'boolean') {
            return value;
        }
        // if function, then call the function to find out
        if (typeof value === 'function') {
            var params = this.createIsColumnFuncParams(rowNode);
            var editableFunc = value;
            return editableFunc(params);
        }
        return false;
    };
    Column.prototype.setMoving = function (moving) {
        this.moving = moving;
        this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_MOVING_CHANGED));
    };
    Column.prototype.createColumnEvent = function (type) {
        return {
            api: this.gridApi,
            columnApi: this.columnApi,
            type: type,
            column: this,
            columns: [this]
        };
    };
    Column.prototype.isMoving = function () {
        return this.moving;
    };
    Column.prototype.getSort = function () {
        return this.sort;
    };
    Column.prototype.setSort = function (sort) {
        if (this.sort !== sort) {
            this.sort = sort;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_SORT_CHANGED));
        }
    };
    Column.prototype.setMenuVisible = function (visible) {
        if (this.menuVisible !== visible) {
            this.menuVisible = visible;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_MENU_VISIBLE_CHANGED));
        }
    };
    Column.prototype.isMenuVisible = function () {
        return this.menuVisible;
    };
    Column.prototype.isSortAscending = function () {
        return this.sort === Column.SORT_ASC;
    };
    Column.prototype.isSortDescending = function () {
        return this.sort === Column.SORT_DESC;
    };
    Column.prototype.isSortNone = function () {
        return utils_1.Utils.missing(this.sort);
    };
    Column.prototype.isSorting = function () {
        return utils_1.Utils.exists(this.sort);
    };
    Column.prototype.getSortedAt = function () {
        return this.sortedAt;
    };
    Column.prototype.setSortedAt = function (sortedAt) {
        this.sortedAt = sortedAt;
    };
    Column.prototype.setAggFunc = function (aggFunc) {
        this.aggFunc = aggFunc;
    };
    Column.prototype.getAggFunc = function () {
        return this.aggFunc;
    };
    Column.prototype.getLeft = function () {
        return this.left;
    };
    Column.prototype.getOldLeft = function () {
        return this.oldLeft;
    };
    Column.prototype.getRight = function () {
        return this.left + this.actualWidth;
    };
    Column.prototype.setLeft = function (left) {
        this.oldLeft = this.left;
        if (this.left !== left) {
            this.left = left;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_LEFT_CHANGED));
        }
    };
    Column.prototype.isFilterActive = function () {
        return this.filterActive;
    };
    Column.prototype.setFilterActive = function (active) {
        if (this.filterActive !== active) {
            this.filterActive = active;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_FILTER_ACTIVE_CHANGED));
        }
        this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_FILTER_CHANGED));
    };
    Column.prototype.setPinned = function (pinned) {
        // pinning is not allowed when doing 'forPrint'
        if (this.gridOptionsWrapper.isForPrint()) {
            return;
        }
        if (pinned === true || pinned === Column.PINNED_LEFT) {
            this.pinned = Column.PINNED_LEFT;
        }
        else if (pinned === Column.PINNED_RIGHT) {
            this.pinned = Column.PINNED_RIGHT;
        }
        else {
            this.pinned = null;
        }
        // console.log(`setColumnsPinned ${this.getColId()} ${this.pinned}`);
    };
    Column.prototype.setFirstRightPinned = function (firstRightPinned) {
        if (this.firstRightPinned !== firstRightPinned) {
            this.firstRightPinned = firstRightPinned;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED));
        }
    };
    Column.prototype.setLastLeftPinned = function (lastLeftPinned) {
        if (this.lastLeftPinned !== lastLeftPinned) {
            this.lastLeftPinned = lastLeftPinned;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_LAST_LEFT_PINNED_CHANGED));
        }
    };
    Column.prototype.isFirstRightPinned = function () {
        return this.firstRightPinned;
    };
    Column.prototype.isLastLeftPinned = function () {
        return this.lastLeftPinned;
    };
    Column.prototype.isPinned = function () {
        return this.pinned === Column.PINNED_LEFT || this.pinned === Column.PINNED_RIGHT;
    };
    Column.prototype.isPinnedLeft = function () {
        return this.pinned === Column.PINNED_LEFT;
    };
    Column.prototype.isPinnedRight = function () {
        return this.pinned === Column.PINNED_RIGHT;
    };
    Column.prototype.getPinned = function () {
        return this.pinned;
    };
    Column.prototype.setVisible = function (visible) {
        var newValue = visible === true;
        if (this.visible !== newValue) {
            this.visible = newValue;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_VISIBLE_CHANGED));
        }
    };
    Column.prototype.isVisible = function () {
        return this.visible;
    };
    Column.prototype.getColDef = function () {
        return this.colDef;
    };
    Column.prototype.getColumnGroupShow = function () {
        return this.colDef.columnGroupShow;
    };
    Column.prototype.getColId = function () {
        return this.colId;
    };
    Column.prototype.getId = function () {
        return this.getColId();
    };
    Column.prototype.getDefinition = function () {
        return this.colDef;
    };
    Column.prototype.getActualWidth = function () {
        return this.actualWidth;
    };
    Column.prototype.getColSpan = function (rowNode) {
        if (utils_1.Utils.missing(this.colDef.colSpan)) {
            return 1;
        }
        else {
            var params = {
                node: rowNode,
                data: rowNode.data,
                colDef: this.colDef,
                column: this,
                api: this.gridOptionsWrapper.getApi(),
                columnApi: this.gridOptionsWrapper.getColumnApi(),
                context: this.gridOptionsWrapper.getContext()
            };
            var colSpan = this.colDef.colSpan(params);
            // colSpan must be number equal to or greater than 1
            if (colSpan > 1) {
                return colSpan;
            }
            else {
                return 1;
            }
        }
    };
    Column.prototype.setActualWidth = function (actualWidth) {
        if (this.actualWidth !== actualWidth) {
            this.actualWidth = actualWidth;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_WIDTH_CHANGED));
        }
    };
    Column.prototype.isGreaterThanMax = function (width) {
        if (this.maxWidth) {
            return width > this.maxWidth;
        }
        else {
            return false;
        }
    };
    Column.prototype.getMinWidth = function () {
        return this.minWidth;
    };
    Column.prototype.getMaxWidth = function () {
        return this.maxWidth;
    };
    Column.prototype.setMinimum = function () {
        this.setActualWidth(this.minWidth);
    };
    Column.prototype.setRowGroupActive = function (rowGroup) {
        if (this.rowGroupActive !== rowGroup) {
            this.rowGroupActive = rowGroup;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_ROW_GROUP_CHANGED));
        }
    };
    Column.prototype.isRowGroupActive = function () {
        return this.rowGroupActive;
    };
    Column.prototype.setPivotActive = function (pivot) {
        if (this.pivotActive !== pivot) {
            this.pivotActive = pivot;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_PIVOT_CHANGED));
        }
    };
    Column.prototype.isPivotActive = function () {
        return this.pivotActive;
    };
    Column.prototype.isAnyFunctionActive = function () {
        return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
    };
    Column.prototype.isAnyFunctionAllowed = function () {
        return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
    };
    Column.prototype.setValueActive = function (value) {
        if (this.aggregationActive !== value) {
            this.aggregationActive = value;
            this.eventService.dispatchEvent(this.createColumnEvent(Column.EVENT_VALUE_CHANGED));
        }
    };
    Column.prototype.isValueActive = function () {
        return this.aggregationActive;
    };
    Column.prototype.isAllowPivot = function () {
        return this.colDef.enablePivot === true;
    };
    Column.prototype.isAllowValue = function () {
        return this.colDef.enableValue === true;
    };
    Column.prototype.isAllowRowGroup = function () {
        return this.colDef.enableRowGroup === true;
    };
    Column.prototype.getMenuTabs = function (defaultValues) {
        var menuTabs = this.getColDef().menuTabs;
        if (menuTabs == null) {
            menuTabs = defaultValues;
        }
        return menuTabs;
    };
    // + renderedHeaderCell - for making header cell transparent when moving
    Column.EVENT_MOVING_CHANGED = 'movingChanged';
    // + renderedCell - changing left position
    Column.EVENT_LEFT_CHANGED = 'leftChanged';
    // + renderedCell - changing width
    Column.EVENT_WIDTH_CHANGED = 'widthChanged';
    // + renderedCell - for changing pinned classes
    Column.EVENT_LAST_LEFT_PINNED_CHANGED = 'lastLeftPinnedChanged';
    Column.EVENT_FIRST_RIGHT_PINNED_CHANGED = 'firstRightPinnedChanged';
    // + renderedColumn - for changing visibility icon
    Column.EVENT_VISIBLE_CHANGED = 'visibleChanged';
    // + every time the filter changes, used in the floating filters
    Column.EVENT_FILTER_CHANGED = 'filterChanged';
    // + renderedHeaderCell - marks the header with filter icon
    Column.EVENT_FILTER_ACTIVE_CHANGED = 'filterActiveChanged';
    // + renderedHeaderCell - marks the header with sort icon
    Column.EVENT_SORT_CHANGED = 'sortChanged';
    Column.EVENT_MENU_VISIBLE_CHANGED = 'menuVisibleChanged';
    // + toolpanel, for gui updates
    Column.EVENT_ROW_GROUP_CHANGED = 'columnRowGroupChanged';
    // + toolpanel, for gui updates
    Column.EVENT_PIVOT_CHANGED = 'columnPivotChanged';
    // + toolpanel, for gui updates
    Column.EVENT_VALUE_CHANGED = 'columnValueChanged';
    Column.PINNED_RIGHT = 'right';
    Column.PINNED_LEFT = 'left';
    Column.SORT_ASC = 'asc';
    Column.SORT_DESC = 'desc';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], Column.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnUtils'),
        __metadata("design:type", columnUtils_1.ColumnUtils)
    ], Column.prototype, "columnUtils", void 0);
    __decorate([
        context_1.Autowired('frameworkFactory'),
        __metadata("design:type", Object)
    ], Column.prototype, "frameworkFactory", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], Column.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], Column.prototype, "gridApi", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Column.prototype, "initialise", null);
    return Column;
}());
exports.Column = Column;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var rowRenderer_1 = __webpack_require__(18);
var borderLayout_1 = __webpack_require__(76);
var logger_1 = __webpack_require__(11);
var context_1 = __webpack_require__(0);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var dragService_1 = __webpack_require__(50);
var constants_1 = __webpack_require__(7);
var selectionController_1 = __webpack_require__(17);
var csvCreator_1 = __webpack_require__(49);
var mouseEventService_1 = __webpack_require__(38);
var focusedCellController_1 = __webpack_require__(24);
var scrollVisibleService_1 = __webpack_require__(34);
var beanStub_1 = __webpack_require__(13);
var rowContainerComponent_1 = __webpack_require__(148);
var paginationProxy_1 = __webpack_require__(29);
var popupEditorWrapper_1 = __webpack_require__(78);
var alignedGridsService_1 = __webpack_require__(45);
var pinnedRowModel_1 = __webpack_require__(30);
var gridApi_1 = __webpack_require__(6);
var animationFrameService_1 = __webpack_require__(40);
var rowComp_1 = __webpack_require__(58);
var navigationService_1 = __webpack_require__(99);
// in the html below, it is important that there are no white space between some of the divs, as if there is white space,
// it won't render correctly in safari, as safari renders white space as a gap
var HEADER_SNIPPET = '<div class="ag-header" role="row">' +
    '<div class="ag-pinned-left-header" role="presentation"></div>' +
    '<div class="ag-pinned-right-header" role="presentation"></div>' +
    '<div class="ag-header-viewport" role="presentation">' +
    '<div class="ag-header-container" role="presentation"></div>' +
    '</div>' +
    '<div class="ag-header-overlay" role="presentation"></div>' +
    '</div>';
var FLOATING_TOP_SNIPPET = '<div class="ag-floating-top" role="presentation">' +
    '<div class="ag-pinned-left-floating-top" role="presentation"></div>' +
    '<div class="ag-pinned-right-floating-top" role="presentation"></div>' +
    '<div class="ag-floating-top-viewport" role="presentation">' +
    '<div class="ag-floating-top-container" role="presentation"></div>' +
    '</div>' +
    '<div class="ag-floating-top-full-width-container" role="presentation"></div>' +
    '</div>';
var FLOATING_BOTTOM_SNIPPET = '<div class="ag-floating-bottom" role="presentation">' +
    '<div class="ag-pinned-left-floating-bottom" role="presentation"></div>' +
    '<div class="ag-pinned-right-floating-bottom" role="presentation"></div>' +
    '<div class="ag-floating-bottom-viewport" role="presentation">' +
    '<div class="ag-floating-bottom-container" role="presentation"></div>' +
    '</div>' +
    '<div class="ag-floating-bottom-full-width-container" role="presentation"></div>' +
    '</div>';
var BODY_SNIPPET = '<div class="ag-body" role="presentation">' +
    '<div class="ag-pinned-left-cols-viewport" role="presentation">' +
    '<div class="ag-pinned-left-cols-container" role="presentation"></div>' +
    '</div>' +
    '<div class="ag-pinned-right-cols-viewport" role="presentation">' +
    '<div class="ag-pinned-right-cols-container" role="presentation"></div>' +
    '</div>' +
    '<div class="ag-body-viewport-wrapper" role="presentation">' +
    '<div class="ag-body-viewport" role="presentation">' +
    '<div class="ag-body-container" role="presentation"></div>' +
    '</div>' +
    '</div>' +
    '<div class="ag-full-width-viewport" role="presentation">' +
    '<div class="ag-full-width-container" role="presentation"></div>' +
    '</div>' +
    '</div>';
// the difference between the 'normal' and 'full height' template is the order of the floating and body,
// for normal, the floating top and bottom go in first as they are fixed position,
// for auto-height, the body is in the middle of the top and bottom as they are just normally laid out
var GRID_PANEL_NORMAL_TEMPLATE = '<div class="ag-root ag-font-style" role="grid">' +
    HEADER_SNIPPET + FLOATING_TOP_SNIPPET + FLOATING_BOTTOM_SNIPPET + BODY_SNIPPET +
    '</div>';
var GRID_PANEL_AUTO_HEIGHT_TEMPLATE = '<div class="ag-root ag-font-style" role="grid">' +
    HEADER_SNIPPET + FLOATING_TOP_SNIPPET + BODY_SNIPPET + FLOATING_BOTTOM_SNIPPET +
    '</div>';
// the template for for-print is much easier than that others, as it doesn't have any pinned areas
// or scrollable areas (so no viewports).
var GRID_PANEL_FOR_PRINT_TEMPLATE = '<div class="ag-root ag-font-style">' +
    // header
    '<div class="ag-header-container"></div>' +
    // floating
    '<div class="ag-floating-top-container"></div>' +
    // body
    '<div class="ag-body-container"></div>' +
    // floating bottom
    '<div class="ag-floating-bottom-container"></div>' +
    '</div>';
// wrapping in outer div, and wrapper, is needed to center the loading icon
// The idea for centering came from here: http://www.vanseodesign.com/css/vertical-centering/
var OVERLAY_TEMPLATE = '<div class="ag-overlay-panel" role="presentation">' +
    '<div class="ag-overlay-wrapper ag-overlay-[OVERLAY_NAME]-wrapper">[OVERLAY_TEMPLATE]</div>' +
    '</div>';
var LOADING_OVERLAY_TEMPLATE = '<span class="ag-overlay-loading-center">[LOADING...]</span>';
var NO_ROWS_TO_SHOW_OVERLAY_TEMPLATE = '<span class="ag-overlay-no-rows-center">[NO_ROWS_TO_SHOW]</span>';
var GridPanel = (function (_super) {
    __extends(GridPanel, _super);
    function GridPanel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.scrollLeft = -1;
        _this.nextScrollLeft = -1;
        _this.scrollTop = -1;
        _this.nextScrollTop = -1;
        _this.verticalRedrawNeeded = false;
        return _this;
    }
    GridPanel.prototype.agWire = function (loggerFactory) {
        this.logger = loggerFactory.create('GridPanel');
        // makes code below more readable if we pull 'forPrint' out
        this.forPrint = this.gridOptionsWrapper.isForPrint();
        this.autoHeight = this.gridOptionsWrapper.isAutoHeight();
        this.scrollWidth = this.gridOptionsWrapper.getScrollbarWidth();
        this.enableRtl = this.gridOptionsWrapper.isEnableRtl();
        this.loadTemplate();
        this.findElements();
    };
    GridPanel.prototype.getVerticalPixelRange = function () {
        var container = this.getPrimaryScrollViewport();
        var result = {
            top: container.scrollTop,
            bottom: container.scrollTop + container.offsetHeight
        };
        return result;
    };
    // we override this, as the base class is missing the annotation
    GridPanel.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
    };
    GridPanel.prototype.onRowDataChanged = function () {
        this.showOrHideOverlay();
    };
    GridPanel.prototype.showOrHideOverlay = function () {
        if (this.paginationProxy.isEmpty() && !this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
            this.showNoRowsOverlay();
        }
        else {
            this.hideOverlay();
        }
    };
    GridPanel.prototype.getLayout = function () {
        return this.layout;
    };
    GridPanel.prototype.init = function () {
        this.useAnimationFrame = !this.gridOptionsWrapper.isSuppressAnimationFrame();
        this.addEventListeners();
        this.addDragListeners();
        this.layout = new borderLayout_1.BorderLayout({
            overlays: {
                loading: utils_1.Utils.loadTemplate(this.createLoadingOverlayTemplate()),
                noRows: utils_1.Utils.loadTemplate(this.createNoRowsOverlayTemplate())
            },
            center: this.eRoot,
            dontFill: this.forPrint,
            fillHorizontalOnly: this.autoHeight,
            name: 'eGridPanel'
        });
        this.layout.addSizeChangeListener(this.setBodyAndHeaderHeights.bind(this));
        this.layout.addSizeChangeListener(this.setLeftAndRightBounds.bind(this));
        this.addScrollListener();
        if (this.gridOptionsWrapper.isSuppressHorizontalScroll()) {
            this.eBodyViewport.style.overflowX = 'hidden';
        }
        if (this.gridOptionsWrapper.isRowModelDefault() && !this.gridOptionsWrapper.getRowData()) {
            this.showLoadingOverlay();
        }
        this.setPinnedContainersVisible();
        this.setBodyAndHeaderHeights();
        this.disableBrowserDragging();
        this.addShortcutKeyListeners();
        this.addMouseListeners();
        this.addKeyboardEvents();
        this.addBodyViewportListener();
        this.addStopEditingWhenGridLosesFocus();
        if (this.$scope) {
            this.addAngularApplyCheck();
        }
        this.onDisplayedColumnsWidthChanged();
    };
    GridPanel.prototype.addStopEditingWhenGridLosesFocus = function () {
        var _this = this;
        if (this.gridOptionsWrapper.isStopEditingWhenGridLosesFocus()) {
            this.addDestroyableEventListener(this.eBody, 'focusout', function (event) {
                // this is the element the focus is moving to
                var elementWithFocus = event.relatedTarget;
                // see if the element the focus is going to is part of the grid
                var clickInsideGrid = false;
                var pointer = elementWithFocus;
                while (utils_1.Utils.exists(pointer) && !clickInsideGrid) {
                    var isPopup = !!_this.gridOptionsWrapper.getDomData(pointer, popupEditorWrapper_1.PopupEditorWrapper.DOM_KEY_POPUP_EDITOR_WRAPPER);
                    var isBody = _this.eBody == pointer;
                    clickInsideGrid = isPopup || isBody;
                    pointer = pointer.parentNode;
                }
                if (!clickInsideGrid) {
                    _this.rowRenderer.stopEditing();
                }
            });
        }
    };
    GridPanel.prototype.addAngularApplyCheck = function () {
        var _this = this;
        // this makes sure if we queue up requests, we only execute oe
        var applyTriggered = false;
        var listener = function () {
            // only need to do one apply at a time
            if (applyTriggered) {
                return;
            }
            applyTriggered = true; // mark 'need apply' to true
            setTimeout(function () {
                applyTriggered = false;
                _this.$scope.$apply();
            }, 0);
        };
        // these are the events we need to do an apply after - these are the ones that can end up
        // with columns added or removed
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, listener);
    };
    // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
    // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
    GridPanel.prototype.disableBrowserDragging = function () {
        this.eRoot.addEventListener('dragstart', function (event) {
            if (event.target instanceof HTMLImageElement) {
                event.preventDefault();
                return false;
            }
        });
    };
    GridPanel.prototype.addEventListeners = function () {
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PINNED_ROW_DATA_CHANGED, this.setBodyAndHeaderHeights.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_ROW_DATA_CHANGED, this.onRowDataChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_ROW_DATA_UPDATED, this.onRowDataChanged.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_GROUP_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_FLOATING_FILTERS_HEIGHT, this.setBodyAndHeaderHeights.bind(this));
    };
    GridPanel.prototype.addDragListeners = function () {
        var _this = this;
        if (this.forPrint // no range select when doing 'for print'
            || !this.gridOptionsWrapper.isEnableRangeSelection() // no range selection if no property
            || utils_1.Utils.missing(this.rangeController)) {
            return;
        }
        var containers = [this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, this.eBodyContainer,
            this.eFloatingTop, this.eFloatingBottom];
        containers.forEach(function (container) {
            var params = {
                dragStartPixels: 0,
                eElement: container,
                onDragStart: _this.rangeController.onDragStart.bind(_this.rangeController),
                onDragStop: _this.rangeController.onDragStop.bind(_this.rangeController),
                onDragging: _this.rangeController.onDragging.bind(_this.rangeController)
            };
            _this.dragService.addDragSource(params);
            _this.addDestroyFunc(function () { return _this.dragService.removeDragSource(params); });
        });
    };
    GridPanel.prototype.addMouseListeners = function () {
        var _this = this;
        var eventNames = ['click', 'mousedown', 'dblclick', 'contextmenu', 'mouseover', 'mouseout'];
        eventNames.forEach(function (eventName) {
            var listener = _this.processMouseEvent.bind(_this, eventName);
            _this.eAllCellContainers.forEach(function (container) {
                return _this.addDestroyableEventListener(container, eventName, listener);
            });
        });
    };
    GridPanel.prototype.addKeyboardEvents = function () {
        var _this = this;
        var eventNames = ['keydown', 'keypress'];
        eventNames.forEach(function (eventName) {
            var listener = _this.processKeyboardEvent.bind(_this, eventName);
            _this.eAllCellContainers.forEach(function (container) {
                _this.addDestroyableEventListener(container, eventName, listener);
            });
        });
    };
    GridPanel.prototype.addBodyViewportListener = function () {
        var _this = this;
        // we never add this when doing 'forPrint'
        if (this.gridOptionsWrapper.isForPrint()) {
            return;
        }
        // we want to listen for clicks directly on the eBodyViewport, so the user has a way of showing
        // the context menu if no rows are displayed, or user simply clicks outside of a cell
        var listener = function (mouseEvent) {
            var target = utils_1.Utils.getTarget(mouseEvent);
            if (target === _this.eBodyViewport || target === _this.ePinnedLeftColsViewport || target === _this.ePinnedRightColsViewport) {
                // show it
                _this.onContextMenu(mouseEvent);
                _this.preventDefaultOnContextMenu(mouseEvent);
            }
        };
        //For some reason listening only to this.eBody doesnt work... Maybe because the event is consumed somewhere else?
        //In any case, not expending much time on this, if anyome comes accross this and knows how to make this work with
        //one listener please go ahead and change it...
        this.addDestroyableEventListener(this.eBodyViewport, 'contextmenu', listener);
        this.addDestroyableEventListener(this.ePinnedRightColsViewport, 'contextmenu', listener);
        this.addDestroyableEventListener(this.ePinnedLeftColsViewport, 'contextmenu', listener);
    };
    GridPanel.prototype.getRowForEvent = function (event) {
        var sourceElement = utils_1.Utils.getTarget(event);
        while (sourceElement) {
            var renderedRow = this.gridOptionsWrapper.getDomData(sourceElement, rowComp_1.RowComp.DOM_DATA_KEY_RENDERED_ROW);
            if (renderedRow) {
                return renderedRow;
            }
            sourceElement = sourceElement.parentElement;
        }
        return null;
    };
    GridPanel.prototype.processKeyboardEvent = function (eventName, keyboardEvent) {
        var renderedCell = this.mouseEventService.getRenderedCellForEvent(keyboardEvent);
        if (!renderedCell) {
            return;
        }
        switch (eventName) {
            case 'keydown':
                // first see if it's a scroll key, page up / down, home / end etc
                var wasScrollKey = this.navigationService.handlePageScrollingKey(keyboardEvent);
                // if not a scroll key, then we pass onto cell
                if (!wasScrollKey) {
                    renderedCell.onKeyDown(keyboardEvent);
                }
                break;
            case 'keypress':
                renderedCell.onKeyPress(keyboardEvent);
                break;
        }
    };
    // gets called by rowRenderer when new data loaded, as it will want to scroll
    // to the top
    GridPanel.prototype.scrollToTop = function () {
        if (!this.forPrint) {
            this.getPrimaryScrollViewport().scrollTop = 0;
        }
    };
    GridPanel.prototype.processMouseEvent = function (eventName, mouseEvent) {
        var cellComp = this.mouseEventService.getRenderedCellForEvent(mouseEvent);
        if (cellComp) {
            cellComp.onMouseEvent(eventName, mouseEvent);
        }
        var rowComp = this.getRowForEvent(mouseEvent);
        if (rowComp) {
            rowComp.onMouseEvent(eventName, mouseEvent);
        }
        this.preventDefaultOnContextMenu(mouseEvent);
    };
    GridPanel.prototype.onContextMenu = function (mouseEvent) {
        // to allow us to debug in chrome, we ignore the event if ctrl is pressed.
        // not everyone wants this, so first 'if' below allows to turn this hack off.
        if (!this.gridOptionsWrapper.isAllowContextMenuWithControlKey()) {
            // then do the check
            if (mouseEvent.ctrlKey || mouseEvent.metaKey) {
                return;
            }
        }
        if (this.contextMenuFactory && !this.gridOptionsWrapper.isSuppressContextMenu()) {
            this.contextMenuFactory.showMenu(null, null, null, mouseEvent);
            mouseEvent.preventDefault();
        }
    };
    GridPanel.prototype.preventDefaultOnContextMenu = function (mouseEvent) {
        // if we don't do this, then middle click will never result in a 'click' event, as 'mousedown'
        // will be consumed by the browser to mean 'scroll' (as you can scroll with the middle mouse
        // button in the browser). so this property allows the user to receive middle button clicks if
        // they want.
        if (this.gridOptionsWrapper.isSuppressMiddleClickScrolls() && mouseEvent.which === 2) {
            mouseEvent.preventDefault();
        }
    };
    GridPanel.prototype.addShortcutKeyListeners = function () {
        var _this = this;
        this.eAllCellContainers.forEach(function (container) {
            container.addEventListener('keydown', function (event) {
                // if the cell the event came from is editing, then we do not
                // want to do the default shortcut keys, otherwise the editor
                // (eg a text field) would not be able to do the normal cut/copy/paste
                var renderedCell = _this.mouseEventService.getRenderedCellForEvent(event);
                if (renderedCell && renderedCell.isEditing()) {
                    return;
                }
                // for copy / paste, we don't want to execute when the event
                // was from a child grid (happens in master detail)
                if (!_this.mouseEventService.isEventFromThisGrid(event)) {
                    return;
                }
                if (event.ctrlKey || event.metaKey) {
                    switch (event.which) {
                        case constants_1.Constants.KEY_A: return _this.onCtrlAndA(event);
                        case constants_1.Constants.KEY_C: return _this.onCtrlAndC(event);
                        case constants_1.Constants.KEY_V: return _this.onCtrlAndV(event);
                        case constants_1.Constants.KEY_D: return _this.onCtrlAndD(event);
                    }
                }
            });
        });
    };
    GridPanel.prototype.onCtrlAndA = function (event) {
        if (this.rangeController && this.paginationProxy.isRowsToRender()) {
            var rowEnd = void 0;
            var floatingStart = void 0;
            var floatingEnd = void 0;
            if (this.pinnedRowModel.isEmpty(constants_1.Constants.PINNED_TOP)) {
                floatingStart = null;
            }
            else {
                floatingStart = constants_1.Constants.PINNED_TOP;
            }
            if (this.pinnedRowModel.isEmpty(constants_1.Constants.PINNED_BOTTOM)) {
                floatingEnd = null;
                rowEnd = this.paginationProxy.getTotalRowCount() - 1;
            }
            else {
                floatingEnd = constants_1.Constants.PINNED_BOTTOM;
                rowEnd = this.pinnedRowModel.getPinnedBottomRowData().length = 1;
            }
            var allDisplayedColumns = this.columnController.getAllDisplayedColumns();
            if (utils_1.Utils.missingOrEmpty(allDisplayedColumns)) {
                return;
            }
            this.rangeController.setRange({
                rowStart: 0,
                floatingStart: floatingStart,
                rowEnd: rowEnd,
                floatingEnd: floatingEnd,
                columnStart: allDisplayedColumns[0],
                columnEnd: allDisplayedColumns[allDisplayedColumns.length - 1]
            });
        }
        event.preventDefault();
        return false;
    };
    GridPanel.prototype.onCtrlAndC = function (event) {
        if (!this.clipboardService) {
            return;
        }
        var focusedCell = this.focusedCellController.getFocusedCell();
        this.clipboardService.copyToClipboard();
        event.preventDefault();
        // the copy operation results in loosing focus on the cell,
        // because of the trickery the copy logic uses with a temporary
        // widget. so we set it back again.
        if (focusedCell) {
            this.focusedCellController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.floating, true);
        }
        return false;
    };
    GridPanel.prototype.onCtrlAndV = function (event) {
        if (!this.rangeController) {
            return;
        }
        this.clipboardService.pasteFromClipboard();
        return false;
    };
    GridPanel.prototype.onCtrlAndD = function (event) {
        if (!this.clipboardService) {
            return;
        }
        this.clipboardService.copyRangeDown();
        event.preventDefault();
        return false;
    };
    GridPanel.prototype.createOverlayTemplate = function (name, defaultTemplate, userProvidedTemplate) {
        var template = OVERLAY_TEMPLATE
            .replace('[OVERLAY_NAME]', name);
        if (userProvidedTemplate) {
            template = template.replace('[OVERLAY_TEMPLATE]', userProvidedTemplate);
        }
        else {
            template = template.replace('[OVERLAY_TEMPLATE]', defaultTemplate);
        }
        return template;
    };
    GridPanel.prototype.createLoadingOverlayTemplate = function () {
        var userProvidedTemplate = this.gridOptionsWrapper.getOverlayLoadingTemplate();
        var templateNotLocalised = this.createOverlayTemplate('loading', LOADING_OVERLAY_TEMPLATE, userProvidedTemplate);
        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
        var templateLocalised = templateNotLocalised.replace('[LOADING...]', localeTextFunc('loadingOoo', 'Loading...'));
        return templateLocalised;
    };
    GridPanel.prototype.createNoRowsOverlayTemplate = function () {
        var userProvidedTemplate = this.gridOptionsWrapper.getOverlayNoRowsTemplate();
        var templateNotLocalised = this.createOverlayTemplate('no-rows', NO_ROWS_TO_SHOW_OVERLAY_TEMPLATE, userProvidedTemplate);
        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
        var templateLocalised = templateNotLocalised.replace('[NO_ROWS_TO_SHOW]', localeTextFunc('noRowsToShow', 'No Rows To Show'));
        return templateLocalised;
    };
    // Valid values for position are bottom, middle and top
    // position should be {'top','middle','bottom', or undefined/null}.
    // if undefined/null, then the grid will to the minimal amount of scrolling,
    // eg if grid needs to scroll up, it scrolls until row is on top,
    //    if grid needs to scroll down, it scrolls until row is on bottom,
    //    if row is already in view, grid does not scroll
    GridPanel.prototype.ensureIndexVisible = function (index, position) {
        // if for print, everything is always visible
        if (this.gridOptionsWrapper.isForPrint()) {
            return;
        }
        this.logger.log('ensureIndexVisible: ' + index);
        var rowCount = this.paginationProxy.getTotalRowCount();
        if (typeof index !== 'number' || index < 0 || index >= rowCount) {
            console.warn('invalid row index for ensureIndexVisible: ' + index);
            return;
        }
        this.paginationProxy.goToPageWithIndex(index);
        var nodeAtIndex = this.paginationProxy.getRow(index);
        var pixelOffset = this.paginationProxy.getPixelOffset();
        var rowTopPixel = nodeAtIndex.rowTop - pixelOffset;
        var rowBottomPixel = rowTopPixel + nodeAtIndex.rowHeight;
        var vRange = this.getVerticalPixelRange();
        var vRangeTop = vRange.top;
        var vRangeBottom = vRange.bottom;
        var scrollShowing = this.isHorizontalScrollShowing();
        if (scrollShowing) {
            vRangeBottom -= this.scrollWidth;
        }
        var rowToHighlightHeight = rowBottomPixel - rowTopPixel;
        var viewportHeight = vRangeBottom - vRangeTop;
        var halfScreenHeight = (viewportHeight / 2) + (rowToHighlightHeight / 2);
        var eViewportToScroll = this.getPrimaryScrollViewport();
        var newScrollPosition;
        switch (position) {
            case 'top':
                newScrollPosition = rowTopPixel;
                break;
            case 'bottom':
                newScrollPosition = rowBottomPixel - viewportHeight;
                break;
            case 'middle':
                newScrollPosition = halfScreenHeight;
                // The if/else logic here protects us from over scrolling
                // ie: Trying to scroll past the row (ie ensureNodeVisible (0, 'middle'))
                newScrollPosition = newScrollPosition > rowTopPixel ? rowTopPixel : newScrollPosition;
                break;
            default:
                newScrollPosition = rowTopPixel;
                var viewportScrolledPastRow = vRangeTop > rowTopPixel;
                var viewportScrolledBeforeRow = vRangeBottom < rowBottomPixel;
                if (viewportScrolledPastRow) {
                    // if row is before, scroll up with row at top
                    newScrollPosition = rowTopPixel;
                }
                else if (viewportScrolledBeforeRow) {
                    // if row is below, scroll down with row at bottom
                    var viewportHeight_1 = vRangeBottom - vRangeTop;
                    newScrollPosition = rowBottomPixel - viewportHeight_1;
                }
                else {
                    // row already in view, and top/middle/bottom not specified, so do nothing.
                    newScrollPosition = null;
                }
                break;
        }
        // this means the row is already in view, and we don't need to scroll
        if (newScrollPosition === null) {
            return;
        }
        eViewportToScroll.scrollTop = newScrollPosition;
        this.rowRenderer.redrawAfterScroll();
    };
    GridPanel.prototype.getPrimaryScrollViewport = function () {
        if (this.enableRtl && this.columnController.isPinningLeft()) {
            return this.ePinnedLeftColsViewport;
        }
        else if (!this.enableRtl && this.columnController.isPinningRight()) {
            return this.ePinnedRightColsViewport;
        }
        else {
            return this.eBodyViewport;
        }
    };
    // + moveColumnController
    GridPanel.prototype.getCenterWidth = function () {
        return this.eBodyViewport.clientWidth;
    };
    GridPanel.prototype.isHorizontalScrollShowing = function () {
        var result = utils_1.Utils.isHorizontalScrollShowing(this.eBodyViewport);
        return result;
    };
    GridPanel.prototype.isVerticalScrollShowing = function () {
        if (this.columnController.isPinningRight()) {
            return utils_1.Utils.isVerticalScrollShowing(this.ePinnedRightColsViewport);
        }
        else {
            return utils_1.Utils.isVerticalScrollShowing(this.eBodyViewport);
        }
    };
    GridPanel.prototype.isBodyVerticalScrollShowing = function () {
        // if the scroll is on the pinned panel, then it is never in the center panel.
        // if LRT, then pinning right means scroll NOT on center
        if (!this.enableRtl && this.columnController.isPinningRight()) {
            return false;
        }
        // if RTL, then pinning left means scroll NOT on center
        if (this.enableRtl && this.columnController.isPinningLeft()) {
            return false;
        }
        return utils_1.Utils.isVerticalScrollShowing(this.eBodyViewport);
    };
    // gets called every 500 ms. we use this to set padding on right pinned column
    GridPanel.prototype.periodicallyCheck = function () {
        if (this.forPrint) {
            return;
        }
        this.setBottomPaddingOnPinnedRight();
        this.setMarginOnFullWidthCellContainer();
        this.setScrollShowing();
    };
    GridPanel.prototype.setScrollShowing = function () {
        var params = {
            vBody: false,
            hBody: false,
            vPinnedLeft: false,
            vPinnedRight: false
        };
        if (this.enableRtl) {
            if (this.columnController.isPinningLeft()) {
                params.vPinnedLeft = this.forPrint ? false : utils_1.Utils.isVerticalScrollShowing(this.ePinnedLeftColsViewport);
            }
            else {
                params.vBody = utils_1.Utils.isVerticalScrollShowing(this.eBodyViewport);
            }
        }
        else {
            if (this.columnController.isPinningRight()) {
                params.vPinnedRight = this.forPrint ? false : utils_1.Utils.isVerticalScrollShowing(this.ePinnedRightColsViewport);
            }
            else {
                params.vBody = utils_1.Utils.isVerticalScrollShowing(this.eBodyViewport);
            }
        }
        params.hBody = utils_1.Utils.isHorizontalScrollShowing(this.eBodyViewport);
        this.scrollVisibleService.setScrollsVisible(params);
    };
    // the pinned container needs extra space at the bottom, some blank space, otherwise when
    // vertically scrolled all the way down, the last row will be hidden behind the scrolls.
    // this extra padding allows the last row to be lifted above the bottom scrollbar.
    GridPanel.prototype.setBottomPaddingOnPinnedRight = function () {
        if (this.forPrint) {
            return;
        }
        if (this.columnController.isPinningRight()) {
            var bodyHorizontalScrollShowing = this.eBodyViewport.clientWidth < this.eBodyViewport.scrollWidth;
            if (bodyHorizontalScrollShowing) {
                this.ePinnedRightColsContainer.style.marginBottom = this.scrollWidth + 'px';
            }
            else {
                this.ePinnedRightColsContainer.style.marginBottom = '';
            }
        }
    };
    GridPanel.prototype.setMarginOnFullWidthCellContainer = function () {
        if (this.forPrint) {
            return;
        }
        // if either right or bottom scrollbars are showing, we need to make sure the
        // fullWidthCell panel isn't covering the scrollbars. originally i tried to do this using
        // margin, but the overflow was not getting clipped and going into the margin,
        // so used border instead. dunno why it works, trial and error found the solution.
        if (this.enableRtl) {
            if (this.isVerticalScrollShowing()) {
                this.eFullWidthCellViewport.style.borderLeft = this.scrollWidth + 'px solid transparent';
            }
            else {
                this.eFullWidthCellViewport.style.borderLeft = '';
            }
        }
        else {
            if (this.isVerticalScrollShowing()) {
                this.eFullWidthCellViewport.style.borderRight = this.scrollWidth + 'px solid transparent';
            }
            else {
                this.eFullWidthCellViewport.style.borderRight = '';
            }
        }
        if (this.isHorizontalScrollShowing()) {
            this.eFullWidthCellViewport.style.borderBottom = this.scrollWidth + 'px solid transparent';
        }
        else {
            this.eFullWidthCellViewport.style.borderBottom = '';
        }
    };
    GridPanel.prototype.ensureColumnVisible = function (key) {
        // if for print, everything is always visible
        if (this.gridOptionsWrapper.isForPrint()) {
            return;
        }
        var column = this.columnController.getGridColumn(key);
        if (!column) {
            return;
        }
        if (column.isPinned()) {
            console.warn('calling ensureIndexVisible on a ' + column.getPinned() + ' pinned column doesn\'t make sense for column ' + column.getColId());
            return;
        }
        if (!this.columnController.isColumnDisplayed(column)) {
            console.warn('column is not currently visible');
            return;
        }
        var colLeftPixel = column.getLeft();
        var colRightPixel = colLeftPixel + column.getActualWidth();
        var viewportWidth = this.eBodyViewport.clientWidth;
        var scrollPosition = this.getBodyViewportScrollLeft();
        var bodyWidth = this.columnController.getBodyContainerWidth();
        var viewportLeftPixel;
        var viewportRightPixel;
        // the logic of working out left and right viewport px is both here and in the ColumnController,
        // need to refactor it out to one place
        if (this.enableRtl) {
            viewportLeftPixel = bodyWidth - scrollPosition - viewportWidth;
            viewportRightPixel = bodyWidth - scrollPosition;
        }
        else {
            viewportLeftPixel = scrollPosition;
            viewportRightPixel = viewportWidth + scrollPosition;
        }
        var viewportScrolledPastCol = viewportLeftPixel > colLeftPixel;
        var viewportScrolledBeforeCol = viewportRightPixel < colRightPixel;
        var colToSmallForViewport = viewportWidth < column.getActualWidth();
        var alignColToLeft = viewportScrolledPastCol || colToSmallForViewport;
        var alignColToRight = viewportScrolledBeforeCol;
        if (alignColToLeft) {
            // if viewport's left side is after col's left side, scroll left to pull col into viewport at left
            if (this.enableRtl) {
                var newScrollPosition = bodyWidth - viewportWidth - colLeftPixel;
                this.setBodyViewportScrollLeft(newScrollPosition);
            }
            else {
                this.setBodyViewportScrollLeft(colLeftPixel);
            }
        }
        else if (alignColToRight) {
            // if viewport's right side is before col's right side, scroll right to pull col into viewport at right
            if (this.enableRtl) {
                var newScrollPosition = bodyWidth - colRightPixel;
                this.setBodyViewportScrollLeft(newScrollPosition);
            }
            else {
                var newScrollPosition = colRightPixel - viewportWidth;
                this.setBodyViewportScrollLeft(newScrollPosition);
            }
        }
        else {
            // otherwise, col is already in view, so do nothing
        }
        // this will happen anyway, as the move will cause a 'scroll' event on the body, however
        // it is possible that the ensureColumnVisible method is called from within ag-Grid and
        // the caller will need to have the columns rendered to continue, which will be before
        // the event has been worked on (which is the case for cell navigation).
        this.setLeftAndRightBounds();
    };
    GridPanel.prototype.showLoadingOverlay = function () {
        if (!this.gridOptionsWrapper.isSuppressLoadingOverlay()) {
            this.layout.showOverlay('loading');
        }
    };
    GridPanel.prototype.showNoRowsOverlay = function () {
        if (!this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
            this.layout.showOverlay('noRows');
        }
    };
    GridPanel.prototype.hideOverlay = function () {
        this.layout.hideOverlay();
    };
    GridPanel.prototype.getWidthForSizeColsToFit = function () {
        var availableWidth = this.eBody.clientWidth;
        // if pinning right, then the scroll bar can show, however for some reason
        // it overlays the grid and doesn't take space. so we are only interested
        // in the body scroll showing.
        var removeVerticalScrollWidth = this.isVerticalScrollShowing();
        if (removeVerticalScrollWidth) {
            availableWidth -= this.scrollWidth;
        }
        return availableWidth;
    };
    // method will call itself if no available width. this covers if the grid
    // isn't visible, but is just about to be visible.
    GridPanel.prototype.sizeColumnsToFit = function (nextTimeout) {
        var _this = this;
        var availableWidth = this.getWidthForSizeColsToFit();
        if (availableWidth > 0) {
            this.columnController.sizeColumnsToFit(availableWidth);
        }
        else {
            if (nextTimeout === undefined) {
                setTimeout(function () {
                    _this.sizeColumnsToFit(100);
                }, 0);
            }
            else if (nextTimeout === 100) {
                setTimeout(function () {
                    _this.sizeColumnsToFit(500);
                }, 100);
            }
            else if (nextTimeout === 500) {
                setTimeout(function () {
                    _this.sizeColumnsToFit(-1);
                }, 500);
            }
            else {
                console.log('ag-Grid: tried to call sizeColumnsToFit() but the grid is coming back with ' +
                    'zero width, maybe the grid is not visible yet on the screen?');
            }
        }
    };
    GridPanel.prototype.getBodyContainer = function () {
        return this.eBodyContainer;
    };
    GridPanel.prototype.getDropTargetBodyContainers = function () {
        if (this.forPrint) {
            return [this.eBodyContainer, this.eFloatingTopContainer, this.eFloatingBottomContainer];
        }
        else {
            return [this.eBodyViewport, this.eFloatingTopViewport, this.eFloatingBottomViewport];
        }
    };
    GridPanel.prototype.getBodyViewport = function () {
        return this.eBodyViewport;
    };
    GridPanel.prototype.getDropTargetLeftContainers = function () {
        if (this.forPrint) {
            return [];
        }
        else {
            return [this.ePinnedLeftColsViewport, this.ePinnedLeftFloatingBottom, this.ePinnedLeftFloatingTop];
        }
    };
    GridPanel.prototype.getDropTargetPinnedRightContainers = function () {
        if (this.forPrint) {
            return [];
        }
        else {
            return [this.ePinnedRightColsViewport, this.ePinnedRightFloatingBottom, this.ePinnedRightFloatingTop];
        }
    };
    GridPanel.prototype.getHeaderContainer = function () {
        return this.eHeaderContainer;
    };
    GridPanel.prototype.getHeaderOverlay = function () {
        return this.eHeaderOverlay;
    };
    GridPanel.prototype.getRoot = function () {
        return this.eRoot;
    };
    GridPanel.prototype.getPinnedLeftHeader = function () {
        return this.ePinnedLeftHeader;
    };
    GridPanel.prototype.getPinnedRightHeader = function () {
        return this.ePinnedRightHeader;
    };
    GridPanel.prototype.queryHtmlElement = function (selector) {
        return this.eRoot.querySelector(selector);
    };
    GridPanel.prototype.loadTemplate = function () {
        // the template we use is different when doing 'for print'
        var template;
        if (this.forPrint) {
            template = GRID_PANEL_FOR_PRINT_TEMPLATE;
        }
        else if (this.autoHeight) {
            template = GRID_PANEL_AUTO_HEIGHT_TEMPLATE;
        }
        else {
            template = GRID_PANEL_NORMAL_TEMPLATE;
        }
        this.eRoot = utils_1.Utils.loadTemplate(template);
    };
    GridPanel.prototype.findElements = function () {
        var _this = this;
        if (this.forPrint) {
            this.eHeaderContainer = this.queryHtmlElement('.ag-header-container');
            this.eBodyContainer = this.queryHtmlElement('.ag-body-container');
            this.eFloatingTopContainer = this.queryHtmlElement('.ag-floating-top-container');
            this.eFloatingBottomContainer = this.queryHtmlElement('.ag-floating-bottom-container');
            this.eAllCellContainers = [this.eBodyContainer, this.eFloatingTopContainer, this.eFloatingBottomContainer];
            var containers = {
                body: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eBodyContainer }),
                fullWidth: null,
                pinnedLeft: null,
                pinnedRight: null,
                floatingTop: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eFloatingTopContainer }),
                floatingTopPinnedLeft: null,
                floatingTopPinnedRight: null,
                floatingTopFullWidth: null,
                floatingBottom: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eFloatingBottomContainer }),
                floatingBottomPinnedLeft: null,
                floatingBottomPinnedRight: null,
                floatingBottomFullWith: null
            };
            this.rowContainerComponents = containers;
            // when doing forPrint, we don't have any fullWidth containers, instead we add directly to the main
            // containers. this works in forPrint only as there are no pinned columns (no need for fullWidth to
            // span pinned columns) and the rows are already the full width of the grid (the reason for fullWidth)
            containers.fullWidth = containers.body;
            containers.floatingBottomFullWith = containers.floatingBottom;
            containers.floatingTopFullWidth = containers.floatingTop;
        }
        else {
            this.eBody = this.queryHtmlElement('.ag-body');
            this.eBodyContainer = this.queryHtmlElement('.ag-body-container');
            this.eBodyViewport = this.queryHtmlElement('.ag-body-viewport');
            this.eBodyViewportWrapper = this.queryHtmlElement('.ag-body-viewport-wrapper');
            this.eFullWidthCellContainer = this.queryHtmlElement('.ag-full-width-container');
            this.eFullWidthCellViewport = this.queryHtmlElement('.ag-full-width-viewport');
            this.ePinnedLeftColsContainer = this.queryHtmlElement('.ag-pinned-left-cols-container');
            this.ePinnedRightColsContainer = this.queryHtmlElement('.ag-pinned-right-cols-container');
            this.ePinnedLeftColsViewport = this.queryHtmlElement('.ag-pinned-left-cols-viewport');
            this.ePinnedRightColsViewport = this.queryHtmlElement('.ag-pinned-right-cols-viewport');
            this.ePinnedLeftHeader = this.queryHtmlElement('.ag-pinned-left-header');
            this.ePinnedRightHeader = this.queryHtmlElement('.ag-pinned-right-header');
            this.eHeader = this.queryHtmlElement('.ag-header');
            this.eHeaderContainer = this.queryHtmlElement('.ag-header-container');
            this.eHeaderOverlay = this.queryHtmlElement('.ag-header-overlay');
            this.eHeaderViewport = this.queryHtmlElement('.ag-header-viewport');
            this.eFloatingTop = this.queryHtmlElement('.ag-floating-top');
            this.ePinnedLeftFloatingTop = this.queryHtmlElement('.ag-pinned-left-floating-top');
            this.ePinnedRightFloatingTop = this.queryHtmlElement('.ag-pinned-right-floating-top');
            this.eFloatingTopContainer = this.queryHtmlElement('.ag-floating-top-container');
            this.eFloatingTopViewport = this.queryHtmlElement('.ag-floating-top-viewport');
            this.eFloatingTopFullWidthCellContainer = this.queryHtmlElement('.ag-floating-top-full-width-container');
            this.eFloatingBottom = this.queryHtmlElement('.ag-floating-bottom');
            this.ePinnedLeftFloatingBottom = this.queryHtmlElement('.ag-pinned-left-floating-bottom');
            this.ePinnedRightFloatingBottom = this.queryHtmlElement('.ag-pinned-right-floating-bottom');
            this.eFloatingBottomContainer = this.queryHtmlElement('.ag-floating-bottom-container');
            this.eFloatingBottomViewport = this.queryHtmlElement('.ag-floating-bottom-viewport');
            this.eFloatingBottomFullWidthCellContainer = this.queryHtmlElement('.ag-floating-bottom-full-width-container');
            this.eAllCellContainers = [
                this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, this.eBodyContainer,
                this.eFloatingTop, this.eFloatingBottom, this.eFullWidthCellContainer
            ];
            this.rowContainerComponents = {
                body: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eBodyContainer, eViewport: this.eBodyViewport }),
                fullWidth: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eFullWidthCellContainer, hideWhenNoChildren: true, eViewport: this.eFullWidthCellViewport }),
                pinnedLeft: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.ePinnedLeftColsContainer, eViewport: this.ePinnedLeftColsViewport }),
                pinnedRight: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.ePinnedRightColsContainer, eViewport: this.ePinnedRightColsViewport }),
                floatingTop: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eFloatingTopContainer }),
                floatingTopPinnedLeft: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.ePinnedLeftFloatingTop }),
                floatingTopPinnedRight: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.ePinnedRightFloatingTop }),
                floatingTopFullWidth: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eFloatingTopFullWidthCellContainer, hideWhenNoChildren: true }),
                floatingBottom: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eFloatingBottomContainer }),
                floatingBottomPinnedLeft: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.ePinnedLeftFloatingBottom }),
                floatingBottomPinnedRight: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.ePinnedRightFloatingBottom }),
                floatingBottomFullWith: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eFloatingBottomFullWidthCellContainer, hideWhenNoChildren: true }),
            };
            this.addMouseWheelEventListeners();
        }
        utils_1.Utils.iterateObject(this.rowContainerComponents, function (key, container) {
            if (container) {
                _this.context.wireBean(container);
            }
        });
    };
    GridPanel.prototype.getRowContainers = function () {
        return this.rowContainerComponents;
    };
    GridPanel.prototype.addMouseWheelEventListeners = function () {
        // IE9, Chrome, Safari, Opera use 'mousewheel', Firefox uses 'DOMMouseScroll'
        this.addDestroyableEventListener(this.eBodyViewport, 'mousewheel', this.centerMouseWheelListener.bind(this));
        this.addDestroyableEventListener(this.eBodyViewport, 'DOMMouseScroll', this.centerMouseWheelListener.bind(this));
        if (this.enableRtl) {
            this.addDestroyableEventListener(this.ePinnedRightColsViewport, 'mousewheel', this.genericMouseWheelListener.bind(this));
            this.addDestroyableEventListener(this.ePinnedRightColsViewport, 'DOMMouseScroll', this.genericMouseWheelListener.bind(this));
        }
        else {
            this.addDestroyableEventListener(this.ePinnedLeftColsViewport, 'mousewheel', this.genericMouseWheelListener.bind(this));
            this.addDestroyableEventListener(this.ePinnedLeftColsViewport, 'DOMMouseScroll', this.genericMouseWheelListener.bind(this));
        }
    };
    GridPanel.prototype.getHeaderViewport = function () {
        return this.eHeaderViewport;
    };
    GridPanel.prototype.centerMouseWheelListener = function (event) {
        // we are only interested in mimicking the mouse wheel if we are not scrolling on the middle,
        // otherwise the body has scrolls and the mouse wheel works for free
        var bodyVScrollShowing = this.isBodyVerticalScrollActive();
        if (!bodyVScrollShowing) {
            var targetPanel = this.enableRtl ? this.ePinnedLeftColsViewport : this.ePinnedRightColsViewport;
            return this.generalMouseWheelListener(event, targetPanel);
        }
    };
    // used for listening to mouse wheel events on 1) left pinned and also the 2) fullWidthCell components.
    // the fullWidthCell listener is added in renderedRow, hence public.
    GridPanel.prototype.genericMouseWheelListener = function (event) {
        var targetPanel;
        var bodyVScrollActive = this.isBodyVerticalScrollActive();
        if (bodyVScrollActive) {
            targetPanel = this.eBodyViewport;
        }
        else {
            targetPanel = this.enableRtl ? this.ePinnedLeftColsViewport : this.ePinnedRightColsViewport;
        }
        return this.generalMouseWheelListener(event, targetPanel);
    };
    GridPanel.prototype.generalMouseWheelListener = function (event, targetPanel) {
        var wheelEvent = utils_1.Utils.normalizeWheel(event);
        // we need to detect in which direction scroll is happening to allow trackpads scroll horizontally
        // horizontal scroll
        if (Math.abs(wheelEvent.pixelX) > Math.abs(wheelEvent.pixelY)) {
            var newLeftPosition = this.eBodyViewport.scrollLeft + wheelEvent.pixelX;
            this.eBodyViewport.scrollLeft = newLeftPosition;
        }
        else {
            var newTopPosition = targetPanel.scrollTop + wheelEvent.pixelY;
            targetPanel.scrollTop = newTopPosition;
        }
        // allow the option to pass mouse wheel events to the browser
        // https://github.com/ag-grid/ag-grid/issues/800
        // in the future, this should be tied in with 'forPrint' option, or have an option 'no vertical scrolls'
        if (!this.gridOptionsWrapper.isSuppressPreventDefaultOnMouseWheel()) {
            // if we don't prevent default, then the whole browser will scroll also as well as the grid
            event.preventDefault();
        }
        return false;
    };
    GridPanel.prototype.onDisplayedColumnsChanged = function () {
        this.setPinnedContainersVisible();
        this.setBodyAndHeaderHeights();
        this.setLeftAndRightBounds();
    };
    GridPanel.prototype.onDisplayedColumnsWidthChanged = function () {
        this.setWidthsOfContainers();
        this.setLeftAndRightBounds();
        if (this.enableRtl) {
            // because RTL is all backwards, a change in the width of the row
            // can cause a change in the scroll position, without a scroll event,
            // because the scroll position in RTL is a function that depends on
            // the width. to be convinced of this, take out this line, enable RTL,
            // scroll all the way to the left and then resize a column
            this.horizontallyScrollHeaderCenterAndFloatingCenter();
        }
    };
    GridPanel.prototype.onScrollVisibilityChanged = function () {
        this.setWidthsOfContainers();
    };
    GridPanel.prototype.setWidthsOfContainers = function () {
        var mainRowWidth = this.columnController.getBodyContainerWidth() + 'px';
        this.eBodyContainer.style.width = mainRowWidth;
        if (this.forPrint) {
            // pinned col doesn't exist when doing forPrint
            return;
        }
        this.eFloatingBottomContainer.style.width = mainRowWidth;
        this.eFloatingTopContainer.style.width = mainRowWidth;
        this.setPinnedLeftWidth();
        this.setPinnedRightWidth();
    };
    GridPanel.prototype.setPinnedLeftWidth = function () {
        var pinnedLeftWidth = this.scrollVisibleService.getPinnedLeftWidth() + 'px';
        var pinnedLeftWidthWithScroll = this.scrollVisibleService.getPinnedLeftWithScrollWidth() + 'px';
        this.ePinnedLeftColsViewport.style.width = pinnedLeftWidthWithScroll;
        this.eBodyViewportWrapper.style.marginLeft = pinnedLeftWidthWithScroll;
        this.ePinnedLeftFloatingBottom.style.width = pinnedLeftWidthWithScroll;
        this.ePinnedLeftFloatingTop.style.width = pinnedLeftWidthWithScroll;
        this.ePinnedLeftColsContainer.style.width = pinnedLeftWidth;
    };
    GridPanel.prototype.setPinnedRightWidth = function () {
        var pinnedRightWidth = this.scrollVisibleService.getPinnedRightWidth() + 'px';
        var pinnedRightWidthWithScroll = this.scrollVisibleService.getPinnedRightWithScrollWidth() + 'px';
        this.ePinnedRightColsViewport.style.width = pinnedRightWidthWithScroll;
        this.eBodyViewportWrapper.style.marginRight = pinnedRightWidthWithScroll;
        this.ePinnedRightFloatingBottom.style.width = pinnedRightWidthWithScroll;
        this.ePinnedRightFloatingTop.style.width = pinnedRightWidthWithScroll;
        this.ePinnedRightColsContainer.style.width = pinnedRightWidth;
    };
    GridPanel.prototype.setPinnedContainersVisible = function () {
        // no need to do this if not using scrolls
        if (this.forPrint) {
            return;
        }
        var changeDetected = false;
        // if we are v scrolling, then one of these will have the scroll position.
        // we us this inside the if(changedDetected), so we don't always use it, however
        // it is changed when we make a pinned panel not visible, so we have to check it
        // before we change display on the pinned panels
        var scrollTop = Math.max(this.eBodyViewport.scrollTop, this.ePinnedLeftColsViewport.scrollTop, this.ePinnedRightColsViewport.scrollTop);
        var showLeftPinned = this.columnController.isPinningLeft();
        if (showLeftPinned !== this.pinningLeft) {
            this.pinningLeft = showLeftPinned;
            this.ePinnedLeftHeader.style.display = showLeftPinned ? 'inline-block' : 'none';
            this.ePinnedLeftColsViewport.style.display = showLeftPinned ? 'inline' : 'none';
            changeDetected = true;
        }
        var showRightPinned = this.columnController.isPinningRight();
        if (showRightPinned !== this.pinningRight) {
            this.pinningRight = showRightPinned;
            this.ePinnedRightHeader.style.display = showRightPinned ? 'inline-block' : 'none';
            this.ePinnedRightColsViewport.style.display = showRightPinned ? 'inline' : 'none';
            changeDetected = true;
        }
        if (changeDetected) {
            var bodyVScrollActive = this.isBodyVerticalScrollActive();
            this.eBodyViewport.style.overflowY = bodyVScrollActive ? 'auto' : 'hidden';
            // the body either uses it's scroll (when scrolling) or it's style.top
            // (when following the scroll of a pinned section), so we need to set it
            // back when changing from one to the other
            if (bodyVScrollActive) {
                this.setFakeScroll(this.eBodyContainer, 0);
                // this.eBodyContainer.style.top = '0px';
            }
            else {
                this.eBodyViewport.scrollTop = 0;
            }
            // when changing the primary scroll viewport, we copy over the scroll position,
            // eg if body was getting scrolled and we were at position 100px, then we start
            // pinning and pinned viewport is now the primary, we need to set it to 100px
            var primaryScrollViewport = this.getPrimaryScrollViewport();
            primaryScrollViewport.scrollTop = scrollTop;
            // this adjusts the scroll position of all the faking panels. they should already
            // be correct except body which has potentially just turned to be fake.
            this.fakeVerticalScroll(scrollTop);
        }
    };
    // init, layoutChanged, floatingDataChanged, headerHeightChanged
    GridPanel.prototype.setBodyAndHeaderHeights = function () {
        if (this.forPrint) {
            // if doing 'for print' or 'auto height', then the header and footers are laid
            // out naturally by the browser. it's whatever height that's needed to fit.
            return;
        }
        var heightOfContainer = this.layout.getCentreHeight();
        if (!heightOfContainer) {
            return;
        }
        var headerRowCount = this.columnController.getHeaderRowCount();
        var totalHeaderHeight;
        var numberOfFloating = 0;
        var groupHeight;
        var headerHeight;
        if (!this.columnController.isPivotMode()) {
            utils_1.Utils.removeCssClass(this.eHeader, 'ag-pivot-on');
            utils_1.Utils.addCssClass(this.eHeader, 'ag-pivot-off');
            if (this.gridOptionsWrapper.isFloatingFilter()) {
                headerRowCount++;
            }
            numberOfFloating = (this.gridOptionsWrapper.isFloatingFilter()) ? 1 : 0;
            groupHeight = this.gridOptionsWrapper.getGroupHeaderHeight();
            headerHeight = this.gridOptionsWrapper.getHeaderHeight();
        }
        else {
            utils_1.Utils.removeCssClass(this.eHeader, 'ag-pivot-off');
            utils_1.Utils.addCssClass(this.eHeader, 'ag-pivot-on');
            numberOfFloating = 0;
            groupHeight = this.gridOptionsWrapper.getPivotGroupHeaderHeight();
            headerHeight = this.gridOptionsWrapper.getPivotHeaderHeight();
        }
        var numberOfNonGroups = 1 + numberOfFloating;
        var numberOfGroups = headerRowCount - numberOfNonGroups;
        totalHeaderHeight = numberOfFloating * this.gridOptionsWrapper.getFloatingFiltersHeight();
        totalHeaderHeight += numberOfGroups * groupHeight;
        totalHeaderHeight += headerHeight;
        this.eHeader.style['height'] = totalHeaderHeight + 'px';
        // if we are doing auto-height, we only size the header, we don't size the
        // other parts as we use the normal browser layout for that
        if (this.autoHeight) {
            return;
        }
        // padding top covers the header and the pinned rows on top
        var floatingTopHeight = this.pinnedRowModel.getPinnedTopTotalHeight();
        var paddingTop = totalHeaderHeight + floatingTopHeight;
        // bottom is just the bottom pinned rows
        var floatingBottomHeight = this.pinnedRowModel.getPinnedBottomTotalHeight();
        var floatingBottomTop = heightOfContainer - floatingBottomHeight;
        var bodyHeight = heightOfContainer - totalHeaderHeight - floatingBottomHeight - floatingTopHeight;
        this.eBody.style.top = paddingTop + 'px';
        this.eBody.style.height = bodyHeight + 'px';
        this.eFloatingTop.style.top = totalHeaderHeight + 'px';
        this.eFloatingTop.style.height = floatingTopHeight + 'px';
        this.eFloatingBottom.style.height = floatingBottomHeight + 'px';
        this.eFloatingBottom.style.top = floatingBottomTop + 'px';
        this.ePinnedLeftColsViewport.style.height = bodyHeight + 'px';
        this.ePinnedRightColsViewport.style.height = bodyHeight + 'px';
        // bodyHeight property is used by pagination service, that may change number of rows
        // in this page based on the height of the grid
        if (this.bodyHeight !== bodyHeight) {
            this.bodyHeight = bodyHeight;
            var event_1 = {
                type: events_1.Events.EVENT_BODY_HEIGHT_CHANGED,
                api: this.gridApi,
                columnApi: this.columnApi
            };
            this.eventService.dispatchEvent(event_1);
        }
    };
    GridPanel.prototype.getBodyHeight = function () {
        return this.bodyHeight;
    };
    GridPanel.prototype.setHorizontalScrollPosition = function (hScrollPosition) {
        this.eBodyViewport.scrollLeft = hScrollPosition;
        // we need to manually do the event handling (rather than wait for the event)
        // for the alignedGridsService, as if we don't, the aligned grid service gets
        // notified async, and then it's 'consuming' flag doesn't get used right, and
        // we can end up with an infinite loop
        if (this.nextScrollLeft !== hScrollPosition) {
            this.nextScrollLeft = hScrollPosition;
            this.doHorizontalScroll();
        }
    };
    // tries to scroll by pixels, but returns what the result actually was
    GridPanel.prototype.scrollHorizontally = function (pixels) {
        var oldScrollPosition = this.eBodyViewport.scrollLeft;
        this.setHorizontalScrollPosition(oldScrollPosition + pixels);
        var newScrollPosition = this.eBodyViewport.scrollLeft;
        return newScrollPosition - oldScrollPosition;
    };
    GridPanel.prototype.addScrollListener = function () {
        var _this = this;
        // if printing, then no scrolling, so no point in listening for scroll events
        if (this.forPrint) {
            return;
        }
        this.addDestroyableEventListener(this.eBodyViewport, 'scroll', this.onBodyScroll.bind(this));
        // below we add two things:
        // pinnedScrollListener -> when pinned panel with scrollbar gets scrolled, it updates body and other pinned
        // suppressScroll -> stops scrolling when pinned panel was moved - which can only happen when user is navigating
        //     in the pinned container, as the pinned col should never scroll. so we rollback the scroll on the pinned.
        var onPinnedLeftVerticalScroll = this.onVerticalScroll.bind(this, this.ePinnedLeftColsViewport);
        var onPinnedRightVerticalScroll = this.onVerticalScroll.bind(this, this.ePinnedRightColsViewport);
        if (this.enableRtl) {
            this.addDestroyableEventListener(this.ePinnedLeftColsViewport, 'scroll', onPinnedLeftVerticalScroll);
            var suppressRightScroll = function () { return _this.ePinnedRightColsViewport.scrollTop = 0; };
            this.addDestroyableEventListener(this.ePinnedRightColsViewport, 'scroll', suppressRightScroll);
        }
        else {
            this.addDestroyableEventListener(this.ePinnedRightColsViewport, 'scroll', onPinnedRightVerticalScroll);
            var suppressLeftScroll = function () { return _this.ePinnedLeftColsViewport.scrollTop = 0; };
            this.addDestroyableEventListener(this.ePinnedLeftColsViewport, 'scroll', suppressLeftScroll);
        }
        var suppressCenterScroll = function () {
            if (_this.getPrimaryScrollViewport() !== _this.eBodyViewport) {
                _this.eBodyViewport.scrollTop = 0;
            }
        };
        this.addDestroyableEventListener(this.eBodyViewport, 'scroll', suppressCenterScroll);
        this.addIEPinFix(onPinnedRightVerticalScroll, onPinnedLeftVerticalScroll);
    };
    GridPanel.prototype.onBodyScroll = function () {
        this.onBodyHorizontalScroll();
        this.onBodyVerticalScroll();
    };
    GridPanel.prototype.onBodyHorizontalScroll = function () {
        var scrollLeft = this.eBodyViewport.scrollLeft;
        if (this.nextScrollLeft !== scrollLeft) {
            this.nextScrollLeft = scrollLeft;
            if (this.useAnimationFrame) {
                this.animationFrameService.schedule();
            }
            else {
                this.doHorizontalScroll();
            }
        }
    };
    GridPanel.prototype.doHorizontalScroll = function () {
        this.scrollLeft = this.nextScrollLeft;
        var event = {
            type: events_1.Events.EVENT_BODY_SCROLL,
            api: this.gridApi,
            columnApi: this.columnApi,
            direction: 'horizontal',
            left: this.scrollLeft,
            top: this.scrollTop
        };
        this.eventService.dispatchEvent(event);
        this.horizontallyScrollHeaderCenterAndFloatingCenter();
        this.setLeftAndRightBounds();
        // this.alignedGridsService.fireHorizontalScrollEvent(this.scrollLeft);
    };
    GridPanel.prototype.onBodyVerticalScroll = function () {
        var bodyVScrollActive = this.isBodyVerticalScrollActive();
        if (bodyVScrollActive) {
            this.onVerticalScroll(this.eBodyViewport);
        }
    };
    GridPanel.prototype.onVerticalScroll = function (sourceElement) {
        var scrollTop = sourceElement.scrollTop;
        if (this.useAnimationFrame) {
            if (this.nextScrollTop !== scrollTop) {
                this.nextScrollTop = scrollTop;
                this.animationFrameService.schedule();
            }
        }
        else {
            if (scrollTop !== this.scrollTop) {
                this.scrollTop = scrollTop;
                this.fakeVerticalScroll(scrollTop);
                this.redrawRowsAfterScroll();
            }
        }
    };
    GridPanel.prototype.executeFrame = function () {
        if (this.scrollLeft !== this.nextScrollLeft) {
            this.doHorizontalScroll();
            return true;
        }
        else if (this.scrollTop !== this.nextScrollTop) {
            this.scrollTop = this.nextScrollTop;
            this.fakeVerticalScroll(this.scrollTop);
            this.verticalRedrawNeeded = true;
            return true;
        }
        else if (this.verticalRedrawNeeded) {
            this.redrawRowsAfterScroll();
            this.verticalRedrawNeeded = false;
            return true;
        }
        else {
            return false;
        }
    };
    GridPanel.prototype.redrawRowsAfterScroll = function () {
        var event = {
            type: events_1.Events.EVENT_BODY_SCROLL,
            direction: 'vertical',
            api: this.gridApi,
            columnApi: this.columnApi,
            left: this.scrollLeft,
            top: this.scrollTop
        };
        this.eventService.dispatchEvent(event);
        this.rowRenderer.redrawAfterScroll();
    };
    // if LTR, we hide body scroll if pinning right (as scroll is in right pinned),
    // if RTL, we hide body scroll if pinning left (as scroll is in left pinned)
    GridPanel.prototype.isBodyVerticalScrollActive = function () {
        var pinningRight = this.columnController.isPinningRight();
        var pinningLeft = this.columnController.isPinningLeft();
        var centerHasScroll = this.enableRtl ? !pinningLeft : !pinningRight;
        return centerHasScroll;
    };
    // this bit is a fix / hack for IE due to this:
    // https://www.ag-grid.com/forum/showthread.php?tid=4303
    // it gets the left panel to reposition itself after a model change
    GridPanel.prototype.addIEPinFix = function (onPinnedRightScroll, onPinnedLeftScroll) {
        var _this = this;
        var listener = function () {
            if (_this.columnController.isPinningRight()) {
                setTimeout(function () {
                    if (_this.enableRtl) {
                        onPinnedLeftScroll();
                    }
                    else {
                        onPinnedRightScroll();
                    }
                }, 0);
            }
        };
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_MODEL_UPDATED, listener);
    };
    // this gets called whenever a change in the viewport, so we can inform column controller it has to work
    // out the virtual columns again. gets called from following locations:
    // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
    GridPanel.prototype.setLeftAndRightBounds = function () {
        if (this.gridOptionsWrapper.isForPrint()) {
            return;
        }
        var scrollWidth = this.eBodyViewport.clientWidth;
        var scrollPosition = this.getBodyViewportScrollLeft();
        this.columnController.setVirtualViewportPosition(scrollWidth, scrollPosition);
    };
    GridPanel.prototype.getBodyViewportScrollLeft = function () {
        if (this.forPrint) {
            return 0;
        }
        // we defer to a util, as how you calculated scrollLeft when doing RTL depends on the browser
        return utils_1.Utils.getScrollLeft(this.eBodyViewport, this.enableRtl);
    };
    GridPanel.prototype.setBodyViewportScrollLeft = function (value) {
        if (this.forPrint) {
            return;
        }
        // we defer to a util, as how you calculated scrollLeft when doing RTL depends on the browser
        utils_1.Utils.setScrollLeft(this.eBodyViewport, value, this.enableRtl);
    };
    GridPanel.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function () {
        var scrollLeft = this.getBodyViewportScrollLeft();
        var offset = this.enableRtl ? scrollLeft : -scrollLeft;
        this.eHeaderContainer.style.left = offset + 'px';
        this.eFloatingBottomContainer.style.left = offset + 'px';
        this.eFloatingTopContainer.style.left = offset + 'px';
    };
    // we say fake scroll as only one panel (left, right or body) has scrolls,
    // the other panels mimic the scroll by getting it's top position updated.
    GridPanel.prototype.fakeVerticalScroll = function (position) {
        if (this.enableRtl) {
            // RTL
            // if pinning left, then body scroll is faking
            var pinningLeft = this.columnController.isPinningLeft();
            if (pinningLeft) {
                this.setFakeScroll(this.eBodyContainer, position);
            }
            // right is always faking
            this.setFakeScroll(this.ePinnedRightColsContainer, position);
        }
        else {
            // LTR
            // if pinning right, then body scroll is faking
            var pinningRight = this.columnController.isPinningRight();
            if (pinningRight) {
                this.setFakeScroll(this.eBodyContainer, position);
            }
            // left is always faking
            this.setFakeScroll(this.ePinnedLeftColsContainer, position);
        }
        // always scroll fullWidth container, as this is never responsible for a scroll
        this.setFakeScroll(this.eFullWidthCellContainer, position);
    };
    GridPanel.prototype.setFakeScroll = function (eContainer, pixels) {
        eContainer.style.top = -pixels + 'px';
        // eContainer.style.transform = `translateY(${-pixels}px)`;
    };
    GridPanel.prototype.addScrollEventListener = function (listener) {
        this.eBodyViewport.addEventListener('scroll', listener);
    };
    GridPanel.prototype.removeScrollEventListener = function (listener) {
        this.eBodyViewport.removeEventListener('scroll', listener);
    };
    __decorate([
        context_1.Autowired('alignedGridsService'),
        __metadata("design:type", alignedGridsService_1.AlignedGridsService)
    ], GridPanel.prototype, "alignedGridsService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], GridPanel.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], GridPanel.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'),
        __metadata("design:type", rowRenderer_1.RowRenderer)
    ], GridPanel.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('pinnedRowModel'),
        __metadata("design:type", pinnedRowModel_1.PinnedRowModel)
    ], GridPanel.prototype, "pinnedRowModel", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], GridPanel.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], GridPanel.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('animationFrameService'),
        __metadata("design:type", animationFrameService_1.AnimationFrameService)
    ], GridPanel.prototype, "animationFrameService", void 0);
    __decorate([
        context_1.Autowired('navigationService'),
        __metadata("design:type", navigationService_1.NavigationService)
    ], GridPanel.prototype, "navigationService", void 0);
    __decorate([
        context_1.Autowired('paginationProxy'),
        __metadata("design:type", paginationProxy_1.PaginationProxy)
    ], GridPanel.prototype, "paginationProxy", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], GridPanel.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], GridPanel.prototype, "gridApi", void 0);
    __decorate([
        context_1.Optional('rangeController'),
        __metadata("design:type", Object)
    ], GridPanel.prototype, "rangeController", void 0);
    __decorate([
        context_1.Autowired('dragService'),
        __metadata("design:type", dragService_1.DragService)
    ], GridPanel.prototype, "dragService", void 0);
    __decorate([
        context_1.Autowired('selectionController'),
        __metadata("design:type", selectionController_1.SelectionController)
    ], GridPanel.prototype, "selectionController", void 0);
    __decorate([
        context_1.Optional('clipboardService'),
        __metadata("design:type", Object)
    ], GridPanel.prototype, "clipboardService", void 0);
    __decorate([
        context_1.Autowired('csvCreator'),
        __metadata("design:type", csvCreator_1.CsvCreator)
    ], GridPanel.prototype, "csvCreator", void 0);
    __decorate([
        context_1.Autowired('mouseEventService'),
        __metadata("design:type", mouseEventService_1.MouseEventService)
    ], GridPanel.prototype, "mouseEventService", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'),
        __metadata("design:type", focusedCellController_1.FocusedCellController)
    ], GridPanel.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Autowired('$scope'),
        __metadata("design:type", Object)
    ], GridPanel.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('scrollVisibleService'),
        __metadata("design:type", scrollVisibleService_1.ScrollVisibleService)
    ], GridPanel.prototype, "scrollVisibleService", void 0);
    __decorate([
        context_1.Optional('contextMenuFactory'),
        __metadata("design:type", Object)
    ], GridPanel.prototype, "contextMenuFactory", void 0);
    __decorate([
        context_1.Autowired('frameworkFactory'),
        __metadata("design:type", Object)
    ], GridPanel.prototype, "frameworkFactory", void 0);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], GridPanel.prototype, "agWire", null);
    __decorate([
        context_1.PreDestroy,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], GridPanel.prototype, "destroy", null);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], GridPanel.prototype, "init", null);
    GridPanel = __decorate([
        context_1.Bean('gridPanel')
    ], GridPanel);
    return GridPanel;
}(beanStub_1.BeanStub));
exports.GridPanel = GridPanel;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var context_1 = __webpack_require__(0);
var context_2 = __webpack_require__(0);
var LoggerFactory = (function () {
    function LoggerFactory() {
    }
    LoggerFactory.prototype.setBeans = function (gridOptionsWrapper) {
        this.logging = gridOptionsWrapper.isDebug();
    };
    LoggerFactory.prototype.create = function (name) {
        return new Logger(name, this.isLogging.bind(this));
    };
    LoggerFactory.prototype.isLogging = function () {
        return this.logging;
    };
    __decorate([
        __param(0, context_2.Qualifier('gridOptionsWrapper')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [gridOptionsWrapper_1.GridOptionsWrapper]),
        __metadata("design:returntype", void 0)
    ], LoggerFactory.prototype, "setBeans", null);
    LoggerFactory = __decorate([
        context_1.Bean('loggerFactory')
    ], LoggerFactory);
    return LoggerFactory;
}());
exports.LoggerFactory = LoggerFactory;
var Logger = (function () {
    function Logger(name, isLoggingFunc) {
        this.name = name;
        this.isLoggingFunc = isLoggingFunc;
    }
    Logger.prototype.isLogging = function () {
        return this.isLoggingFunc();
    };
    Logger.prototype.log = function (message) {
        if (this.isLoggingFunc()) {
            console.log('ag-Grid.' + this.name + ': ' + message);
        }
    };
    return Logger;
}());
exports.Logger = Logger;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
function QuerySelector(selector) {
    return querySelectorFunc.bind(this, selector);
}
exports.QuerySelector = QuerySelector;
function RefSelector(ref) {
    return querySelectorFunc.bind(this, '[ref=' + ref + ']');
}
exports.RefSelector = RefSelector;
function querySelectorFunc(selector, classPrototype, methodOrAttributeName, index) {
    if (selector === null) {
        console.error('ag-Grid: QuerySelector selector should not be null');
        return;
    }
    if (typeof index === 'number') {
        console.error('ag-Grid: QuerySelector should be on an attribute');
        return;
    }
    // it's an attribute on the class
    var props = getOrCreateProps(classPrototype, classPrototype.constructor.name);
    if (!props.querySelectors) {
        props.querySelectors = [];
    }
    props.querySelectors.push({
        attributeName: methodOrAttributeName,
        querySelector: selector
    });
}
function Listener(eventName) {
    return listenerFunc.bind(this, eventName);
}
exports.Listener = Listener;
function listenerFunc(eventName, target, methodName, descriptor) {
    if (eventName === null) {
        console.error('ag-Grid: EventListener eventName should not be null');
        return;
    }
    // it's an attribute on the class
    var props = getOrCreateProps(target, target.constructor.name);
    if (!props.listenerMethods) {
        props.listenerMethods = [];
    }
    props.listenerMethods.push({
        methodName: methodName,
        eventName: eventName
    });
}
function getOrCreateProps(target, instanceName) {
    if (!target.__agComponentMetaData) {
        target.__agComponentMetaData = {};
    }
    if (!target.__agComponentMetaData[instanceName]) {
        target.__agComponentMetaData[instanceName] = {};
    }
    return target.__agComponentMetaData[instanceName];
}


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var eventService_1 = __webpack_require__(4);
var gridOptionsWrapper_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(1);
var BeanStub = (function () {
    function BeanStub() {
        this.destroyFunctions = [];
        this.destroyed = false;
    }
    BeanStub.prototype.destroy = function () {
        this.destroyFunctions.forEach(function (func) { return func(); });
        this.destroyFunctions.length = 0;
        this.destroyed = true;
    };
    BeanStub.prototype.addEventListener = function (eventType, listener) {
        if (!this.localEventService) {
            this.localEventService = new eventService_1.EventService();
        }
        this.localEventService.addEventListener(eventType, listener);
    };
    BeanStub.prototype.removeEventListener = function (eventType, listener) {
        if (this.localEventService) {
            this.localEventService.removeEventListener(eventType, listener);
        }
    };
    BeanStub.prototype.dispatchEventAsync = function (event) {
        var _this = this;
        setTimeout(function () { return _this.dispatchEvent(event); }, 0);
    };
    BeanStub.prototype.dispatchEvent = function (event) {
        if (this.localEventService) {
            this.localEventService.dispatchEvent(event);
        }
    };
    BeanStub.prototype.addDestroyableEventListener = function (eElement, event, listener) {
        if (this.destroyed) {
            return;
        }
        if (eElement instanceof HTMLElement) {
            utils_1._.addSafePassiveEventListener(eElement, event, listener);
        }
        else if (eElement instanceof gridOptionsWrapper_1.GridOptionsWrapper) {
            eElement.addEventListener(event, listener);
        }
        else {
            eElement.addEventListener(event, listener);
        }
        this.destroyFunctions.push(function () {
            if (eElement instanceof HTMLElement) {
                eElement.removeEventListener(event, listener);
            }
            else if (eElement instanceof gridOptionsWrapper_1.GridOptionsWrapper) {
                eElement.removeEventListener(event, listener);
            }
            else {
                eElement.removeEventListener(event, listener);
            }
        });
    };
    BeanStub.prototype.isAlive = function () {
        return !this.destroyed;
    };
    BeanStub.prototype.addDestroyFunc = function (func) {
        // if we are already destroyed, we execute the func now
        if (this.isAlive()) {
            this.destroyFunctions.push(func);
        }
        else {
            func();
        }
    };
    return BeanStub;
}());
exports.BeanStub = BeanStub;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("./vendor");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var gridOptionsWrapper_1 = __webpack_require__(2);
var selectionController_1 = __webpack_require__(17);
var valueService_1 = __webpack_require__(20);
var columnController_1 = __webpack_require__(3);
var context_1 = __webpack_require__(0);
var constants_1 = __webpack_require__(7);
var utils_1 = __webpack_require__(1);
var valueCache_1 = __webpack_require__(36);
var gridApi_1 = __webpack_require__(6);
var RowNode = (function () {
    function RowNode() {
        /** Children mapped by the pivot columns */
        this.childrenMapped = {};
        this.selected = false;
    }
    RowNode.prototype.setData = function (data) {
        var oldData = this.data;
        this.data = data;
        this.valueCache.onDataChanged();
        var event = this.createDataChangedEvent(data, oldData, false);
        this.dispatchLocalEvent(event);
    };
    RowNode.prototype.createDataChangedEvent = function (newData, oldData, update) {
        return {
            type: RowNode.EVENT_DATA_CHANGED,
            node: this,
            oldData: oldData,
            newData: newData,
            update: update
        };
    };
    RowNode.prototype.createLocalRowEvent = function (type) {
        return {
            type: type,
            node: this
        };
    };
    // similar to setRowData, however it is expected that the data is the same data item. this
    // is intended to be used with Redux type stores, where the whole data can be changed. we are
    // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
    // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
    // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
    RowNode.prototype.updateData = function (data) {
        var oldData = this.data;
        this.data = data;
        var event = this.createDataChangedEvent(data, oldData, true);
        this.dispatchLocalEvent(event);
    };
    RowNode.prototype.getRowIndexString = function () {
        if (this.rowPinned === constants_1.Constants.PINNED_TOP) {
            return 't-' + this.rowIndex;
        }
        else if (this.rowPinned === constants_1.Constants.PINNED_BOTTOM) {
            return 'b-' + this.rowIndex;
        }
        else {
            return this.rowIndex.toString();
        }
    };
    RowNode.prototype.createDaemonNode = function () {
        var oldNode = new RowNode();
        this.context.wireBean(oldNode);
        // just copy the id and data, this is enough for the node to be used
        // in the selection controller (the selection controller is the only
        // place where daemon nodes can live).
        oldNode.id = this.id;
        oldNode.data = this.data;
        oldNode.daemon = true;
        oldNode.selected = this.selected;
        oldNode.level = this.level;
        return oldNode;
    };
    RowNode.prototype.setDataAndId = function (data, id) {
        var oldNode = utils_1.Utils.exists(this.id) ? this.createDaemonNode() : null;
        var oldData = this.data;
        this.data = data;
        this.setId(id);
        this.selectionController.syncInRowNode(this, oldNode);
        var event = this.createDataChangedEvent(data, oldData, false);
        this.dispatchLocalEvent(event);
    };
    RowNode.prototype.setId = function (id) {
        // see if user is providing the id's
        var getRowNodeId = this.gridOptionsWrapper.getRowNodeIdFunc();
        if (getRowNodeId) {
            // if user is providing the id's, then we set the id only after the data has been set.
            // this is important for virtual pagination and viewport, where empty rows exist.
            if (this.data) {
                this.id = getRowNodeId(this.data);
            }
            else {
                // this can happen if user has set blank into the rowNode after the row previously
                // having data. this happens in virtual page row model, when data is delete and
                // the page is refreshed.
                this.id = undefined;
            }
        }
        else {
            this.id = id;
        }
    };
    RowNode.prototype.isPixelInRange = function (pixel) {
        return pixel >= this.rowTop && pixel < (this.rowTop + this.rowHeight);
    };
    RowNode.prototype.clearRowTop = function () {
        this.oldRowTop = this.rowTop;
        this.setRowTop(null);
    };
    RowNode.prototype.setFirstChild = function (firstChild) {
        if (this.firstChild === firstChild) {
            return;
        }
        this.firstChild = firstChild;
        if (this.eventService) {
            this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_FIRST_CHILD_CHANGED));
        }
    };
    RowNode.prototype.setLastChild = function (lastChild) {
        if (this.lastChild === lastChild) {
            return;
        }
        this.lastChild = lastChild;
        if (this.eventService) {
            this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_LAST_CHILD_CHANGED));
        }
    };
    RowNode.prototype.setChildIndex = function (childIndex) {
        if (this.childIndex === childIndex) {
            return;
        }
        this.childIndex = childIndex;
        if (this.eventService) {
            this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_CHILD_INDEX_CHANGED));
        }
    };
    RowNode.prototype.setRowTop = function (rowTop) {
        if (this.rowTop === rowTop) {
            return;
        }
        this.rowTop = rowTop;
        if (this.eventService) {
            this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_TOP_CHANGED));
        }
    };
    RowNode.prototype.setAllChildrenCount = function (allChildrenCount) {
        if (this.allChildrenCount === allChildrenCount) {
            return;
        }
        this.allChildrenCount = allChildrenCount;
        if (this.eventService) {
            this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED));
        }
    };
    RowNode.prototype.setRowHeight = function (rowHeight) {
        this.rowHeight = rowHeight;
        if (this.eventService) {
            this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_HEIGHT_CHANGED));
        }
    };
    RowNode.prototype.setRowIndex = function (rowIndex) {
        this.rowIndex = rowIndex;
        if (this.eventService) {
            this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_ROW_INDEX_CHANGED));
        }
    };
    RowNode.prototype.setUiLevel = function (uiLevel) {
        if (this.uiLevel === uiLevel) {
            return;
        }
        this.uiLevel = uiLevel;
        if (this.eventService) {
            this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_UI_LEVEL_CHANGED));
        }
    };
    RowNode.prototype.setExpanded = function (expanded) {
        if (this.expanded === expanded) {
            return;
        }
        this.expanded = expanded;
        if (this.eventService) {
            this.eventService.dispatchEvent(this.createLocalRowEvent(RowNode.EVENT_EXPANDED_CHANGED));
        }
        var event = this.createGlobalRowEvent(events_1.Events.EVENT_ROW_GROUP_OPENED);
        this.mainEventService.dispatchEvent(event);
    };
    RowNode.prototype.createGlobalRowEvent = function (type) {
        var event = {
            type: type,
            node: this,
            data: this.data,
            rowIndex: this.rowIndex,
            rowPinned: this.rowPinned,
            context: this.gridOptionsWrapper.getContext(),
            api: this.gridOptionsWrapper.getApi(),
            columnApi: this.gridOptionsWrapper.getColumnApi()
        };
        return event;
    };
    RowNode.prototype.dispatchLocalEvent = function (event) {
        if (this.eventService) {
            this.eventService.dispatchEvent(event);
        }
    };
    // we also allow editing the value via the editors. when it is done via
    // the editors, no 'cell changed' event gets fired, as it's assumed that
    // the cell knows about the change given it's in charge of the editing.
    // this method is for the client to call, so the cell listens for the change
    // event, and also flashes the cell when the change occurs.
    RowNode.prototype.setDataValue = function (colKey, newValue) {
        var column = this.columnController.getPrimaryColumn(colKey);
        this.valueService.setValue(this, column, newValue);
        this.dispatchCellChangedEvent(column, newValue);
    };
    RowNode.prototype.setGroupValue = function (colKey, newValue) {
        var column = this.columnController.getGridColumn(colKey);
        if (utils_1.Utils.missing(this.groupData)) {
            this.groupData = {};
        }
        this.groupData[column.getColId()] = newValue;
        this.dispatchCellChangedEvent(column, newValue);
    };
    // sets the data for an aggregation
    RowNode.prototype.setAggData = function (newAggData) {
        var _this = this;
        // find out all keys that could potentially change
        var colIds = utils_1.Utils.getAllKeysInObjects([this.aggData, newAggData]);
        this.aggData = newAggData;
        // if no event service, nobody has registered for events, so no need fire event
        if (this.eventService) {
            colIds.forEach(function (colId) {
                var column = _this.columnController.getGridColumn(colId);
                var value = _this.aggData ? _this.aggData[colId] : undefined;
                _this.dispatchCellChangedEvent(column, value);
            });
        }
    };
    RowNode.prototype.hasChildren = function () {
        // we need to return true when this.group=true, as this is used by enterprise row model
        // (as children are lazy loaded and stored in a cache anyway). otherwise we return true
        // if children exist.
        return this.group || (this.childrenAfterGroup && this.childrenAfterGroup.length > 0);
    };
    RowNode.prototype.isEmptyFillerNode = function () {
        return this.group && utils_1.Utils.missingOrEmpty(this.childrenAfterGroup);
    };
    RowNode.prototype.dispatchCellChangedEvent = function (column, newValue) {
        var cellChangedEvent = {
            type: RowNode.EVENT_CELL_CHANGED,
            node: this,
            column: column,
            newValue: newValue
        };
        this.dispatchLocalEvent(cellChangedEvent);
    };
    RowNode.prototype.resetQuickFilterAggregateText = function () {
        this.quickFilterAggregateText = null;
    };
    RowNode.prototype.isExpandable = function () {
        return this.hasChildren() || this.canFlower;
    };
    RowNode.prototype.isSelected = function () {
        // for footers, we just return what our sibling selected state is, as cannot select a footer
        if (this.footer) {
            return this.sibling.isSelected();
        }
        return this.selected;
    };
    RowNode.prototype.depthFirstSearch = function (callback) {
        if (this.childrenAfterGroup) {
            this.childrenAfterGroup.forEach(function (child) { return child.depthFirstSearch(callback); });
        }
        callback(this);
    };
    // + rowController.updateGroupsInSelection()
    RowNode.prototype.calculateSelectedFromChildren = function () {
        var atLeastOneSelected = false;
        var atLeastOneDeSelected = false;
        var atLeastOneMixed = false;
        var newSelectedValue;
        if (this.childrenAfterGroup) {
            for (var i = 0; i < this.childrenAfterGroup.length; i++) {
                var childState = this.childrenAfterGroup[i].isSelected();
                switch (childState) {
                    case true:
                        atLeastOneSelected = true;
                        break;
                    case false:
                        atLeastOneDeSelected = true;
                        break;
                    default:
                        atLeastOneMixed = true;
                        break;
                }
            }
        }
        if (atLeastOneMixed) {
            newSelectedValue = undefined;
        }
        else if (atLeastOneSelected && !atLeastOneDeSelected) {
            newSelectedValue = true;
        }
        else if (!atLeastOneSelected && atLeastOneDeSelected) {
            newSelectedValue = false;
        }
        else {
            newSelectedValue = undefined;
        }
        this.selectThisNode(newSelectedValue);
    };
    RowNode.prototype.calculateSelectedFromChildrenBubbleUp = function () {
        this.calculateSelectedFromChildren();
        if (this.parent) {
            this.parent.calculateSelectedFromChildrenBubbleUp();
        }
    };
    RowNode.prototype.setSelectedInitialValue = function (selected) {
        this.selected = selected;
    };
    RowNode.prototype.setSelected = function (newValue, clearSelection, tailingNodeInSequence) {
        if (clearSelection === void 0) { clearSelection = false; }
        if (tailingNodeInSequence === void 0) { tailingNodeInSequence = false; }
        this.setSelectedParams({
            newValue: newValue,
            clearSelection: clearSelection,
            tailingNodeInSequence: tailingNodeInSequence,
            rangeSelect: false
        });
    };
    RowNode.prototype.isRowPinned = function () {
        return this.rowPinned === constants_1.Constants.PINNED_TOP || this.rowPinned === constants_1.Constants.PINNED_BOTTOM;
    };
    // to make calling code more readable, this is the same method as setSelected except it takes names parameters
    RowNode.prototype.setSelectedParams = function (params) {
        var groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
        var newValue = params.newValue === true;
        var clearSelection = params.clearSelection === true;
        var tailingNodeInSequence = params.tailingNodeInSequence === true;
        var rangeSelect = params.rangeSelect === true;
        // groupSelectsFiltered only makes sense when group selects children
        var groupSelectsFiltered = groupSelectsChildren && (params.groupSelectsFiltered === true);
        if (this.id === undefined) {
            console.warn('ag-Grid: cannot select node until id for node is known');
            return 0;
        }
        if (this.rowPinned) {
            console.log('ag-Grid: cannot select pinned rows');
            return 0;
        }
        // if we are a footer, we don't do selection, just pass the info
        // to the sibling (the parent of the group)
        if (this.footer) {
            var count = this.sibling.setSelectedParams(params);
            return count;
        }
        if (rangeSelect) {
            var newRowClicked = this.selectionController.getLastSelectedNode() !== this;
            var allowMultiSelect = this.gridOptionsWrapper.isRowSelectionMulti();
            if (newRowClicked && allowMultiSelect) {
                return this.doRowRangeSelection();
            }
        }
        var updatedCount = 0;
        // when groupSelectsFiltered, then this node may end up intermediate despite
        // trying to set it to true / false. this group will be calculated further on
        // down when we call calculatedSelectedForAllGroupNodes(). we need to skip it
        // here, otherwise the updatedCount would include it.
        var skipThisNode = groupSelectsFiltered && this.group;
        if (!skipThisNode) {
            var thisNodeWasSelected = this.selectThisNode(newValue);
            if (thisNodeWasSelected) {
                updatedCount++;
            }
        }
        if (groupSelectsChildren && this.group) {
            updatedCount += this.selectChildNodes(newValue, groupSelectsFiltered);
        }
        // clear other nodes if not doing multi select
        var actionWasOnThisNode = !tailingNodeInSequence;
        if (actionWasOnThisNode) {
            if (newValue && (clearSelection || !this.gridOptionsWrapper.isRowSelectionMulti())) {
                updatedCount += this.selectionController.clearOtherNodes(this);
            }
            // only if we selected something, then update groups and fire events
            if (updatedCount > 0) {
                // update groups
                if (groupSelectsFiltered) {
                    // if the group was selecting filtered, then all nodes above and or below
                    // this node could have check, unchecked or intermediate, so easiest is to
                    // recalculate selected state for all group nodes
                    this.calculatedSelectedForAllGroupNodes();
                }
                else {
                    // if no selecting filtered, then everything below the group node was either
                    // selected or not selected, no intermediate, so no need to check items below
                    // this one, just the parents all the way up to the root
                    if (groupSelectsChildren && this.parent) {
                        this.parent.calculateSelectedFromChildrenBubbleUp();
                    }
                }
                // fire events
                // this is the very end of the 'action node', so we are finished all the updates,
                // include any parent / child changes that this method caused
                var event_1 = {
                    type: events_1.Events.EVENT_SELECTION_CHANGED,
                    api: this.gridApi,
                    columnApi: this.columnApi
                };
                this.mainEventService.dispatchEvent(event_1);
            }
            // so if user next does shift-select, we know where to start the selection from
            if (newValue) {
                this.selectionController.setLastSelectedNode(this);
            }
        }
        return updatedCount;
    };
    // selects all rows between this node and the last selected node (or the top if this is the first selection).
    // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
    // holding down 'shift'.
    RowNode.prototype.doRowRangeSelection = function () {
        var updatedCount = 0;
        var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
        var lastSelectedNode = this.selectionController.getLastSelectedNode();
        var nodesToSelect = this.rowModel.getNodesInRangeForSelection(lastSelectedNode, this);
        nodesToSelect.forEach(function (rowNode) {
            if (rowNode.group && groupsSelectChildren) {
                return;
            }
            var nodeWasSelected = rowNode.selectThisNode(true);
            if (nodeWasSelected) {
                updatedCount++;
            }
        });
        if (groupsSelectChildren) {
            this.calculatedSelectedForAllGroupNodes();
        }
        var event = {
            type: events_1.Events.EVENT_SELECTION_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.mainEventService.dispatchEvent(event);
        return updatedCount;
    };
    RowNode.prototype.isParentOfNode = function (potentialParent) {
        var parentNode = this.parent;
        while (parentNode) {
            if (parentNode === potentialParent) {
                return true;
            }
            parentNode = parentNode.parent;
        }
        return false;
    };
    RowNode.prototype.calculatedSelectedForAllGroupNodes = function () {
        // we have to make sure we do this dept first, as parent nodes
        // will have dependencies on the children having correct values
        var inMemoryRowModel = this.rowModel;
        inMemoryRowModel.getTopLevelNodes().forEach(function (topLevelNode) {
            if (topLevelNode.group) {
                topLevelNode.depthFirstSearch(function (childNode) {
                    if (childNode.group) {
                        childNode.calculateSelectedFromChildren();
                    }
                });
                topLevelNode.calculateSelectedFromChildren();
            }
        });
    };
    RowNode.prototype.selectThisNode = function (newValue) {
        if (this.selected === newValue) {
            return false;
        }
        this.selected = newValue;
        if (this.eventService) {
            this.dispatchLocalEvent(this.createLocalRowEvent(RowNode.EVENT_ROW_SELECTED));
        }
        var event = this.createGlobalRowEvent(events_1.Events.EVENT_ROW_SELECTED);
        this.mainEventService.dispatchEvent(event);
        return true;
    };
    RowNode.prototype.selectChildNodes = function (newValue, groupSelectsFiltered) {
        var children = groupSelectsFiltered ? this.childrenAfterFilter : this.childrenAfterGroup;
        var updatedCount = 0;
        if (utils_1.Utils.missing(children)) {
            return;
        }
        for (var i = 0; i < children.length; i++) {
            updatedCount += children[i].setSelectedParams({
                newValue: newValue,
                clearSelection: false,
                tailingNodeInSequence: true
            });
        }
        return updatedCount;
    };
    RowNode.prototype.addEventListener = function (eventType, listener) {
        if (!this.eventService) {
            this.eventService = new eventService_1.EventService();
        }
        this.eventService.addEventListener(eventType, listener);
    };
    RowNode.prototype.removeEventListener = function (eventType, listener) {
        this.eventService.removeEventListener(eventType, listener);
    };
    RowNode.prototype.onMouseEnter = function () {
        this.dispatchLocalEvent(this.createLocalRowEvent(RowNode.EVENT_MOUSE_ENTER));
    };
    RowNode.prototype.onMouseLeave = function () {
        this.dispatchLocalEvent(this.createLocalRowEvent(RowNode.EVENT_MOUSE_LEAVE));
    };
    RowNode.prototype.getFirstChildOfFirstChild = function (rowGroupColumn) {
        var currentRowNode = this;
        // if we are hiding groups, then if we are the first child, of the first child,
        // all the way up to the column we are interested in, then we show the group cell.
        var isCandidate = true;
        var foundFirstChildPath = false;
        var nodeToSwapIn;
        while (isCandidate && !foundFirstChildPath) {
            var parentRowNode = currentRowNode.parent;
            var firstChild = utils_1.Utils.exists(parentRowNode) && currentRowNode.firstChild;
            if (firstChild) {
                if (parentRowNode.rowGroupColumn === rowGroupColumn) {
                    foundFirstChildPath = true;
                    nodeToSwapIn = parentRowNode;
                }
            }
            else {
                isCandidate = false;
            }
            currentRowNode = parentRowNode;
        }
        return foundFirstChildPath ? nodeToSwapIn : null;
    };
    RowNode.EVENT_ROW_SELECTED = 'rowSelected';
    RowNode.EVENT_DATA_CHANGED = 'dataChanged';
    RowNode.EVENT_CELL_CHANGED = 'cellChanged';
    RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED = 'allChildrenCountChanged';
    RowNode.EVENT_MOUSE_ENTER = 'mouseEnter';
    RowNode.EVENT_MOUSE_LEAVE = 'mouseLeave';
    RowNode.EVENT_HEIGHT_CHANGED = 'heightChanged';
    RowNode.EVENT_TOP_CHANGED = 'topChanged';
    RowNode.EVENT_FIRST_CHILD_CHANGED = 'firstChildChanged';
    RowNode.EVENT_LAST_CHILD_CHANGED = 'lastChildChanged';
    RowNode.EVENT_CHILD_INDEX_CHANGED = 'childIndexChanged';
    RowNode.EVENT_ROW_INDEX_CHANGED = 'rowIndexChanged';
    RowNode.EVENT_EXPANDED_CHANGED = 'expandedChanged';
    RowNode.EVENT_UI_LEVEL_CHANGED = 'uiLevelChanged';
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], RowNode.prototype, "mainEventService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], RowNode.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('selectionController'),
        __metadata("design:type", selectionController_1.SelectionController)
    ], RowNode.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], RowNode.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('valueService'),
        __metadata("design:type", valueService_1.ValueService)
    ], RowNode.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], RowNode.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], RowNode.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('valueCache'),
        __metadata("design:type", valueCache_1.ValueCache)
    ], RowNode.prototype, "valueCache", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], RowNode.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], RowNode.prototype, "gridApi", void 0);
    return RowNode;
}());
exports.RowNode = RowNode;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var popupService_1 = __webpack_require__(37);
var valueService_1 = __webpack_require__(20);
var columnController_1 = __webpack_require__(3);
var context_1 = __webpack_require__(0);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var gridApi_1 = __webpack_require__(6);
var componentResolver_1 = __webpack_require__(22);
var FilterManager = (function () {
    function FilterManager() {
        this.allFilters = {};
        this.quickFilter = null;
    }
    FilterManager_1 = FilterManager;
    FilterManager.prototype.init = function () {
        this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.onNewRowsLoaded.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));
        this.quickFilter = this.parseQuickFilter(this.gridOptionsWrapper.getQuickFilterText());
        // check this here, in case there is a filter from the start
        this.checkExternalFilter();
    };
    FilterManager.prototype.setFilterModel = function (model) {
        var _this = this;
        var allPromises = [];
        if (model) {
            // mark the filters as we set them, so any active filters left over we stop
            var modelKeys_1 = Object.keys(model);
            utils_1.Utils.iterateObject(this.allFilters, function (colId, filterWrapper) {
                utils_1.Utils.removeFromArray(modelKeys_1, colId);
                var newModel = model[colId];
                _this.setModelOnFilterWrapper(filterWrapper.filterPromise, newModel);
                allPromises.push(filterWrapper.filterPromise);
            });
            // at this point, processedFields contains data for which we don't have a filter working yet
            utils_1.Utils.iterateArray(modelKeys_1, function (colId) {
                var column = _this.columnController.getPrimaryColumn(colId);
                if (!column) {
                    console.warn('Warning ag-grid setFilterModel - no column found for colId ' + colId);
                    return;
                }
                var filterWrapper = _this.getOrCreateFilterWrapper(column);
                _this.setModelOnFilterWrapper(filterWrapper.filterPromise, model[colId]);
                allPromises.push(filterWrapper.filterPromise);
            });
        }
        else {
            utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
                _this.setModelOnFilterWrapper(filterWrapper.filterPromise, null);
                allPromises.push(filterWrapper.filterPromise);
            });
        }
        utils_1.Promise.all(allPromises).then(function (whatever) {
            _this.onFilterChanged();
        });
    };
    FilterManager.prototype.setModelOnFilterWrapper = function (filterPromise, newModel) {
        filterPromise.then(function (filter) {
            if (typeof filter.setModel !== 'function') {
                console.warn('Warning ag-grid - filter missing setModel method, which is needed for setFilterModel');
                return;
            }
            filter.setModel(newModel);
        });
    };
    FilterManager.prototype.getFilterModel = function () {
        var result = {};
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            // because user can provide filters, we provide useful error checking and messages
            var filterPromise = filterWrapper.filterPromise;
            var filter = filterPromise.resolveNow(null, function (filter) { return filter; });
            if (filter == null)
                return null;
            if (typeof filter.getModel !== 'function') {
                console.warn('Warning ag-grid - filter API missing getModel method, which is needed for getFilterModel');
                return;
            }
            var model = filter.getModel();
            if (utils_1.Utils.exists(model)) {
                result[key] = model;
            }
        });
        return result;
    };
    // returns true if any advanced filter (ie not quick filter) active
    FilterManager.prototype.isAdvancedFilterPresent = function () {
        return this.advancedFilterPresent;
    };
    FilterManager.prototype.setAdvancedFilterPresent = function () {
        var atLeastOneActive = false;
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            if (filterWrapper.filterPromise.resolveNow(false, function (filter) { return filter.isFilterActive(); })) {
                atLeastOneActive = true;
            }
        });
        this.advancedFilterPresent = atLeastOneActive;
    };
    FilterManager.prototype.updateFilterFlagInColumns = function () {
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            var filterActive = filterWrapper.filterPromise.resolveNow(false, function (filter) { return filter.isFilterActive(); });
            filterWrapper.column.setFilterActive(filterActive);
        });
    };
    // returns true if quickFilter or advancedFilter
    FilterManager.prototype.isAnyFilterPresent = function () {
        return this.isQuickFilterPresent() || this.advancedFilterPresent || this.externalFilterPresent;
    };
    FilterManager.prototype.doesFilterPass = function (node, filterToSkip) {
        var data = node.data;
        var colKeys = Object.keys(this.allFilters);
        for (var i = 0, l = colKeys.length; i < l; i++) {
            var colId = colKeys[i];
            var filterWrapper = this.allFilters[colId];
            // if no filter, always pass
            if (filterWrapper === undefined) {
                continue;
            }
            var filter = filterWrapper.filterPromise.resolveNow(undefined, function (filter) { return filter; });
            // if filter not yet there, continue
            if (filter === undefined) {
                continue;
            }
            if (filter === filterToSkip) {
                continue;
            }
            // don't bother with filters that are not active
            if (!filter.isFilterActive()) {
                continue;
            }
            if (!filter.doesFilterPass) {
                console.error('Filter is missing method doesFilterPass');
            }
            var params = {
                node: node,
                data: data
            };
            if (!filter.doesFilterPass(params)) {
                return false;
            }
        }
        // all filters passed
        return true;
    };
    FilterManager.prototype.parseQuickFilter = function (newFilter) {
        if (utils_1.Utils.missing(newFilter) || newFilter === "") {
            return null;
        }
        if (this.gridOptionsWrapper.isRowModelInfinite()) {
            console.warn('ag-grid: cannot do quick filtering when doing virtual paging');
            return null;
        }
        return newFilter.toUpperCase();
    };
    // returns true if it has changed (not just same value again)
    FilterManager.prototype.setQuickFilter = function (newFilter) {
        var parsedFilter = this.parseQuickFilter(newFilter);
        if (this.quickFilter !== parsedFilter) {
            this.quickFilter = parsedFilter;
            this.onFilterChanged();
        }
    };
    FilterManager.prototype.checkExternalFilter = function () {
        this.externalFilterPresent = this.gridOptionsWrapper.isExternalFilterPresent();
    };
    FilterManager.prototype.onFilterChanged = function () {
        this.setAdvancedFilterPresent();
        this.updateFilterFlagInColumns();
        this.checkExternalFilter();
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            filterWrapper.filterPromise.then(function (filter) {
                if (filter.onAnyFilterChanged) {
                    filter.onAnyFilterChanged();
                }
            });
        });
        var event = {
            type: events_1.Events.EVENT_FILTER_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    FilterManager.prototype.isQuickFilterPresent = function () {
        return this.quickFilter !== null;
    };
    FilterManager.prototype.doesRowPassOtherFilters = function (filterToSkip, node) {
        return this.doesRowPassFilter(node, filterToSkip);
    };
    FilterManager.prototype.doesRowPassQuickFilterNoCache = function (node) {
        var _this = this;
        var columns = this.columnController.getAllPrimaryColumns();
        var filterPasses = false;
        columns.forEach(function (column) {
            if (filterPasses) {
                return;
            }
            var part = _this.getQuickFilterTextForColumn(column, node);
            if (utils_1.Utils.exists(part)) {
                if (part.indexOf(_this.quickFilter) >= 0) {
                    filterPasses = true;
                }
            }
        });
        return filterPasses;
    };
    FilterManager.prototype.doesRowPassQuickFilterCache = function (node) {
        if (!node.quickFilterAggregateText) {
            this.aggregateRowForQuickFilter(node);
        }
        var filterPasses = node.quickFilterAggregateText.indexOf(this.quickFilter) >= 0;
        return filterPasses;
    };
    FilterManager.prototype.doesRowPassQuickFilter = function (node) {
        var filterPasses;
        if (this.gridOptionsWrapper.isCacheQuickFilter()) {
            filterPasses = this.doesRowPassQuickFilterCache(node);
        }
        else {
            filterPasses = this.doesRowPassQuickFilterNoCache(node);
        }
        return filterPasses;
    };
    FilterManager.prototype.doesRowPassFilter = function (node, filterToSkip) {
        // the row must pass ALL of the filters, so if any of them fail,
        // we return true. that means if a row passes the quick filter,
        // but fails the column filter, it fails overall
        // first up, check quick filter
        if (this.isQuickFilterPresent()) {
            if (!this.doesRowPassQuickFilter(node)) {
                return false;
            }
        }
        // secondly, give the client a chance to reject this row
        if (this.externalFilterPresent) {
            if (!this.gridOptionsWrapper.doesExternalFilterPass(node)) {
                return false;
            }
        }
        // lastly, check our internal advanced filter
        if (this.advancedFilterPresent) {
            if (!this.doesFilterPass(node, filterToSkip)) {
                return false;
            }
        }
        // got this far, all filters pass
        return true;
    };
    FilterManager.prototype.getQuickFilterTextForColumn = function (column, rowNode) {
        var value = this.valueService.getValue(column, rowNode);
        var valueAfterCallback;
        var colDef = column.getColDef();
        if (column.getColDef().getQuickFilterText) {
            var params = {
                value: value,
                node: rowNode,
                data: rowNode.data,
                column: column,
                colDef: colDef
            };
            valueAfterCallback = column.getColDef().getQuickFilterText(params);
        }
        else {
            valueAfterCallback = value;
        }
        if (valueAfterCallback && valueAfterCallback !== '') {
            return valueAfterCallback.toString().toUpperCase();
        }
        else {
            return null;
        }
    };
    FilterManager.prototype.aggregateRowForQuickFilter = function (node) {
        var _this = this;
        var stringParts = [];
        var columns = this.columnController.getAllPrimaryColumns();
        columns.forEach(function (column) {
            var part = _this.getQuickFilterTextForColumn(column, node);
            if (utils_1.Utils.exists(part)) {
                stringParts.push(part);
            }
        });
        node.quickFilterAggregateText = stringParts.join(FilterManager_1.QUICK_FILTER_SEPARATOR);
    };
    FilterManager.prototype.onNewRowsLoaded = function () {
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            filterWrapper.filterPromise.then(function (filter) {
                if (filter.onNewRowsLoaded) {
                    filter.onNewRowsLoaded();
                }
            });
        });
        this.updateFilterFlagInColumns();
        this.setAdvancedFilterPresent();
    };
    FilterManager.prototype.createValueGetter = function (column) {
        var that = this;
        return function valueGetter(node) {
            return that.valueService.getValue(column, node);
        };
    };
    FilterManager.prototype.getFilterComponent = function (column) {
        var filterWrapper = this.getOrCreateFilterWrapper(column);
        return filterWrapper.filterPromise;
    };
    FilterManager.prototype.getOrCreateFilterWrapper = function (column) {
        var filterWrapper = this.cachedFilter(column);
        if (!filterWrapper) {
            filterWrapper = this.createFilterWrapper(column);
            this.allFilters[column.getColId()] = filterWrapper;
        }
        return filterWrapper;
    };
    FilterManager.prototype.cachedFilter = function (column) {
        return this.allFilters[column.getColId()];
    };
    FilterManager.prototype.createFilterInstance = function (column, $scope) {
        var _this = this;
        var defaultFilter = 'textColumnFilter';
        if (this.gridOptionsWrapper.isEnterprise()) {
            defaultFilter = 'setColumnFilter';
        }
        var sanitisedColDef = utils_1.Utils.cloneObject(column.getColDef());
        var event = {
            type: events_1.Events.EVENT_FILTER_MODIFIED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.translateFilter(sanitisedColDef, 'set');
        this.translateFilter(sanitisedColDef, 'text');
        this.translateFilter(sanitisedColDef, 'number');
        this.translateFilter(sanitisedColDef, 'date');
        var filterChangedCallback = this.onFilterChanged.bind(this);
        var filterModifiedCallback = function () { return _this.eventService.dispatchEvent(event); };
        var params = {
            column: column,
            colDef: sanitisedColDef,
            rowModel: this.rowModel,
            filterChangedCallback: filterChangedCallback,
            filterModifiedCallback: filterModifiedCallback,
            valueGetter: this.createValueGetter(column),
            context: this.gridOptionsWrapper.getContext(),
            doesRowPassOtherFilter: null,
            $scope: $scope
        };
        return this.componentResolver.createAgGridComponent(sanitisedColDef, params, 'filter', defaultFilter, true, function (params, filter) { return utils_1.Utils.assign(params, {
            doesRowPassOtherFilter: _this.doesRowPassOtherFilters.bind(_this, filter),
        }); });
    };
    FilterManager.prototype.translateFilter = function (target, toTranslate) {
        if (target.filter === toTranslate) {
            target.filter = toTranslate + "ColumnFilter";
        }
    };
    FilterManager.prototype.createFilterWrapper = function (column) {
        var filterWrapper = {
            column: column,
            filterPromise: null,
            scope: null,
            guiPromise: utils_1.Promise.external()
        };
        var $scope = this.gridOptionsWrapper.isAngularCompileFilters() ? this.$scope.$new() : null;
        filterWrapper.filterPromise = this.createFilterInstance(column, $scope);
        this.putIntoGui(filterWrapper);
        return filterWrapper;
    };
    FilterManager.prototype.putIntoGui = function (filterWrapper) {
        var _this = this;
        var eFilterGui = document.createElement('div');
        eFilterGui.className = 'ag-filter';
        filterWrapper.filterPromise.then(function (filter) {
            var guiFromFilter = filter.getGui();
            // for backwards compatibility with Angular 1 - we
            // used to allow providing back HTML from getGui().
            // once we move away from supporting Angular 1
            // directly, we can change this.
            if (typeof guiFromFilter === 'string') {
                guiFromFilter = utils_1.Utils.loadTemplate(guiFromFilter);
            }
            eFilterGui.appendChild(guiFromFilter);
            if (filterWrapper.scope) {
                filterWrapper.guiPromise.resolve(_this.$compile(eFilterGui)(filterWrapper.scope)[0]);
            }
            else {
                filterWrapper.guiPromise.resolve(eFilterGui);
            }
        });
    };
    FilterManager.prototype.onNewColumnsLoaded = function () {
        this.destroy();
    };
    // destroys the filter, so it not longer takes part
    FilterManager.prototype.destroyFilter = function (column) {
        var filterWrapper = this.allFilters[column.getColId()];
        if (filterWrapper) {
            this.disposeFilterWrapper(filterWrapper);
            this.onFilterChanged();
        }
    };
    FilterManager.prototype.disposeFilterWrapper = function (filterWrapper) {
        var _this = this;
        filterWrapper.filterPromise.then(function (filter) {
            filter.setModel(null);
            if (filter.destroy) {
                filter.destroy();
            }
            filterWrapper.column.setFilterActive(false);
            delete _this.allFilters[filterWrapper.column.getColId()];
        });
    };
    FilterManager.prototype.destroy = function () {
        var _this = this;
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            _this.disposeFilterWrapper(filterWrapper);
        });
    };
    FilterManager.QUICK_FILTER_SEPARATOR = '\n';
    __decorate([
        context_1.Autowired('$compile'),
        __metadata("design:type", Object)
    ], FilterManager.prototype, "$compile", void 0);
    __decorate([
        context_1.Autowired('$scope'),
        __metadata("design:type", Object)
    ], FilterManager.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], FilterManager.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('gridCore'),
        __metadata("design:type", Object)
    ], FilterManager.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('popupService'),
        __metadata("design:type", popupService_1.PopupService)
    ], FilterManager.prototype, "popupService", void 0);
    __decorate([
        context_1.Autowired('valueService'),
        __metadata("design:type", valueService_1.ValueService)
    ], FilterManager.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], FilterManager.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], FilterManager.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], FilterManager.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('enterprise'),
        __metadata("design:type", Boolean)
    ], FilterManager.prototype, "enterprise", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], FilterManager.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], FilterManager.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], FilterManager.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('componentResolver'),
        __metadata("design:type", componentResolver_1.ComponentResolver)
    ], FilterManager.prototype, "componentResolver", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], FilterManager.prototype, "init", null);
    __decorate([
        context_1.PreDestroy,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], FilterManager.prototype, "destroy", null);
    FilterManager = FilterManager_1 = __decorate([
        context_1.Bean('filterManager')
    ], FilterManager);
    return FilterManager;
    var FilterManager_1;
}());
exports.FilterManager = FilterManager;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var context_1 = __webpack_require__(0);
var context_2 = __webpack_require__(0);
var logger_1 = __webpack_require__(11);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var context_3 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var context_4 = __webpack_require__(0);
var constants_1 = __webpack_require__(7);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
var SelectionController = (function () {
    function SelectionController() {
    }
    SelectionController.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('SelectionController');
        this.reset();
        if (this.gridOptionsWrapper.isRowModelDefault()) {
            this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.reset.bind(this));
        }
        else {
            this.logger.log('dont know what to do here');
        }
    };
    SelectionController.prototype.init = function () {
        this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
        this.eventService.addEventListener(events_1.Events.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
    };
    SelectionController.prototype.setLastSelectedNode = function (rowNode) {
        this.lastSelectedNode = rowNode;
    };
    SelectionController.prototype.getLastSelectedNode = function () {
        return this.lastSelectedNode;
    };
    SelectionController.prototype.getSelectedNodes = function () {
        var selectedNodes = [];
        utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
            if (rowNode) {
                selectedNodes.push(rowNode);
            }
        });
        return selectedNodes;
    };
    SelectionController.prototype.getSelectedRows = function () {
        var selectedRows = [];
        utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
            if (rowNode && rowNode.data) {
                selectedRows.push(rowNode.data);
            }
        });
        return selectedRows;
    };
    SelectionController.prototype.removeGroupsFromSelection = function () {
        var _this = this;
        utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
            if (rowNode && rowNode.group) {
                _this.selectedNodes[rowNode.id] = undefined;
            }
        });
    };
    // should only be called if groupSelectsChildren=true
    SelectionController.prototype.updateGroupsFromChildrenSelections = function () {
        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY) {
            console.warn('updateGroupsFromChildrenSelections not available when rowModel is not normal');
        }
        var inMemoryRowModel = this.rowModel;
        inMemoryRowModel.getTopLevelNodes().forEach(function (rowNode) {
            rowNode.depthFirstSearch(function (rowNode) {
                if (rowNode.group) {
                    rowNode.calculateSelectedFromChildren();
                }
            });
        });
    };
    SelectionController.prototype.getNodeForIdIfSelected = function (id) {
        return this.selectedNodes[id];
    };
    SelectionController.prototype.clearOtherNodes = function (rowNodeToKeepSelected) {
        var _this = this;
        var groupsToRefresh = {};
        var updatedCount = 0;
        utils_1.Utils.iterateObject(this.selectedNodes, function (key, otherRowNode) {
            if (otherRowNode && otherRowNode.id !== rowNodeToKeepSelected.id) {
                var rowNode = _this.selectedNodes[otherRowNode.id];
                updatedCount += rowNode.setSelectedParams({ newValue: false, clearSelection: false, tailingNodeInSequence: true });
                if (_this.groupSelectsChildren && otherRowNode.parent) {
                    groupsToRefresh[otherRowNode.parent.id] = otherRowNode.parent;
                }
            }
        });
        utils_1.Utils.iterateObject(groupsToRefresh, function (key, group) {
            group.calculateSelectedFromChildren();
        });
        return updatedCount;
    };
    SelectionController.prototype.onRowSelected = function (event) {
        var rowNode = event.node;
        // we do not store the group rows when the groups select children
        if (this.groupSelectsChildren && rowNode.group) {
            return;
        }
        if (rowNode.isSelected()) {
            this.selectedNodes[rowNode.id] = rowNode;
        }
        else {
            this.selectedNodes[rowNode.id] = undefined;
        }
    };
    SelectionController.prototype.syncInRowNode = function (rowNode, oldNode) {
        this.syncInOldRowNode(rowNode, oldNode);
        this.syncInNewRowNode(rowNode);
    };
    // if the id has changed for the node, then this means the rowNode
    // is getting used for a different data item, which breaks
    // our selectedNodes, as the node now is mapped by the old id
    // which is inconsistent. so to keep the old node as selected,
    // we swap in the clone (with the old id and old data). this means
    // the oldNode is effectively a daemon we keep a reference to,
    // so if client calls api.getSelectedNodes(), it gets the daemon
    // in the result. when the client un-selects, the reference to the
    // daemon is removed. the daemon, because it's an oldNode, is not
    // used by the grid for rendering, it's a copy of what the node used
    // to be like before the id was changed.
    SelectionController.prototype.syncInOldRowNode = function (rowNode, oldNode) {
        var oldNodeHasDifferentId = utils_1.Utils.exists(oldNode) && (rowNode.id !== oldNode.id);
        if (oldNodeHasDifferentId) {
            var oldNodeSelected = utils_1.Utils.exists(this.selectedNodes[oldNode.id]);
            if (oldNodeSelected) {
                this.selectedNodes[oldNode.id] = oldNode;
            }
        }
    };
    SelectionController.prototype.syncInNewRowNode = function (rowNode) {
        if (utils_1.Utils.exists(this.selectedNodes[rowNode.id])) {
            rowNode.setSelectedInitialValue(true);
            this.selectedNodes[rowNode.id] = rowNode;
        }
        else {
            rowNode.setSelectedInitialValue(false);
        }
    };
    SelectionController.prototype.reset = function () {
        this.logger.log('reset');
        this.selectedNodes = {};
        this.lastSelectedNode = null;
    };
    // returns a list of all nodes at 'best cost' - a feature to be used
    // with groups / trees. if a group has all it's children selected,
    // then the group appears in the result, but not the children.
    // Designed for use with 'children' as the group selection type,
    // where groups don't actually appear in the selection normally.
    SelectionController.prototype.getBestCostNodeSelection = function () {
        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY) {
            console.warn('getBestCostNodeSelection is only avilable when using normal row model');
        }
        var inMemoryRowModel = this.rowModel;
        var topLevelNodes = inMemoryRowModel.getTopLevelNodes();
        if (topLevelNodes === null) {
            console.warn('selectAll not available doing rowModel=virtual');
            return;
        }
        var result = [];
        // recursive function, to find the selected nodes
        function traverse(nodes) {
            for (var i = 0, l = nodes.length; i < l; i++) {
                var node = nodes[i];
                if (node.isSelected()) {
                    result.push(node);
                }
                else {
                    // if not selected, then if it's a group, and the group
                    // has children, continue to search for selections
                    if (node.group && node.children) {
                        traverse(node.children);
                    }
                }
            }
        }
        traverse(topLevelNodes);
        return result;
    };
    SelectionController.prototype.setRowModel = function (rowModel) {
        this.rowModel = rowModel;
    };
    SelectionController.prototype.isEmpty = function () {
        var count = 0;
        utils_1.Utils.iterateObject(this.selectedNodes, function (nodeId, rowNode) {
            if (rowNode) {
                count++;
            }
        });
        return count === 0;
    };
    SelectionController.prototype.deselectAllRowNodes = function (justFiltered) {
        if (justFiltered === void 0) { justFiltered = false; }
        var callback = function (rowNode) { return rowNode.selectThisNode(false); };
        var rowModelInMemory = this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY;
        if (justFiltered) {
            if (!rowModelInMemory) {
                console.error('ag-Grid: selecting just filtered only works with In Memory Row Model');
                return;
            }
            var inMemoryRowModel = this.rowModel;
            inMemoryRowModel.forEachNodeAfterFilter(callback);
        }
        else {
            utils_1.Utils.iterateObject(this.selectedNodes, function (id, rowNode) {
                // remember the reference can be to null, as we never 'delete' from the map
                if (rowNode) {
                    callback(rowNode);
                }
            });
            // this clears down the map (whereas above only sets the items in map to 'undefined')
            this.reset();
        }
        // the above does not clean up the parent rows if they are selected
        if (rowModelInMemory && this.groupSelectsChildren) {
            this.updateGroupsFromChildrenSelections();
        }
        var event = {
            type: events_1.Events.EVENT_SELECTION_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    SelectionController.prototype.selectAllRowNodes = function (justFiltered) {
        if (justFiltered === void 0) { justFiltered = false; }
        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY) {
            throw "selectAll only available with normal row model, ie not " + this.rowModel.getType();
        }
        var inMemoryRowModel = this.rowModel;
        var callback = function (rowNode) { return rowNode.selectThisNode(true); };
        if (justFiltered) {
            inMemoryRowModel.forEachNodeAfterFilter(callback);
        }
        else {
            inMemoryRowModel.forEachNode(callback);
        }
        // the above does not clean up the parent rows if they are selected
        if (this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY && this.groupSelectsChildren) {
            this.updateGroupsFromChildrenSelections();
        }
        var event = {
            type: events_1.Events.EVENT_SELECTION_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    // Deprecated method
    SelectionController.prototype.selectNode = function (rowNode, tryMulti) {
        rowNode.setSelectedParams({ newValue: true, clearSelection: !tryMulti });
    };
    // Deprecated method
    SelectionController.prototype.deselectIndex = function (rowIndex) {
        var node = this.rowModel.getRow(rowIndex);
        this.deselectNode(node);
    };
    // Deprecated method
    SelectionController.prototype.deselectNode = function (rowNode) {
        rowNode.setSelectedParams({ newValue: false, clearSelection: false });
    };
    // Deprecated method
    SelectionController.prototype.selectIndex = function (index, tryMulti) {
        var node = this.rowModel.getRow(index);
        this.selectNode(node, tryMulti);
    };
    __decorate([
        context_3.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], SelectionController.prototype, "eventService", void 0);
    __decorate([
        context_3.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], SelectionController.prototype, "rowModel", void 0);
    __decorate([
        context_3.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], SelectionController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_3.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], SelectionController.prototype, "columnApi", void 0);
    __decorate([
        context_3.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], SelectionController.prototype, "gridApi", void 0);
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], SelectionController.prototype, "setBeans", null);
    __decorate([
        context_4.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], SelectionController.prototype, "init", null);
    SelectionController = __decorate([
        context_1.Bean('selectionController')
    ], SelectionController);
    return SelectionController;
}());
exports.SelectionController = SelectionController;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var gridPanel_1 = __webpack_require__(10);
var expressionService_1 = __webpack_require__(19);
var templateService_1 = __webpack_require__(60);
var valueService_1 = __webpack_require__(20);
var eventService_1 = __webpack_require__(4);
var rowComp_1 = __webpack_require__(58);
var events_1 = __webpack_require__(5);
var constants_1 = __webpack_require__(7);
var cellComp_1 = __webpack_require__(41);
var context_1 = __webpack_require__(0);
var gridCore_1 = __webpack_require__(33);
var columnController_1 = __webpack_require__(3);
var logger_1 = __webpack_require__(11);
var focusedCellController_1 = __webpack_require__(24);
var cellNavigationService_1 = __webpack_require__(64);
var gridCell_1 = __webpack_require__(23);
var beanStub_1 = __webpack_require__(13);
var paginationProxy_1 = __webpack_require__(29);
var gridApi_1 = __webpack_require__(6);
var pinnedRowModel_1 = __webpack_require__(30);
var beans_1 = __webpack_require__(35);
var animationFrameService_1 = __webpack_require__(40);
var RowRenderer = (function (_super) {
    __extends(RowRenderer, _super);
    function RowRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // map of row ids to row objects. keeps track of which elements
        // are rendered for which rows in the dom.
        _this.rowCompsByIndex = {};
        _this.floatingTopRowComps = [];
        _this.floatingBottomRowComps = [];
        // we only allow one refresh at a time, otherwise the internal memory structure here
        // will get messed up. this can happen if the user has a cellRenderer, and inside the
        // renderer they call an API method that results in another pass of the refresh,
        // then it will be trying to draw rows in the middle of a refresh.
        _this.refreshInProgress = false;
        return _this;
    }
    RowRenderer.prototype.agWire = function (loggerFactory) {
        this.logger = loggerFactory.create('RowRenderer');
    };
    RowRenderer.prototype.init = function () {
        this.forPrint = this.gridOptionsWrapper.isForPrint();
        this.autoHeight = this.gridOptionsWrapper.isAutoHeight();
        this.rowContainers = this.gridPanel.getRowContainers();
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
        this.redrawAfterModelUpdate();
    };
    RowRenderer.prototype.onPageLoaded = function (refreshEvent) {
        if (utils_1.Utils.missing(refreshEvent)) {
            refreshEvent = {
                type: events_1.Events.EVENT_MODEL_UPDATED,
                api: this.gridApi,
                columnApi: this.columnApi,
                animate: false,
                keepRenderedRows: false,
                newData: false,
                newPage: false
            };
        }
        this.onModelUpdated(refreshEvent);
    };
    RowRenderer.prototype.getAllCellsForColumn = function (column) {
        var eCells = [];
        utils_1.Utils.iterateObject(this.rowCompsByIndex, callback);
        utils_1.Utils.iterateObject(this.floatingBottomRowComps, callback);
        utils_1.Utils.iterateObject(this.floatingTopRowComps, callback);
        function callback(key, rowComp) {
            var eCell = rowComp.getCellForCol(column);
            if (eCell) {
                eCells.push(eCell);
            }
        }
        return eCells;
    };
    RowRenderer.prototype.refreshFloatingRowComps = function () {
        this.refreshFloatingRows(this.floatingTopRowComps, this.pinnedRowModel.getPinnedTopRowData(), this.rowContainers.floatingTopPinnedLeft, this.rowContainers.floatingTopPinnedRight, this.rowContainers.floatingTop, this.rowContainers.floatingTopFullWidth);
        this.refreshFloatingRows(this.floatingBottomRowComps, this.pinnedRowModel.getPinnedBottomRowData(), this.rowContainers.floatingBottomPinnedLeft, this.rowContainers.floatingBottomPinnedRight, this.rowContainers.floatingBottom, this.rowContainers.floatingBottomFullWith);
    };
    RowRenderer.prototype.refreshFloatingRows = function (rowComps, rowNodes, pinnedLeftContainerComp, pinnedRightContainerComp, bodyContainerComp, fullWidthContainerComp) {
        var _this = this;
        rowComps.forEach(function (row) {
            row.destroy();
        });
        rowComps.length = 0;
        // if no cols, don't draw row - can we get rid of this???
        var columns = this.columnController.getAllDisplayedColumns();
        if (utils_1.Utils.missingOrEmpty(columns)) {
            return;
        }
        if (rowNodes) {
            rowNodes.forEach(function (node) {
                var rowComp = new rowComp_1.RowComp(_this.$scope, bodyContainerComp, pinnedLeftContainerComp, pinnedRightContainerComp, fullWidthContainerComp, node, _this.beans, false, false);
                rowComp.init();
                rowComps.push(rowComp);
            });
        }
        this.flushContainers(rowComps);
    };
    RowRenderer.prototype.onPinnedRowDataChanged = function () {
        this.redrawAfterModelUpdate();
    };
    RowRenderer.prototype.onModelUpdated = function (refreshEvent) {
        var params = {
            recycleRows: refreshEvent.keepRenderedRows,
            animate: refreshEvent.animate,
            newData: refreshEvent.newData,
            newPage: refreshEvent.newPage
        };
        this.redrawAfterModelUpdate(params);
        // this.eventService.dispatchEvent(Events.DEPRECATED_EVENT_PAGINATION_PAGE_LOADED);
    };
    // if the row nodes are not rendered, no index is returned
    RowRenderer.prototype.getRenderedIndexesForRowNodes = function (rowNodes) {
        var result = [];
        if (utils_1.Utils.missing(rowNodes)) {
            return result;
        }
        utils_1.Utils.iterateObject(this.rowCompsByIndex, function (index, renderedRow) {
            var rowNode = renderedRow.getRowNode();
            if (rowNodes.indexOf(rowNode) >= 0) {
                result.push(index);
            }
        });
        return result;
    };
    RowRenderer.prototype.redrawRows = function (rowNodes) {
        if (!rowNodes || rowNodes.length == 0) {
            return;
        }
        // we only need to be worried about rendered rows, as this method is
        // called to whats rendered. if the row isn't rendered, we don't care
        var indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes);
        // remove the rows
        this.removeRowComps(indexesToRemove);
        // add draw them again
        this.redrawAfterModelUpdate({
            recycleRows: true
        });
    };
    RowRenderer.prototype.getCellToRestoreFocusToAfterRefresh = function (params) {
        var focusedCell = params.suppressKeepFocus ? null : this.focusedCellController.getFocusCellToUseAfterRefresh();
        if (utils_1.Utils.missing(focusedCell)) {
            return null;
        }
        // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this
        // solves is with editing - if the user is editing, eg focus is on a text field, and not on the
        // cell itself, then the cell can be registered as having focus, however it's the text field that
        // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus
        // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,
        // the focus is lost from the text field. we do not want this.
        var activeElement = document.activeElement;
        var domData = this.gridOptionsWrapper.getDomData(activeElement, cellComp_1.CellComp.DOM_DATA_KEY_CELL_COMP);
        var elementIsNotACellDev = utils_1.Utils.missing(domData);
        if (elementIsNotACellDev) {
            return null;
        }
        return focusedCell;
    };
    // gets called after changes to the model.
    RowRenderer.prototype.redrawAfterModelUpdate = function (params) {
        if (params === void 0) { params = {}; }
        this.getLockOnRefresh();
        var focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);
        if (!this.forPrint) {
            this.sizeContainerToPageHeight();
        }
        this.scrollToTopIfNewData(params);
        // never keep rendered rows if doing forPrint or autoHeight, as we do not use 'top' to
        // position the rows (it uses normal flow), so we have to remove
        // all rows and insert them again from scratch
        var rowsUsingFlow = this.forPrint || this.autoHeight;
        var recycleRows = rowsUsingFlow ? false : params.recycleRows;
        var animate = rowsUsingFlow ? false : (params.animate && this.gridOptionsWrapper.isAnimateRows());
        var rowsToRecycle = this.binRowComps(recycleRows);
        this.redraw(rowsToRecycle, animate);
        if (!params.onlyBody) {
            this.refreshFloatingRowComps();
        }
        this.restoreFocusedCell(focusedCell);
        this.releaseLockOnRefresh();
    };
    RowRenderer.prototype.scrollToTopIfNewData = function (params) {
        var scrollToTop = params.newData || params.newPage;
        var suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();
        if (scrollToTop && !suppressScrollToTop) {
            this.gridPanel.scrollToTop();
        }
    };
    RowRenderer.prototype.sizeContainerToPageHeight = function () {
        var containerHeight = this.paginationProxy.getCurrentPageHeight();
        // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,
        // we still want the scroll to be present, otherwise there would be no way to access the columns
        // on the RHS - and if that was where the filter was that cause no rows to be presented, there
        // is no way to remove the filter.
        if (containerHeight === 0) {
            containerHeight = 1;
        }
        this.rowContainers.body.setHeight(containerHeight);
        this.rowContainers.fullWidth.setHeight(containerHeight);
        this.rowContainers.pinnedLeft.setHeight(containerHeight);
        this.rowContainers.pinnedRight.setHeight(containerHeight);
    };
    RowRenderer.prototype.getLockOnRefresh = function () {
        if (this.refreshInProgress) {
            throw 'ag-Grid: cannot get grid to draw rows when it is in the middle of drawing rows. ' +
                'Your code probably called a grid API method while the grid was in the render stage. To overcome ' +
                'this, put the API call into a timeout, eg instead of api.refreshView(), ' +
                'call setTimeout(function(){api.refreshView(),0}). To see what part of your code ' +
                'that caused the refresh check this stacktrace.';
        }
        this.refreshInProgress = true;
    };
    RowRenderer.prototype.releaseLockOnRefresh = function () {
        this.refreshInProgress = false;
    };
    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
    // edited cell).
    RowRenderer.prototype.restoreFocusedCell = function (gridCell) {
        if (gridCell) {
            this.focusedCellController.setFocusedCell(gridCell.rowIndex, gridCell.column, gridCell.floating, true);
        }
    };
    RowRenderer.prototype.stopEditing = function (cancel) {
        if (cancel === void 0) { cancel = false; }
        this.forEachRowComp(function (key, renderedRow) {
            renderedRow.stopEditing(cancel);
        });
    };
    RowRenderer.prototype.forEachCellComp = function (callback) {
        utils_1.Utils.iterateObject(this.rowCompsByIndex, function (index, renderedRow) {
            renderedRow.forEachCellComp(callback);
        });
    };
    RowRenderer.prototype.forEachRowComp = function (callback) {
        utils_1.Utils.iterateObject(this.rowCompsByIndex, callback);
        utils_1.Utils.iterateObject(this.floatingTopRowComps, callback);
        utils_1.Utils.iterateObject(this.floatingBottomRowComps, callback);
    };
    RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {
        var rowComp = this.rowCompsByIndex[rowIndex];
        if (rowComp) {
            rowComp.addEventListener(eventName, callback);
        }
    };
    RowRenderer.prototype.refreshCells = function (params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        var rowIdsMap;
        if (utils_1.Utils.exists(params.rowNodes)) {
            rowIdsMap = {
                top: {},
                bottom: {},
                normal: {}
            };
            params.rowNodes.forEach(function (rowNode) {
                if (rowNode.rowPinned === constants_1.Constants.PINNED_TOP) {
                    rowIdsMap.top[rowNode.id] = true;
                }
                else if (rowNode.rowPinned === constants_1.Constants.PINNED_BOTTOM) {
                    rowIdsMap.bottom[rowNode.id] = true;
                }
                else {
                    rowIdsMap.normal[rowNode.id] = true;
                }
            });
        }
        var colIdsMap;
        if (utils_1.Utils.exists(params.columns)) {
            colIdsMap = {};
            params.columns.forEach(function (colKey) {
                var column = _this.columnController.getGridColumn(colKey);
                colIdsMap[column.getId()] = true;
            });
        }
        var processRow = function (rowComp) {
            var rowNode = rowComp.getRowNode();
            var id = rowNode.id;
            var floating = rowNode.rowPinned;
            // skip this row if it is missing from the provided list
            if (utils_1.Utils.exists(rowIdsMap)) {
                if (floating === constants_1.Constants.PINNED_BOTTOM) {
                    if (!rowIdsMap.bottom[id]) {
                        return;
                    }
                }
                else if (floating === constants_1.Constants.PINNED_TOP) {
                    if (!rowIdsMap.top[id]) {
                        return;
                    }
                }
                else {
                    if (!rowIdsMap.normal[id]) {
                        return;
                    }
                }
            }
            rowComp.forEachCellComp(function (cellComp) {
                var colId = cellComp.getColumn().getId();
                var excludeColFromRefresh = colIdsMap && !colIdsMap[colId];
                if (excludeColFromRefresh) {
                    return;
                }
                cellComp.refreshCell({
                    forceRefresh: params.force,
                    volatile: params.volatile,
                    newData: false
                });
            });
        };
        utils_1.Utils.iterateObject(this.rowCompsByIndex, function (index, rowComp) {
            processRow(rowComp);
        });
        if (this.floatingTopRowComps) {
            this.floatingTopRowComps.forEach(processRow);
        }
        if (this.floatingBottomRowComps) {
            this.floatingBottomRowComps.forEach(processRow);
        }
    };
    RowRenderer.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        var rowIndexesToRemove = Object.keys(this.rowCompsByIndex);
        this.removeRowComps(rowIndexesToRemove);
    };
    RowRenderer.prototype.binRowComps = function (recycleRows) {
        var _this = this;
        var indexesToRemove;
        var rowsToRecycle = {};
        if (recycleRows) {
            indexesToRemove = [];
            utils_1.Utils.iterateObject(this.rowCompsByIndex, function (index, rowComp) {
                var rowNode = rowComp.getRowNode();
                if (utils_1.Utils.exists(rowNode.id)) {
                    rowsToRecycle[rowNode.id] = rowComp;
                    delete _this.rowCompsByIndex[index];
                }
                else {
                    indexesToRemove.push(index);
                }
            });
        }
        else {
            indexesToRemove = Object.keys(this.rowCompsByIndex);
        }
        this.removeRowComps(indexesToRemove);
        return rowsToRecycle;
    };
    // takes array of row indexes
    RowRenderer.prototype.removeRowComps = function (rowsToRemove) {
        var _this = this;
        // if no fromIndex then set to -1, which will refresh everything
        // let realFromIndex = -1;
        rowsToRemove.forEach(function (indexToRemove) {
            var renderedRow = _this.rowCompsByIndex[indexToRemove];
            renderedRow.destroy();
            delete _this.rowCompsByIndex[indexToRemove];
        });
    };
    // gets called when rows don't change, but viewport does, so after:
    // 1) size of grid changed
    // 2) grid scrolled to new position
    // 3) ensure index visible (which is a scroll)
    RowRenderer.prototype.redrawAfterScroll = function () {
        this.getLockOnRefresh();
        this.redraw(null, false, true);
        this.releaseLockOnRefresh();
    };
    RowRenderer.prototype.removeRowCompsNotToDraw = function (indexesToDraw) {
        // for speedy lookup, dump into map
        var indexesToDrawMap = {};
        indexesToDraw.forEach(function (index) { return indexesToDrawMap[index] = true; });
        var existingIndexes = Object.keys(this.rowCompsByIndex);
        var indexesNotToDraw = utils_1.Utils.filter(existingIndexes, function (index) { return !indexesToDrawMap[index]; });
        this.removeRowComps(indexesNotToDraw);
    };
    RowRenderer.prototype.calculateIndexesToDraw = function () {
        var _this = this;
        // all in all indexes in the viewport
        var indexesToDraw = utils_1.Utils.createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);
        // add in indexes of rows we want to keep, because they are currently editing
        utils_1.Utils.iterateObject(this.rowCompsByIndex, function (indexStr, rowComp) {
            var index = Number(indexStr);
            if (index < _this.firstRenderedRow || index > _this.lastRenderedRow) {
                if (_this.keepRowBecauseEditing(rowComp)) {
                    indexesToDraw.push(index);
                }
            }
        });
        indexesToDraw.sort(function (a, b) { return a - b; });
        return indexesToDraw;
    };
    RowRenderer.prototype.redraw = function (rowsToRecycle, animate, afterScroll) {
        var _this = this;
        if (animate === void 0) { animate = false; }
        if (afterScroll === void 0) { afterScroll = false; }
        this.workOutFirstAndLastRowsToRender();
        // the row can already exist and be in the following:
        // rowsToRecycle -> if model change, then the index may be different, however row may
        //                         exist here from previous time (mapped by id).
        // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport
        // this is all the indexes we want, including those that already exist, so this method
        // will end up going through each index and drawing only if the row doesn't already exist
        var indexesToDraw = this.calculateIndexesToDraw();
        this.removeRowCompsNotToDraw(indexesToDraw);
        // add in new rows
        var nextVmTurnFunctions = [];
        var rowComps = [];
        indexesToDraw.forEach(function (rowIndex) {
            var rowComp = _this.createOrUpdateRowComp(rowIndex, rowsToRecycle, animate, afterScroll);
            if (utils_1.Utils.exists(rowComp)) {
                rowComps.push(rowComp);
                utils_1.Utils.pushAll(nextVmTurnFunctions, rowComp.getAndClearNextVMTurnFunctions());
            }
        });
        this.flushContainers(rowComps);
        utils_1.Utils.executeNextVMTurn(nextVmTurnFunctions);
        if (afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame()) {
            this.beans.taskQueue.addP2Task(this.destroyRowComps.bind(this, rowsToRecycle, animate));
        }
        else {
            this.destroyRowComps(rowsToRecycle, animate);
        }
        this.checkAngularCompile();
    };
    RowRenderer.prototype.flushContainers = function (rowComps) {
        utils_1.Utils.iterateObject(this.rowContainers, function (key, rowContainerComp) {
            if (rowContainerComp) {
                rowContainerComp.flushRowTemplates();
            }
        });
        rowComps.forEach(function (rowComp) { return rowComp.afterFlush(); });
    };
    RowRenderer.prototype.onDisplayedColumnsChanged = function () {
        var pinningLeft = this.columnController.isPinningLeft();
        var pinningRight = this.columnController.isPinningRight();
        var atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;
        if (atLeastOneChanged) {
            this.pinningLeft = pinningLeft;
            this.pinningRight = pinningRight;
            if (this.gridOptionsWrapper.isEmbedFullWidthRows()) {
                this.redrawFullWidthEmbeddedRows();
            }
        }
    };
    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
    // then it should go into the pinned left area if pinning left, or the center area if not pinning.
    RowRenderer.prototype.redrawFullWidthEmbeddedRows = function () {
        // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when
        // embedded, as what appears in each section depends on whether we are pinned or not
        var rowsToRemove = [];
        this.forEachRowComp(function (id, rowComp) {
            if (rowComp.isFullWidth()) {
                var rowIndex = rowComp.getRowNode().rowIndex;
                rowsToRemove.push(rowIndex.toString());
            }
        });
        this.removeRowComps(rowsToRemove);
        this.redrawAfterScroll();
    };
    RowRenderer.prototype.createOrUpdateRowComp = function (rowIndex, rowsToRecycle, animate, afterScroll) {
        var rowNode;
        var rowComp = this.rowCompsByIndex[rowIndex];
        // if no row comp, see if we can get it from the previous rowComps
        if (!rowComp) {
            rowNode = this.paginationProxy.getRow(rowIndex);
            if (utils_1.Utils.exists(rowNode) && utils_1.Utils.exists(rowsToRecycle) && rowsToRecycle[rowNode.id]) {
                rowComp = rowsToRecycle[rowNode.id];
                rowsToRecycle[rowNode.id] = null;
            }
        }
        var creatingNewRowComp = !rowComp;
        if (creatingNewRowComp) {
            // create a new one
            if (!rowNode) {
                rowNode = this.paginationProxy.getRow(rowIndex);
            }
            if (utils_1.Utils.exists(rowNode)) {
                rowComp = this.createRowComp(rowNode, animate, afterScroll);
            }
            else {
                // this should never happen - if somehow we are trying to create
                // a row for a rowNode that does not exist.
                return;
            }
        }
        else {
            // ensure row comp is in right position in DOM
            rowComp.ensureDomOrder();
        }
        this.rowCompsByIndex[rowIndex] = rowComp;
        return rowComp;
    };
    RowRenderer.prototype.destroyRowComps = function (rowCompsMap, animate) {
        var delayedFuncs = [];
        utils_1.Utils.iterateObject(rowCompsMap, function (nodeId, rowComp) {
            // if row was used, then it's null
            if (!rowComp) {
                return;
            }
            rowComp.destroy(animate);
            utils_1.Utils.pushAll(delayedFuncs, rowComp.getAndClearDelayedDestroyFunctions());
        });
        utils_1.Utils.executeInAWhile(delayedFuncs);
    };
    RowRenderer.prototype.checkAngularCompile = function () {
        var _this = this;
        // if we are doing angular compiling, then do digest the scope here
        if (this.gridOptionsWrapper.isAngularCompileRows()) {
            // we do it in a timeout, in case we are already in an apply
            setTimeout(function () { _this.$scope.$apply(); }, 0);
        }
    };
    RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {
        var newFirst;
        var newLast;
        if (!this.paginationProxy.isRowsToRender()) {
            newFirst = 0;
            newLast = -1; // setting to -1 means nothing in range
        }
        else {
            var pageFirstRow = this.paginationProxy.getPageFirstRow();
            var pageLastRow = this.paginationProxy.getPageLastRow();
            if (this.forPrint) {
                newFirst = pageFirstRow;
                newLast = pageLastRow;
            }
            else {
                var pixelOffset = this.paginationProxy ? this.paginationProxy.getPixelOffset() : 0;
                var bodyVRange = this.gridPanel.getVerticalPixelRange();
                var topPixel = bodyVRange.top;
                var bottomPixel = bodyVRange.bottom;
                var first = this.paginationProxy.getRowIndexAtPixel(topPixel + pixelOffset);
                var last = this.paginationProxy.getRowIndexAtPixel(bottomPixel + pixelOffset);
                //add in buffer
                var buffer = this.gridOptionsWrapper.getRowBuffer();
                first = first - buffer;
                last = last + buffer;
                // adjust, in case buffer extended actual size
                if (first < pageFirstRow) {
                    first = pageFirstRow;
                }
                if (last > pageLastRow) {
                    last = pageLastRow;
                }
                newFirst = first;
                newLast = last;
            }
        }
        var firstDiffers = newFirst !== this.firstRenderedRow;
        var lastDiffers = newLast !== this.lastRenderedRow;
        if (firstDiffers || lastDiffers) {
            this.firstRenderedRow = newFirst;
            this.lastRenderedRow = newLast;
            var event_1 = {
                type: events_1.Events.EVENT_VIEWPORT_CHANGED,
                firstRow: newFirst,
                lastRow: newLast,
                api: this.gridApi,
                columnApi: this.columnApi
            };
            this.eventService.dispatchEvent(event_1);
        }
    };
    RowRenderer.prototype.getFirstVirtualRenderedRow = function () {
        return this.firstRenderedRow;
    };
    RowRenderer.prototype.getLastVirtualRenderedRow = function () {
        return this.lastRenderedRow;
    };
    // check that none of the rows to remove are editing or focused as:
    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
    //    the edit is reset - so we want to keep it rendered.
    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
    //    otherwise the user can range select and drag (with focus cell going out of the viewport)
    //    and then ctrl+c, nothing will happen if cell is removed from dom.
    RowRenderer.prototype.keepRowBecauseEditing = function (rowComp) {
        var REMOVE_ROW = false;
        var KEEP_ROW = true;
        var rowNode = rowComp.getRowNode();
        var rowHasFocus = this.focusedCellController.isRowNodeFocused(rowNode);
        var rowIsEditing = rowComp.isEditing();
        var mightWantToKeepRow = rowHasFocus || rowIsEditing;
        // if we deffo don't want to keep it,
        if (!mightWantToKeepRow) {
            return REMOVE_ROW;
        }
        // editing row, only remove if it is no longer rendered, eg filtered out or new data set.
        // the reason we want to keep is if user is scrolling up and down, we don't want to loose
        // the context of the editing in process.
        var rowNodePresent = this.paginationProxy.isRowPresent(rowNode);
        return rowNodePresent ? KEEP_ROW : REMOVE_ROW;
    };
    RowRenderer.prototype.createRowComp = function (rowNode, animate, afterScroll) {
        var useAnimationFrameForCreate = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame();
        var rowComp = new rowComp_1.RowComp(this.$scope, this.rowContainers.body, this.rowContainers.pinnedLeft, this.rowContainers.pinnedRight, this.rowContainers.fullWidth, rowNode, this.beans, animate, useAnimationFrameForCreate);
        rowComp.init();
        return rowComp;
    };
    RowRenderer.prototype.getRenderedNodes = function () {
        var renderedRows = this.rowCompsByIndex;
        return Object.keys(renderedRows).map(function (key) {
            return renderedRows[key].getRowNode();
        });
    };
    // we use index for rows, but column object for columns, as the next column (by index) might not
    // be visible (header grouping) so it's not reliable, so using the column object instead.
    RowRenderer.prototype.navigateToNextCell = function (event, key, rowIndex, column, floating) {
        var previousCell = new gridCell_1.GridCell({ rowIndex: rowIndex, floating: floating, column: column });
        var nextCell = previousCell;
        // we keep searching for a next cell until we find one. this is how the group rows get skipped
        while (true) {
            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);
            if (utils_1.Utils.missing(nextCell)) {
                break;
            }
            var skipGroupRows = this.gridOptionsWrapper.isGroupUseEntireRow();
            if (skipGroupRows) {
                var rowNode = this.paginationProxy.getRow(nextCell.rowIndex);
                if (!rowNode.group) {
                    break;
                }
            }
            else {
                break;
            }
        }
        // allow user to override what cell to go to next
        var userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();
        if (utils_1.Utils.exists(userFunc)) {
            var params = {
                key: key,
                previousCellDef: previousCell,
                nextCellDef: nextCell ? nextCell.getGridCellDef() : null,
                event: event
            };
            var nextCellDef = userFunc(params);
            if (utils_1.Utils.exists(nextCellDef)) {
                nextCell = new gridCell_1.GridCell(nextCellDef);
            }
            else {
                nextCell = null;
            }
        }
        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid
        if (!nextCell) {
            return;
        }
        // this scrolls the row into view
        if (utils_1.Utils.missing(nextCell.floating)) {
            this.gridPanel.ensureIndexVisible(nextCell.rowIndex);
        }
        if (!nextCell.column.isPinned()) {
            this.gridPanel.ensureColumnVisible(nextCell.column);
        }
        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible
        // floating cell, the scrolls get out of sync
        this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();
        // need to flush frames, to make sure the correct cells are rendered
        this.animationFrameService.flushAllFrames();
        this.focusedCellController.setFocusedCell(nextCell.rowIndex, nextCell.column, nextCell.floating, true);
        if (this.rangeController) {
            var gridCell = new gridCell_1.GridCell({ rowIndex: nextCell.rowIndex, floating: nextCell.floating, column: nextCell.column });
            this.rangeController.setRangeToCell(gridCell);
        }
    };
    RowRenderer.prototype.startEditingCell = function (gridCell, keyPress, charPress) {
        var cell = this.getComponentForCell(gridCell);
        if (cell) {
            cell.startRowOrCellEdit(keyPress, charPress);
        }
    };
    RowRenderer.prototype.getComponentForCell = function (gridCell) {
        var rowComponent;
        switch (gridCell.floating) {
            case constants_1.Constants.PINNED_TOP:
                rowComponent = this.floatingTopRowComps[gridCell.rowIndex];
                break;
            case constants_1.Constants.PINNED_BOTTOM:
                rowComponent = this.floatingBottomRowComps[gridCell.rowIndex];
                break;
            default:
                rowComponent = this.rowCompsByIndex[gridCell.rowIndex];
                break;
        }
        if (!rowComponent) {
            return null;
        }
        var cellComponent = rowComponent.getRenderedCellForColumn(gridCell.column);
        return cellComponent;
    };
    RowRenderer.prototype.onTabKeyDown = function (previousRenderedCell, keyboardEvent) {
        var backwards = keyboardEvent.shiftKey;
        var success = this.moveToCellAfter(previousRenderedCell, backwards);
        if (success) {
            keyboardEvent.preventDefault();
        }
    };
    RowRenderer.prototype.tabToNextCell = function (backwards) {
        var focusedCell = this.focusedCellController.getFocusedCell();
        // if no focus, then cannot navigate
        if (utils_1.Utils.missing(focusedCell)) {
            return false;
        }
        var renderedCell = this.getComponentForCell(focusedCell);
        // if cell is not rendered, means user has scrolled away from the cell
        if (utils_1.Utils.missing(renderedCell)) {
            return false;
        }
        var result = this.moveToCellAfter(renderedCell, backwards);
        return result;
    };
    // returns true if moving to next cell was successful
    RowRenderer.prototype.moveToCellAfter = function (previousRenderedCell, backwards) {
        var editing = previousRenderedCell.isEditing();
        var gridCell = previousRenderedCell.getGridCell();
        // find the next cell to start editing
        var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, editing);
        var foundCell = utils_1.Utils.exists(nextRenderedCell);
        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default
        // to the normal tabbing so user can exit the grid.
        if (foundCell) {
            if (editing) {
                if (this.gridOptionsWrapper.isFullRowEdit()) {
                    this.moveEditToNextCellOrRow(previousRenderedCell, nextRenderedCell);
                }
                else {
                    this.moveEditToNextCell(previousRenderedCell, nextRenderedCell);
                }
            }
            else {
                nextRenderedCell.focusCell(true);
            }
            return true;
        }
        else {
            return false;
        }
    };
    RowRenderer.prototype.moveEditToNextCell = function (previousRenderedCell, nextRenderedCell) {
        previousRenderedCell.stopEditing();
        nextRenderedCell.startEditingIfEnabled(null, null, true);
        nextRenderedCell.focusCell(false);
    };
    RowRenderer.prototype.moveEditToNextCellOrRow = function (previousRenderedCell, nextRenderedCell) {
        var pGridCell = previousRenderedCell.getGridCell();
        var nGridCell = nextRenderedCell.getGridCell();
        var rowsMatch = (pGridCell.rowIndex === nGridCell.rowIndex)
            && (pGridCell.floating === nGridCell.floating);
        if (rowsMatch) {
            // same row, so we don't start / stop editing, we just move the focus along
            previousRenderedCell.setFocusOutOnEditor();
            nextRenderedCell.setFocusInOnEditor();
        }
        else {
            var pRow = previousRenderedCell.getRenderedRow();
            var nRow = nextRenderedCell.getRenderedRow();
            previousRenderedCell.setFocusOutOnEditor();
            pRow.stopEditing();
            nRow.startRowEditing();
            nextRenderedCell.setFocusInOnEditor();
        }
        nextRenderedCell.focusCell();
    };
    // called by the cell, when tab is pressed while editing.
    // @return: RenderedCell when navigation successful, otherwise null
    RowRenderer.prototype.findNextCellToFocusOn = function (gridCell, backwards, startEditing) {
        var nextCell = gridCell;
        while (true) {
            nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, backwards);
            // allow user to override what cell to go to next
            var userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();
            if (utils_1.Utils.exists(userFunc)) {
                var params = {
                    backwards: backwards,
                    editing: startEditing,
                    previousCellDef: gridCell.getGridCellDef(),
                    nextCellDef: nextCell ? nextCell.getGridCellDef() : null
                };
                var nextCellDef = userFunc(params);
                if (utils_1.Utils.exists(nextCellDef)) {
                    nextCell = new gridCell_1.GridCell(nextCellDef);
                }
                else {
                    nextCell = null;
                }
            }
            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,
            // so bottom right cell going forwards, or top left going backwards
            if (!nextCell) {
                return null;
            }
            // this scrolls the row into view
            var cellIsNotFloating = utils_1.Utils.missing(nextCell.floating);
            if (cellIsNotFloating) {
                this.gridPanel.ensureIndexVisible(nextCell.rowIndex);
            }
            // pinned columns don't scroll, so no need to ensure index visible
            if (!nextCell.column.isPinned()) {
                this.gridPanel.ensureColumnVisible(nextCell.column);
            }
            // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible
            // floating cell, the scrolls get out of sync
            this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();
            // get the grid panel to flush all animation frames - otherwise the call below to get the cellComp
            // could fail, if we just scrolled the grid (to make a cell visible) and the rendering hasn't finished.
            this.animationFrameService.flushAllFrames();
            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column
            // or row that is not currently in view, hence the renderedCell would not exist
            var nextCellComp = this.getComponentForCell(nextCell);
            // if next cell is fullWidth row, then no rendered cell,
            // as fullWidth rows have no cells, so we skip it
            if (utils_1.Utils.missing(nextCellComp)) {
                continue;
            }
            // if editing, but cell not editable, skip cell
            if (startEditing && !nextCellComp.isCellEditable()) {
                continue;
            }
            if (nextCellComp.isSuppressNavigable()) {
                continue;
            }
            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation
            // consistent, we set into range here also.
            if (this.rangeController) {
                var gridCell_2 = new gridCell_1.GridCell({ rowIndex: nextCell.rowIndex, floating: nextCell.floating, column: nextCell.column });
                this.rangeController.setRangeToCell(gridCell_2);
            }
            // we successfully tabbed onto a grid cell, so return true
            return nextCellComp;
        }
    };
    __decorate([
        context_1.Autowired('paginationProxy'),
        __metadata("design:type", paginationProxy_1.PaginationProxy)
    ], RowRenderer.prototype, "paginationProxy", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], RowRenderer.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], RowRenderer.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('gridCore'),
        __metadata("design:type", gridCore_1.GridCore)
    ], RowRenderer.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], RowRenderer.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('$scope'),
        __metadata("design:type", Object)
    ], RowRenderer.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('expressionService'),
        __metadata("design:type", expressionService_1.ExpressionService)
    ], RowRenderer.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('templateService'),
        __metadata("design:type", templateService_1.TemplateService)
    ], RowRenderer.prototype, "templateService", void 0);
    __decorate([
        context_1.Autowired('valueService'),
        __metadata("design:type", valueService_1.ValueService)
    ], RowRenderer.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], RowRenderer.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('pinnedRowModel'),
        __metadata("design:type", pinnedRowModel_1.PinnedRowModel)
    ], RowRenderer.prototype, "pinnedRowModel", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], RowRenderer.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('loggerFactory'),
        __metadata("design:type", logger_1.LoggerFactory)
    ], RowRenderer.prototype, "loggerFactory", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'),
        __metadata("design:type", focusedCellController_1.FocusedCellController)
    ], RowRenderer.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Autowired('cellNavigationService'),
        __metadata("design:type", cellNavigationService_1.CellNavigationService)
    ], RowRenderer.prototype, "cellNavigationService", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], RowRenderer.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], RowRenderer.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('beans'),
        __metadata("design:type", beans_1.Beans)
    ], RowRenderer.prototype, "beans", void 0);
    __decorate([
        context_1.Autowired('animationFrameService'),
        __metadata("design:type", animationFrameService_1.AnimationFrameService)
    ], RowRenderer.prototype, "animationFrameService", void 0);
    __decorate([
        context_1.Optional('rangeController'),
        __metadata("design:type", Object)
    ], RowRenderer.prototype, "rangeController", void 0);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], RowRenderer.prototype, "agWire", null);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], RowRenderer.prototype, "init", null);
    __decorate([
        context_1.PreDestroy,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], RowRenderer.prototype, "destroy", null);
    RowRenderer = __decorate([
        context_1.Bean('rowRenderer')
    ], RowRenderer);
    return RowRenderer;
}(beanStub_1.BeanStub));
exports.RowRenderer = RowRenderer;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(11);
var context_1 = __webpack_require__(0);
var context_2 = __webpack_require__(0);
var ExpressionService = (function () {
    function ExpressionService() {
        this.expressionToFunctionCache = {};
    }
    ExpressionService.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('ExpressionService');
    };
    ExpressionService.prototype.evaluate = function (expressionOrFunc, params) {
        if (typeof expressionOrFunc === 'function') {
            // valueGetter is a function, so just call it
            var func = expressionOrFunc;
            return func(params);
        }
        else if (typeof expressionOrFunc === 'string') {
            // valueGetter is an expression, so execute the expression
            var expression = expressionOrFunc;
            return this.evaluateExpression(expression, params);
        }
        else {
            console.error('ag-Grid: value should be either a string or a function', expressionOrFunc);
        }
    };
    ExpressionService.prototype.evaluateExpression = function (expression, params) {
        try {
            var javaScriptFunction = this.createExpressionFunction(expression);
            // the params don't have all these values, rather we add every possible
            // value a params can have, which makes whatever is in the params available.
            var result = javaScriptFunction(params.value, params.context, params.oldValue, params.newValue, params.value, params.node, params.data, params.colDef, params.rowIndex, params.api, params.columnApi, params.getValue, params.column, params.columnGroup);
            return result;
        }
        catch (e) {
            // the expression failed, which can happen, as it's the client that
            // provides the expression. so print a nice message
            console.log('Processing of the expression failed');
            console.log('Expression = ' + expression);
            console.log('Exception = ' + e);
            return null;
        }
    };
    ExpressionService.prototype.createExpressionFunction = function (expression) {
        // check cache first
        if (this.expressionToFunctionCache[expression]) {
            return this.expressionToFunctionCache[expression];
        }
        // if not found in cache, return the function
        var functionBody = this.createFunctionBody(expression);
        var theFunction = new Function('x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup', functionBody);
        // store in cache
        this.expressionToFunctionCache[expression] = theFunction;
        return theFunction;
    };
    ExpressionService.prototype.createFunctionBody = function (expression) {
        // if the expression has the 'return' word in it, then use as is,
        // if not, then wrap it with return and ';' to make a function
        if (expression.indexOf('return') >= 0) {
            return expression;
        }
        else {
            return 'return ' + expression + ';';
        }
    };
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], ExpressionService.prototype, "setBeans", null);
    ExpressionService = __decorate([
        context_1.Bean('expressionService')
    ], ExpressionService);
    return ExpressionService;
}());
exports.ExpressionService = ExpressionService;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var expressionService_1 = __webpack_require__(19);
var columnController_1 = __webpack_require__(3);
var context_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(1);
var events_1 = __webpack_require__(5);
var eventService_1 = __webpack_require__(4);
var valueCache_1 = __webpack_require__(36);
var ValueService = (function () {
    function ValueService() {
        this.initialised = false;
    }
    ValueService.prototype.init = function () {
        this.cellExpressions = this.gridOptionsWrapper.isEnableCellExpressions();
        this.initialised = true;
    };
    ValueService.prototype.getValue = function (column, rowNode, ignoreAggData) {
        // console.log(`turnActive = ${this.turnActive}`);
        if (ignoreAggData === void 0) { ignoreAggData = false; }
        // hack - the grid is getting refreshed before this bean gets initialised, race condition.
        // really should have a way so they get initialised in the right order???
        if (!this.initialised) {
            this.init();
        }
        // pull these out to make code below easier to read
        var colDef = column.getColDef();
        var field = colDef.field;
        var colId = column.getId();
        var data = rowNode.data;
        var result;
        // if there is a value getter, this gets precedence over a field
        var groupDataExists = rowNode.groupData && rowNode.groupData[colId] !== undefined;
        var aggDataExists = !ignoreAggData && rowNode.aggData && rowNode.aggData[colId] !== undefined;
        if (groupDataExists) {
            result = rowNode.groupData[colId];
        }
        else if (aggDataExists) {
            result = rowNode.aggData[colId];
        }
        else if (colDef.valueGetter) {
            result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
        }
        else if (field && data) {
            result = utils_1._.getValueUsingField(data, field, column.isFieldContainsDots());
        }
        else {
            result = undefined;
        }
        // the result could be an expression itself, if we are allowing cell values to be expressions
        if (this.cellExpressions && (typeof result === 'string') && result.indexOf('=') === 0) {
            var cellValueGetter = result.substring(1);
            result = this.executeValueGetter(cellValueGetter, data, column, rowNode);
        }
        return result;
    };
    ValueService.prototype.setValue = function (rowNode, colKey, newValue) {
        var column = this.columnController.getPrimaryColumn(colKey);
        if (!rowNode || !column) {
            return;
        }
        // this will only happen if user is trying to paste into a group row, which doesn't make sense
        // the user should not be trying to paste into group rows
        var data = rowNode.data;
        if (utils_1._.missing(data)) {
            rowNode.data = {};
        }
        // for backwards compatibility we are also retrieving the newValueHandler as well as the valueSetter
        var _a = column.getColDef(), field = _a.field, newValueHandler = _a.newValueHandler, valueSetter = _a.valueSetter;
        // need either a field or a newValueHandler for this to work
        if (utils_1._.missing(field) && utils_1._.missing(newValueHandler) && utils_1._.missing(valueSetter)) {
            // we don't tell user about newValueHandler, as that is deprecated
            console.warn("ag-Grid: you need either field or valueSetter set on colDef for editing to work");
            return;
        }
        var params = {
            node: rowNode,
            data: rowNode.data,
            oldValue: this.getValue(column, rowNode),
            newValue: newValue,
            colDef: column.getColDef(),
            column: column,
            api: this.gridOptionsWrapper.getApi(),
            columnApi: this.gridOptionsWrapper.getColumnApi(),
            context: this.gridOptionsWrapper.getContext()
        };
        params.newValue = newValue;
        var valueWasDifferent;
        if (utils_1._.exists(newValueHandler)) {
            valueWasDifferent = newValueHandler(params);
        }
        else if (utils_1._.exists(valueSetter)) {
            valueWasDifferent = this.expressionService.evaluate(valueSetter, params);
        }
        else {
            valueWasDifferent = this.setValueUsingField(data, field, newValue, column.isFieldContainsDots());
        }
        // in case user forgot to return something (possible if they are not using TypeScript
        // and just forgot, or using an old newValueHandler we didn't always expect a return
        // value here), we default the return value to true, so we always refresh.
        if (valueWasDifferent === undefined) {
            valueWasDifferent = true;
        }
        // if no change to the value, then no need to do the updating, or notifying via events.
        // otherwise the user could be tabbing around the grid, and cellValueChange would get called
        // all the time.
        if (!valueWasDifferent) {
            return;
        }
        // reset quick filter on this row
        rowNode.resetQuickFilterAggregateText();
        this.valueCache.onDataChanged();
        params.newValue = this.getValue(column, rowNode);
        if (typeof column.getColDef().onCellValueChanged === 'function') {
            column.getColDef().onCellValueChanged(params);
        }
        var event = {
            type: events_1.Events.EVENT_CELL_VALUE_CHANGED,
            event: null,
            rowIndex: rowNode.rowIndex,
            rowPinned: rowNode.rowPinned,
            column: params.column,
            api: params.api,
            colDef: params.colDef,
            columnApi: params.columnApi,
            context: params.context,
            data: rowNode.data,
            node: rowNode,
            oldValue: params.oldValue,
            newValue: params.newValue,
            value: params.newValue
        };
        this.eventService.dispatchEvent(event);
    };
    ValueService.prototype.setValueUsingField = function (data, field, newValue, isFieldContainsDots) {
        // if no '.', then it's not a deep value
        var valuesAreSame;
        if (!isFieldContainsDots) {
            data[field] = newValue;
        }
        else {
            // otherwise it is a deep value, so need to dig for it
            var fieldPieces = field.split('.');
            var currentObject = data;
            while (fieldPieces.length > 0 && currentObject) {
                var fieldPiece = fieldPieces.shift();
                if (fieldPieces.length === 0) {
                    currentObject[fieldPiece] = newValue;
                }
                else {
                    currentObject = currentObject[fieldPiece];
                }
            }
        }
        return !valuesAreSame;
    };
    ValueService.prototype.executeValueGetter = function (valueGetter, data, column, rowNode) {
        var colId = column.getId();
        // if inside the same turn, just return back the value we got last time
        var valueFromCache = this.valueCache.getValue(rowNode, colId);
        if (valueFromCache !== undefined) {
            return valueFromCache;
        }
        var params = {
            data: data,
            node: rowNode,
            column: column,
            colDef: column.getColDef(),
            api: this.gridOptionsWrapper.getApi(),
            columnApi: this.gridOptionsWrapper.getColumnApi(),
            context: this.gridOptionsWrapper.getContext(),
            getValue: this.getValueCallback.bind(this, rowNode)
        };
        var result = this.expressionService.evaluate(valueGetter, params);
        // if a turn is active, store the value in case the grid asks for it again
        this.valueCache.setValue(rowNode, colId, result);
        return result;
    };
    ValueService.prototype.getValueCallback = function (node, field) {
        var otherColumn = this.columnController.getPrimaryColumn(field);
        if (otherColumn) {
            return this.getValue(otherColumn, node);
        }
        else {
            return null;
        }
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ValueService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'),
        __metadata("design:type", expressionService_1.ExpressionService)
    ], ValueService.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], ValueService.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], ValueService.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('valueCache'),
        __metadata("design:type", valueCache_1.ValueCache)
    ], ValueService.prototype, "valueCache", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ValueService.prototype, "init", null);
    ValueService = __decorate([
        context_1.Bean('valueService')
    ], ValueService);
    return ValueService;
}());
exports.ValueService = ValueService;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(11);
var context_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var dragService_1 = __webpack_require__(50);
var columnController_1 = __webpack_require__(3);
var environment_1 = __webpack_require__(51);
var DragSourceType;
(function (DragSourceType) {
    DragSourceType[DragSourceType["ToolPanel"] = 0] = "ToolPanel";
    DragSourceType[DragSourceType["HeaderCell"] = 1] = "HeaderCell";
})(DragSourceType = exports.DragSourceType || (exports.DragSourceType = {}));
var VDirection;
(function (VDirection) {
    VDirection[VDirection["Up"] = 0] = "Up";
    VDirection[VDirection["Down"] = 1] = "Down";
})(VDirection = exports.VDirection || (exports.VDirection = {}));
var HDirection;
(function (HDirection) {
    HDirection[HDirection["Left"] = 0] = "Left";
    HDirection[HDirection["Right"] = 1] = "Right";
})(HDirection = exports.HDirection || (exports.HDirection = {}));
var DragAndDropService = (function () {
    function DragAndDropService() {
        this.dragSourceAndParamsList = [];
        this.dropTargets = [];
    }
    DragAndDropService_1 = DragAndDropService;
    DragAndDropService.prototype.init = function () {
        this.ePinnedIcon = utils_1.Utils.createIcon('columnMovePin', this.gridOptionsWrapper, null);
        this.ePlusIcon = utils_1.Utils.createIcon('columnMoveAdd', this.gridOptionsWrapper, null);
        this.eHiddenIcon = utils_1.Utils.createIcon('columnMoveHide', this.gridOptionsWrapper, null);
        this.eMoveIcon = utils_1.Utils.createIcon('columnMoveMove', this.gridOptionsWrapper, null);
        this.eLeftIcon = utils_1.Utils.createIcon('columnMoveLeft', this.gridOptionsWrapper, null);
        this.eRightIcon = utils_1.Utils.createIcon('columnMoveRight', this.gridOptionsWrapper, null);
        this.eGroupIcon = utils_1.Utils.createIcon('columnMoveGroup', this.gridOptionsWrapper, null);
        this.eAggregateIcon = utils_1.Utils.createIcon('columnMoveValue', this.gridOptionsWrapper, null);
        this.ePivotIcon = utils_1.Utils.createIcon('columnMovePivot', this.gridOptionsWrapper, null);
        this.eDropNotAllowedIcon = utils_1.Utils.createIcon('dropNotAllowed', this.gridOptionsWrapper, null);
    };
    DragAndDropService.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('OldToolPanelDragAndDropService');
    };
    DragAndDropService.prototype.addDragSource = function (dragSource, allowTouch) {
        if (allowTouch === void 0) { allowTouch = false; }
        var params = {
            eElement: dragSource.eElement,
            onDragStart: this.onDragStart.bind(this, dragSource),
            onDragStop: this.onDragStop.bind(this),
            onDragging: this.onDragging.bind(this)
        };
        this.dragSourceAndParamsList.push({ params: params, dragSource: dragSource });
        this.dragService.addDragSource(params, allowTouch);
    };
    DragAndDropService.prototype.removeDragSource = function (dragSource) {
        var sourceAndParams = utils_1.Utils.find(this.dragSourceAndParamsList, function (item) { return item.dragSource === dragSource; });
        if (sourceAndParams) {
            this.dragService.removeDragSource(sourceAndParams.params);
            utils_1.Utils.removeFromArray(this.dragSourceAndParamsList, sourceAndParams);
        }
    };
    DragAndDropService.prototype.destroy = function () {
        var _this = this;
        this.dragSourceAndParamsList.forEach(function (sourceAndParams) {
            _this.dragService.removeDragSource(sourceAndParams.params);
        });
        this.dragSourceAndParamsList.length = 0;
    };
    DragAndDropService.prototype.nudge = function () {
        if (this.dragging) {
            this.onDragging(this.eventLastTime, true);
        }
    };
    DragAndDropService.prototype.onDragStart = function (dragSource, mouseEvent) {
        this.dragging = true;
        this.dragSource = dragSource;
        this.eventLastTime = mouseEvent;
        this.dragItem = this.dragSource.dragItemCallback();
        this.dragItem.columns.forEach(function (column) { return column.setMoving(true); });
        this.lastDropTarget = this.dragSource.dragSourceDropTarget;
        this.createGhost();
    };
    DragAndDropService.prototype.onDragStop = function (mouseEvent) {
        this.eventLastTime = null;
        this.dragging = false;
        this.dragItem.columns.forEach(function (column) { return column.setMoving(false); });
        if (this.lastDropTarget && this.lastDropTarget.onDragStop) {
            var draggingEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, null, null, false);
            this.lastDropTarget.onDragStop(draggingEvent);
        }
        this.lastDropTarget = null;
        this.dragItem = null;
        this.removeGhost();
    };
    DragAndDropService.prototype.onDragging = function (mouseEvent, fromNudge) {
        var hDirection = this.workOutHDirection(mouseEvent);
        var vDirection = this.workOutVDirection(mouseEvent);
        this.eventLastTime = mouseEvent;
        this.positionGhost(mouseEvent);
        // check if mouseEvent intersects with any of the drop targets
        var dropTarget = utils_1.Utils.find(this.dropTargets, this.isMouseOnDropTarget.bind(this, mouseEvent));
        if (dropTarget !== this.lastDropTarget) {
            this.leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge);
            this.enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            this.lastDropTarget = dropTarget;
        }
        else if (dropTarget) {
            var draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            dropTarget.onDragging(draggingEvent);
        }
    };
    DragAndDropService.prototype.enterDragTargetIfExists = function (dropTarget, mouseEvent, hDirection, vDirection, fromNudge) {
        if (!dropTarget) {
            return;
        }
        var dragEnterEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
        dropTarget.onDragEnter(dragEnterEvent);
        this.setGhostIcon(dropTarget.getIconName ? dropTarget.getIconName() : null);
    };
    DragAndDropService.prototype.leaveLastTargetIfExists = function (mouseEvent, hDirection, vDirection, fromNudge) {
        if (!this.lastDropTarget) {
            return;
        }
        var dragLeaveEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, hDirection, vDirection, fromNudge);
        this.lastDropTarget.onDragLeave(dragLeaveEvent);
        this.setGhostIcon(null);
    };
    DragAndDropService.prototype.getAllContainersFromDropTarget = function (dropTarget) {
        var containers = [dropTarget.getContainer()];
        var secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
        if (secondaryContainers) {
            containers = containers.concat(secondaryContainers);
        }
        return containers;
    };
    // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
    DragAndDropService.prototype.isMouseOnDropTarget = function (mouseEvent, dropTarget) {
        var allContainers = this.getAllContainersFromDropTarget(dropTarget);
        var gotMatch = false;
        allContainers.forEach(function (eContainer) {
            if (!eContainer) {
                return;
            } // secondary can be missing
            var rect = eContainer.getBoundingClientRect();
            // if element is not visible, then width and height are zero
            if (rect.width === 0 || rect.height === 0) {
                return;
            }
            var horizontalFit = mouseEvent.clientX >= rect.left && mouseEvent.clientX <= rect.right;
            var verticalFit = mouseEvent.clientY >= rect.top && mouseEvent.clientY <= rect.bottom;
            //console.log(`rect.width = ${rect.width} || rect.height = ${rect.height} ## verticalFit = ${verticalFit}, horizontalFit = ${horizontalFit}, `);
            if (horizontalFit && verticalFit) {
                gotMatch = true;
            }
        });
        return gotMatch;
    };
    DragAndDropService.prototype.addDropTarget = function (dropTarget) {
        this.dropTargets.push(dropTarget);
    };
    DragAndDropService.prototype.workOutHDirection = function (event) {
        if (this.eventLastTime.clientX > event.clientX) {
            return HDirection.Left;
        }
        else if (this.eventLastTime.clientX < event.clientX) {
            return HDirection.Right;
        }
        else {
            return null;
        }
    };
    DragAndDropService.prototype.workOutVDirection = function (event) {
        if (this.eventLastTime.clientY > event.clientY) {
            return VDirection.Up;
        }
        else if (this.eventLastTime.clientY < event.clientY) {
            return VDirection.Down;
        }
        else {
            return null;
        }
    };
    DragAndDropService.prototype.createDropTargetEvent = function (dropTarget, event, hDirection, vDirection, fromNudge) {
        // localise x and y to the target component
        var rect = dropTarget.getContainer().getBoundingClientRect();
        var x = event.clientX - rect.left;
        var y = event.clientY - rect.top;
        var dropTargetEvent = {
            event: event,
            x: x,
            y: y,
            vDirection: vDirection,
            hDirection: hDirection,
            dragSource: this.dragSource,
            fromNudge: fromNudge,
            dragItem: this.dragItem
        };
        return dropTargetEvent;
    };
    DragAndDropService.prototype.positionGhost = function (event) {
        var ghostRect = this.eGhost.getBoundingClientRect();
        var ghostHeight = ghostRect.height;
        // for some reason, without the '-2', it still overlapped by 1 or 2 pixels, which
        // then brought in scrollbars to the browser. no idea why, but putting in -2 here
        // works around it which is good enough for me.
        var browserWidth = utils_1.Utils.getBodyWidth() - 2;
        var browserHeight = utils_1.Utils.getBodyHeight() - 2;
        // put ghost vertically in middle of cursor
        var top = event.pageY - (ghostHeight / 2);
        // horizontally, place cursor just right of icon
        var left = event.pageX - 30;
        var usrDocument = this.gridOptionsWrapper.getDocument();
        var windowScrollY = window.pageYOffset || usrDocument.documentElement.scrollTop;
        var windowScrollX = window.pageXOffset || usrDocument.documentElement.scrollLeft;
        // check ghost is not positioned outside of the browser
        if (browserWidth > 0) {
            if ((left + this.eGhost.clientWidth) > (browserWidth + windowScrollX)) {
                left = browserWidth + windowScrollX - this.eGhost.clientWidth;
            }
        }
        if (left < 0) {
            left = 0;
        }
        if (browserHeight > 0) {
            if ((top + this.eGhost.clientHeight) > (browserHeight + windowScrollY)) {
                top = browserHeight + windowScrollY - this.eGhost.clientHeight;
            }
        }
        if (top < 0) {
            top = 0;
        }
        this.eGhost.style.left = left + 'px';
        this.eGhost.style.top = top + 'px';
    };
    DragAndDropService.prototype.removeGhost = function () {
        if (this.eGhost && this.eGhostParent) {
            this.eGhostParent.removeChild(this.eGhost);
        }
        this.eGhost = null;
    };
    DragAndDropService.prototype.createGhost = function () {
        this.eGhost = utils_1.Utils.loadTemplate(DragAndDropService_1.GHOST_TEMPLATE);
        this.eGhost.classList.add(this.environment.getTheme());
        this.eGhostIcon = this.eGhost.querySelector('.ag-dnd-ghost-icon');
        this.setGhostIcon(null);
        var eText = this.eGhost.querySelector('.ag-dnd-ghost-label');
        eText.innerHTML = this.dragSource.dragItemName;
        this.eGhost.style.height = '25px';
        this.eGhost.style.top = '20px';
        this.eGhost.style.left = '20px';
        var usrDocument = this.gridOptionsWrapper.getDocument();
        this.eGhostParent = usrDocument.querySelector('body');
        if (!this.eGhostParent) {
            console.warn('ag-Grid: could not find document body, it is needed for dragging columns');
        }
        else {
            this.eGhostParent.appendChild(this.eGhost);
        }
    };
    DragAndDropService.prototype.setGhostIcon = function (iconName, shake) {
        if (shake === void 0) { shake = false; }
        utils_1.Utils.removeAllChildren(this.eGhostIcon);
        var eIcon;
        switch (iconName) {
            case DragAndDropService_1.ICON_ADD:
                eIcon = this.ePlusIcon;
                break;
            case DragAndDropService_1.ICON_PINNED:
                eIcon = this.ePinnedIcon;
                break;
            case DragAndDropService_1.ICON_MOVE:
                eIcon = this.eMoveIcon;
                break;
            case DragAndDropService_1.ICON_LEFT:
                eIcon = this.eLeftIcon;
                break;
            case DragAndDropService_1.ICON_RIGHT:
                eIcon = this.eRightIcon;
                break;
            case DragAndDropService_1.ICON_GROUP:
                eIcon = this.eGroupIcon;
                break;
            case DragAndDropService_1.ICON_AGGREGATE:
                eIcon = this.eAggregateIcon;
                break;
            case DragAndDropService_1.ICON_PIVOT:
                eIcon = this.ePivotIcon;
                break;
            case DragAndDropService_1.ICON_NOT_ALLOWED:
                eIcon = this.eDropNotAllowedIcon;
                break;
            default:
                eIcon = this.eHiddenIcon;
                break;
        }
        this.eGhostIcon.appendChild(eIcon);
        utils_1.Utils.addOrRemoveCssClass(this.eGhostIcon, 'ag-shake-left-to-right', shake);
    };
    DragAndDropService.ICON_PINNED = 'pinned';
    DragAndDropService.ICON_ADD = 'add';
    DragAndDropService.ICON_MOVE = 'move';
    DragAndDropService.ICON_LEFT = 'left';
    DragAndDropService.ICON_RIGHT = 'right';
    DragAndDropService.ICON_GROUP = 'group';
    DragAndDropService.ICON_AGGREGATE = 'aggregate';
    DragAndDropService.ICON_PIVOT = 'pivot';
    DragAndDropService.ICON_NOT_ALLOWED = 'notAllowed';
    DragAndDropService.GHOST_TEMPLATE = '<div class="ag-dnd-ghost">' +
        '  <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>' +
        '  <div class="ag-dnd-ghost-label">' +
        '  </div>' +
        '</div>';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], DragAndDropService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('dragService'),
        __metadata("design:type", dragService_1.DragService)
    ], DragAndDropService.prototype, "dragService", void 0);
    __decorate([
        context_1.Autowired('environment'),
        __metadata("design:type", environment_1.Environment)
    ], DragAndDropService.prototype, "environment", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], DragAndDropService.prototype, "columnController", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], DragAndDropService.prototype, "init", null);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], DragAndDropService.prototype, "setBeans", null);
    __decorate([
        context_1.PreDestroy,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], DragAndDropService.prototype, "destroy", null);
    DragAndDropService = DragAndDropService_1 = __decorate([
        context_1.Bean('dragAndDropService')
    ], DragAndDropService);
    return DragAndDropService;
    var DragAndDropService_1;
}());
exports.DragAndDropService = DragAndDropService;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(1);
var namedComponentResolver_1 = __webpack_require__(96);
var agComponentUtils_1 = __webpack_require__(48);
var componentMetadataProvider_1 = __webpack_require__(67);
var ComponentType;
(function (ComponentType) {
    ComponentType[ComponentType["AG_GRID"] = 0] = "AG_GRID";
    ComponentType[ComponentType["FRAMEWORK"] = 1] = "FRAMEWORK";
})(ComponentType = exports.ComponentType || (exports.ComponentType = {}));
var ComponentSource;
(function (ComponentSource) {
    ComponentSource[ComponentSource["DEFAULT"] = 0] = "DEFAULT";
    ComponentSource[ComponentSource["REGISTERED_BY_NAME"] = 1] = "REGISTERED_BY_NAME";
    ComponentSource[ComponentSource["HARDCODED"] = 2] = "HARDCODED";
})(ComponentSource = exports.ComponentSource || (exports.ComponentSource = {}));
var ComponentResolver = (function () {
    function ComponentResolver() {
    }
    /**
     * This method returns the underlying representation of the component to be created. ie for Javascript the
     * underlying function where we should be calling new into. In case of the frameworks, the framework class
     * object that represents the component to be created.
     *
     * This method is handy for different reasons, for example if you want to check if a component has a particular
     * method implemented without having to create the component, just by inspecting the source component
     *
     * It takes
     *  @param holder: This is the context for which this component needs to be created, it can be gridOptions
     *      (global) or columnDef mostly.
     *  @param propertyName: The name of the property used in ag-grid as a convention to refer to the component, it can be:
     *      'floatingFilter', 'cellRenderer', is used to find if the user is specifying a custom component
     *  @param componentNameOpt: The actual name of the component to instantiate, this is usually the same as propertyName, but in
     *      some cases is not, like floatingFilter, if it is the same is not necessary to specify
     *  @param mandatory: Handy method to tell if this should return a component ALWAYS. if that is the case, but there is no
     *      component found, it throws an error, by default all components are MANDATORY
     */
    ComponentResolver.prototype.getComponentToUse = function (holder, propertyName, componentNameOpt) {
        var componentName = componentNameOpt == null ? propertyName : componentNameOpt;
        /**
         * There are five things that can happen when resolving a component.
         *  a) HardcodedFwComponent: That holder[propertyName]Framework has associated a Framework native component
         *  b) HardcodedJsComponent: That holder[propertyName] has associate a JS component
         *  c) hardcodedJsFunction: That holder[propertyName] has associate a JS function
         *  d) hardcodedNameComponent: That holder[propertyName] has associate a string that represents a component to load
         *  e) That none of the three previous are specified, then we need to use the DefaultRegisteredComponent
         */
        var hardcodedNameComponent = null;
        var HardcodedJsComponent = null;
        var hardcodedJsFunction = null;
        var HardcodedFwComponent = null;
        if (holder != null) {
            var componentPropertyValue = holder[propertyName];
            if (componentPropertyValue != null) {
                if (typeof componentPropertyValue === 'string') {
                    hardcodedNameComponent = componentPropertyValue;
                }
                else if (this.agComponentUtils.doesImplementIComponent(componentPropertyValue)) {
                    HardcodedJsComponent = componentPropertyValue;
                }
                else {
                    hardcodedJsFunction = componentPropertyValue;
                }
            }
            HardcodedFwComponent = holder[propertyName + "Framework"];
        }
        /**
         * Since we allow many types of flavors for specifying the components, let's make sure this is not an illegal
         * combination
         */
        if ((HardcodedJsComponent && HardcodedFwComponent) ||
            (hardcodedNameComponent && HardcodedFwComponent) ||
            (hardcodedJsFunction && HardcodedFwComponent)) {
            throw Error("You are trying to specify: " + propertyName + " twice as a component.");
        }
        if (HardcodedFwComponent && !this.frameworkComponentWrapper) {
            throw Error("You are specifying a framework component but you are not using a framework version of ag-grid for : " + propertyName);
        }
        /**
         * At this stage we are guaranteed to either have,
         * DEPRECATED
         * - A unique HardcodedFwComponent
         * - A unique HardcodedJsComponent
         * - A unique hardcodedJsFunction
         * BY NAME- FAVOURED APPROACH
         * - A unique hardcodedNameComponent
         * - None of the previous, hence we revert to: RegisteredComponent
         */
        if (HardcodedFwComponent) {
            // console.warn(`ag-grid: Since version 12.1.0 specifying a component directly is deprecated, you should register the component by name`);
            // console.warn(`${HardcodedFwComponent}`);
            return {
                type: ComponentType.FRAMEWORK,
                component: HardcodedFwComponent,
                source: ComponentSource.HARDCODED
            };
        }
        if (HardcodedJsComponent) {
            // console.warn(`ag-grid: Since version 12.1.0 specifying a component directly is deprecated, you should register the component by name`);
            // console.warn(`${HardcodedJsComponent}`);
            return {
                type: ComponentType.AG_GRID,
                component: HardcodedJsComponent,
                source: ComponentSource.HARDCODED
            };
        }
        if (hardcodedJsFunction) {
            // console.warn(`ag-grid: Since version 12.1.0 specifying a function directly is deprecated, you should register the component by name`);
            // console.warn(`${hardcodedJsFunction}`);
            return this.agComponentUtils.adaptFunction(propertyName, hardcodedJsFunction, ComponentType.AG_GRID, ComponentSource.HARDCODED);
        }
        //^^^^^ABOVE DEPRECATED
        var componentNameToUse;
        if (hardcodedNameComponent) {
            componentNameToUse = hardcodedNameComponent;
        }
        else {
            componentNameToUse = componentName;
        }
        return this.namedComponentResolver.resolve(propertyName, componentNameToUse);
    };
    /**
     * Useful to check what would be the resultant params for a given object
     *  @param holder: This is the context for which this component needs to be created, it can be gridOptions
     *      (global) or columnDef mostly.
     *  @param propertyName: The name of the property used in ag-grid as a convention to refer to the component, it can be:
     *      'floatingFilter', 'cellRenderer', is used to find if the user is specifying a custom component
     *  @param agGridParams: Params to be passed to the component and passed by ag-Grid. This will get merged with any params
     *      specified by the user in the configuration
     * @returns {any} It merges the user agGridParams with the actual params specified by the user.
     */
    ComponentResolver.prototype.mergeParams = function (holder, propertyName, agGridParams) {
        var customParams = holder ? holder[propertyName + "Params"] : null;
        var finalParams = {};
        utils_1._.mergeDeep(finalParams, agGridParams);
        utils_1._.mergeDeep(finalParams, customParams);
        if (!finalParams.api) {
            finalParams.api = this.gridOptions.api;
        }
        return finalParams;
    };
    /**
     * This method creates a component given everything needed to guess what sort of component needs to be instantiated
     * It takes
     *  @param holderOpt: This is the context for which this component needs to be created, it can be gridOptions
     *      (global) or columnDef mostly.
     *  @param agGridParams: Params to be passed to the component and passed by ag-Grid. This will get merged with any params
     *      specified by the user in the configuration
     *  @param propertyName: The name of the property used in ag-grid as a convention to refer to the component, it can be:
     *      'floatingFilter', 'cellRenderer', is used to find if the user is specifying a custom component
     *  @param componentNameOpt: The actual name of the component to instantiate, this is usually the same as propertyName, but in
     *      some cases is not, like floatingFilter, if it is the same is not necessary to specify
     *  @param mandatory: Handy method to tell if this should return a component ALWAYS. if that is the case, but there is no
     *      component found, it throws an error, by default all components are MANDATORY
     *  @param customInitParamsCb: A chance to customise the params passed to the init method. It receives what the current
     *  params are and the component that init is about to get called for
     */
    ComponentResolver.prototype.createAgGridComponent = function (holderOpt, agGridParams, propertyName, componentNameOpt, mandatory, customInitParamsCb) {
        if (mandatory === void 0) { mandatory = true; }
        var holder = holderOpt == null ? this.gridOptions : holderOpt;
        var componentName = componentNameOpt == null ? propertyName : componentNameOpt;
        //Create the component instance
        var component = this.newAgGridComponent(holder, propertyName, componentName, mandatory);
        if (!component)
            return null;
        //Wire the component and call the init method with the correct params
        var finalParams = this.mergeParams(holder, propertyName, agGridParams);
        this.context.wireBean(component);
        var deferredInit;
        if (customInitParamsCb == null) {
            deferredInit = component.init(finalParams);
        }
        else {
            deferredInit = component.init(customInitParamsCb(finalParams, component));
        }
        if (deferredInit == null) {
            return utils_1.Promise.resolve(component);
            // return new Promise<A> (resolve=>{
            //     setTimeout(
            //         ()=>resolve(component),
            //         500
            //     )
            // })
        }
        else {
            var asPromise = deferredInit;
            return asPromise.map(function (notRelevant) { return component; });
        }
    };
    ComponentResolver.prototype.newAgGridComponent = function (holder, propertyName, componentName, mandatory) {
        if (mandatory === void 0) { mandatory = true; }
        var componentToUse = this.getComponentToUse(holder, propertyName, componentName);
        if (!componentToUse || !componentToUse.component) {
            if (mandatory) {
                console.error("Error creating component " + propertyName + "=>" + componentName);
            }
            return null;
        }
        if (componentToUse.type === ComponentType.AG_GRID) {
            return new componentToUse.component();
        }
        //Using framework component
        var FrameworkComponentRaw = componentToUse.component;
        var thisComponentConfig = this.componentMetadataProvider.retrieve(propertyName);
        return this.frameworkComponentWrapper.wrap(FrameworkComponentRaw, thisComponentConfig.mandatoryMethodList, thisComponentConfig.optionalMethodList, componentName);
    };
    __decorate([
        context_1.Autowired("gridOptions"),
        __metadata("design:type", Object)
    ], ComponentResolver.prototype, "gridOptions", void 0);
    __decorate([
        context_1.Autowired("gridOptionsWrapper"),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ComponentResolver.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired("context"),
        __metadata("design:type", context_1.Context)
    ], ComponentResolver.prototype, "context", void 0);
    __decorate([
        context_1.Autowired("namedComponentResolver"),
        __metadata("design:type", namedComponentResolver_1.NamedComponentResolver)
    ], ComponentResolver.prototype, "namedComponentResolver", void 0);
    __decorate([
        context_1.Autowired("agComponentUtils"),
        __metadata("design:type", agComponentUtils_1.AgComponentUtils)
    ], ComponentResolver.prototype, "agComponentUtils", void 0);
    __decorate([
        context_1.Autowired("componentMetadataProvider"),
        __metadata("design:type", componentMetadataProvider_1.ComponentMetadataProvider)
    ], ComponentResolver.prototype, "componentMetadataProvider", void 0);
    __decorate([
        context_1.Optional("frameworkComponentWrapper"),
        __metadata("design:type", Object)
    ], ComponentResolver.prototype, "frameworkComponentWrapper", void 0);
    ComponentResolver = __decorate([
        context_1.Bean('componentResolver')
    ], ComponentResolver);
    return ComponentResolver;
}());
exports.ComponentResolver = ComponentResolver;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var gridRow_1 = __webpack_require__(70);
var GridCell = (function () {
    function GridCell(gridCellDef) {
        this.rowIndex = gridCellDef.rowIndex;
        this.column = gridCellDef.column;
        this.floating = utils_1.Utils.makeNull(gridCellDef.floating);
    }
    GridCell.prototype.getGridCellDef = function () {
        return {
            rowIndex: this.rowIndex,
            column: this.column,
            floating: this.floating
        };
    };
    GridCell.prototype.getGridRow = function () {
        return new gridRow_1.GridRow(this.rowIndex, this.floating);
    };
    GridCell.prototype.toString = function () {
        return "rowIndex = " + this.rowIndex + ", floating = " + this.floating + ", column = " + (this.column ? this.column.getId() : null);
    };
    GridCell.prototype.createId = function () {
        return this.rowIndex + "." + this.floating + "." + this.column.getId();
    };
    return GridCell;
}());
exports.GridCell = GridCell;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(1);
var gridCell_1 = __webpack_require__(23);
var gridApi_1 = __webpack_require__(6);
var cellComp_1 = __webpack_require__(41);
var FocusedCellController = (function () {
    function FocusedCellController() {
    }
    FocusedCellController.prototype.init = function () {
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.clearFocusedCell.bind(this));
    };
    FocusedCellController.prototype.clearFocusedCell = function () {
        this.focusedCell = null;
        this.onCellFocused(false);
    };
    FocusedCellController.prototype.getFocusedCell = function () {
        return this.focusedCell;
    };
    // we check if the browser is focusing something, and if it is, and
    // it's the cell we think is focused, then return the cell. so this
    // methods returns the cell if a) we think it has focus and b) the
    // browser thinks it has focus. this then returns nothing if we
    // first focus a cell, then second click outside the grid, as then the
    // grid cell will still be focused as far as the grid is concerned,
    // however the browser focus will have moved somewhere else.
    FocusedCellController.prototype.getFocusCellToUseAfterRefresh = function () {
        if (this.gridOptionsWrapper.isSuppressFocusAfterRefresh()) {
            return null;
        }
        if (!this.focusedCell) {
            return null;
        }
        var browserFocusedCell = this.getGridCellForDomElement(document.activeElement);
        if (!browserFocusedCell) {
            return null;
        }
        var gridFocusId = this.focusedCell.createId();
        var browserFocusId = browserFocusedCell.createId();
        if (gridFocusId === browserFocusId) {
            return this.focusedCell;
        }
        else {
            return null;
        }
    };
    FocusedCellController.prototype.getGridCellForDomElement = function (eBrowserCell) {
        var ePointer = eBrowserCell;
        while (ePointer) {
            var cellComp = this.gridOptionsWrapper.getDomData(ePointer, cellComp_1.CellComp.DOM_DATA_KEY_CELL_COMP);
            if (cellComp) {
                return cellComp.getGridCell();
            }
            ePointer = ePointer.parentNode;
        }
        return null;
    };
    FocusedCellController.prototype.setFocusedCell = function (rowIndex, colKey, floating, forceBrowserFocus) {
        if (forceBrowserFocus === void 0) { forceBrowserFocus = false; }
        if (this.gridOptionsWrapper.isSuppressCellSelection()) {
            return;
        }
        var column = utils_1.Utils.makeNull(this.columnController.getGridColumn(colKey));
        this.focusedCell = new gridCell_1.GridCell({ rowIndex: rowIndex,
            floating: utils_1.Utils.makeNull(floating),
            column: column });
        this.onCellFocused(forceBrowserFocus);
    };
    FocusedCellController.prototype.isCellFocused = function (gridCell) {
        if (utils_1.Utils.missing(this.focusedCell)) {
            return false;
        }
        return this.focusedCell.column === gridCell.column && this.isRowFocused(gridCell.rowIndex, gridCell.floating);
    };
    FocusedCellController.prototype.isRowNodeFocused = function (rowNode) {
        return this.isRowFocused(rowNode.rowIndex, rowNode.rowPinned);
    };
    FocusedCellController.prototype.isAnyCellFocused = function () {
        return !!this.focusedCell;
    };
    FocusedCellController.prototype.isRowFocused = function (rowIndex, floating) {
        if (utils_1.Utils.missing(this.focusedCell)) {
            return false;
        }
        var floatingOrNull = utils_1.Utils.makeNull(floating);
        return this.focusedCell.rowIndex === rowIndex && this.focusedCell.floating === floatingOrNull;
    };
    FocusedCellController.prototype.onCellFocused = function (forceBrowserFocus) {
        var event = {
            type: events_1.Events.EVENT_CELL_FOCUSED,
            forceBrowserFocus: forceBrowserFocus,
            rowIndex: null,
            column: null,
            floating: null,
            api: this.gridApi,
            columnApi: this.columnApi,
            rowPinned: null
        };
        if (this.focusedCell) {
            event.rowIndex = this.focusedCell.rowIndex;
            event.column = this.focusedCell.column;
            event.rowPinned = this.focusedCell.floating;
        }
        this.eventService.dispatchEvent(event);
    };
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], FocusedCellController.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], FocusedCellController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], FocusedCellController.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], FocusedCellController.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], FocusedCellController.prototype, "gridApi", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], FocusedCellController.prototype, "init", null);
    FocusedCellController = __decorate([
        context_1.Bean('focusedCellController')
    ], FocusedCellController);
    return FocusedCellController;
}());
exports.FocusedCellController = FocusedCellController;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var column_1 = __webpack_require__(9);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var context_2 = __webpack_require__(0);
var utils_1 = __webpack_require__(1);
var gridApi_1 = __webpack_require__(6);
var SortController = (function () {
    function SortController() {
    }
    SortController_1 = SortController;
    SortController.prototype.progressSort = function (column, multiSort) {
        var nextDirection = this.getNextSortDirection(column);
        this.setSortForColumn(column, nextDirection, multiSort);
    };
    SortController.prototype.setSortForColumn = function (column, sort, multiSort) {
        // auto correct - if sort not legal value, then set it to 'no sort' (which is null)
        if (sort !== column_1.Column.SORT_ASC && sort !== column_1.Column.SORT_DESC) {
            sort = null;
        }
        // update sort on current col
        column.setSort(sort);
        // sortedAt used for knowing order of cols when multi-col sort
        if (column.getSort()) {
            var sortedAt = Number(new Date().valueOf());
            column.setSortedAt(sortedAt);
        }
        else {
            column.setSortedAt(null);
        }
        var doingMultiSort = multiSort && !this.gridOptionsWrapper.isSuppressMultiSort();
        // clear sort on all columns except this one, and update the icons
        if (!doingMultiSort) {
            this.clearSortBarThisColumn(column);
        }
        this.dispatchSortChangedEvents();
    };
    // gets called by API, so if data changes, use can call this, which will end up
    // working out the sort order again of the rows.
    SortController.prototype.onSortChanged = function () {
        this.dispatchSortChangedEvents();
    };
    SortController.prototype.dispatchSortChangedEvents = function () {
        var event = {
            type: events_1.Events.EVENT_SORT_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    SortController.prototype.clearSortBarThisColumn = function (columnToSkip) {
        this.columnController.getPrimaryAndSecondaryAndAutoColumns().forEach(function (columnToClear) {
            // Do not clear if either holding shift, or if column in question was clicked
            if (!(columnToClear === columnToSkip)) {
                columnToClear.setSort(null);
            }
        });
    };
    SortController.prototype.getNextSortDirection = function (column) {
        var sortingOrder;
        if (column.getColDef().sortingOrder) {
            sortingOrder = column.getColDef().sortingOrder;
        }
        else if (this.gridOptionsWrapper.getSortingOrder()) {
            sortingOrder = this.gridOptionsWrapper.getSortingOrder();
        }
        else {
            sortingOrder = SortController_1.DEFAULT_SORTING_ORDER;
        }
        if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
            console.warn('ag-grid: sortingOrder must be an array with at least one element, currently it\'s ' + sortingOrder);
            return;
        }
        var currentIndex = sortingOrder.indexOf(column.getSort());
        var notInArray = currentIndex < 0;
        var lastItemInArray = currentIndex == sortingOrder.length - 1;
        var result;
        if (notInArray || lastItemInArray) {
            result = sortingOrder[0];
        }
        else {
            result = sortingOrder[currentIndex + 1];
        }
        // verify the sort type exists, as the user could provide the sortOrder, need to make sure it's valid
        if (SortController_1.DEFAULT_SORTING_ORDER.indexOf(result) < 0) {
            console.warn('ag-grid: invalid sort type ' + result);
            return null;
        }
        return result;
    };
    // used by the public api, for saving the sort model
    SortController.prototype.getSortModel = function () {
        var columnsWithSorting = this.getColumnsWithSortingOrdered();
        return utils_1.Utils.map(columnsWithSorting, function (column) {
            return {
                colId: column.getColId(),
                sort: column.getSort()
            };
        });
    };
    SortController.prototype.setSortModel = function (sortModel) {
        var _this = this;
        if (!this.gridOptionsWrapper.isEnableSorting()) {
            console.warn('ag-grid: You are setting the sort model on a grid that does not have sorting enabled');
            return;
        }
        // first up, clear any previous sort
        var sortModelProvided = sortModel && sortModel.length > 0;
        var allColumnsIncludingAuto = this.columnController.getPrimaryAndSecondaryAndAutoColumns();
        allColumnsIncludingAuto.forEach(function (column) {
            var sortForCol = null;
            var sortedAt = -1;
            if (sortModelProvided && !column.getColDef().suppressSorting) {
                for (var j = 0; j < sortModel.length; j++) {
                    var sortModelEntry = sortModel[j];
                    if (typeof sortModelEntry.colId === 'string'
                        && typeof column.getColId() === 'string'
                        && _this.compareColIds(sortModelEntry, column)) {
                        sortForCol = sortModelEntry.sort;
                        sortedAt = j;
                    }
                }
            }
            if (sortForCol) {
                column.setSort(sortForCol);
                column.setSortedAt(sortedAt);
            }
            else {
                column.setSort(null);
                column.setSortedAt(null);
            }
        });
        this.dispatchSortChangedEvents();
    };
    SortController.prototype.compareColIds = function (sortModelEntry, column) {
        return sortModelEntry.colId === column.getColId();
    };
    SortController.prototype.getColumnsWithSortingOrdered = function () {
        // pull out all the columns that have sorting set
        var allColumnsIncludingAuto = this.columnController.getPrimaryAndSecondaryAndAutoColumns();
        var columnsWithSorting = utils_1.Utils.filter(allColumnsIncludingAuto, function (column) { return !!column.getSort(); });
        // put the columns in order of which one got sorted first
        columnsWithSorting.sort(function (a, b) { return a.sortedAt - b.sortedAt; });
        return columnsWithSorting;
    };
    // used by row controller, when doing the sorting
    SortController.prototype.getSortForRowController = function () {
        var columnsWithSorting = this.getColumnsWithSortingOrdered();
        return utils_1.Utils.map(columnsWithSorting, function (column) {
            var ascending = column.getSort() === column_1.Column.SORT_ASC;
            return {
                inverter: ascending ? 1 : -1,
                column: column
            };
        });
    };
    SortController.DEFAULT_SORTING_ORDER = [column_1.Column.SORT_ASC, column_1.Column.SORT_DESC, null];
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], SortController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], SortController.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], SortController.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], SortController.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], SortController.prototype, "gridApi", void 0);
    SortController = SortController_1 = __decorate([
        context_2.Bean('sortController')
    ], SortController);
    return SortController;
    var SortController_1;
}());
exports.SortController = SortController;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(6);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var filterManager_1 = __webpack_require__(16);
var componentResolver_1 = __webpack_require__(22);
var ComponentType;
(function (ComponentType) {
    ComponentType[ComponentType["AG_GRID"] = 0] = "AG_GRID";
    ComponentType[ComponentType["FRAMEWORK"] = 1] = "FRAMEWORK";
})(ComponentType || (ComponentType = {}));
var ComponentRecipes = (function () {
    function ComponentRecipes() {
    }
    ComponentRecipes.prototype.newDateComponent = function (params) {
        return this.componentResolver.createAgGridComponent(this.gridOptions, params, "dateComponent");
    };
    ComponentRecipes.prototype.newHeaderComponent = function (params) {
        return this.componentResolver.createAgGridComponent(params.column.getColDef(), params, "headerComponent");
    };
    ComponentRecipes.prototype.newHeaderGroupComponent = function (params) {
        return this.componentResolver.createAgGridComponent(params.columnGroup.getColGroupDef(), params, "headerGroupComponent");
    };
    ComponentRecipes.prototype.newFloatingFilterComponent = function (type, colDef, params) {
        //type if populated must be one of ['set','number','text','date']
        var floatingFilterName = type + "FloatingFilterComponent";
        return this.componentResolver.createAgGridComponent(colDef, params, "floatingFilterComponent", floatingFilterName, false);
    };
    ComponentRecipes.prototype.newFloatingFilterWrapperComponent = function (column, params) {
        var _this = this;
        var colDef = column.getColDef();
        if (colDef.suppressFilter) {
            return this.newEmptyFloatingFilterWrapperComponent(column);
        }
        var floatingFilterType;
        if (typeof colDef.filter === 'string') {
            floatingFilterType = colDef.filter;
        }
        else if (!colDef.filter) {
            floatingFilterType = this.gridOptionsWrapper.isEnterprise() ? 'set' : 'text';
        }
        else {
            floatingFilterType = 'custom';
        }
        var floatingFilter = this.newFloatingFilterComponent(floatingFilterType, colDef, params);
        var floatingFilterWrapperComponentParams = {
            column: column,
            floatingFilterComp: floatingFilter,
            suppressFilterButton: this.componentResolver.mergeParams(colDef, 'floatingFilterComponent', params).suppressFilterButton
        };
        if (!floatingFilter) {
            var filterComponent = this.getFilterComponentPrototype(colDef);
            if (filterComponent && !filterComponent.component.prototype.getModelAsString) {
                return this.newEmptyFloatingFilterWrapperComponent(column);
            }
            var rawModelFn_1 = params.currentParentModel;
            params.currentParentModel = function () {
                var parentPromise = _this.filterManager.getFilterComponent(column);
                return parentPromise.resolveNow(null, function (parent) { return parent.getModelAsString ? parent.getModelAsString(rawModelFn_1()) : null; });
            };
            floatingFilterWrapperComponentParams.floatingFilterComp = this.newFloatingFilterComponent('readModelAsString', colDef, params);
        }
        return this.componentResolver.createAgGridComponent(colDef, floatingFilterWrapperComponentParams, "floatingFilterWrapperComponent");
    };
    ComponentRecipes.prototype.newFullWidthGroupRowInnerCellRenderer = function (params) {
        return this.componentResolver.createAgGridComponent(this.gridOptions, params, "groupRowInnerRenderer", "groupRowInnerRenderer", false);
    };
    ComponentRecipes.prototype.newCellRenderer = function (target, params) {
        return this.componentResolver.createAgGridComponent(target, params, "cellRenderer", "cellRenderer", false);
    };
    ComponentRecipes.prototype.newInnerCellRenderer = function (target, params) {
        return this.componentResolver.createAgGridComponent(target, params, "innerRenderer");
    };
    ComponentRecipes.prototype.newFullRowGroupRenderer = function (params) {
        return this.componentResolver.createAgGridComponent(this.gridOptionsWrapper, params, "fullWidthCellRenderer");
    };
    ComponentRecipes.prototype.getFilterComponentPrototype = function (colDef) {
        return this.componentResolver.getComponentToUse(colDef, "filterComponent");
    };
    ComponentRecipes.prototype.newEmptyFloatingFilterWrapperComponent = function (column) {
        var floatingFilterWrapperComponentParams = {
            column: column,
            floatingFilterComp: null
        };
        return this.componentResolver.createAgGridComponent(column.getColDef(), floatingFilterWrapperComponentParams, "floatingFilterWrapperComponent", "emptyFloatingFilterWrapperComponent");
    };
    __decorate([
        context_1.Autowired("componentResolver"),
        __metadata("design:type", componentResolver_1.ComponentResolver)
    ], ComponentRecipes.prototype, "componentResolver", void 0);
    __decorate([
        context_1.Autowired("gridOptions"),
        __metadata("design:type", Object)
    ], ComponentRecipes.prototype, "gridOptions", void 0);
    __decorate([
        context_1.Autowired("gridOptionsWrapper"),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ComponentRecipes.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('filterManager'),
        __metadata("design:type", filterManager_1.FilterManager)
    ], ComponentRecipes.prototype, "filterManager", void 0);
    ComponentRecipes = __decorate([
        context_1.Bean('componentRecipes')
    ], ComponentRecipes);
    return ComponentRecipes;
}());
exports.ComponentRecipes = ComponentRecipes;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var column_1 = __webpack_require__(9);
var eventService_1 = __webpack_require__(4);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
var ColumnGroup = (function () {
    function ColumnGroup(originalColumnGroup, groupId, instanceId) {
        // depends on the open/closed state of the group, only displaying columns are stored here
        this.displayedChildren = [];
        this.localEventService = new eventService_1.EventService();
        this.groupId = groupId;
        this.instanceId = instanceId;
        this.originalColumnGroup = originalColumnGroup;
    }
    // this is static, a it is used outside of this class
    ColumnGroup.createUniqueId = function (groupId, instanceId) {
        return groupId + '_' + instanceId;
    };
    // as the user is adding and removing columns, the groups are recalculated.
    // this reset clears out all children, ready for children to be added again
    ColumnGroup.prototype.reset = function () {
        this.parent = null;
        this.children = null;
        this.displayedChildren = null;
    };
    ColumnGroup.prototype.getParent = function () {
        return this.parent;
    };
    ColumnGroup.prototype.setParent = function (parent) {
        this.parent = parent;
    };
    ColumnGroup.prototype.getUniqueId = function () {
        return ColumnGroup.createUniqueId(this.groupId, this.instanceId);
    };
    ColumnGroup.prototype.isEmptyGroup = function () {
        return this.displayedChildren.length === 0;
    };
    ColumnGroup.prototype.checkLeft = function () {
        // first get all children to setLeft, as it impacts our decision below
        this.displayedChildren.forEach(function (child) {
            if (child instanceof ColumnGroup) {
                child.checkLeft();
            }
        });
        // set our left based on first displayed column
        if (this.displayedChildren.length > 0) {
            if (this.gridOptionsWrapper.isEnableRtl()) {
                var lastChild = this.displayedChildren[this.displayedChildren.length - 1];
                var lastChildLeft = lastChild.getLeft();
                this.setLeft(lastChildLeft);
            }
            else {
                var firstChildLeft = this.displayedChildren[0].getLeft();
                this.setLeft(firstChildLeft);
            }
        }
        else {
            // this should never happen, as if we have no displayed columns, then
            // this groups should not even exist.
            this.setLeft(null);
        }
    };
    ColumnGroup.prototype.getLeft = function () {
        return this.left;
    };
    ColumnGroup.prototype.getOldLeft = function () {
        return this.oldLeft;
    };
    ColumnGroup.prototype.setLeft = function (left) {
        this.oldLeft = left;
        if (this.left !== left) {
            this.left = left;
            this.localEventService.dispatchEvent(this.createAgEvent(ColumnGroup.EVENT_LEFT_CHANGED));
        }
    };
    ColumnGroup.prototype.createAgEvent = function (type) {
        return {
            type: type,
        };
    };
    ColumnGroup.prototype.addEventListener = function (eventType, listener) {
        this.localEventService.addEventListener(eventType, listener);
    };
    ColumnGroup.prototype.removeEventListener = function (eventType, listener) {
        this.localEventService.removeEventListener(eventType, listener);
    };
    ColumnGroup.prototype.getGroupId = function () {
        return this.groupId;
    };
    ColumnGroup.prototype.getInstanceId = function () {
        return this.instanceId;
    };
    ColumnGroup.prototype.isChildInThisGroupDeepSearch = function (wantedChild) {
        var result = false;
        this.children.forEach(function (foundChild) {
            if (wantedChild === foundChild) {
                result = true;
            }
            if (foundChild instanceof ColumnGroup) {
                if (foundChild.isChildInThisGroupDeepSearch(wantedChild)) {
                    result = true;
                }
            }
        });
        return result;
    };
    ColumnGroup.prototype.getActualWidth = function () {
        var groupActualWidth = 0;
        if (this.displayedChildren) {
            this.displayedChildren.forEach(function (child) {
                groupActualWidth += child.getActualWidth();
            });
        }
        return groupActualWidth;
    };
    ColumnGroup.prototype.isResizable = function () {
        if (!this.displayedChildren) {
            return false;
        }
        // if at least one child is resizable, then the group is resizable
        var result = false;
        this.displayedChildren.forEach(function (child) {
            if (child.isResizable()) {
                result = true;
            }
        });
        return result;
    };
    ColumnGroup.prototype.getMinWidth = function () {
        var result = 0;
        this.displayedChildren.forEach(function (groupChild) {
            result += groupChild.getMinWidth();
        });
        return result;
    };
    ColumnGroup.prototype.addChild = function (child) {
        if (!this.children) {
            this.children = [];
        }
        this.children.push(child);
    };
    ColumnGroup.prototype.getDisplayedChildren = function () {
        return this.displayedChildren;
    };
    ColumnGroup.prototype.getLeafColumns = function () {
        var result = [];
        this.addLeafColumns(result);
        return result;
    };
    ColumnGroup.prototype.getDisplayedLeafColumns = function () {
        var result = [];
        this.addDisplayedLeafColumns(result);
        return result;
    };
    // why two methods here doing the same thing?
    ColumnGroup.prototype.getDefinition = function () {
        return this.originalColumnGroup.getColGroupDef();
    };
    ColumnGroup.prototype.getColGroupDef = function () {
        return this.originalColumnGroup.getColGroupDef();
    };
    ColumnGroup.prototype.isPadding = function () {
        return this.originalColumnGroup.isPadding();
    };
    ColumnGroup.prototype.isExpandable = function () {
        return this.originalColumnGroup.isExpandable();
    };
    ColumnGroup.prototype.isExpanded = function () {
        return this.originalColumnGroup.isExpanded();
    };
    ColumnGroup.prototype.setExpanded = function (expanded) {
        this.originalColumnGroup.setExpanded(expanded);
    };
    ColumnGroup.prototype.addDisplayedLeafColumns = function (leafColumns) {
        this.displayedChildren.forEach(function (child) {
            if (child instanceof column_1.Column) {
                leafColumns.push(child);
            }
            else if (child instanceof ColumnGroup) {
                child.addDisplayedLeafColumns(leafColumns);
            }
        });
    };
    ColumnGroup.prototype.addLeafColumns = function (leafColumns) {
        this.children.forEach(function (child) {
            if (child instanceof column_1.Column) {
                leafColumns.push(child);
            }
            else if (child instanceof ColumnGroup) {
                child.addLeafColumns(leafColumns);
            }
        });
    };
    ColumnGroup.prototype.getChildren = function () {
        return this.children;
    };
    ColumnGroup.prototype.getColumnGroupShow = function () {
        return this.originalColumnGroup.getColumnGroupShow();
    };
    ColumnGroup.prototype.getOriginalColumnGroup = function () {
        return this.originalColumnGroup;
    };
    ColumnGroup.prototype.calculateDisplayedColumns = function () {
        var _this = this;
        // clear out last time we calculated
        this.displayedChildren = [];
        // it not expandable, everything is visible
        if (!this.originalColumnGroup.isExpandable()) {
            this.displayedChildren = this.children;
        }
        else {
            // and calculate again
            this.children.forEach(function (abstractColumn) {
                var headerGroupShow = abstractColumn.getColumnGroupShow();
                switch (headerGroupShow) {
                    case ColumnGroup.HEADER_GROUP_SHOW_OPEN:
                        // when set to open, only show col if group is open
                        if (_this.originalColumnGroup.isExpanded()) {
                            _this.displayedChildren.push(abstractColumn);
                        }
                        break;
                    case ColumnGroup.HEADER_GROUP_SHOW_CLOSED:
                        // when set to open, only show col if group is open
                        if (!_this.originalColumnGroup.isExpanded()) {
                            _this.displayedChildren.push(abstractColumn);
                        }
                        break;
                    default:
                        // default is always show the column
                        _this.displayedChildren.push(abstractColumn);
                        break;
                }
            });
        }
        this.localEventService.dispatchEvent(this.createAgEvent(ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED));
    };
    ColumnGroup.HEADER_GROUP_SHOW_OPEN = 'open';
    ColumnGroup.HEADER_GROUP_SHOW_CLOSED = 'closed';
    ColumnGroup.EVENT_LEFT_CHANGED = 'leftChanged';
    ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED = 'leftChanged';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ColumnGroup.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], ColumnGroup.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], ColumnGroup.prototype, "gridApi", void 0);
    return ColumnGroup;
}());
exports.ColumnGroup = ColumnGroup;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var beanStub_1 = __webpack_require__(13);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var utils_1 = __webpack_require__(1);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var gridPanel_1 = __webpack_require__(10);
var scrollVisibleService_1 = __webpack_require__(34);
var selectionController_1 = __webpack_require__(17);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
var PaginationAutoPageSizeService = (function (_super) {
    __extends(PaginationAutoPageSizeService, _super);
    function PaginationAutoPageSizeService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PaginationAutoPageSizeService.prototype.notActive = function () {
        return !this.gridOptionsWrapper.isPaginationAutoPageSize();
    };
    PaginationAutoPageSizeService.prototype.postConstruct = function () {
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_BODY_HEIGHT_CHANGED, this.onBodyHeightChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));
        this.checkPageSize();
    };
    PaginationAutoPageSizeService.prototype.onScrollVisibilityChanged = function () {
        this.checkPageSize();
    };
    PaginationAutoPageSizeService.prototype.onBodyHeightChanged = function () {
        this.checkPageSize();
    };
    PaginationAutoPageSizeService.prototype.checkPageSize = function () {
        if (this.notActive()) {
            return;
        }
        var rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();
        var bodyHeight = this.gridPanel.getBodyHeight();
        if (this.scrollVisibleService.isHBodyShowing()) {
            bodyHeight = bodyHeight - this.gridOptionsWrapper.getScrollbarWidth();
        }
        if (bodyHeight > 0) {
            var newPageSize = Math.floor(bodyHeight / rowHeight);
            this.gridOptionsWrapper.setProperty('paginationPageSize', newPageSize);
        }
    };
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], PaginationAutoPageSizeService.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], PaginationAutoPageSizeService.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], PaginationAutoPageSizeService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('scrollVisibleService'),
        __metadata("design:type", scrollVisibleService_1.ScrollVisibleService)
    ], PaginationAutoPageSizeService.prototype, "scrollVisibleService", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], PaginationAutoPageSizeService.prototype, "postConstruct", null);
    PaginationAutoPageSizeService = __decorate([
        context_1.Bean('paginationAutoPageSizeService')
    ], PaginationAutoPageSizeService);
    return PaginationAutoPageSizeService;
}(beanStub_1.BeanStub));
exports.PaginationAutoPageSizeService = PaginationAutoPageSizeService;
var PaginationProxy = (function (_super) {
    __extends(PaginationProxy, _super);
    function PaginationProxy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.currentPage = 0;
        _this.topRowIndex = 0;
        _this.bottomRowIndex = 0;
        _this.pixelOffset = 0;
        return _this;
    }
    PaginationProxy.prototype.postConstruct = function () {
        this.active = this.gridOptionsWrapper.isPagination();
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, 'paginationPageSize', this.onModelUpdated.bind(this));
        this.onModelUpdated();
    };
    PaginationProxy.prototype.isLastRowFound = function () {
        return this.rowModel.isLastRowFound();
    };
    PaginationProxy.prototype.onModelUpdated = function (modelUpdatedEvent) {
        this.setIndexesAndBounds();
        var paginationChangedEvent = {
            type: events_1.Events.EVENT_PAGINATION_CHANGED,
            animate: modelUpdatedEvent ? modelUpdatedEvent.animate : false,
            newData: modelUpdatedEvent ? modelUpdatedEvent.newData : false,
            newPage: modelUpdatedEvent ? modelUpdatedEvent.newPage : false,
            keepRenderedRows: modelUpdatedEvent ? modelUpdatedEvent.keepRenderedRows : false,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(paginationChangedEvent);
    };
    PaginationProxy.prototype.goToPage = function (page) {
        if (!this.active) {
            return;
        }
        if (this.currentPage === page) {
            return;
        }
        this.currentPage = page;
        var event = {
            type: events_1.Events.EVENT_MODEL_UPDATED,
            animate: false,
            keepRenderedRows: false,
            newData: false,
            newPage: true,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.onModelUpdated(event);
    };
    PaginationProxy.prototype.getPixelOffset = function () {
        return this.pixelOffset;
    };
    PaginationProxy.prototype.getRow = function (index) {
        return this.rowModel.getRow(index);
    };
    PaginationProxy.prototype.getRowIndexAtPixel = function (pixel) {
        return this.rowModel.getRowIndexAtPixel(pixel);
    };
    PaginationProxy.prototype.getCurrentPageHeight = function () {
        if (utils_1._.missing(this.topRowBounds) || utils_1._.missing(this.bottomRowBounds)) {
            return 0;
        }
        return this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop;
    };
    PaginationProxy.prototype.isRowPresent = function (rowNode) {
        if (!this.rowModel.isRowPresent(rowNode)) {
            return false;
        }
        var nodeIsInPage = rowNode.rowIndex >= this.topRowIndex && rowNode.rowIndex <= this.bottomRowIndex;
        return nodeIsInPage;
    };
    PaginationProxy.prototype.isEmpty = function () {
        return this.rowModel.isEmpty();
    };
    PaginationProxy.prototype.isRowsToRender = function () {
        return this.rowModel.isRowsToRender();
    };
    PaginationProxy.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {
        return this.rowModel.getNodesInRangeForSelection(firstInRange, lastInRange);
    };
    PaginationProxy.prototype.forEachNode = function (callback) {
        return this.rowModel.forEachNode(callback);
    };
    PaginationProxy.prototype.getType = function () {
        return this.rowModel.getType();
    };
    PaginationProxy.prototype.getRowBounds = function (index) {
        return this.rowModel.getRowBounds(index);
    };
    PaginationProxy.prototype.getPageFirstRow = function () {
        return this.pageSize * this.currentPage;
    };
    PaginationProxy.prototype.getPageLastRow = function () {
        var totalLastRow = (this.pageSize * (this.currentPage + 1)) - 1;
        var pageLastRow = this.rowModel.getPageLastRow();
        if (pageLastRow > totalLastRow) {
            return totalLastRow;
        }
        else {
            return pageLastRow;
        }
    };
    PaginationProxy.prototype.getRowCount = function () {
        return this.rowModel.getRowCount();
    };
    PaginationProxy.prototype.goToPageWithIndex = function (index) {
        if (!this.active) {
            return;
        }
        var pageNumber = Math.floor(index / this.pageSize);
        this.goToPage(pageNumber);
    };
    PaginationProxy.prototype.getTotalRowCount = function () {
        return this.rowModel.getPageLastRow() + 1;
    };
    PaginationProxy.prototype.isLastPageFound = function () {
        return this.rowModel.isLastRowFound();
    };
    PaginationProxy.prototype.getCurrentPage = function () {
        return this.currentPage;
    };
    PaginationProxy.prototype.goToNextPage = function () {
        this.goToPage(this.currentPage + 1);
    };
    PaginationProxy.prototype.goToPreviousPage = function () {
        this.goToPage(this.currentPage - 1);
    };
    PaginationProxy.prototype.goToFirstPage = function () {
        this.goToPage(0);
    };
    PaginationProxy.prototype.goToLastPage = function () {
        var rowCount = this.rowModel.getPageLastRow() + 1;
        var lastPage = Math.floor(rowCount / this.pageSize);
        this.goToPage(lastPage);
    };
    PaginationProxy.prototype.getPageSize = function () {
        return this.pageSize;
    };
    PaginationProxy.prototype.getTotalPages = function () {
        return this.totalPages;
    };
    PaginationProxy.prototype.setPageSize = function () {
        // show put this into super class
        this.pageSize = this.gridOptionsWrapper.getPaginationPageSize();
        if (!(this.pageSize >= 1)) {
            this.pageSize = 100;
        }
    };
    PaginationProxy.prototype.setIndexesAndBounds = function () {
        if (this.active) {
            this.setPageSize();
            var totalRowCount = this.getTotalRowCount();
            this.totalPages = Math.floor((totalRowCount - 1) / this.pageSize) + 1;
            if (this.currentPage >= this.totalPages) {
                this.currentPage = this.totalPages - 1;
            }
            if (!utils_1._.isNumeric(this.currentPage) || this.currentPage < 0) {
                this.currentPage = 0;
            }
            this.topRowIndex = this.pageSize * this.currentPage;
            this.bottomRowIndex = (this.pageSize * (this.currentPage + 1)) - 1;
            var maxRowAllowed = this.rowModel.getPageLastRow();
            if (this.bottomRowIndex > maxRowAllowed) {
                this.bottomRowIndex = maxRowAllowed;
            }
        }
        else {
            this.pageSize = this.rowModel.getPageLastRow() + 1;
            this.totalPages = 1;
            this.currentPage = 0;
            this.topRowIndex = 0;
            this.bottomRowIndex = this.rowModel.getPageLastRow();
        }
        this.topRowBounds = this.rowModel.getRowBounds(this.topRowIndex);
        this.bottomRowBounds = this.rowModel.getRowBounds(this.bottomRowIndex);
        this.pixelOffset = utils_1._.exists(this.topRowBounds) ? this.topRowBounds.rowTop : 0;
    };
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], PaginationProxy.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], PaginationProxy.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], PaginationProxy.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], PaginationProxy.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('selectionController'),
        __metadata("design:type", selectionController_1.SelectionController)
    ], PaginationProxy.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], PaginationProxy.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], PaginationProxy.prototype, "gridApi", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], PaginationProxy.prototype, "postConstruct", null);
    PaginationProxy = __decorate([
        context_1.Bean('paginationProxy')
    ], PaginationProxy);
    return PaginationProxy;
}(beanStub_1.BeanStub));
exports.PaginationProxy = PaginationProxy;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var rowNode_1 = __webpack_require__(15);
var context_1 = __webpack_require__(0);
var eventService_1 = __webpack_require__(4);
var context_2 = __webpack_require__(0);
var events_1 = __webpack_require__(5);
var context_3 = __webpack_require__(0);
var constants_1 = __webpack_require__(7);
var utils_1 = __webpack_require__(1);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
var PinnedRowModel = (function () {
    function PinnedRowModel() {
    }
    PinnedRowModel.prototype.init = function () {
        this.setPinnedTopRowData(this.gridOptionsWrapper.getPinnedTopRowData());
        this.setPinnedBottomRowData(this.gridOptionsWrapper.getPinnedBottomRowData());
    };
    PinnedRowModel.prototype.isEmpty = function (floating) {
        var rows = floating === constants_1.Constants.PINNED_TOP ? this.pinnedTopRows : this.pinnedBottomRows;
        return utils_1.Utils.missingOrEmpty(rows);
    };
    PinnedRowModel.prototype.isRowsToRender = function (floating) {
        return !this.isEmpty(floating);
    };
    PinnedRowModel.prototype.getRowAtPixel = function (pixel, floating) {
        var rows = floating === constants_1.Constants.PINNED_TOP ? this.pinnedTopRows : this.pinnedBottomRows;
        if (utils_1.Utils.missingOrEmpty(rows)) {
            return 0; // this should never happen, just in case, 0 is graceful failure
        }
        for (var i = 0; i < rows.length; i++) {
            var rowNode = rows[i];
            var rowTopPixel = rowNode.rowTop + rowNode.rowHeight - 1;
            // only need to range check against the top pixel, as we are going through the list
            // in order, first row to hit the pixel wins
            if (rowTopPixel >= pixel) {
                return i;
            }
        }
        return rows.length - 1;
    };
    PinnedRowModel.prototype.setPinnedTopRowData = function (rowData) {
        this.pinnedTopRows = this.createNodesFromData(rowData, true);
        var event = {
            type: events_1.Events.EVENT_PINNED_ROW_DATA_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    PinnedRowModel.prototype.setPinnedBottomRowData = function (rowData) {
        this.pinnedBottomRows = this.createNodesFromData(rowData, false);
        var event = {
            type: events_1.Events.EVENT_PINNED_ROW_DATA_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    PinnedRowModel.prototype.createNodesFromData = function (allData, isTop) {
        var _this = this;
        var rowNodes = [];
        if (allData) {
            var nextRowTop_1 = 0;
            allData.forEach(function (dataItem, index) {
                var rowNode = new rowNode_1.RowNode();
                _this.context.wireBean(rowNode);
                rowNode.data = dataItem;
                rowNode.rowPinned = isTop ? constants_1.Constants.PINNED_TOP : constants_1.Constants.PINNED_BOTTOM;
                rowNode.setRowTop(nextRowTop_1);
                rowNode.setRowHeight(_this.gridOptionsWrapper.getRowHeightForNode(rowNode));
                rowNode.setRowIndex(index);
                nextRowTop_1 += rowNode.rowHeight;
                rowNodes.push(rowNode);
            });
        }
        return rowNodes;
    };
    PinnedRowModel.prototype.getPinnedTopRowData = function () {
        return this.pinnedTopRows;
    };
    PinnedRowModel.prototype.getPinnedBottomRowData = function () {
        return this.pinnedBottomRows;
    };
    PinnedRowModel.prototype.getPinnedTopTotalHeight = function () {
        return this.getTotalHeight(this.pinnedTopRows);
    };
    PinnedRowModel.prototype.getPinnedTopRowCount = function () {
        return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
    };
    PinnedRowModel.prototype.getPinnedBottomRowCount = function () {
        return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
    };
    PinnedRowModel.prototype.getPinnedTopRow = function (index) {
        return this.pinnedTopRows[index];
    };
    PinnedRowModel.prototype.getPinnedBottomRow = function (index) {
        return this.pinnedBottomRows[index];
    };
    PinnedRowModel.prototype.forEachPinnedTopRow = function (callback) {
        if (utils_1.Utils.missingOrEmpty(this.pinnedTopRows)) {
            return;
        }
        this.pinnedTopRows.forEach(callback);
    };
    PinnedRowModel.prototype.forEachPinnedBottomRow = function (callback) {
        if (utils_1.Utils.missingOrEmpty(this.pinnedBottomRows)) {
            return;
        }
        this.pinnedBottomRows.forEach(callback);
    };
    PinnedRowModel.prototype.getPinnedBottomTotalHeight = function () {
        return this.getTotalHeight(this.pinnedBottomRows);
    };
    PinnedRowModel.prototype.getTotalHeight = function (rowNodes) {
        if (!rowNodes || rowNodes.length === 0) {
            return 0;
        }
        else {
            var lastNode = rowNodes[rowNodes.length - 1];
            return lastNode.rowTop + lastNode.rowHeight;
        }
    };
    __decorate([
        context_2.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], PinnedRowModel.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_2.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], PinnedRowModel.prototype, "eventService", void 0);
    __decorate([
        context_2.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], PinnedRowModel.prototype, "context", void 0);
    __decorate([
        context_2.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], PinnedRowModel.prototype, "columnApi", void 0);
    __decorate([
        context_2.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], PinnedRowModel.prototype, "gridApi", void 0);
    __decorate([
        context_3.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], PinnedRowModel.prototype, "init", null);
    PinnedRowModel = __decorate([
        context_1.Bean('pinnedRowModel')
    ], PinnedRowModel);
    return PinnedRowModel;
}());
exports.PinnedRowModel = PinnedRowModel;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnGroup_1 = __webpack_require__(28);
var originalColumnGroup_1 = __webpack_require__(32);
var context_1 = __webpack_require__(0);
var context_2 = __webpack_require__(0);
// takes in a list of columns, as specified by the column definitions, and returns column groups
var ColumnUtils = (function () {
    function ColumnUtils() {
    }
    ColumnUtils.prototype.calculateColInitialWidth = function (colDef) {
        if (!colDef.width) {
            // if no width defined in colDef, use default
            return this.gridOptionsWrapper.getColWidth();
        }
        else if (colDef.width < this.gridOptionsWrapper.getMinColWidth()) {
            // if width in col def to small, set to min width
            return this.gridOptionsWrapper.getMinColWidth();
        }
        else {
            // otherwise use the provided width
            return colDef.width;
        }
    };
    ColumnUtils.prototype.getOriginalPathForColumn = function (column, originalBalancedTree) {
        var result = [];
        var found = false;
        recursePath(originalBalancedTree, 0);
        // we should always find the path, but in case there is a bug somewhere, returning null
        // will make it fail rather than provide a 'hard to track down' bug
        if (found) {
            return result;
        }
        else {
            return null;
        }
        function recursePath(balancedColumnTree, dept) {
            for (var i = 0; i < balancedColumnTree.length; i++) {
                if (found) {
                    // quit the search, so 'result' is kept with the found result
                    return;
                }
                var node = balancedColumnTree[i];
                if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
                    var nextNode = node;
                    recursePath(nextNode.getChildren(), dept + 1);
                    result[dept] = node;
                }
                else {
                    if (node === column) {
                        found = true;
                    }
                }
            }
        }
    };
    /*    public getPathForColumn(column: Column, allDisplayedColumnGroups: ColumnGroupChild[]): ColumnGroup[] {
            let result: ColumnGroup[] = [];
            let found = false;
    
            recursePath(allDisplayedColumnGroups, 0);
    
            // we should always find the path, but in case there is a bug somewhere, returning null
            // will make it fail rather than provide a 'hard to track down' bug
            if (found) {
                return result;
            } else {
                return null;
            }
    
            function recursePath(balancedColumnTree: ColumnGroupChild[], dept: number): void {
    
                for (let i = 0; i<balancedColumnTree.length; i++) {
                    if (found) {
                        // quit the search, so 'result' is kept with the found result
                        return;
                    }
                    let node = balancedColumnTree[i];
                    if (node instanceof ColumnGroup) {
                        let nextNode = <ColumnGroup> node;
                        recursePath(nextNode.getChildren(), dept+1);
                        result[dept] = node;
                    } else {
                        if (node === column) {
                            found = true;
                        }
                    }
                }
            }
        }*/
    ColumnUtils.prototype.depthFirstOriginalTreeSearch = function (tree, callback) {
        var _this = this;
        if (!tree) {
            return;
        }
        tree.forEach(function (child) {
            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                _this.depthFirstOriginalTreeSearch(child.getChildren(), callback);
            }
            callback(child);
        });
    };
    ColumnUtils.prototype.depthFirstAllColumnTreeSearch = function (tree, callback) {
        var _this = this;
        if (!tree) {
            return;
        }
        tree.forEach(function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                _this.depthFirstAllColumnTreeSearch(child.getChildren(), callback);
            }
            callback(child);
        });
    };
    ColumnUtils.prototype.depthFirstDisplayedColumnTreeSearch = function (tree, callback) {
        var _this = this;
        if (!tree) {
            return;
        }
        tree.forEach(function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                _this.depthFirstDisplayedColumnTreeSearch(child.getDisplayedChildren(), callback);
            }
            callback(child);
        });
    };
    __decorate([
        context_2.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ColumnUtils.prototype, "gridOptionsWrapper", void 0);
    ColumnUtils = __decorate([
        context_1.Bean('columnUtils')
    ], ColumnUtils);
    return ColumnUtils;
}());
exports.ColumnUtils = ColumnUtils;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var columnGroup_1 = __webpack_require__(28);
var column_1 = __webpack_require__(9);
var eventService_1 = __webpack_require__(4);
var context_1 = __webpack_require__(0);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
var OriginalColumnGroup = (function () {
    function OriginalColumnGroup(colGroupDef, groupId, padding) {
        this.localEventService = new eventService_1.EventService();
        this.expandable = false;
        this.colGroupDef = colGroupDef;
        this.groupId = groupId;
        this.expanded = colGroupDef && !!colGroupDef.openByDefault;
        this.padding = padding;
    }
    OriginalColumnGroup.prototype.isVisible = function () {
        // return true if at least one child is visible
        if (this.children) {
            return this.children.some(function (child) { return child.isVisible(); });
        }
        else {
            return false;
        }
    };
    OriginalColumnGroup.prototype.isPadding = function () {
        return this.padding;
    };
    OriginalColumnGroup.prototype.setExpanded = function (expanded) {
        this.expanded = expanded;
        var event = {
            type: OriginalColumnGroup.EVENT_EXPANDED_CHANGED
        };
        this.localEventService.dispatchEvent(event);
    };
    OriginalColumnGroup.prototype.isExpandable = function () {
        return this.expandable;
    };
    OriginalColumnGroup.prototype.isExpanded = function () {
        return this.expanded;
    };
    OriginalColumnGroup.prototype.getGroupId = function () {
        return this.groupId;
    };
    OriginalColumnGroup.prototype.getId = function () {
        return this.getGroupId();
    };
    OriginalColumnGroup.prototype.setChildren = function (children) {
        this.children = children;
    };
    OriginalColumnGroup.prototype.getChildren = function () {
        return this.children;
    };
    OriginalColumnGroup.prototype.getColGroupDef = function () {
        return this.colGroupDef;
    };
    OriginalColumnGroup.prototype.getLeafColumns = function () {
        var result = [];
        this.addLeafColumns(result);
        return result;
    };
    OriginalColumnGroup.prototype.addLeafColumns = function (leafColumns) {
        this.children.forEach(function (child) {
            if (child instanceof column_1.Column) {
                leafColumns.push(child);
            }
            else if (child instanceof OriginalColumnGroup) {
                child.addLeafColumns(leafColumns);
            }
        });
    };
    OriginalColumnGroup.prototype.getColumnGroupShow = function () {
        if (!this.padding) {
            return this.colGroupDef.columnGroupShow;
        }
        else {
            // if this is padding we have exactly only child. we then
            // take the value from the child and push it up, making
            // this group 'invisible'.
            return this.children[0].getColumnGroupShow();
        }
    };
    // need to check that this group has at least one col showing when both expanded and contracted.
    // if not, then we don't allow expanding and contracting on this group
    OriginalColumnGroup.prototype.setupExpandable = function () {
        var _this = this;
        this.setExpandable();
        // note - we should be removing this event listener
        this.getLeafColumns().forEach(function (col) { return col.addEventListener(column_1.Column.EVENT_VISIBLE_CHANGED, _this.onColumnVisibilityChanged.bind(_this)); });
    };
    OriginalColumnGroup.prototype.setExpandable = function () {
        // want to make sure the group doesn't disappear when it's open
        var atLeastOneShowingWhenOpen = false;
        // want to make sure the group doesn't disappear when it's closed
        var atLeastOneShowingWhenClosed = false;
        // want to make sure the group has something to show / hide
        var atLeastOneChangeable = false;
        for (var i = 0, j = this.children.length; i < j; i++) {
            var abstractColumn = this.children[i];
            if (!abstractColumn.isVisible()) {
                continue;
            }
            // if the abstractColumn is a grid generated group, there will be no colDef
            var headerGroupShow = abstractColumn.getColumnGroupShow();
            if (headerGroupShow === columnGroup_1.ColumnGroup.HEADER_GROUP_SHOW_OPEN) {
                atLeastOneShowingWhenOpen = true;
                atLeastOneChangeable = true;
            }
            else if (headerGroupShow === columnGroup_1.ColumnGroup.HEADER_GROUP_SHOW_CLOSED) {
                atLeastOneShowingWhenClosed = true;
                atLeastOneChangeable = true;
            }
            else {
                atLeastOneShowingWhenOpen = true;
                atLeastOneShowingWhenClosed = true;
            }
        }
        var expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
        if (this.expandable !== expandable) {
            this.expandable = expandable;
            var event_1 = {
                type: OriginalColumnGroup.EVENT_EXPANDABLE_CHANGED
            };
            this.localEventService.dispatchEvent(event_1);
        }
    };
    OriginalColumnGroup.prototype.onColumnVisibilityChanged = function () {
        this.setExpandable();
    };
    OriginalColumnGroup.prototype.addEventListener = function (eventType, listener) {
        this.localEventService.addEventListener(eventType, listener);
    };
    OriginalColumnGroup.prototype.removeEventListener = function (eventType, listener) {
        this.localEventService.removeEventListener(eventType, listener);
    };
    OriginalColumnGroup.EVENT_EXPANDED_CHANGED = 'expandedChanged';
    OriginalColumnGroup.EVENT_EXPANDABLE_CHANGED = 'expandableChanged';
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], OriginalColumnGroup.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], OriginalColumnGroup.prototype, "gridApi", void 0);
    return OriginalColumnGroup;
}());
exports.OriginalColumnGroup = OriginalColumnGroup;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var rowRenderer_1 = __webpack_require__(18);
var filterManager_1 = __webpack_require__(16);
var eventService_1 = __webpack_require__(4);
var gridPanel_1 = __webpack_require__(10);
var logger_1 = __webpack_require__(11);
var constants_1 = __webpack_require__(7);
var popupService_1 = __webpack_require__(37);
var events_1 = __webpack_require__(5);
var utils_1 = __webpack_require__(1);
var borderLayout_1 = __webpack_require__(76);
var context_1 = __webpack_require__(0);
var focusedCellController_1 = __webpack_require__(24);
var component_1 = __webpack_require__(8);
var paginationComp_1 = __webpack_require__(151);
var gridApi_1 = __webpack_require__(6);
var GridCore = (function () {
    function GridCore(loggerFactory) {
        this.destroyFunctions = [];
        this.logger = loggerFactory.create('GridCore');
    }
    GridCore.prototype.init = function () {
        var _this = this;
        var eSouthPanel = this.createSouthPanel();
        var eastPanel;
        var westPanel;
        if (this.toolPanel && !this.gridOptionsWrapper.isForPrint()) {
            // if we are doing RTL, then the tool panel appears on the left
            if (this.gridOptionsWrapper.isEnableRtl()) {
                westPanel = this.toolPanel.getGui();
            }
            else {
                eastPanel = this.toolPanel.getGui();
            }
        }
        var createTopPanelGui = this.createNorthPanel();
        this.eRootPanel = new borderLayout_1.BorderLayout({
            center: this.gridPanel.getLayout(),
            east: eastPanel,
            west: westPanel,
            north: createTopPanelGui,
            south: eSouthPanel,
            dontFill: this.gridOptionsWrapper.isForPrint(),
            fillHorizontalOnly: this.gridOptionsWrapper.isAutoHeight(),
            name: 'eRootPanel'
        });
        // parts of the CSS need to know if we are in 'for print' mode or not,
        // so we add a class to allow applying CSS based on this.
        if (this.gridOptionsWrapper.isForPrint()) {
            utils_1.Utils.addCssClass(this.eRootPanel.getGui(), 'ag-layout-for-print');
            // kept to limit breaking changes, ag-no-scrolls was renamed to ag-layout-for-print
            utils_1.Utils.addCssClass(this.eRootPanel.getGui(), 'ag-no-scrolls');
        }
        else if (this.gridOptionsWrapper.isAutoHeight()) {
            utils_1.Utils.addCssClass(this.eRootPanel.getGui(), 'ag-layout-auto-height');
        }
        else {
            utils_1.Utils.addCssClass(this.eRootPanel.getGui(), 'ag-layout-normal');
            // kept to limit breaking changes, ag-scrolls was renamed to ag-layout-normal
            utils_1.Utils.addCssClass(this.eRootPanel.getGui(), 'ag-scrolls');
        }
        // see what the grid options are for default of toolbar
        this.showToolPanel(this.gridOptionsWrapper.isShowToolPanel());
        this.eGridDiv.appendChild(this.eRootPanel.getGui());
        // if using angular, watch for quickFilter changes
        if (this.$scope) {
            this.$scope.$watch(this.quickFilterOnScope, function (newFilter) { return _this.filterManager.setQuickFilter(newFilter); });
        }
        if (!this.gridOptionsWrapper.isForPrint()) {
            this.addWindowResizeListener();
        }
        // important to set rtl before doLayout, as setting the RTL class impacts the scroll position,
        // which doLayout indirectly depends on
        this.addRtlSupport();
        this.doLayout();
        this.finished = false;
        this.periodicallyDoLayout();
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onRowGroupChanged.bind(this));
        this.onRowGroupChanged();
        this.logger.log('ready');
    };
    GridCore.prototype.addRtlSupport = function () {
        if (this.gridOptionsWrapper.isEnableRtl()) {
            utils_1.Utils.addCssClass(this.eRootPanel.getGui(), 'ag-rtl');
        }
        else {
            utils_1.Utils.addCssClass(this.eRootPanel.getGui(), 'ag-ltr');
        }
    };
    GridCore.prototype.createNorthPanel = function () {
        var _this = this;
        if (!this.gridOptionsWrapper.isEnterprise()) {
            return null;
        }
        var topPanelGui = document.createElement('div');
        var dropPanelVisibleListener = this.onDropPanelVisible.bind(this);
        this.rowGroupComp = this.rowGroupCompFactory.create();
        this.pivotComp = this.pivotCompFactory.create();
        topPanelGui.appendChild(this.rowGroupComp.getGui());
        topPanelGui.appendChild(this.pivotComp.getGui());
        this.rowGroupComp.addEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
        this.pivotComp.addEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
        this.destroyFunctions.push(function () {
            _this.rowGroupComp.removeEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
            _this.pivotComp.removeEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
        });
        this.onDropPanelVisible();
        return topPanelGui;
    };
    GridCore.prototype.onDropPanelVisible = function () {
        var bothVisible = this.rowGroupComp.isVisible() && this.pivotComp.isVisible();
        this.rowGroupComp.addOrRemoveCssClass('ag-width-half', bothVisible);
        this.pivotComp.addOrRemoveCssClass('ag-width-half', bothVisible);
    };
    GridCore.prototype.getRootGui = function () {
        return this.eRootPanel.getGui();
    };
    GridCore.prototype.createSouthPanel = function () {
        if (!this.statusBar && this.gridOptionsWrapper.isEnableStatusBar()) {
            console.warn('ag-Grid: status bar is only available in ag-Grid-Enterprise');
        }
        var statusBarEnabled = this.statusBar && this.gridOptionsWrapper.isEnableStatusBar();
        var isPaging = this.gridOptionsWrapper.isPagination();
        var paginationPanelEnabled = isPaging
            && !this.gridOptionsWrapper.isForPrint()
            && !this.gridOptionsWrapper.isSuppressPaginationPanel();
        if (!statusBarEnabled && !paginationPanelEnabled) {
            return null;
        }
        var eSouthPanel = document.createElement('div');
        if (statusBarEnabled) {
            eSouthPanel.appendChild(this.statusBar.getGui());
        }
        if (paginationPanelEnabled) {
            var paginationComp = new paginationComp_1.PaginationComp();
            this.context.wireBean(paginationComp);
            eSouthPanel.appendChild(paginationComp.getGui());
            this.destroyFunctions.push(paginationComp.destroy.bind(paginationComp));
        }
        return eSouthPanel;
    };
    GridCore.prototype.onRowGroupChanged = function () {
        if (!this.rowGroupComp) {
            return;
        }
        var rowGroupPanelShow = this.gridOptionsWrapper.getRowGroupPanelShow();
        if (rowGroupPanelShow === constants_1.Constants.ALWAYS) {
            this.rowGroupComp.setVisible(true);
        }
        else if (rowGroupPanelShow === constants_1.Constants.ONLY_WHEN_GROUPING) {
            var grouping = !this.columnController.isRowGroupEmpty();
            this.rowGroupComp.setVisible(grouping);
        }
        else {
            this.rowGroupComp.setVisible(false);
        }
        this.eRootPanel.doLayout();
    };
    GridCore.prototype.addWindowResizeListener = function () {
        var eventListener = this.doLayout.bind(this);
        window.addEventListener('resize', eventListener);
        this.destroyFunctions.push(function () { return window.removeEventListener('resize', eventListener); });
    };
    GridCore.prototype.periodicallyDoLayout = function () {
        var _this = this;
        if (!this.finished) {
            var intervalMillis = this.gridOptionsWrapper.getLayoutInterval();
            // if interval is negative, this stops the layout from happening
            if (intervalMillis > 0) {
                this.frameworkFactory.setTimeout(function () {
                    _this.doLayout();
                    _this.gridPanel.periodicallyCheck();
                    _this.periodicallyDoLayout();
                }, intervalMillis);
            }
            else {
                // if user provided negative number, we still do the check every 5 seconds,
                // in case the user turns the number positive again
                this.frameworkFactory.setTimeout(function () {
                    _this.periodicallyDoLayout();
                }, 5000);
            }
        }
    };
    GridCore.prototype.showToolPanel = function (show) {
        if (show && !this.toolPanel) {
            console.warn('ag-Grid: toolPanel is only available in ag-Grid Enterprise');
            this.toolPanelShowing = false;
            return;
        }
        this.toolPanelShowing = show;
        if (this.toolPanel) {
            this.toolPanel.setVisible(show);
            this.eRootPanel.doLayout();
        }
    };
    GridCore.prototype.isToolPanelShowing = function () {
        return this.toolPanelShowing;
    };
    GridCore.prototype.destroy = function () {
        this.finished = true;
        this.eGridDiv.removeChild(this.eRootPanel.getGui());
        this.logger.log('Grid DOM removed');
        this.destroyFunctions.forEach(function (func) { return func(); });
    };
    // Valid values for position are bottom, middle and top
    GridCore.prototype.ensureNodeVisible = function (comparator, position) {
        if (position === void 0) { position = 'top'; }
        if (this.doingVirtualPaging) {
            throw 'Cannot use ensureNodeVisible when doing virtual paging, as we cannot check rows that are not in memory';
        }
        // look for the node index we want to display
        var rowCount = this.rowModel.getPageLastRow() + 1;
        var comparatorIsAFunction = typeof comparator === 'function';
        var indexToSelect = -1;
        // go through all the nodes, find the one we want to show
        for (var i = 0; i < rowCount; i++) {
            var node = this.rowModel.getRow(i);
            if (comparatorIsAFunction) {
                if (comparator(node)) {
                    indexToSelect = i;
                    break;
                }
            }
            else {
                // check object equality against node and data
                if (comparator === node || comparator === node.data) {
                    indexToSelect = i;
                    break;
                }
            }
        }
        if (indexToSelect >= 0) {
            this.gridPanel.ensureIndexVisible(indexToSelect, position);
        }
    };
    GridCore.prototype.doLayout = function () {
        // need to do layout first, as drawVirtualRows and setPinnedColHeight
        // need to know the result of the resizing of the panels.
        var sizeChanged = this.eRootPanel.doLayout();
        // not sure why, this is a hack, but if size changed, it may need to be called
        // again - as the size change can change whether scrolls are visible or not (i think).
        // to see why, take this second 'doLayout' call out, and see example in docs for
        // width & height, the grid will flicker as it doesn't get laid out correctly with
        // one call to doLayout()
        if (sizeChanged) {
            this.eRootPanel.doLayout();
        }
        // both of the two below should be done in gridPanel, the gridPanel should register 'resize' to the panel
        if (sizeChanged) {
            this.rowRenderer.redrawAfterScroll();
            var event_1 = {
                type: events_1.Events.EVENT_GRID_SIZE_CHANGED,
                clientWidth: this.eRootPanel.getGui().clientWidth,
                clientHeight: this.eRootPanel.getGui().clientHeight,
                api: this.gridApi,
                columnApi: this.columnApi
            };
            this.eventService.dispatchEvent(event_1);
        }
    };
    __decorate([
        context_1.Autowired('gridOptions'),
        __metadata("design:type", Object)
    ], GridCore.prototype, "gridOptions", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], GridCore.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], GridCore.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('frameworkFactory'),
        __metadata("design:type", Object)
    ], GridCore.prototype, "frameworkFactory", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], GridCore.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'),
        __metadata("design:type", rowRenderer_1.RowRenderer)
    ], GridCore.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('filterManager'),
        __metadata("design:type", filterManager_1.FilterManager)
    ], GridCore.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], GridCore.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], GridCore.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('eGridDiv'),
        __metadata("design:type", HTMLElement)
    ], GridCore.prototype, "eGridDiv", void 0);
    __decorate([
        context_1.Autowired('$scope'),
        __metadata("design:type", Object)
    ], GridCore.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('quickFilterOnScope'),
        __metadata("design:type", String)
    ], GridCore.prototype, "quickFilterOnScope", void 0);
    __decorate([
        context_1.Autowired('popupService'),
        __metadata("design:type", popupService_1.PopupService)
    ], GridCore.prototype, "popupService", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'),
        __metadata("design:type", focusedCellController_1.FocusedCellController)
    ], GridCore.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], GridCore.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], GridCore.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], GridCore.prototype, "gridApi", void 0);
    __decorate([
        context_1.Optional('rowGroupCompFactory'),
        __metadata("design:type", Object)
    ], GridCore.prototype, "rowGroupCompFactory", void 0);
    __decorate([
        context_1.Optional('pivotCompFactory'),
        __metadata("design:type", Object)
    ], GridCore.prototype, "pivotCompFactory", void 0);
    __decorate([
        context_1.Optional('toolPanel'),
        __metadata("design:type", component_1.Component)
    ], GridCore.prototype, "toolPanel", void 0);
    __decorate([
        context_1.Optional('statusBar'),
        __metadata("design:type", component_1.Component)
    ], GridCore.prototype, "statusBar", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], GridCore.prototype, "init", null);
    __decorate([
        context_1.PreDestroy,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], GridCore.prototype, "destroy", null);
    GridCore = __decorate([
        context_1.Bean('gridCore'),
        __param(0, context_1.Qualifier('loggerFactory')),
        __metadata("design:paramtypes", [logger_1.LoggerFactory])
    ], GridCore);
    return GridCore;
}());
exports.GridCore = GridCore;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(1);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
var ScrollVisibleService = (function () {
    function ScrollVisibleService() {
    }
    ScrollVisibleService.prototype.setScrollsVisible = function (params) {
        var atLeastOneDifferent = this.vBody !== params.vBody
            || this.hBody !== params.hBody
            || this.vPinnedLeft !== params.vPinnedLeft
            || this.vPinnedRight !== params.vPinnedRight;
        if (atLeastOneDifferent) {
            this.vBody = params.vBody;
            this.hBody = params.hBody;
            this.vPinnedLeft = params.vPinnedLeft;
            this.vPinnedRight = params.vPinnedRight;
            var event_1 = {
                type: events_1.Events.EVENT_SCROLL_VISIBILITY_CHANGED,
                api: this.gridApi,
                columnApi: this.columnApi
            };
            this.eventService.dispatchEvent(event_1);
        }
    };
    ScrollVisibleService.prototype.isVBodyShowing = function () {
        return this.vBody;
    };
    ScrollVisibleService.prototype.isHBodyShowing = function () {
        return this.hBody;
    };
    ScrollVisibleService.prototype.isVPinnedLeftShowing = function () {
        return this.vPinnedLeft;
    };
    ScrollVisibleService.prototype.isVPinnedRightShowing = function () {
        return this.vPinnedRight;
    };
    ScrollVisibleService.prototype.getPinnedLeftWidth = function () {
        return this.columnController.getPinnedLeftContainerWidth();
    };
    ScrollVisibleService.prototype.getPinnedLeftWithScrollWidth = function () {
        var result = this.getPinnedLeftWidth();
        if (this.vPinnedLeft) {
            result += utils_1.Utils.getScrollbarWidth();
        }
        return result;
    };
    ScrollVisibleService.prototype.getPinnedRightWidth = function () {
        return this.columnController.getPinnedRightContainerWidth();
    };
    ScrollVisibleService.prototype.getPinnedRightWithScrollWidth = function () {
        var result = this.getPinnedRightWidth();
        if (this.vPinnedRight) {
            result += utils_1.Utils.getScrollbarWidth();
        }
        return result;
    };
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], ScrollVisibleService.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], ScrollVisibleService.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], ScrollVisibleService.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], ScrollVisibleService.prototype, "gridApi", void 0);
    ScrollVisibleService = __decorate([
        context_1.Bean('scrollVisibleService')
    ], ScrollVisibleService);
    return ScrollVisibleService;
}());
exports.ScrollVisibleService = ScrollVisibleService;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
var gridOptionsWrapper_1 = __webpack_require__(2);
var expressionService_1 = __webpack_require__(19);
var rowRenderer_1 = __webpack_require__(18);
var templateService_1 = __webpack_require__(60);
var valueService_1 = __webpack_require__(20);
var eventService_1 = __webpack_require__(4);
var columnAnimationService_1 = __webpack_require__(85);
var focusedCellController_1 = __webpack_require__(24);
var cellEditorFactory_1 = __webpack_require__(55);
var cellRendererFactory_1 = __webpack_require__(56);
var popupService_1 = __webpack_require__(37);
var cellRendererService_1 = __webpack_require__(57);
var valueFormatterService_1 = __webpack_require__(43);
var stylingService_1 = __webpack_require__(90);
var columnHoverService_1 = __webpack_require__(86);
var gridPanel_1 = __webpack_require__(10);
var paginationProxy_1 = __webpack_require__(29);
var animationFrameService_1 = __webpack_require__(40);
var componentResolver_1 = __webpack_require__(22);
var Beans = (function () {
    function Beans() {
    }
    Beans.prototype.postConstruct = function () {
        this.forPrint = this.gridOptionsWrapper.isForPrint();
    };
    __decorate([
        context_1.Autowired('paginationProxy'),
        __metadata("design:type", paginationProxy_1.PaginationProxy)
    ], Beans.prototype, "paginationProxy", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], Beans.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], Beans.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], Beans.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], Beans.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], Beans.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'),
        __metadata("design:type", expressionService_1.ExpressionService)
    ], Beans.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'),
        __metadata("design:type", rowRenderer_1.RowRenderer)
    ], Beans.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('$compile'),
        __metadata("design:type", Object)
    ], Beans.prototype, "$compile", void 0);
    __decorate([
        context_1.Autowired('templateService'),
        __metadata("design:type", templateService_1.TemplateService)
    ], Beans.prototype, "templateService", void 0);
    __decorate([
        context_1.Autowired('valueService'),
        __metadata("design:type", valueService_1.ValueService)
    ], Beans.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], Beans.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], Beans.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('columnAnimationService'),
        __metadata("design:type", columnAnimationService_1.ColumnAnimationService)
    ], Beans.prototype, "columnAnimationService", void 0);
    __decorate([
        context_1.Optional('rangeController'),
        __metadata("design:type", Object)
    ], Beans.prototype, "rangeController", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'),
        __metadata("design:type", focusedCellController_1.FocusedCellController)
    ], Beans.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Optional('contextMenuFactory'),
        __metadata("design:type", Object)
    ], Beans.prototype, "contextMenuFactory", void 0);
    __decorate([
        context_1.Autowired('cellEditorFactory'),
        __metadata("design:type", cellEditorFactory_1.CellEditorFactory)
    ], Beans.prototype, "cellEditorFactory", void 0);
    __decorate([
        context_1.Autowired('cellRendererFactory'),
        __metadata("design:type", cellRendererFactory_1.CellRendererFactory)
    ], Beans.prototype, "cellRendererFactory", void 0);
    __decorate([
        context_1.Autowired('popupService'),
        __metadata("design:type", popupService_1.PopupService)
    ], Beans.prototype, "popupService", void 0);
    __decorate([
        context_1.Autowired('cellRendererService'),
        __metadata("design:type", cellRendererService_1.CellRendererService)
    ], Beans.prototype, "cellRendererService", void 0);
    __decorate([
        context_1.Autowired('valueFormatterService'),
        __metadata("design:type", valueFormatterService_1.ValueFormatterService)
    ], Beans.prototype, "valueFormatterService", void 0);
    __decorate([
        context_1.Autowired('stylingService'),
        __metadata("design:type", stylingService_1.StylingService)
    ], Beans.prototype, "stylingService", void 0);
    __decorate([
        context_1.Autowired('columnHoverService'),
        __metadata("design:type", columnHoverService_1.ColumnHoverService)
    ], Beans.prototype, "columnHoverService", void 0);
    __decorate([
        context_1.Autowired('enterprise'),
        __metadata("design:type", Boolean)
    ], Beans.prototype, "enterprise", void 0);
    __decorate([
        context_1.Autowired('componentResolver'),
        __metadata("design:type", componentResolver_1.ComponentResolver)
    ], Beans.prototype, "componentResolver", void 0);
    __decorate([
        context_1.Autowired('animationFrameService'),
        __metadata("design:type", animationFrameService_1.AnimationFrameService)
    ], Beans.prototype, "taskQueue", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Beans.prototype, "postConstruct", null);
    Beans = __decorate([
        context_1.Bean('beans')
    ], Beans);
    return Beans;
}());
exports.Beans = Beans;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var ValueCache = (function () {
    function ValueCache() {
        this.cacheVersion = 0;
    }
    ValueCache.prototype.init = function () {
        this.active = this.gridOptionsWrapper.isValueCache();
        this.neverExpires = this.gridOptionsWrapper.isValueCacheNeverExpires();
    };
    ValueCache.prototype.onDataChanged = function () {
        if (this.neverExpires) {
            return;
        }
        this.expire();
    };
    ValueCache.prototype.expire = function () {
        this.cacheVersion++;
    };
    ValueCache.prototype.setValue = function (rowNode, colId, value) {
        if (this.active) {
            if (rowNode.__cacheVersion !== this.cacheVersion) {
                rowNode.__cacheVersion = this.cacheVersion;
                rowNode.__cacheData = {};
            }
            rowNode.__cacheData[colId] = value;
        }
    };
    ValueCache.prototype.getValue = function (rowNode, colId) {
        var valueInCache = this.active
            && rowNode.__cacheVersion === this.cacheVersion
            && rowNode.__cacheData[colId] !== undefined;
        if (valueInCache) {
            return rowNode.__cacheData[colId];
        }
        else {
            return undefined;
        }
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ValueCache.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ValueCache.prototype, "init", null);
    ValueCache = __decorate([
        context_1.Bean('valueCache')
    ], ValueCache);
    return ValueCache;
}());
exports.ValueCache = ValueCache;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var constants_1 = __webpack_require__(7);
var context_1 = __webpack_require__(0);
var gridCore_1 = __webpack_require__(33);
var gridOptionsWrapper_1 = __webpack_require__(2);
var PopupService = (function () {
    function PopupService() {
        // this.popupService.setPopupParent(this.eRootPanel.getGui());
        this.activePopupElements = [];
    }
    PopupService.prototype.getPopupParent = function () {
        return this.gridCore.getRootGui();
    };
    PopupService.prototype.positionPopupForMenu = function (params) {
        var sourceRect = params.eventSource.getBoundingClientRect();
        var parentRect = this.getPopupParent().getBoundingClientRect();
        var y = sourceRect.top - parentRect.top;
        y = this.keepYWithinBounds(params, y);
        var minWidth = (params.ePopup.clientWidth > 0) ? params.ePopup.clientWidth : 200;
        var widthOfParent = parentRect.right - parentRect.left;
        var maxX = widthOfParent - minWidth;
        // the x position of the popup depends on RTL or LTR. for normal cases, LTR, we put the child popup
        // to the right, unless it doesn't fit and we then put it to the left. for RTL it's the other way around,
        // we try place it first to the left, and then if not to the right.
        var x;
        if (this.gridOptionsWrapper.isEnableRtl()) {
            // for RTL, try left first
            x = xLeftPosition();
            if (x < 0) {
                x = xRightPosition();
            }
            if (x > maxX) {
                x = 0;
            }
        }
        else {
            // for LTR, try right first
            x = xRightPosition();
            if (x > maxX) {
                x = xLeftPosition();
            }
            if (x < 0) {
                x = 0;
            }
        }
        params.ePopup.style.left = x + "px";
        params.ePopup.style.top = y + "px";
        function xRightPosition() {
            return sourceRect.right - parentRect.left - 2;
        }
        function xLeftPosition() {
            return sourceRect.left - parentRect.left - minWidth;
        }
    };
    PopupService.prototype.positionPopupUnderMouseEvent = function (params) {
        var parentRect = this.getPopupParent().getBoundingClientRect();
        this.positionPopup({
            ePopup: params.ePopup,
            x: params.mouseEvent.clientX - parentRect.left,
            y: params.mouseEvent.clientY - parentRect.top,
            keepWithinBounds: true
        });
        this.callPostProcessPopup(params.ePopup, null, params.mouseEvent, params.type, params.column, params.rowNode);
    };
    PopupService.prototype.positionPopupUnderComponent = function (params) {
        var sourceRect = params.eventSource.getBoundingClientRect();
        var parentRect = this.getPopupParent().getBoundingClientRect();
        this.positionPopup({
            ePopup: params.ePopup,
            minWidth: params.minWidth,
            nudgeX: params.nudgeX,
            nudgeY: params.nudgeY,
            x: sourceRect.left - parentRect.left,
            y: sourceRect.top - parentRect.top + sourceRect.height,
            keepWithinBounds: params.keepWithinBounds
        });
        this.callPostProcessPopup(params.ePopup, params.eventSource, null, params.type, params.column, params.rowNode);
    };
    PopupService.prototype.callPostProcessPopup = function (ePopup, eventSource, mouseEvent, type, column, rowNode) {
        var callback = this.gridOptionsWrapper.getPostProcessPopupFunc();
        if (callback) {
            var params = {
                column: column,
                rowNode: rowNode,
                ePopup: ePopup,
                type: type,
                eventSource: eventSource,
                mouseEvent: mouseEvent
            };
            callback(params);
        }
    };
    PopupService.prototype.positionPopupOverComponent = function (params) {
        var sourceRect = params.eventSource.getBoundingClientRect();
        var parentRect = this.getPopupParent().getBoundingClientRect();
        this.positionPopup({
            ePopup: params.ePopup,
            minWidth: params.minWidth,
            nudgeX: params.nudgeX,
            nudgeY: params.nudgeY,
            x: sourceRect.left - parentRect.left,
            y: sourceRect.top - parentRect.top,
            keepWithinBounds: params.keepWithinBounds
        });
        this.callPostProcessPopup(params.ePopup, params.eventSource, null, params.type, params.column, params.rowNode);
    };
    PopupService.prototype.positionPopup = function (params) {
        var x = params.x;
        var y = params.y;
        if (params.nudgeX) {
            x += params.nudgeX;
        }
        if (params.nudgeY) {
            y += params.nudgeY;
        }
        // if popup is overflowing to the bottom, move it up
        if (params.keepWithinBounds) {
            x = this.keepXWithinBounds(params, x);
            y = this.keepYWithinBounds(params, y);
        }
        params.ePopup.style.left = x + "px";
        params.ePopup.style.top = y + "px";
    };
    PopupService.prototype.keepYWithinBounds = function (params, y) {
        var parentRect = this.getPopupParent().getBoundingClientRect();
        var minHeight;
        if (params.ePopup.clientHeight > 0) {
            minHeight = params.ePopup.clientHeight;
        }
        else {
            minHeight = 200;
        }
        var heightOfParent = parentRect.bottom - parentRect.top;
        var maxY = heightOfParent - minHeight - 5;
        if (y > maxY) {
            return maxY;
        }
        else if (y < 0) {
            return 0;
        }
        else {
            return y;
        }
    };
    PopupService.prototype.keepXWithinBounds = function (params, x) {
        var parentRect = this.getPopupParent().getBoundingClientRect();
        var minWidth;
        if (params.minWidth > 0) {
            minWidth = params.minWidth;
        }
        else if (params.ePopup.clientWidth > 0) {
            minWidth = params.ePopup.clientWidth;
        }
        else {
            minWidth = 200;
        }
        var widthOfParent = parentRect.right - parentRect.left;
        var maxX = widthOfParent - minWidth - 5;
        if (x > maxX) {
            return maxX;
        }
        else if (x < 0) {
            return 0;
        }
        else {
            return x;
        }
    };
    //adds an element to a div, but also listens to background checking for clicks,
    //so that when the background is clicked, the child is removed again, giving
    //a model look to popups.
    PopupService.prototype.addAsModalPopup = function (eChild, closeOnEsc, closedCallback) {
        var _this = this;
        var eBody = this.gridOptionsWrapper.getDocument();
        if (!eBody) {
            console.warn('ag-grid: could not find the body of the document, document.body is empty');
            return;
        }
        eChild.style.top = '0px';
        eChild.style.left = '0px';
        var popupAlreadyShown = utils_1.Utils.isVisible(eChild);
        if (popupAlreadyShown) {
            return;
        }
        var ePopupParent = this.getPopupParent();
        ePopupParent.appendChild(eChild);
        this.activePopupElements.push(eChild);
        var popupHidden = false;
        // let timeOfMouseEventOnChild = new Date().getTime();
        // let childMouseClick: MouseEvent = null;
        // let childTouch: TouchEvent = null;
        var hidePopupOnEsc = function (event) {
            var key = event.which || event.keyCode;
            if (key === constants_1.Constants.KEY_ESCAPE) {
                hidePopup(null);
            }
        };
        var hidePopup = function (event) {
            // we don't hide popup if the event was on the child, or any
            // children of this child
            var indexOfThisChild = _this.activePopupElements.indexOf(eChild);
            for (var i = indexOfThisChild; i < _this.activePopupElements.length; i++) {
                var element = _this.activePopupElements[i];
                if (utils_1.Utils.isElementInEventPath(element, event)) {
                    return;
                }
            }
            // this method should only be called once. the client can have different
            // paths, each one wanting to close, so this method may be called multiple
            // times.
            if (popupHidden) {
                return;
            }
            popupHidden = true;
            ePopupParent.removeChild(eChild);
            utils_1.Utils.removeFromArray(_this.activePopupElements, eChild);
            eBody.removeEventListener('keydown', hidePopupOnEsc);
            eBody.removeEventListener('click', hidePopup);
            eBody.removeEventListener('touchstart', hidePopup);
            eBody.removeEventListener('contextmenu', hidePopup);
            // eChild.removeEventListener('click', consumeMouseClick);
            // eChild.removeEventListener('touchstart', consumeTouchClick);
            if (closedCallback) {
                closedCallback();
            }
        };
        // if we add these listeners now, then the current mouse
        // click will be included, which we don't want
        setTimeout(function () {
            if (closeOnEsc) {
                eBody.addEventListener('keydown', hidePopupOnEsc);
            }
            eBody.addEventListener('click', hidePopup);
            eBody.addEventListener('touchstart', hidePopup);
            eBody.addEventListener('contextmenu', hidePopup);
        }, 0);
        return hidePopup;
    };
    __decorate([
        context_1.Autowired('gridCore'),
        __metadata("design:type", gridCore_1.GridCore)
    ], PopupService.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], PopupService.prototype, "gridOptionsWrapper", void 0);
    PopupService = __decorate([
        context_1.Bean('popupService')
    ], PopupService);
    return PopupService;
}());
exports.PopupService = PopupService;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var context_2 = __webpack_require__(0);
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var cellComp_1 = __webpack_require__(41);
var MouseEventService = (function () {
    function MouseEventService() {
        this.gridInstanceId = MouseEventService_1.gridInstanceSequence.next();
    }
    MouseEventService_1 = MouseEventService;
    MouseEventService.prototype.init = function () {
        this.stampDomElementWithGridInstance();
    };
    // we put the instance id onto the main DOM element. this is used for events, when grids are inside grids,
    // so the grid can work out if the even came from this grid or a grid inside this one. see the ctrl+v logic
    // for where this is used.
    MouseEventService.prototype.stampDomElementWithGridInstance = function () {
        this.eGridDiv[MouseEventService_1.GRID_DOM_KEY] = this.gridInstanceId;
    };
    MouseEventService.prototype.getRenderedCellForEvent = function (event) {
        var sourceElement = utils_1.Utils.getTarget(event);
        while (sourceElement) {
            var renderedCell = this.gridOptionsWrapper.getDomData(sourceElement, cellComp_1.CellComp.DOM_DATA_KEY_CELL_COMP);
            if (renderedCell) {
                return renderedCell;
            }
            sourceElement = sourceElement.parentElement;
        }
        return null;
    };
    // walks the path of the event, and returns true if this grid is the first one that it finds. if doing
    // master / detail grids, and a child grid is found, then it returns false. this stops things like copy/paste
    // getting executed on many grids at the same time.
    MouseEventService.prototype.isEventFromThisGrid = function (event) {
        var path = utils_1.Utils.getEventPath(event);
        for (var i = 0; i < path.length; i++) {
            var element = path[i];
            var instanceId = element[MouseEventService_1.GRID_DOM_KEY];
            if (utils_1.Utils.exists(instanceId)) {
                var eventFromThisGrid = instanceId === this.gridInstanceId;
                return eventFromThisGrid;
            }
        }
        return false;
    };
    MouseEventService.prototype.getGridCellForEvent = function (event) {
        var cellComp = this.getRenderedCellForEvent(event);
        return cellComp ? cellComp.getGridCell() : null;
    };
    MouseEventService.gridInstanceSequence = new utils_1.NumberSequence();
    MouseEventService.GRID_DOM_KEY = '__ag_grid_instance';
    __decorate([
        context_2.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], MouseEventService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_2.Autowired('eGridDiv'),
        __metadata("design:type", HTMLElement)
    ], MouseEventService.prototype, "eGridDiv", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], MouseEventService.prototype, "init", null);
    MouseEventService = MouseEventService_1 = __decorate([
        context_1.Bean('mouseEventService')
    ], MouseEventService);
    return MouseEventService;
    var MouseEventService_1;
}());
exports.MouseEventService = MouseEventService;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var context_1 = __webpack_require__(0);
var HorizontalDragService = (function () {
    function HorizontalDragService() {
    }
    HorizontalDragService.prototype.addDragHandling = function (params) {
        var _this = this;
        params.eDraggableElement.addEventListener('mousedown', function (startEvent) {
            var myDocument = _this.gridOptionsWrapper.getDocument();
            var eBody = myDocument.querySelector('body');
            new DragInstance(params, startEvent, eBody);
        });
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], HorizontalDragService.prototype, "gridOptionsWrapper", void 0);
    HorizontalDragService = __decorate([
        context_1.Bean('horizontalDragService')
    ], HorizontalDragService);
    return HorizontalDragService;
}());
exports.HorizontalDragService = HorizontalDragService;
var DragInstance = (function () {
    function DragInstance(params, startEvent, eBody) {
        this.mouseMove = this.onMouseMove.bind(this);
        this.mouseUp = this.onMouseUp.bind(this);
        this.mouseLeave = this.onMouseLeave.bind(this);
        this.lastDelta = 0;
        this.params = params;
        this.eDragParent = eBody;
        this.dragStartX = startEvent.clientX;
        this.startEvent = startEvent;
        this.eDragParent.addEventListener('mousemove', this.mouseMove);
        this.eDragParent.addEventListener('mouseup', this.mouseUp);
        this.eDragParent.addEventListener('mouseleave', this.mouseLeave);
        this.draggingStarted = false;
        var startAfterPixelsExist = typeof params.startAfterPixels === 'number' && params.startAfterPixels > 0;
        if (!startAfterPixelsExist) {
            this.startDragging();
        }
    }
    DragInstance.prototype.startDragging = function () {
        this.draggingStarted = true;
        this.oldBodyCursor = this.params.eBody.style.cursor;
        this.oldParentCursor = this.eDragParent.style.cursor;
        this.oldMsUserSelect = this.eDragParent.style.msUserSelect;
        this.oldWebkitUserSelect = this.eDragParent.style.webkitUserSelect;
        // change the body cursor, so when drag moves out of the drag bar, the cursor is still 'resize' (or 'move'
        this.params.eBody.style.cursor = this.params.cursor;
        // same for outside the grid, we want to keep the resize (or move) cursor
        this.eDragParent.style.cursor = this.params.cursor;
        // we don't want text selection outside the grid (otherwise it looks weird as text highlights when we move)
        this.eDragParent.style.msUserSelect = 'none';
        this.eDragParent.style.webkitUserSelect = 'none';
        this.params.onDragStart(this.startEvent);
    };
    DragInstance.prototype.onMouseMove = function (moveEvent) {
        var newX = moveEvent.clientX;
        this.lastDelta = newX - this.dragStartX;
        if (!this.draggingStarted) {
            var dragExceededStartAfterPixels = Math.abs(this.lastDelta) >= this.params.startAfterPixels;
            if (dragExceededStartAfterPixels) {
                this.startDragging();
            }
        }
        if (this.draggingStarted) {
            this.params.onDragging(this.lastDelta, false);
        }
    };
    DragInstance.prototype.onMouseUp = function () {
        this.stopDragging();
    };
    DragInstance.prototype.onMouseLeave = function () {
        this.stopDragging();
    };
    DragInstance.prototype.stopDragging = function () {
        // reset cursor back to original cursor, if they were changed in the first place
        if (this.draggingStarted) {
            this.params.eBody.style.cursor = this.oldBodyCursor;
            this.eDragParent.style.cursor = this.oldParentCursor;
            this.eDragParent.style.msUserSelect = this.oldMsUserSelect;
            this.eDragParent.style.webkitUserSelect = this.oldWebkitUserSelect;
            this.params.onDragging(this.lastDelta, true);
        }
        // always remove the listeners, as these are always added
        this.eDragParent.removeEventListener('mousemove', this.mouseMove);
        this.eDragParent.removeEventListener('mouseup', this.mouseUp);
        this.eDragParent.removeEventListener('mouseleave', this.mouseLeave);
    };
    return DragInstance;
}());


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridPanel_1 = __webpack_require__(10);
var linkedList_1 = __webpack_require__(145);
var AnimationFrameService = (function () {
    function AnimationFrameService() {
        this.p1Tasks = new linkedList_1.LinkedList();
        this.p2Tasks = new linkedList_1.LinkedList();
        this.ticking = false;
    }
    AnimationFrameService.prototype.addP1Task = function (task) {
        this.p1Tasks.add(task);
        this.schedule();
    };
    AnimationFrameService.prototype.addP2Task = function (task) {
        this.p2Tasks.add(task);
        this.schedule();
    };
    AnimationFrameService.prototype.executeFrame = function (millis) {
        var frameStart = new Date().getTime();
        var duration = (new Date().getTime()) - frameStart;
        var gridPanelNeedsAFrame = true;
        // 16ms is 60 fps
        var noMaxMillis = millis <= 0;
        while (noMaxMillis || duration < millis) {
            if (gridPanelNeedsAFrame) {
                gridPanelNeedsAFrame = this.gridPanel.executeFrame();
            }
            else if (!this.p1Tasks.isEmpty()) {
                var task = this.p1Tasks.remove();
                task();
            }
            else if (!this.p2Tasks.isEmpty()) {
                var task = this.p2Tasks.remove();
                task();
            }
            else {
                break;
            }
            duration = (new Date().getTime()) - frameStart;
        }
        if (gridPanelNeedsAFrame || !this.p1Tasks.isEmpty() || !this.p2Tasks.isEmpty()) {
            this.requestFrame();
        }
        else {
            this.ticking = false;
        }
    };
    AnimationFrameService.prototype.flushAllFrames = function () {
        this.executeFrame(-1);
    };
    AnimationFrameService.prototype.schedule = function () {
        if (!this.ticking) {
            this.ticking = true;
            this.requestFrame();
        }
    };
    AnimationFrameService.prototype.requestFrame = function () {
        // check for the existence of requestAnimationFrame, and if
        // it's missing, then we polyfill it with setTimeout()
        var callback = this.executeFrame.bind(this, 60);
        if (window.requestAnimationFrame) {
            window.requestAnimationFrame(callback);
        }
        else if (window.webkitRequestAnimationFrame) {
            window.webkitRequestAnimationFrame(callback);
        }
        else {
            setTimeout(callback, 0);
        }
    };
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], AnimationFrameService.prototype, "gridPanel", void 0);
    AnimationFrameService = __decorate([
        context_1.Bean('animationFrameService')
    ], AnimationFrameService);
    return AnimationFrameService;
}());
exports.AnimationFrameService = AnimationFrameService;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var column_1 = __webpack_require__(9);
var rowNode_1 = __webpack_require__(15);
var constants_1 = __webpack_require__(7);
var events_1 = __webpack_require__(5);
var gridCell_1 = __webpack_require__(23);
var component_1 = __webpack_require__(8);
var checkboxSelectionComponent_1 = __webpack_require__(84);
var CellComp = (function (_super) {
    __extends(CellComp, _super);
    function CellComp(scope, beans, column, rowNode, rowComp) {
        var _this = _super.call(this) || this;
        _this.editingCell = false;
        // every time we go into edit mode, or back again, this gets incremented.
        // it's the components way of dealing with the async nature of framework components,
        // so if a framework component takes a while to be created, we know if the object
        // is still relevant when creating is finished. eg we could click edit / unedit 20
        // times before the first React edit component comes back - we should discard
        // the first 19.
        _this.cellEditorVersion = 0;
        _this.cellRendererVersion = 0;
        _this.scope = scope;
        _this.beans = beans;
        _this.column = column;
        _this.rowNode = rowNode;
        _this.rowComp = rowComp;
        _this.createGridCellVo();
        _this.rangeSelectionEnabled = beans.enterprise && beans.gridOptionsWrapper.isEnableRangeSelection();
        _this.cellFocused = _this.beans.focusedCellController.isCellFocused(_this.gridCell);
        _this.firstRightPinned = _this.column.isFirstRightPinned();
        _this.lastLeftPinned = _this.column.isLastLeftPinned();
        if (_this.rangeSelectionEnabled) {
            _this.rangeCount = _this.beans.rangeController.getCellRangeCount(_this.gridCell);
        }
        _this.value = _this.getValue();
        _this.setUsingWrapper();
        _this.chooseCellRenderer();
        _this.setupColSpan();
        return _this;
    }
    CellComp.prototype.getCreateTemplate = function () {
        var templateParts = [];
        var col = this.column;
        var width = this.getCellWidth();
        var left = col.getLeft();
        var valueToRender = this.getInitialValueToRender();
        var valueSanitised = utils_1._.get(this.column, 'colDef.template', null) ? valueToRender : utils_1._.escape(valueToRender);
        var tooltip = this.getToolTip();
        var tooltipSanitised = utils_1._.escape(tooltip);
        var wrapperStartTemplate;
        var wrapperEndTemplate;
        var stylesFromColDef = this.preProcessStylesFromColDef();
        var cssClasses = this.getInitialCssClasses();
        if (this.usingWrapper) {
            wrapperStartTemplate = '<span ref="eCellWrapper" class="ag-cell-wrapper"><span ref="eCellValue" class="ag-cell-value">';
            wrapperEndTemplate = '</span></span>';
        }
        // hey, this looks like React!!!
        templateParts.push("<div");
        templateParts.push(" tabindex=\"-1\"");
        templateParts.push(" role=\"gridcell\"");
        templateParts.push(" comp-id=\"" + this.getCompId() + "\" ");
        templateParts.push(" col-id=\"" + col.getId() + "\"");
        templateParts.push(" class=\"" + cssClasses.join(' ') + "\"");
        templateParts.push(tooltipSanitised ? " title=\"" + tooltipSanitised + "\"" : "");
        templateParts.push(" style=\"width: " + width + "px; left: " + left + "px; " + stylesFromColDef + "\" >");
        templateParts.push(wrapperStartTemplate);
        templateParts.push(valueSanitised);
        templateParts.push(wrapperEndTemplate);
        templateParts.push("</div>");
        return templateParts.join('');
    };
    CellComp.prototype.afterAttached = function () {
        var querySelector = "[comp-id=\"" + this.getCompId() + "\"]";
        var eGui = this.eParentRow.querySelector(querySelector);
        this.setGui(eGui);
        // all of these have dependencies on the eGui, so only do them after eGui is set
        this.addDomData();
        this.addSelectionCheckbox();
        this.attachCellRenderer();
        this.angular1Compile();
        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_CELL_FOCUSED, this.onCellFocused.bind(this));
        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_FLASH_CELLS, this.onFlashCells.bind(this));
        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_COLUMN_HOVER_CHANGED, this.onColumnHover.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_CELL_CHANGED, this.onCellChanged.bind(this));
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this));
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_WIDTH_CHANGED, this.onWidthChanged.bind(this));
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, this.onFirstRightPinnedChanged.bind(this));
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, this.onLastLeftPinnedChanged.bind(this));
        // if not doing enterprise, then range selection service would be missing
        // so need to check before trying to use it
        if (this.rangeSelectionEnabled) {
            this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_RANGE_SELECTION_CHANGED, this.onRangeSelectionChanged.bind(this));
        }
    };
    CellComp.prototype.onColumnHover = function () {
        var isHovered = this.beans.columnHoverService.isHovered(this.column);
        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-column-hover', isHovered);
    };
    CellComp.prototype.onCellChanged = function (event) {
        var eventImpactsThisCell = event.column === this.column;
        if (eventImpactsThisCell) {
            this.refreshCell({});
        }
    };
    CellComp.prototype.getCellLeft = function () {
        var mostLeftCol;
        if (this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning) {
            mostLeftCol = this.colsSpanning[this.colsSpanning.length - 1];
        }
        else {
            mostLeftCol = this.column;
        }
        return mostLeftCol.getLeft();
    };
    CellComp.prototype.getCellWidth = function () {
        if (this.colsSpanning) {
            var result_1 = 0;
            this.colsSpanning.forEach(function (col) { return result_1 += col.getActualWidth(); });
            return result_1;
        }
        else {
            return this.column.getActualWidth();
        }
    };
    CellComp.prototype.onFlashCells = function (event) {
        var cellId = this.gridCell.createId();
        var shouldFlash = event.cells[cellId];
        if (shouldFlash) {
            this.animateCell('highlight');
        }
    };
    CellComp.prototype.setupColSpan = function () {
        // if no col span is active, then we don't set it up, as it would be wasteful of CPU
        if (utils_1._.missing(this.column.getColDef().colSpan)) {
            return;
        }
        // because we are col spanning, a reorder of the cols can change what cols we are spanning over
        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this));
        // because we are spanning over multiple cols, we check for width any time any cols width changes.
        // this is expensive - really we should be explicitly checking only the cols we are spanning over
        // instead of every col, however it would be tricky code to track the cols we are spanning over, so
        // because hardly anyone will be using colSpan, am favoring this easier way for more maintainable code.
        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this));
        this.colsSpanning = this.getColSpanningList();
    };
    CellComp.prototype.getColSpanningList = function () {
        var colSpan = this.column.getColSpan(this.rowNode);
        var colsSpanning = [];
        // if just one col, the col span is just the column we are in
        if (colSpan === 1) {
            colsSpanning.push(this.column);
        }
        else {
            var pointer = this.column;
            var pinned = this.column.getPinned();
            for (var i = 0; i < colSpan; i++) {
                colsSpanning.push(pointer);
                pointer = this.beans.columnController.getDisplayedColAfter(pointer);
                if (utils_1._.missing(pointer)) {
                    break;
                }
                // we do not allow col spanning to span outside of pinned areas
                if (pinned !== pointer.getPinned()) {
                    break;
                }
            }
        }
        return colsSpanning;
    };
    CellComp.prototype.onDisplayColumnsChanged = function () {
        var colsSpanning = this.getColSpanningList();
        if (!utils_1._.compareArrays(this.colsSpanning, colsSpanning)) {
            this.colsSpanning = colsSpanning;
            this.onWidthChanged();
            this.onLeftChanged(); // left changes when doing RTL
        }
    };
    CellComp.prototype.getInitialCssClasses = function () {
        var cssClasses = ["ag-cell", "ag-cell-not-inline-editing"];
        cssClasses.push(this.cellFocused ? 'ag-cell-focus' : 'ag-cell-no-focus');
        if (this.firstRightPinned) {
            cssClasses.push('ag-cell-first-right-pinned');
        }
        if (this.lastLeftPinned) {
            cssClasses.push('ag-cell-last-left-pinned');
        }
        if (this.beans.columnHoverService.isHovered(this.column)) {
            cssClasses.push('ag-column-hover');
        }
        utils_1._.pushAll(cssClasses, this.preProcessClassesFromColDef());
        utils_1._.pushAll(cssClasses, this.preProcessCellClassRules());
        utils_1._.pushAll(cssClasses, this.getRangeClasses());
        // if using the wrapper, this class goes on the wrapper instead
        if (!this.usingWrapper) {
            cssClasses.push('ag-cell-value');
        }
        return cssClasses;
    };
    CellComp.prototype.getInitialValueToRender = function () {
        // if using a cellRenderer, then render the html from the cell renderer if it exists
        if (this.usingCellRenderer) {
            if (typeof this.cellRendererGui === 'string') {
                return this.cellRendererGui;
            }
            else {
                return '';
            }
        }
        var colDef = this.column.getColDef();
        if (colDef.template) {
            // template is really only used for angular 1 - as people using ng1 are used to providing templates with
            // bindings in it. in ng2, people will hopefully want to provide components, not templates.
            return colDef.template;
        }
        else if (colDef.templateUrl) {
            // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.
            // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would
            // not do these, but would follow a pattern that was friendly towards components, not templates.
            var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));
            if (template) {
                return template;
            }
            else {
                return '';
            }
        }
        else {
            var valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, null, this.value);
            var valueFormattedExits = valueFormatted !== null && valueFormatted !== undefined;
            return valueFormattedExits ? valueFormatted : this.value;
        }
    };
    CellComp.prototype.getRenderedRow = function () {
        return this.rowComp;
    };
    CellComp.prototype.isSuppressNavigable = function () {
        return this.column.isSuppressNavigable(this.rowNode);
    };
    // + stop editing {forceRefresh: true, suppressFlash: true}
    // + event cellChanged {}
    // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
    // + rowComp: event dataChanged {animate: update, newData: !update}
    // + rowComp: api refreshCells() {animate: true/false}
    // + rowRenderer: api softRefreshView() {}
    CellComp.prototype.refreshCell = function (params) {
        if (this.editingCell) {
            return;
        }
        var newData = params && params.newData;
        var suppressFlash = params && params.suppressFlash;
        var volatile = params && params.volatile;
        var forceRefresh = params && params.forceRefresh;
        // if only refreshing volatile cells, then skip the refresh if we are not volatile
        if (volatile && !this.isVolatile()) {
            return;
        }
        var oldValue = this.value;
        this.value = this.getValue();
        // for simple values only (not pojo's), see if the value is the same, and if it is, skip the refresh.
        // when never allow skipping after an edit, as after editing, we need to put the GUI back to the way
        // if was before the edit.
        var skipRefresh = !forceRefresh && this.valuesAreEqual(oldValue, this.value);
        if (skipRefresh) {
            return;
        }
        var cellRendererRefreshed;
        // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.
        // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')
        // then we are not showing a movement in the stock price, rather we are showing different stock.
        if (newData || suppressFlash) {
            cellRendererRefreshed = false;
        }
        else {
            cellRendererRefreshed = this.attemptCellRendererRefresh();
        }
        // we do the replace if not doing refresh, or if refresh was unsuccessful.
        // the refresh can be unsuccessful if we are using a framework (eg ng2 or react) and the framework
        // wrapper has the refresh method, but the underlying component doesn't
        if (!cellRendererRefreshed) {
            this.replaceContentsAfterRefresh();
        }
        if (!suppressFlash) {
            this.flashCell();
        }
        // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static
        this.postProcessStylesFromColDef();
        this.postProcessClassesFromColDef();
        this.postProcessCellClassRules();
    };
    CellComp.prototype.flashCell = function () {
        if (this.beans.gridOptionsWrapper.isEnableCellChangeFlash() || this.column.getColDef().enableCellChangeFlash) {
            this.animateCell('data-changed');
        }
    };
    CellComp.prototype.animateCell = function (cssName) {
        var fullName = 'ag-cell-' + cssName;
        var animationFullName = 'ag-cell-' + cssName + '-animation';
        var element = this.getGui();
        // we want to highlight the cells, without any animation
        utils_1._.addCssClass(element, fullName);
        utils_1._.removeCssClass(element, animationFullName);
        // then once that is applied, we remove the highlight with animation
        setTimeout(function () {
            utils_1._.removeCssClass(element, fullName);
            utils_1._.addCssClass(element, animationFullName);
            setTimeout(function () {
                // and then to leave things as we got them, we remove the animation
                utils_1._.removeCssClass(element, animationFullName);
            }, 1000);
        }, 500);
    };
    CellComp.prototype.replaceContentsAfterRefresh = function () {
        // otherwise we rip out the cell and replace it
        utils_1._.removeAllChildren(this.eParentOfValue);
        // remove old renderer component if it exists
        if (this.cellRenderer && this.cellRenderer.destroy) {
            this.cellRenderer.destroy();
        }
        this.cellRenderer = null;
        this.cellRendererGui = null;
        // populate
        this.putDataIntoCellAfterRefresh();
        this.angular1Compile();
    };
    CellComp.prototype.angular1Compile = function () {
        // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)
        if (this.beans.gridOptionsWrapper.isAngularCompileRows()) {
            var eGui = this.getGui();
            this.beans.$compile(eGui)(this.scope);
        }
    };
    CellComp.prototype.postProcessStylesFromColDef = function () {
        var stylesToUse = this.processStylesFromColDef();
        if (stylesToUse) {
            utils_1._.addStylesToElement(this.getGui(), stylesToUse);
        }
    };
    CellComp.prototype.preProcessStylesFromColDef = function () {
        var stylesToUse = this.processStylesFromColDef();
        return utils_1._.cssStyleObjectToMarkup(stylesToUse);
    };
    CellComp.prototype.processStylesFromColDef = function () {
        var colDef = this.column.getColDef();
        if (colDef.cellStyle) {
            var cssToUse = void 0;
            if (typeof colDef.cellStyle === 'function') {
                var cellStyleParams = {
                    value: this.value,
                    data: this.rowNode.data,
                    node: this.rowNode,
                    colDef: colDef,
                    column: this.column,
                    $scope: this.scope,
                    context: this.beans.gridOptionsWrapper.getContext(),
                    api: this.beans.gridOptionsWrapper.getApi()
                };
                var cellStyleFunc = colDef.cellStyle;
                cssToUse = cellStyleFunc(cellStyleParams);
            }
            else {
                cssToUse = colDef.cellStyle;
            }
            return cssToUse;
        }
    };
    CellComp.prototype.postProcessClassesFromColDef = function () {
        var _this = this;
        this.processClassesFromColDef(function (className) { return utils_1._.addCssClass(_this.getGui(), className); });
    };
    CellComp.prototype.preProcessClassesFromColDef = function () {
        var res = [];
        this.processClassesFromColDef(function (className) { return res.push(className); });
        return res;
    };
    CellComp.prototype.processClassesFromColDef = function (onApplicableClass) {
        this.beans.stylingService.processStaticCellClasses(this.column.getColDef(), {
            value: this.value,
            data: this.rowNode.data,
            node: this.rowNode,
            colDef: this.column.getColDef(),
            rowIndex: this.rowNode.rowIndex,
            $scope: this.scope,
            api: this.beans.gridOptionsWrapper.getApi(),
            context: this.beans.gridOptionsWrapper.getContext()
        }, onApplicableClass);
    };
    CellComp.prototype.putDataIntoCellAfterRefresh = function () {
        // template gets preference, then cellRenderer, then do it ourselves
        var colDef = this.column.getColDef();
        if (colDef.template) {
            // template is really only used for angular 1 - as people using ng1 are used to providing templates with
            // bindings in it. in ng2, people will hopefully want to provide components, not templates.
            this.eParentOfValue.innerHTML = colDef.template;
        }
        else if (colDef.templateUrl) {
            // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.
            // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would
            // not do these, but would follow a pattern that was friendly towards components, not templates.
            var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));
            if (template) {
                this.eParentOfValue.innerHTML = template;
            }
            // use cell renderer if it exists
        }
        else if (this.usingCellRenderer) {
            this.attachCellRenderer();
        }
        else {
            var valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, this.value);
            var valueFormattedExits = valueFormatted !== null && valueFormatted !== undefined;
            var valueToRender = valueFormattedExits ? valueFormatted : this.value;
            if (valueToRender !== null && valueToRender !== undefined) {
                this.eParentOfValue.innerText = valueToRender;
            }
        }
        if (colDef.tooltipField) {
            var data = this.rowNode.data;
            if (utils_1._.exists(data)) {
                var tooltip = utils_1._.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());
                if (utils_1._.exists(tooltip)) {
                    this.eParentOfValue.setAttribute('title', tooltip);
                }
                else {
                    this.eParentOfValue.removeAttribute('title');
                }
            }
        }
    };
    CellComp.prototype.attemptCellRendererRefresh = function () {
        if (utils_1._.missing(this.cellRenderer) || utils_1._.missing(this.cellRenderer.refresh)) {
            return false;
        }
        // if the cell renderer has a refresh method, we call this instead of doing a refresh
        // note: should pass in params here instead of value?? so that client has formattedValue
        var valueFormatted = this.formatValue(this.value);
        var params = this.createCellRendererParams(valueFormatted);
        var result = this.cellRenderer.refresh(params);
        // NOTE on undefined: previous version of the cellRenderer.refresh() interface
        // returned nothing, if the method existed, we assumed it refreshed. so for
        // backwards compatibility, we assume if method exists and returns nothing,
        // that it was successful.
        return result === true || result === undefined;
    };
    CellComp.prototype.isVolatile = function () {
        return this.column.getColDef().volatile;
    };
    CellComp.prototype.valuesAreEqual = function (val1, val2) {
        // if the user provided an equals method, use that, otherwise do simple comparison
        var colDef = this.column.getColDef();
        var equalsMethod = colDef ? colDef.equals : null;
        if (equalsMethod) {
            return equalsMethod(val1, val2);
        }
        else {
            return val1 === val2;
        }
    };
    CellComp.prototype.getToolTip = function () {
        var colDef = this.column.getColDef();
        var data = this.rowNode.data;
        if (colDef.tooltipField && utils_1._.exists(data)) {
            return utils_1._.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());
        }
        else {
            return null;
        }
    };
    CellComp.prototype.processCellClassRules = function (onApplicableClass, onNotApplicableClass) {
        this.beans.stylingService.processClassRules(this.column.getColDef().cellClassRules, {
            value: this.value,
            data: this.rowNode.data,
            node: this.rowNode,
            colDef: this.column.getColDef(),
            rowIndex: this.gridCell.rowIndex,
            api: this.beans.gridOptionsWrapper.getApi(),
            context: this.beans.gridOptionsWrapper.getContext()
        }, onApplicableClass, onNotApplicableClass);
    };
    CellComp.prototype.postProcessCellClassRules = function () {
        var _this = this;
        this.processCellClassRules(function (className) {
            utils_1._.addCssClass(_this.getGui(), className);
        }, function (className) {
            utils_1._.removeCssClass(_this.getGui(), className);
        });
    };
    CellComp.prototype.preProcessCellClassRules = function () {
        var res = [];
        this.processCellClassRules(function (className) {
            res.push(className);
        }, function (className) {
            // not catered for, if creating, no need
            // to remove class as it was never there
        });
        return res;
    };
    // a wrapper is used when we are putting a selection checkbox in the cell with the value
    CellComp.prototype.setUsingWrapper = function () {
        var colDef = this.column.getColDef();
        // never allow selection on pinned rows
        if (this.rowNode.rowPinned) {
            this.usingWrapper = false;
        }
        else if (typeof colDef.checkboxSelection === 'boolean') {
            this.usingWrapper = colDef.checkboxSelection;
        }
        else if (typeof colDef.checkboxSelection === 'function') {
            // if checkboxSelection is a function, then the checkbox may or may not be present,
            // so we include the HTML wrapper to cater for either case
            this.usingWrapper = true;
        }
        else {
            this.usingWrapper = false;
        }
    };
    CellComp.prototype.chooseCellRenderer = function () {
        // template gets preference, then cellRenderer, then do it ourselves
        var colDef = this.column.getColDef();
        // templates are for ng1, ideally we wouldn't have these, they are ng1 support
        // inside the core which is bad
        if (colDef.template || colDef.templateUrl) {
            this.usingCellRenderer = false;
            return;
        }
        var cellRenderer = this.beans.componentResolver.getComponentToUse(colDef, 'cellRenderer');
        var pinnedRowCellRenderer = this.beans.componentResolver.getComponentToUse(colDef, 'pinnedRowCellRenderer');
        if (pinnedRowCellRenderer && this.rowNode.rowPinned) {
            this.cellRendererType = 'pinnedRowCellRenderer';
            this.usingCellRenderer = true;
        }
        else if (cellRenderer) {
            this.cellRendererType = 'cellRenderer';
            this.usingCellRenderer = true;
        }
        else {
            this.usingCellRenderer = false;
        }
    };
    CellComp.prototype.createCellRendererInstance = function () {
        var valueToRender = this.formatValue(this.value);
        var params = this.createCellRendererParams(valueToRender);
        this.cellRendererVersion++;
        var callback = this.afterCellRendererCreated.bind(this, this.cellRendererVersion);
        this.beans.componentResolver.createAgGridComponent(this.column.getColDef(), params, this.cellRendererType).then(callback);
    };
    CellComp.prototype.afterCellRendererCreated = function (cellRendererVersion, cellRenderer) {
        // see if daemon
        if (cellRendererVersion !== this.cellRendererVersion) {
            if (cellRenderer.destroy) {
                cellRenderer.destroy();
            }
            return;
        }
        this.cellRenderer = cellRenderer;
        this.cellRendererGui = this.cellRenderer.getGui();
        if (utils_1._.missing(this.cellRendererGui)) {
            return;
        }
        // if async components, then it's possible the user started editing since
        // this call was made
        if (!this.editingCell) {
            this.eParentOfValue.appendChild(this.cellRendererGui);
        }
    };
    CellComp.prototype.attachCellRenderer = function () {
        if (!this.usingCellRenderer) {
            return;
        }
        this.createCellRendererInstance();
    };
    CellComp.prototype.createCellRendererParams = function (valueFormatted) {
        var _this = this;
        var params = {
            value: this.value,
            valueFormatted: valueFormatted,
            getValue: this.getValue.bind(this),
            setValue: function (value) { _this.beans.valueService.setValue(_this.rowNode, _this.column, value); },
            formatValue: this.formatValue.bind(this),
            data: this.rowNode.data,
            node: this.rowNode,
            colDef: this.column.getColDef(),
            column: this.column,
            $scope: this.scope,
            rowIndex: this.gridCell.rowIndex,
            api: this.beans.gridOptionsWrapper.getApi(),
            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
            context: this.beans.gridOptionsWrapper.getContext(),
            refreshCell: this.refreshCell.bind(this),
            // todo danger - in the new world, these are not present :(
            eGridCell: this.getGui(),
            eParentOfValue: this.eParentOfValue,
            // these bits are not documented anywhere, so we could drop them?
            // it was in the olden days to allow user to register for when rendered
            // row was removed (the row comp was removed), however now that the user
            // can provide components for cells, the destroy method gets call when this
            // happens so no longer need to fire event.
            addRowCompListener: this.rowComp.addEventListener.bind(this.rowComp),
            addRenderedRowListener: function (eventType, listener) {
                console.warn('ag-Grid: since ag-Grid .v11, params.addRenderedRowListener() is now params.addRowCompListener()');
                _this.rowComp.addEventListener(eventType, listener);
            }
        };
        return params;
    };
    CellComp.prototype.formatValue = function (value) {
        var valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, value);
        var valueFormattedExists = valueFormatted !== null && valueFormatted !== undefined;
        return valueFormattedExists ? valueFormatted : value;
    };
    CellComp.prototype.getValue = function () {
        // if we don't check this, then the grid will render leaf groups as open even if we are not
        // allowing the user to open leaf groups. confused? remember for pivot mode we don't allow
        // opening leaf groups, so we have to force leafGroups to be closed in case the user expanded
        // them via the API, or user user expanded them in the UI before turning on pivot mode
        var lockedClosedGroup = this.rowNode.leafGroup && this.beans.columnController.isPivotMode();
        var isOpenGroup = this.rowNode.group && this.rowNode.expanded && !this.rowNode.footer && !lockedClosedGroup;
        if (isOpenGroup && this.beans.gridOptionsWrapper.isGroupIncludeFooter()) {
            // if doing grouping and footers, we don't want to include the agg value
            // in the header when the group is open
            return this.beans.valueService.getValue(this.column, this.rowNode, true);
        }
        else {
            return this.beans.valueService.getValue(this.column, this.rowNode);
        }
    };
    CellComp.prototype.onMouseEvent = function (eventName, mouseEvent) {
        switch (eventName) {
            case 'click':
                this.onCellClicked(mouseEvent);
                break;
            case 'mousedown':
                this.onMouseDown();
                break;
            case 'dblclick':
                this.onCellDoubleClicked(mouseEvent);
                break;
            case 'contextmenu':
                this.onContextMenu(mouseEvent);
                break;
            case 'mouseout':
                this.onMouseOut(mouseEvent);
                break;
            case 'mouseover':
                this.onMouseOver(mouseEvent);
                break;
        }
    };
    CellComp.prototype.createEvent = function (domEvent, eventType) {
        var event = {
            node: this.rowNode,
            data: this.rowNode.data,
            value: this.value,
            column: this.column,
            colDef: this.column.getColDef(),
            context: this.beans.gridOptionsWrapper.getContext(),
            api: this.beans.gridApi,
            columnApi: this.beans.columnApi,
            rowPinned: this.rowNode.rowPinned,
            event: domEvent,
            type: eventType,
            rowIndex: this.rowNode.rowIndex
        };
        // because we are hacking in $scope for angular 1, we have to de-reference
        if (this.scope) {
            event.$scope = this.scope;
        }
        return event;
    };
    CellComp.prototype.onMouseOut = function (mouseEvent) {
        var cellMouseOutEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OUT);
        this.beans.eventService.dispatchEvent(cellMouseOutEvent);
    };
    CellComp.prototype.onMouseOver = function (mouseEvent) {
        var cellMouseOverEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OVER);
        this.beans.eventService.dispatchEvent(cellMouseOverEvent);
    };
    CellComp.prototype.onContextMenu = function (mouseEvent) {
        // to allow us to debug in chrome, we ignore the event if ctrl is pressed.
        // not everyone wants this, so first 'if' below allows to turn this hack off.
        if (!this.beans.gridOptionsWrapper.isAllowContextMenuWithControlKey()) {
            // then do the check
            if (mouseEvent.ctrlKey || mouseEvent.metaKey) {
                return;
            }
        }
        var colDef = this.column.getColDef();
        var cellContextMenuEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_CONTEXT_MENU);
        this.beans.eventService.dispatchEvent(cellContextMenuEvent);
        if (colDef.onCellContextMenu) {
            colDef.onCellContextMenu(cellContextMenuEvent);
        }
        if (this.beans.contextMenuFactory && !this.beans.gridOptionsWrapper.isSuppressContextMenu()) {
            this.beans.contextMenuFactory.showMenu(this.rowNode, this.column, this.value, mouseEvent);
            mouseEvent.preventDefault();
        }
    };
    CellComp.prototype.onCellDoubleClicked = function (mouseEvent) {
        var colDef = this.column.getColDef();
        // always dispatch event to eventService
        var cellDoubleClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_DOUBLE_CLICKED);
        this.beans.eventService.dispatchEvent(cellDoubleClickedEvent);
        // check if colDef also wants to handle event
        if (typeof colDef.onCellDoubleClicked === 'function') {
            colDef.onCellDoubleClicked(cellDoubleClickedEvent);
        }
        var editOnDoubleClick = !this.beans.gridOptionsWrapper.isSingleClickEdit()
            && !this.beans.gridOptionsWrapper.isSuppressClickEdit();
        if (editOnDoubleClick) {
            this.startRowOrCellEdit();
        }
    };
    // called by rowRenderer when user navigates via tab key
    CellComp.prototype.startRowOrCellEdit = function (keyPress, charPress) {
        if (this.beans.gridOptionsWrapper.isFullRowEdit()) {
            this.rowComp.startRowEditing(keyPress, charPress, this);
        }
        else {
            this.startEditingIfEnabled(keyPress, charPress, true);
        }
    };
    CellComp.prototype.isCellEditable = function () {
        return this.column.isCellEditable(this.rowNode);
    };
    // either called internally if single cell editing, or called by rowRenderer if row editing
    CellComp.prototype.startEditingIfEnabled = function (keyPress, charPress, cellStartedEdit) {
        if (keyPress === void 0) { keyPress = null; }
        if (charPress === void 0) { charPress = null; }
        if (cellStartedEdit === void 0) { cellStartedEdit = false; }
        // don't do it if not editable
        if (!this.isCellEditable()) {
            return;
        }
        // don't do it if already editing
        if (this.editingCell) {
            return;
        }
        this.editingCell = true;
        this.cellEditorVersion++;
        var callback = this.afterCellEditorCreated.bind(this, this.cellEditorVersion);
        var params = this.createCellEditorParams(keyPress, charPress, cellStartedEdit);
        this.beans.cellEditorFactory.createCellEditor(this.column.getColDef(), params).then(callback);
        // if we don't do this, and editor component is async, then there will be a period
        // when the component isn't present and keyboard navigation won't work - so example
        // of user hitting tab quickly (more quickly than renderers getting created) won't work
        var cellEditorAsync = utils_1._.missing(this.cellEditor);
        if (cellEditorAsync && cellStartedEdit) {
            this.focusCell(true);
        }
    };
    CellComp.prototype.afterCellEditorCreated = function (cellEditorVersion, cellEditor) {
        // if editingCell=false, means user cancelled the editor before component was ready.
        // if versionMismatch, then user cancelled the edit, then started the edit again, and this
        //   is the first editor which is now stale.
        var versionMismatch = cellEditorVersion !== this.cellEditorVersion;
        if (versionMismatch || !this.editingCell) {
            if (cellEditor.destroy) {
                cellEditor.destroy();
            }
            return;
        }
        if (cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart()) {
            if (cellEditor.destroy) {
                cellEditor.destroy();
            }
            this.editingCell = false;
            return;
        }
        if (!cellEditor.getGui) {
            console.warn("ag-Grid: cellEditor for column " + this.column.getId() + " is missing getGui() method");
            // no getGui, for React guys, see if they attached a react component directly
            if (cellEditor.render) {
                console.warn("ag-Grid: we found 'render' on the component, are you trying to set a React renderer but added it as colDef.cellEditor instead of colDef.cellEditorFmk?");
            }
            if (cellEditor.destroy) {
                cellEditor.destroy();
            }
            this.editingCell = false;
            return;
        }
        this.cellEditor = cellEditor;
        this.cellEditorInPopup = cellEditor.isPopup && cellEditor.isPopup();
        this.setInlineEditingClass();
        if (this.cellEditorInPopup) {
            this.addPopupCellEditor();
        }
        else {
            this.addInCellEditor();
        }
        if (cellEditor.afterGuiAttached) {
            cellEditor.afterGuiAttached();
        }
        var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STARTED);
        this.beans.eventService.dispatchEvent(event);
    };
    CellComp.prototype.addInCellEditor = function () {
        utils_1._.removeAllChildren(this.getGui());
        this.getGui().appendChild(this.cellEditor.getGui());
        this.angular1Compile();
    };
    CellComp.prototype.addPopupCellEditor = function () {
        var _this = this;
        var ePopupGui = this.cellEditor.getGui();
        this.hideEditorPopup = this.beans.popupService.addAsModalPopup(ePopupGui, true, 
        // callback for when popup disappears
        function () {
            _this.onPopupEditorClosed();
        });
        this.beans.popupService.positionPopupOverComponent({
            column: this.column,
            rowNode: this.rowNode,
            type: 'popupCellEditor',
            eventSource: this.getGui(),
            ePopup: ePopupGui,
            keepWithinBounds: true
        });
        this.angular1Compile();
    };
    CellComp.prototype.onPopupEditorClosed = function () {
        // we only call stopEditing if we are editing, as
        // it's possible the popup called 'stop editing'
        // before this, eg if 'enter key' was pressed on
        // the editor.
        if (this.editingCell) {
            // note: this only happens when use clicks outside of the grid. if use clicks on another
            // cell, then the editing will have already stopped on this cell
            this.stopRowOrCellEdit();
            // we only focus cell again if this cell is still focused. it is possible
            // it is not focused if the user cancelled the edit by clicking on another
            // cell outside of this one
            if (this.beans.focusedCellController.isCellFocused(this.gridCell)) {
                this.focusCell(true);
            }
        }
    };
    // if we are editing inline, then we don't have the padding in the cell (set in the themes)
    // to allow the text editor full access to the entire cell
    CellComp.prototype.setInlineEditingClass = function () {
        var editingInline = this.editingCell && !this.cellEditorInPopup;
        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-inline-editing', editingInline);
        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-not-inline-editing', !editingInline);
    };
    CellComp.prototype.createCellEditorParams = function (keyPress, charPress, cellStartedEdit) {
        var params = {
            value: this.getValue(),
            keyPress: keyPress,
            charPress: charPress,
            column: this.column,
            rowIndex: this.gridCell.rowIndex,
            node: this.rowNode,
            api: this.beans.gridOptionsWrapper.getApi(),
            cellStartedEdit: cellStartedEdit,
            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
            context: this.beans.gridOptionsWrapper.getContext(),
            $scope: this.scope,
            onKeyDown: this.onKeyDown.bind(this),
            stopEditing: this.stopEditingAndFocus.bind(this),
            eGridCell: this.getGui(),
            parseValue: this.parseValue.bind(this),
            formatValue: this.formatValue.bind(this)
        };
        return params;
    };
    // cell editors call this, when they want to stop for reasons other
    // than what we pick up on. eg selecting from a dropdown ends editing.
    CellComp.prototype.stopEditingAndFocus = function () {
        this.stopRowOrCellEdit();
        this.focusCell(true);
    };
    CellComp.prototype.parseValue = function (newValue) {
        var params = {
            node: this.rowNode,
            data: this.rowNode.data,
            oldValue: this.value,
            newValue: newValue,
            colDef: this.column.getColDef(),
            column: this.column,
            api: this.beans.gridOptionsWrapper.getApi(),
            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
            context: this.beans.gridOptionsWrapper.getContext()
        };
        var valueParser = this.column.getColDef().valueParser;
        return utils_1._.exists(valueParser) ? this.beans.expressionService.evaluate(valueParser, params) : newValue;
    };
    CellComp.prototype.focusCell = function (forceBrowserFocus) {
        if (forceBrowserFocus === void 0) { forceBrowserFocus = false; }
        this.beans.focusedCellController.setFocusedCell(this.gridCell.rowIndex, this.column, this.rowNode.rowPinned, forceBrowserFocus);
    };
    CellComp.prototype.setFocusInOnEditor = function () {
        if (this.editingCell) {
            if (this.cellEditor && this.cellEditor.focusIn) {
                // if the editor is present, then we just focus it
                this.cellEditor.focusIn();
            }
            else {
                // if the editor is not present, it means async cell editor (eg React fibre)
                // and we are trying to set focus before the cell editor is present, so we
                // focus the cell instead
                this.focusCell(true);
            }
        }
    };
    CellComp.prototype.isEditing = function () {
        return this.editingCell;
    };
    CellComp.prototype.onKeyDown = function (event) {
        var key = event.which || event.keyCode;
        // give user a chance to cancel event processing
        if (this.doesUserWantToCancelKeyboardEvent(event)) {
            return;
        }
        switch (key) {
            case constants_1.Constants.KEY_ENTER:
                this.onEnterKeyDown();
                break;
            case constants_1.Constants.KEY_F2:
                this.onF2KeyDown();
                break;
            case constants_1.Constants.KEY_ESCAPE:
                this.onEscapeKeyDown();
                break;
            case constants_1.Constants.KEY_TAB:
                this.onTabKeyDown(event);
                break;
            case constants_1.Constants.KEY_BACKSPACE:
            case constants_1.Constants.KEY_DELETE:
                this.onBackspaceOrDeleteKeyPressed(key);
                break;
            case constants_1.Constants.KEY_DOWN:
            case constants_1.Constants.KEY_UP:
            case constants_1.Constants.KEY_RIGHT:
            case constants_1.Constants.KEY_LEFT:
                this.onNavigationKeyPressed(event, key);
                break;
        }
    };
    CellComp.prototype.doesUserWantToCancelKeyboardEvent = function (event) {
        var callback = this.column.getColDef().suppressKeyboardEvent;
        if (utils_1._.missing(callback)) {
            return false;
        }
        else {
            // if editing is null or undefined, this sets it to false
            var params = {
                event: event,
                editing: this.editingCell,
                column: this.column,
                api: this.beans.gridOptionsWrapper.getApi(),
                node: this.rowNode,
                colDef: this.column.getColDef(),
                context: this.beans.gridOptionsWrapper.getContext(),
                columnApi: this.beans.gridOptionsWrapper.getColumnApi()
            };
            return callback(params);
        }
    };
    CellComp.prototype.setFocusOutOnEditor = function () {
        if (this.editingCell && this.cellEditor && this.cellEditor.focusOut) {
            this.cellEditor.focusOut();
        }
    };
    CellComp.prototype.onNavigationKeyPressed = function (event, key) {
        if (this.editingCell) {
            this.stopRowOrCellEdit();
        }
        this.beans.rowRenderer.navigateToNextCell(event, key, this.gridCell.rowIndex, this.column, this.rowNode.rowPinned);
        // if we don't prevent default, the grid will scroll with the navigation keys
        event.preventDefault();
    };
    CellComp.prototype.onTabKeyDown = function (event) {
        if (this.beans.gridOptionsWrapper.isSuppressTabbing()) {
            return;
        }
        this.beans.rowRenderer.onTabKeyDown(this, event);
    };
    CellComp.prototype.onBackspaceOrDeleteKeyPressed = function (key) {
        if (!this.editingCell) {
            this.startRowOrCellEdit(key);
        }
    };
    CellComp.prototype.onEnterKeyDown = function () {
        if (this.editingCell) {
            this.stopRowOrCellEdit();
            this.focusCell(true);
        }
        else {
            this.startRowOrCellEdit(constants_1.Constants.KEY_ENTER);
        }
    };
    CellComp.prototype.onF2KeyDown = function () {
        if (!this.editingCell) {
            this.startRowOrCellEdit(constants_1.Constants.KEY_F2);
        }
    };
    CellComp.prototype.onEscapeKeyDown = function () {
        if (this.editingCell) {
            this.stopRowOrCellEdit(true);
            this.focusCell(true);
        }
    };
    CellComp.prototype.onKeyPress = function (event) {
        // check this, in case focus is on a (for example) a text field inside the cell,
        // in which cse we should not be listening for these key pressed
        var eventTarget = utils_1._.getTarget(event);
        var eventOnChildComponent = eventTarget !== this.getGui();
        if (eventOnChildComponent) {
            return;
        }
        if (!this.editingCell) {
            var pressedChar = String.fromCharCode(event.charCode);
            if (pressedChar === ' ') {
                this.onSpaceKeyPressed(event);
            }
            else {
                if (utils_1._.isEventFromPrintableCharacter(event)) {
                    this.startRowOrCellEdit(null, pressedChar);
                    // if we don't prevent default, then the keypress also gets applied to the text field
                    // (at least when doing the default editor), but we need to allow the editor to decide
                    // what it wants to do. we only do this IF editing was started - otherwise it messes
                    // up when the use is not doing editing, but using rendering with text fields in cellRenderer
                    // (as it would block the the user from typing into text fields).
                    event.preventDefault();
                }
            }
        }
    };
    CellComp.prototype.onSpaceKeyPressed = function (event) {
        if (!this.editingCell && this.beans.gridOptionsWrapper.isRowSelection()) {
            var selected = this.rowNode.isSelected();
            this.rowNode.setSelected(!selected);
        }
        // prevent default as space key, by default, moves browser scroll down
        event.preventDefault();
    };
    CellComp.prototype.onMouseDown = function () {
        // we pass false to focusCell, as we don't want the cell to focus
        // also get the browser focus. if we did, then the cellRenderer could
        // have a text field in it, for example, and as the user clicks on the
        // text field, the text field, the focus doesn't get to the text
        // field, instead to goes to the div behind, making it impossible to
        // select the text field.
        this.focusCell(false);
        // if it's a right click, then if the cell is already in range,
        // don't change the range, however if the cell is not in a range,
        // we set a new range
        if (this.beans.rangeController) {
            var thisCell = this.gridCell;
            var cellAlreadyInRange = this.beans.rangeController.isCellInAnyRange(thisCell);
            if (!cellAlreadyInRange) {
                this.beans.rangeController.setRangeToCell(thisCell);
            }
        }
    };
    CellComp.prototype.onCellClicked = function (mouseEvent) {
        var cellClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_CLICKED);
        this.beans.eventService.dispatchEvent(cellClickedEvent);
        var colDef = this.column.getColDef();
        if (colDef.onCellClicked) {
            colDef.onCellClicked(cellClickedEvent);
        }
        var editOnSingleClick = this.beans.gridOptionsWrapper.isSingleClickEdit()
            && !this.beans.gridOptionsWrapper.isSuppressClickEdit();
        if (editOnSingleClick) {
            this.startRowOrCellEdit();
        }
        this.doIeFocusHack();
    };
    // https://ag-grid.com/forum/showthread.php?tid=4362
    // when in IE or Edge, when you are editing a cell, then click on another cell,
    // the other cell doesn't keep focus, so navigation keys, type to start edit etc
    // don't work. appears that when you update the dom in IE it looses focus
    CellComp.prototype.doIeFocusHack = function () {
        if (utils_1._.isBrowserIE() || utils_1._.isBrowserEdge()) {
            if (utils_1._.missing(document.activeElement) || document.activeElement === document.body) {
                // console.log('missing focus');
                this.getGui().focus();
            }
        }
    };
    CellComp.prototype.createGridCellVo = function () {
        var gridCellDef = {
            rowIndex: this.rowNode.rowIndex,
            floating: this.rowNode.rowPinned,
            column: this.column
        };
        this.gridCell = new gridCell_1.GridCell(gridCellDef);
    };
    CellComp.prototype.getGridCell = function () {
        return this.gridCell;
    };
    CellComp.prototype.getParentRow = function () {
        return this.eParentRow;
    };
    CellComp.prototype.setParentRow = function (eParentRow) {
        this.eParentRow = eParentRow;
    };
    CellComp.prototype.getColumn = function () {
        return this.column;
    };
    CellComp.prototype.detach = function () {
        this.eParentRow.removeChild(this.getGui());
    };
    // if the row is also getting destroyed, then we don't need to remove from dom,
    // as the row will also get removed, so no need to take out the cells from the row
    // if the row is going (removing is an expensive operation, so only need to remove
    // the top part)
    CellComp.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.cellEditor && this.cellEditor.destroy) {
            this.cellEditor.destroy();
            this.cellEditor = null;
        }
        if (this.cellRenderer && this.cellRenderer.destroy) {
            this.cellRenderer.destroy();
            this.cellRenderer = null;
        }
    };
    CellComp.prototype.onLeftChanged = function () {
        var left = this.getCellLeft();
        this.getGui().style.left = left + 'px';
    };
    CellComp.prototype.onWidthChanged = function () {
        var width = this.getCellWidth();
        this.getGui().style.width = width + 'px';
    };
    CellComp.prototype.getRangeClasses = function () {
        var res = [];
        if (!this.rangeSelectionEnabled) {
            return res;
        }
        if (this.rangeCount !== 0) {
            res.push('ag-cell-range-selected');
        }
        if (this.rangeCount === 1) {
            res.push('ag-cell-range-selected-1');
        }
        if (this.rangeCount === 2) {
            res.push('ag-cell-range-selected-2');
        }
        if (this.rangeCount === 3) {
            res.push('ag-cell-range-selected-3');
        }
        if (this.rangeCount >= 4) {
            res.push('ag-cell-range-selected-4');
        }
        return res;
    };
    CellComp.prototype.onRowIndexChanged = function () {
        // when index changes, this influences items that need the index, so we update the
        // grid cell so they are working off the new index.
        this.createGridCellVo();
        // when the index of the row changes, ie means the cell may have lost or gained focus
        this.onCellFocused();
        // check range selection
        this.onRangeSelectionChanged();
    };
    CellComp.prototype.onRangeSelectionChanged = function () {
        if (!this.beans.enterprise) {
            return;
        }
        var newRangeCount = this.beans.rangeController.getCellRangeCount(this.gridCell);
        var element = this.getGui();
        if (this.rangeCount !== newRangeCount) {
            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected', newRangeCount !== 0);
            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-1', newRangeCount === 1);
            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-2', newRangeCount === 2);
            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-3', newRangeCount === 3);
            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-4', newRangeCount >= 4);
            this.rangeCount = newRangeCount;
        }
    };
    CellComp.prototype.onFirstRightPinnedChanged = function () {
        var firstRightPinned = this.column.isFirstRightPinned();
        if (this.firstRightPinned !== firstRightPinned) {
            this.firstRightPinned = firstRightPinned;
            utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-first-right-pinned', firstRightPinned);
        }
    };
    CellComp.prototype.onLastLeftPinnedChanged = function () {
        var lastLeftPinned = this.column.isLastLeftPinned();
        if (this.lastLeftPinned !== lastLeftPinned) {
            this.lastLeftPinned = lastLeftPinned;
            utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-last-left-pinned', lastLeftPinned);
        }
    };
    CellComp.prototype.addSelectionCheckbox = function () {
        if (this.usingWrapper) {
            this.eParentOfValue = this.getRefElement('eCellValue');
            this.eCellWrapper = this.getRefElement('eCellWrapper');
            var cbSelectionComponent_1 = new checkboxSelectionComponent_1.CheckboxSelectionComponent();
            this.beans.context.wireBean(cbSelectionComponent_1);
            var visibleFunc = this.column.getColDef().checkboxSelection;
            visibleFunc = typeof visibleFunc === 'function' ? visibleFunc : null;
            cbSelectionComponent_1.init({ rowNode: this.rowNode, column: this.column, visibleFunc: visibleFunc });
            this.addDestroyFunc(function () { return cbSelectionComponent_1.destroy(); });
            // put the checkbox in before the value
            this.eCellWrapper.insertBefore(cbSelectionComponent_1.getGui(), this.eParentOfValue);
        }
        else {
            this.eParentOfValue = this.getGui();
        }
    };
    CellComp.prototype.addDomData = function () {
        var _this = this;
        var element = this.getGui();
        this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, this);
        this.addDestroyFunc(function () {
            return _this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, null);
        });
    };
    CellComp.prototype.onCellFocused = function (event) {
        var cellFocused = this.beans.focusedCellController.isCellFocused(this.gridCell);
        // see if we need to change the classes on this cell
        if (cellFocused !== this.cellFocused) {
            utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-focus', cellFocused);
            utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-no-focus', !cellFocused);
            this.cellFocused = cellFocused;
        }
        // if this cell was just focused, see if we need to force browser focus, his can
        // happen if focus is programmatically set.
        if (cellFocused && event && event.forceBrowserFocus) {
            this.getGui().focus();
        }
        // if another cell was focused, and we are editing, then stop editing
        var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();
        if (!cellFocused && !fullRowEdit && this.editingCell) {
            this.stopRowOrCellEdit();
        }
    };
    // pass in 'true' to cancel the editing.
    CellComp.prototype.stopRowOrCellEdit = function (cancel) {
        if (cancel === void 0) { cancel = false; }
        if (this.beans.gridOptionsWrapper.isFullRowEdit()) {
            this.rowComp.stopRowEditing(cancel);
        }
        else {
            this.stopEditing(cancel);
        }
    };
    CellComp.prototype.stopEditing = function (cancel) {
        if (cancel === void 0) { cancel = false; }
        if (!this.editingCell) {
            return;
        }
        // if no cell editor, this means due to async, that the cell editor never got initialised,
        // so we just carry on regardless as if the editing was never started.
        if (!this.cellEditor) {
            this.editingCell = false;
            return;
        }
        if (!cancel) {
            // also have another option here to cancel after editing, so for example user could have a popup editor and
            // it is closed by user clicking outside the editor. then the editor will close automatically (with false
            // passed above) and we need to see if the editor wants to accept the new value.
            var userWantsToCancel = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();
            if (!userWantsToCancel) {
                var newValue = this.cellEditor.getValue();
                this.rowNode.setDataValue(this.column, newValue);
                this.value = this.getValue();
            }
        }
        // it is important we set this after setValue() above, as otherwise the cell will flash
        // when editing stops. the 'refresh' method checks editing, and doesn't refresh editing cells.
        // thus it will skip the refresh on this cell until the end of this method where we call
        // refresh directly and we suppress the flash.
        this.editingCell = false;
        if (this.cellEditor.destroy) {
            this.cellEditor.destroy();
        }
        // important to clear this out - as parts of the code will check for
        // this to see if an async cellEditor has yet to be created
        this.cellEditor = null;
        if (this.cellEditorInPopup) {
            this.hideEditorPopup();
            this.hideEditorPopup = null;
        }
        else {
            utils_1._.removeAllChildren(this.getGui());
            // put the cell back the way it was before editing
            if (this.usingWrapper) {
                // if wrapper, then put the wrapper back
                this.getGui().appendChild(this.eCellWrapper);
            }
            else {
                // if cellRenderer, then put the gui back in. if the renderer has
                // a refresh, it will be called. however if it doesn't, then later
                // the renderer will be destroyed and a new one will be created.
                if (this.cellRenderer) {
                    // we know it's a dom element (not a string) because we converted
                    // it after the gui was attached if it was a string.
                    var eCell = this.cellRendererGui;
                    // can be null if cell was previously null / contained empty string,
                    // this will result in new value not being rendered.
                    if (eCell) {
                        this.getGui().appendChild(eCell);
                    }
                }
            }
        }
        this.setInlineEditingClass();
        // we suppress the flash, as it is not correct to flash the cell the user has finished editing,
        // the user doesn't need to flash as they were the one who did the edit, the flash is pointless
        // (as the flash is meant to draw the user to a change that they didn't manually do themselves).
        this.refreshCell({ forceRefresh: true, suppressFlash: true });
        var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STOPPED);
        this.beans.eventService.dispatchEvent(event);
    };
    CellComp.DOM_DATA_KEY_CELL_COMP = 'cellComp';
    return CellComp;
}(component_1.Component));
exports.CellComp = CellComp;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var column_1 = __webpack_require__(9);
var beanStub_1 = __webpack_require__(13);
var SetLeftFeature = (function (_super) {
    __extends(SetLeftFeature, _super);
    function SetLeftFeature(columnOrGroup, eCell, beans, colsSpanning) {
        var _this = _super.call(this) || this;
        _this.columnOrGroup = columnOrGroup;
        _this.eCell = eCell;
        _this.colsSpanning = colsSpanning;
        _this.beans = beans;
        return _this;
    }
    SetLeftFeature.prototype.setColsSpanning = function (colsSpanning) {
        this.colsSpanning = colsSpanning;
        this.onLeftChanged();
    };
    SetLeftFeature.prototype.getColumnOrGroup = function () {
        if (this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning) {
            return this.colsSpanning[this.colsSpanning.length - 1];
        }
        else {
            return this.columnOrGroup;
        }
    };
    SetLeftFeature.prototype.init = function () {
        this.addDestroyableEventListener(this.columnOrGroup, column_1.Column.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this));
        this.setLeftFirstTime();
    };
    SetLeftFeature.prototype.setLeftFirstTime = function () {
        var suppressMoveAnimation = this.beans.gridOptionsWrapper.isSuppressColumnMoveAnimation();
        var oldLeftExists = utils_1.Utils.exists(this.columnOrGroup.getOldLeft());
        var animateColumnMove = this.beans.columnAnimationService.isActive() && oldLeftExists && !suppressMoveAnimation;
        if (animateColumnMove) {
            this.animateInLeft();
        }
        else {
            this.onLeftChanged();
        }
    };
    SetLeftFeature.prototype.animateInLeft = function () {
        var _this = this;
        var left = this.getColumnOrGroup().getLeft();
        var oldLeft = this.getColumnOrGroup().getOldLeft();
        this.setLeft(oldLeft);
        // we must keep track of the left we want to set to, as this would otherwise lead to a race
        // condition, if the user changed the left value many times in one VM turn, then we want to make
        // make sure the actualLeft we set in the timeout below (in the next VM turn) is the correct left
        // position. eg if user changes column position twice, then setLeft() below executes twice in next
        // VM turn, but only one (the correct one) should get applied.
        this.actualLeft = left;
        this.beans.columnAnimationService.executeNextVMTurn(function () {
            // test this left value is the latest one to be applied, and if not, do nothing
            if (_this.actualLeft === left) {
                _this.setLeft(left);
            }
        });
    };
    SetLeftFeature.prototype.onLeftChanged = function () {
        this.actualLeft = this.getColumnOrGroup().getLeft();
        this.setLeft(this.actualLeft);
    };
    SetLeftFeature.prototype.setLeft = function (value) {
        // if the value is null, then that means the column is no longer
        // displayed. there is logic in the rendering to fade these columns
        // out, so we don't try and change their left positions.
        if (utils_1.Utils.exists(value)) {
            this.eCell.style.left = value + 'px';
        }
    };
    return SetLeftFeature;
}(beanStub_1.BeanStub));
exports.SetLeftFeature = SetLeftFeature;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var expressionService_1 = __webpack_require__(19);
var ValueFormatterService = (function () {
    function ValueFormatterService() {
    }
    ValueFormatterService.prototype.formatValue = function (column, rowNode, $scope, value) {
        var formatter;
        var colDef = column.getColDef();
        // if floating, give preference to the floating formatter
        if (rowNode && rowNode.rowPinned) {
            formatter = colDef.pinnedRowValueFormatter ? colDef.pinnedRowValueFormatter : colDef.valueFormatter;
        }
        else {
            formatter = colDef.valueFormatter;
        }
        var result = null;
        if (formatter) {
            var params = {
                value: value,
                node: rowNode,
                data: rowNode ? rowNode.data : null,
                colDef: column.getColDef(),
                column: column,
                api: this.gridOptionsWrapper.getApi(),
                columnApi: this.gridOptionsWrapper.getColumnApi(),
                context: this.gridOptionsWrapper.getContext()
            };
            // originally we put the angular 1 scope here, but we don't want the scope
            // in the params interface, as other frameworks will see the interface, and
            // angular 1 is not cool any more. so we hack the scope in here (we cannot
            // include it above, as it's not in the interface, so would cause a compile error).
            // in the future, when we stop supporting angular 1, we can take this out.
            params.$scope = $scope;
            result = this.expressionService.evaluate(formatter, params);
        }
        else if (colDef.refData) {
            return colDef.refData[value];
        }
        // if we don't do this, then arrays get displayed as 1,2,3, but we want 1, 2, 3 (ie with spaces)
        if ((result === null || result === undefined) && Array.isArray(value)) {
            result = value.join(', ');
        }
        return result;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ValueFormatterService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'),
        __metadata("design:type", expressionService_1.ExpressionService)
    ], ValueFormatterService.prototype, "expressionService", void 0);
    ValueFormatterService = __decorate([
        context_1.Bean('valueFormatterService')
    ], ValueFormatterService);
    return ValueFormatterService;
}());
exports.ValueFormatterService = ValueFormatterService;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(150);

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var gridPanel_1 = __webpack_require__(10);
var eventService_1 = __webpack_require__(4);
var logger_1 = __webpack_require__(11);
var events_1 = __webpack_require__(5);
var context_1 = __webpack_require__(0);
var context_2 = __webpack_require__(0);
var context_3 = __webpack_require__(0);
var context_4 = __webpack_require__(0);
var counter = 0;
var AlignedGridsService = (function () {
    function AlignedGridsService() {
        this.instanceId = counter++;
        // flag to mark if we are consuming. to avoid cyclic events (ie other grid firing back to master
        // while processing a master event) we mark this if consuming an event, and if we are, then
        // we don't fire back any events.
        this.consuming = false;
    }
    AlignedGridsService.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('AlignedGridsService');
    };
    AlignedGridsService.prototype.init = function () {
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this));
    };
    // common logic across all the fire methods
    AlignedGridsService.prototype.fireEvent = function (callback) {
        // if we are already consuming, then we are acting on an event from a master,
        // so we don't cause a cyclic firing of events
        if (this.consuming) {
            return;
        }
        // iterate through the aligned grids, and pass each aligned grid service to the callback
        var otherGrids = this.gridOptionsWrapper.getAlignedGrids();
        if (otherGrids) {
            otherGrids.forEach(function (otherGridOptions) {
                if (otherGridOptions.api) {
                    var alignedGridService = otherGridOptions.api.__getAlignedGridService();
                    callback(alignedGridService);
                }
            });
        }
    };
    // common logic across all consume methods. very little common logic, however extracting
    // guarantees consistency across the methods.
    AlignedGridsService.prototype.onEvent = function (callback) {
        this.consuming = true;
        callback();
        this.consuming = false;
    };
    AlignedGridsService.prototype.fireColumnEvent = function (event) {
        this.fireEvent(function (alignedGridsService) {
            alignedGridsService.onColumnEvent(event);
        });
    };
    AlignedGridsService.prototype.fireScrollEvent = function (event) {
        if (event.direction !== 'horizontal') {
            return;
        }
        this.fireEvent(function (alignedGridsService) {
            alignedGridsService.onScrollEvent(event);
        });
    };
    AlignedGridsService.prototype.onScrollEvent = function (event) {
        var _this = this;
        this.onEvent(function () {
            _this.gridPanel.setHorizontalScrollPosition(event.left);
        });
    };
    AlignedGridsService.prototype.getMasterColumns = function (event) {
        var result = [];
        if (event.columns) {
            event.columns.forEach(function (column) {
                result.push(column);
            });
        }
        else if (event.column) {
            result.push(event.column);
        }
        return result;
    };
    AlignedGridsService.prototype.getColumnIds = function (event) {
        var result = [];
        if (event.columns) {
            event.columns.forEach(function (column) {
                result.push(column.getColId());
            });
        }
        else if (event.columns) {
            result.push(event.column.getColId());
        }
        return result;
    };
    AlignedGridsService.prototype.onColumnEvent = function (event) {
        var _this = this;
        this.onEvent(function () {
            switch (event.type) {
                case events_1.Events.EVENT_COLUMN_MOVED:
                case events_1.Events.EVENT_COLUMN_VISIBLE:
                case events_1.Events.EVENT_COLUMN_PINNED:
                case events_1.Events.EVENT_COLUMN_RESIZED:
                    var colEvent = event;
                    _this.processColumnEvent(colEvent);
                    break;
                case events_1.Events.EVENT_COLUMN_GROUP_OPENED:
                    var groupOpenedEvent = event;
                    _this.processGroupOpenedEvent(groupOpenedEvent);
                    break;
                case events_1.Events.EVENT_COLUMN_PIVOT_CHANGED:
                    // we cannot support pivoting with aligned grids as the columns will be out of sync as the
                    // grids will have columns created based on the row data of the grid.
                    console.warn('ag-Grid: pivoting is not supported with aligned grids. ' +
                        'You can only use one of these features at a time in a grid.');
                    break;
            }
        });
    };
    AlignedGridsService.prototype.processGroupOpenedEvent = function (groupOpenedEvent) {
        // likewise for column group
        var masterColumnGroup = groupOpenedEvent.columnGroup;
        var otherColumnGroup;
        if (masterColumnGroup) {
            var groupId = masterColumnGroup.getGroupId();
            otherColumnGroup = this.columnController.getOriginalColumnGroup(groupId);
        }
        if (masterColumnGroup && !otherColumnGroup) {
            return;
        }
        this.logger.log('onColumnEvent-> processing ' + event + ' expanded = ' + masterColumnGroup.isExpanded());
        this.columnController.setColumnGroupOpened(otherColumnGroup, masterColumnGroup.isExpanded());
    };
    AlignedGridsService.prototype.processColumnEvent = function (colEvent) {
        var _this = this;
        // the column in the event is from the master grid. need to
        // look up the equivalent from this (other) grid
        var masterColumn = colEvent.column;
        var otherColumn;
        if (masterColumn) {
            otherColumn = this.columnController.getPrimaryColumn(masterColumn.getColId());
        }
        // if event was with respect to a master column, that is not present in this
        // grid, then we ignore the event
        if (masterColumn && !otherColumn) {
            return;
        }
        // in time, all the methods below should use the column ids, it's a more generic way
        // of handling columns, and also allows for single or multi column events
        var columnIds = this.getColumnIds(colEvent);
        var masterColumns = this.getMasterColumns(colEvent);
        switch (colEvent.type) {
            case events_1.Events.EVENT_COLUMN_MOVED:
                var movedEvent = colEvent;
                this.logger.log('onColumnEvent-> processing ' + colEvent.type + ' toIndex = ' + movedEvent.toIndex);
                this.columnController.moveColumns(columnIds, movedEvent.toIndex);
                break;
            case events_1.Events.EVENT_COLUMN_VISIBLE:
                var visibleEvent = colEvent;
                this.logger.log('onColumnEvent-> processing ' + colEvent.type + ' visible = ' + visibleEvent.visible);
                this.columnController.setColumnsVisible(columnIds, visibleEvent.visible);
                break;
            case events_1.Events.EVENT_COLUMN_PINNED:
                var pinnedEvent = colEvent;
                this.logger.log('onColumnEvent-> processing ' + colEvent.type + ' pinned = ' + pinnedEvent.pinned);
                this.columnController.setColumnsPinned(columnIds, pinnedEvent.pinned);
                break;
            case events_1.Events.EVENT_COLUMN_RESIZED:
                var resizedEvent_1 = colEvent;
                masterColumns.forEach(function (masterColumn) {
                    _this.logger.log('onColumnEvent-> processing ' + colEvent.type + ' actualWidth = ' + masterColumn.getActualWidth());
                    _this.columnController.setColumnWidth(masterColumn.getColId(), masterColumn.getActualWidth(), resizedEvent_1.finished);
                });
                break;
        }
    };
    __decorate([
        context_3.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], AlignedGridsService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_3.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], AlignedGridsService.prototype, "columnController", void 0);
    __decorate([
        context_3.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], AlignedGridsService.prototype, "gridPanel", void 0);
    __decorate([
        context_3.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], AlignedGridsService.prototype, "eventService", void 0);
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], AlignedGridsService.prototype, "setBeans", null);
    __decorate([
        context_4.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AlignedGridsService.prototype, "init", null);
    AlignedGridsService = __decorate([
        context_1.Bean('alignedGridsService')
    ], AlignedGridsService);
    return AlignedGridsService;
}());
exports.AlignedGridsService = AlignedGridsService;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var logger_1 = __webpack_require__(11);
var columnUtils_1 = __webpack_require__(31);
var columnKeyCreator_1 = __webpack_require__(95);
var originalColumnGroup_1 = __webpack_require__(32);
var column_1 = __webpack_require__(9);
var context_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(1);
var defaultColumnTypes_1 = __webpack_require__(134);
// takes in a list of columns, as specified by the column definitions, and returns column groups
var BalancedColumnTreeBuilder = (function () {
    function BalancedColumnTreeBuilder() {
    }
    BalancedColumnTreeBuilder.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('BalancedColumnTreeBuilder');
    };
    BalancedColumnTreeBuilder.prototype.createBalancedColumnGroups = function (abstractColDefs, primaryColumns) {
        // column key creator dishes out unique column id's in a deterministic way,
        // so if we have two grids (that cold be master/slave) with same column definitions,
        // then this ensures the two grids use identical id's.
        var columnKeyCreator = new columnKeyCreator_1.ColumnKeyCreator();
        // create am unbalanced tree that maps the provided definitions
        var unbalancedTree = this.recursivelyCreateColumns(abstractColDefs, 0, columnKeyCreator, primaryColumns);
        var treeDept = this.findMaxDept(unbalancedTree, 0);
        this.logger.log('Number of levels for grouped columns is ' + treeDept);
        var balancedTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);
        this.columnUtils.depthFirstOriginalTreeSearch(balancedTree, function (child) {
            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                child.setupExpandable();
            }
        });
        return {
            balancedTree: balancedTree,
            treeDept: treeDept
        };
    };
    BalancedColumnTreeBuilder.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {
        var _this = this;
        var result = [];
        // go through each child, for groups, recurse a level deeper,
        // for columns we need to pad
        unbalancedTree.forEach(function (child) {
            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                var originalGroup = child;
                var newChildren = _this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);
                originalGroup.setChildren(newChildren);
                result.push(originalGroup);
            }
            else {
                var newChild = child;
                for (var i = columnDept - 1; i >= currentDept; i--) {
                    var newColId = columnKeyCreator.getUniqueKey(null, null);
                    var colGroupDefMerged = _this.createMergedColGroupDef(null);
                    var paddedGroup = new originalColumnGroup_1.OriginalColumnGroup(colGroupDefMerged, newColId, true);
                    _this.context.wireBean(paddedGroup);
                    paddedGroup.setChildren([newChild]);
                    newChild = paddedGroup;
                }
                result.push(newChild);
            }
        });
        return result;
    };
    BalancedColumnTreeBuilder.prototype.findMaxDept = function (treeChildren, dept) {
        var maxDeptThisLevel = dept;
        for (var i = 0; i < treeChildren.length; i++) {
            var abstractColumn = treeChildren[i];
            if (abstractColumn instanceof originalColumnGroup_1.OriginalColumnGroup) {
                var originalGroup = abstractColumn;
                var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);
                if (maxDeptThisLevel < newDept) {
                    maxDeptThisLevel = newDept;
                }
            }
        }
        return maxDeptThisLevel;
    };
    BalancedColumnTreeBuilder.prototype.recursivelyCreateColumns = function (abstractColDefs, level, columnKeyCreator, primaryColumns) {
        var _this = this;
        var result = [];
        if (!abstractColDefs) {
            return result;
        }
        abstractColDefs.forEach(function (abstractColDef) {
            var newGroupOrColumn;
            if (_this.isColumnGroup(abstractColDef)) {
                newGroupOrColumn = _this.createColumnGroup(columnKeyCreator, primaryColumns, abstractColDef, level);
            }
            else {
                newGroupOrColumn = _this.createColumn(columnKeyCreator, primaryColumns, abstractColDef);
            }
            result.push(newGroupOrColumn);
        });
        return result;
    };
    BalancedColumnTreeBuilder.prototype.createColumnGroup = function (columnKeyCreator, primaryColumns, colGroupDef, level) {
        var colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);
        var groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId, null);
        var originalGroup = new originalColumnGroup_1.OriginalColumnGroup(colGroupDefMerged, groupId, false);
        this.context.wireBean(originalGroup);
        var children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, columnKeyCreator, primaryColumns);
        originalGroup.setChildren(children);
        return originalGroup;
    };
    BalancedColumnTreeBuilder.prototype.createMergedColGroupDef = function (colGroupDef) {
        var colGroupDefMerged = {};
        utils_1.Utils.assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());
        utils_1.Utils.assign(colGroupDefMerged, colGroupDef);
        this.checkForDeprecatedItems(colGroupDefMerged);
        return colGroupDefMerged;
    };
    BalancedColumnTreeBuilder.prototype.createColumn = function (columnKeyCreator, primaryColumns, colDef) {
        var colDefMerged = this.mergeColDefs(colDef);
        this.checkForDeprecatedItems(colDefMerged);
        var colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);
        var column = new column_1.Column(colDefMerged, colId, primaryColumns);
        this.context.wireBean(column);
        return column;
    };
    BalancedColumnTreeBuilder.prototype.mergeColDefs = function (colDef) {
        // start with empty merged definition
        var colDefMerged = {};
        // merge properties from default column definitions
        utils_1.Utils.assign(colDefMerged, this.gridOptionsWrapper.getDefaultColDef());
        // merge properties from column type properties
        if (colDef.type) {
            this.assignColumnTypes(colDef, colDefMerged);
        }
        // merge properties from column definitions
        utils_1.Utils.assign(colDefMerged, colDef);
        return colDefMerged;
    };
    BalancedColumnTreeBuilder.prototype.assignColumnTypes = function (colDef, colDefMerged) {
        var typeKeys;
        if (colDef.type instanceof Array) {
            var invalidArray = colDef.type.some(function (a) { return typeof a !== 'string'; });
            if (invalidArray) {
                console.warn("ag-grid: if colDef.type is supplied an array it should be of type 'string[]'");
            }
            else {
                typeKeys = colDef.type;
            }
        }
        else if (typeof colDef.type === 'string') {
            typeKeys = colDef.type.split(',');
        }
        else {
            console.warn("ag-grid: colDef.type should be of type 'string' | 'string[]'");
            return;
        }
        // merge user defined with default column types
        var allColumnTypes = utils_1.Utils.assign({}, this.gridOptionsWrapper.getColumnTypes(), defaultColumnTypes_1.DefaultColumnTypes);
        typeKeys.forEach(function (t) {
            var typeColDef = allColumnTypes[t.trim()];
            if (typeColDef) {
                utils_1.Utils.assign(colDefMerged, typeColDef);
            }
            else {
                console.warn("ag-grid: colDef.type '" + t + "' does not correspond to defined gridOptions.columnTypes");
            }
        });
    };
    BalancedColumnTreeBuilder.prototype.checkForDeprecatedItems = function (colDef) {
        if (colDef) {
            var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type
            if (colDefNoType.group !== undefined) {
                console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');
            }
            if (colDefNoType.headerGroup !== undefined) {
                console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');
            }
            if (colDefNoType.headerGroupShow !== undefined) {
                console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');
            }
            if (colDefNoType.suppressRowGroup !== undefined) {
                console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');
            }
            if (colDefNoType.suppressAggregation !== undefined) {
                console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');
            }
            if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {
                console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');
            }
            if (colDefNoType.displayName) {
                console.warn("ag-grid: Found displayName " + colDefNoType.displayName + ", please use headerName instead, displayName is deprecated.");
                colDefNoType.headerName = colDefNoType.displayName;
            }
        }
    };
    // if object has children, we assume it's a group
    BalancedColumnTreeBuilder.prototype.isColumnGroup = function (abstractColDef) {
        return abstractColDef.children !== undefined;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], BalancedColumnTreeBuilder.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnUtils'),
        __metadata("design:type", columnUtils_1.ColumnUtils)
    ], BalancedColumnTreeBuilder.prototype, "columnUtils", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], BalancedColumnTreeBuilder.prototype, "context", void 0);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], BalancedColumnTreeBuilder.prototype, "setBeans", null);
    BalancedColumnTreeBuilder = __decorate([
        context_1.Bean('balancedColumnTreeBuilder')
    ], BalancedColumnTreeBuilder);
    return BalancedColumnTreeBuilder;
}());
exports.BalancedColumnTreeBuilder = BalancedColumnTreeBuilder;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var columnUtils_1 = __webpack_require__(31);
var columnGroup_1 = __webpack_require__(28);
var originalColumnGroup_1 = __webpack_require__(32);
var context_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(1);
var context_2 = __webpack_require__(0);
// takes in a list of columns, as specified by the column definitions, and returns column groups
var DisplayedGroupCreator = (function () {
    function DisplayedGroupCreator() {
    }
    DisplayedGroupCreator.prototype.createDisplayedGroups = function (
        // all displayed columns sorted - this is the columns the grid should show
        sortedVisibleColumns, 
        // the tree of columns, as provided by the users, used to know what groups columns roll up into
        balancedColumnTree, 
        // create's unique id's for the group
        groupInstanceIdCreator, 
        // we try to reuse old groups if we can, to allow gui to do animation
        oldDisplayedGroups) {
        var _this = this;
        var result = [];
        var previousRealPath;
        var previousOriginalPath;
        var oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);
        // go through each column, then do a bottom up comparison to the previous column, and start
        // to share groups if they converge at any point.
        sortedVisibleColumns.forEach(function (currentColumn) {
            var currentOriginalPath = _this.getOriginalPathForColumn(balancedColumnTree, currentColumn);
            var currentRealPath = [];
            var firstColumn = !previousOriginalPath;
            for (var i = 0; i < currentOriginalPath.length; i++) {
                if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {
                    // new group needed
                    var newGroup = _this.createColumnGroup(currentOriginalPath[i], groupInstanceIdCreator, oldColumnsMapped);
                    currentRealPath[i] = newGroup;
                    // if top level, add to result, otherwise add to parent
                    if (i == 0) {
                        result.push(newGroup);
                    }
                    else {
                        currentRealPath[i - 1].addChild(newGroup);
                    }
                }
                else {
                    // reuse old group
                    currentRealPath[i] = previousRealPath[i];
                }
            }
            var noColumnGroups = currentRealPath.length === 0;
            if (noColumnGroups) {
                // if we are not grouping, then the result of the above is an empty
                // path (no groups), and we just add the column to the root list.
                result.push(currentColumn);
            }
            else {
                var leafGroup = currentRealPath[currentRealPath.length - 1];
                leafGroup.addChild(currentColumn);
            }
            previousRealPath = currentRealPath;
            previousOriginalPath = currentOriginalPath;
        });
        this.setupParentsIntoColumns(result, null);
        return result;
    };
    DisplayedGroupCreator.prototype.createColumnGroup = function (originalGroup, groupInstanceIdCreator, oldColumnsMapped) {
        var groupId = originalGroup.getGroupId();
        var instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
        var uniqueId = columnGroup_1.ColumnGroup.createUniqueId(groupId, instanceId);
        var columnGroup = oldColumnsMapped[uniqueId];
        // if the user is setting new colDefs, it is possible that the id's overlap, and we
        // would have a false match from above. so we double check we are talking about the
        // same original column group.
        if (columnGroup && columnGroup.getOriginalColumnGroup() !== originalGroup) {
            columnGroup = null;
        }
        if (utils_1.Utils.exists(columnGroup)) {
            // clean out the old column group here, as we will be adding children into it again
            columnGroup.reset();
        }
        else {
            columnGroup = new columnGroup_1.ColumnGroup(originalGroup, groupId, instanceId);
            this.context.wireBean(columnGroup);
        }
        return columnGroup;
    };
    // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
    DisplayedGroupCreator.prototype.mapOldGroupsById = function (displayedGroups) {
        var result = {};
        var recursive = function (columnsOrGroups) {
            columnsOrGroups.forEach(function (columnOrGroup) {
                if (columnOrGroup instanceof columnGroup_1.ColumnGroup) {
                    var columnGroup = columnOrGroup;
                    result[columnOrGroup.getUniqueId()] = columnGroup;
                    recursive(columnGroup.getChildren());
                }
            });
        };
        if (displayedGroups) {
            recursive(displayedGroups);
        }
        return result;
    };
    DisplayedGroupCreator.prototype.setupParentsIntoColumns = function (columnsOrGroups, parent) {
        var _this = this;
        columnsOrGroups.forEach(function (columnsOrGroup) {
            columnsOrGroup.setParent(parent);
            if (columnsOrGroup instanceof columnGroup_1.ColumnGroup) {
                var columnGroup = columnsOrGroup;
                _this.setupParentsIntoColumns(columnGroup.getChildren(), columnGroup);
            }
        });
    };
    DisplayedGroupCreator.prototype.createFakePath = function (balancedColumnTree) {
        var result = [];
        var currentChildren = balancedColumnTree;
        // this while look does search on the balanced tree, so our result is the right length
        var index = 0;
        while (currentChildren && currentChildren[0] && currentChildren[0] instanceof originalColumnGroup_1.OriginalColumnGroup) {
            // putting in a deterministic fake id, in case the API in the future needs to reference the col
            var fakePath = new originalColumnGroup_1.OriginalColumnGroup(null, 'FAKE_PATH_' + index, true);
            this.context.wireBean(fakePath);
            result.push(fakePath);
            currentChildren = currentChildren[0].getChildren();
            index++;
        }
        return result;
    };
    DisplayedGroupCreator.prototype.getOriginalPathForColumn = function (balancedColumnTree, column) {
        var result = [];
        var found = false;
        recursePath(balancedColumnTree, 0);
        // it's possible we didn't find a path. this happens if the column is generated
        // by the grid, in that the definition didn't come from the client. in this case,
        // we create a fake original path.
        if (found) {
            return result;
        }
        else {
            return this.createFakePath(balancedColumnTree);
        }
        function recursePath(balancedColumnTree, dept) {
            for (var i = 0; i < balancedColumnTree.length; i++) {
                if (found) {
                    // quit the search, so 'result' is kept with the found result
                    return;
                }
                var node = balancedColumnTree[i];
                if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
                    var nextNode = node;
                    recursePath(nextNode.getChildren(), dept + 1);
                    result[dept] = node;
                }
                else {
                    if (node === column) {
                        found = true;
                    }
                }
            }
        }
    };
    __decorate([
        context_2.Autowired('columnUtils'),
        __metadata("design:type", columnUtils_1.ColumnUtils)
    ], DisplayedGroupCreator.prototype, "columnUtils", void 0);
    __decorate([
        context_2.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], DisplayedGroupCreator.prototype, "context", void 0);
    DisplayedGroupCreator = __decorate([
        context_1.Bean('displayedGroupCreator')
    ], DisplayedGroupCreator);
    return DisplayedGroupCreator;
}());
exports.DisplayedGroupCreator = DisplayedGroupCreator;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var componentMetadataProvider_1 = __webpack_require__(67);
var utils_1 = __webpack_require__(1);
var AgComponentUtils = (function () {
    function AgComponentUtils() {
    }
    AgComponentUtils.prototype.adaptFunction = function (propertyName, hardcodedJsFunction, type, source) {
        if (hardcodedJsFunction == null)
            return {
                component: null,
                type: type,
                source: source
            };
        var metadata = this.componentMetadataProvider.retrieve(propertyName);
        if (metadata && metadata.functionAdapter) {
            return {
                type: type,
                component: metadata.functionAdapter(hardcodedJsFunction),
                source: source
            };
        }
        console.error("It seems like you are providing a function as a component: " + hardcodedJsFunction + ", but this component: [" + propertyName + "] doesnt accept functions");
        return null;
    };
    AgComponentUtils.prototype.adaptCellRendererFunction = function (callback) {
        var Adapter = (function () {
            function Adapter() {
            }
            Adapter.prototype.refresh = function (params) {
                return false;
            };
            Adapter.prototype.getGui = function () {
                var callbackResult = callback(this.params);
                if (typeof callbackResult != 'string')
                    return callbackResult;
                return utils_1._.loadTemplate('<span>' + callbackResult + '</span>');
            };
            Adapter.prototype.init = function (params) {
                this.params = params;
            };
            return Adapter;
        }());
        return Adapter;
    };
    AgComponentUtils.prototype.doesImplementIComponent = function (candidate) {
        if (!candidate)
            return false;
        return candidate.prototype && 'getGui' in candidate.prototype;
    };
    __decorate([
        context_1.Autowired("componentMetadataProvider"),
        __metadata("design:type", componentMetadataProvider_1.ComponentMetadataProvider)
    ], AgComponentUtils.prototype, "componentMetadataProvider", void 0);
    AgComponentUtils = __decorate([
        context_1.Bean("agComponentUtils")
    ], AgComponentUtils);
    return AgComponentUtils;
}());
exports.AgComponentUtils = AgComponentUtils;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridSerializer_1 = __webpack_require__(73);
var downloader_1 = __webpack_require__(69);
var columnController_1 = __webpack_require__(3);
var valueService_1 = __webpack_require__(20);
var gridOptionsWrapper_1 = __webpack_require__(2);
var constants_1 = __webpack_require__(7);
var utils_1 = __webpack_require__(1);
var LINE_SEPARATOR = '\r\n';
var CsvSerializingSession = (function (_super) {
    __extends(CsvSerializingSession, _super);
    function CsvSerializingSession(columnController, valueService, gridOptionsWrapper, processCellCallback, processHeaderCallback, suppressQuotes, columnSeparator) {
        var _this = _super.call(this, columnController, valueService, gridOptionsWrapper, processCellCallback, processHeaderCallback) || this;
        _this.suppressQuotes = suppressQuotes;
        _this.columnSeparator = columnSeparator;
        _this.result = '';
        _this.lineOpened = false;
        return _this;
    }
    CsvSerializingSession.prototype.prepare = function (columnsToExport) {
    };
    CsvSerializingSession.prototype.addCustomHeader = function (customHeader) {
        if (!customHeader)
            return;
        this.result += customHeader + LINE_SEPARATOR;
    };
    CsvSerializingSession.prototype.addCustomFooter = function (customFooter) {
        if (!customFooter)
            return;
        this.result += customFooter + LINE_SEPARATOR;
    };
    CsvSerializingSession.prototype.onNewHeaderGroupingRow = function () {
        if (this.lineOpened)
            this.result += LINE_SEPARATOR;
        return {
            onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
        };
    };
    CsvSerializingSession.prototype.onNewHeaderGroupingRowColumn = function (header, index, span) {
        if (index != 0) {
            this.result += this.columnSeparator;
        }
        this.result += header;
        for (var i = 1; i <= span; i++) {
            this.result += this.columnSeparator + this.putInQuotes("", this.suppressQuotes);
        }
        this.lineOpened = true;
    };
    CsvSerializingSession.prototype.onNewHeaderRow = function () {
        if (this.lineOpened)
            this.result += LINE_SEPARATOR;
        return {
            onColumn: this.onNewHeaderRowColumn.bind(this)
        };
    };
    CsvSerializingSession.prototype.onNewHeaderRowColumn = function (column, index, node) {
        if (index != 0) {
            this.result += this.columnSeparator;
        }
        this.result += this.putInQuotes(this.extractHeaderValue(column), this.suppressQuotes);
        this.lineOpened = true;
    };
    CsvSerializingSession.prototype.onNewBodyRow = function () {
        if (this.lineOpened)
            this.result += LINE_SEPARATOR;
        return {
            onColumn: this.onNewBodyRowColumn.bind(this)
        };
    };
    CsvSerializingSession.prototype.onNewBodyRowColumn = function (column, index, node) {
        if (index != 0) {
            this.result += this.columnSeparator;
        }
        this.result += this.putInQuotes(this.extractRowCellValue(column, index, constants_1.Constants.EXPORT_TYPE_CSV, node), this.suppressQuotes);
        this.lineOpened = true;
    };
    CsvSerializingSession.prototype.putInQuotes = function (value, suppressQuotes) {
        if (suppressQuotes) {
            return value;
        }
        if (value === null || value === undefined) {
            return '""';
        }
        var stringValue;
        if (typeof value === 'string') {
            stringValue = value;
        }
        else if (typeof value.toString === 'function') {
            stringValue = value.toString();
        }
        else {
            console.warn('unknown value type during csv conversion');
            stringValue = '';
        }
        // replace each " with "" (ie two sets of double quotes is how to do double quotes in csv)
        var valueEscaped = stringValue.replace(/"/g, "\"\"");
        return '"' + valueEscaped + '"';
    };
    CsvSerializingSession.prototype.parse = function () {
        return this.result;
    };
    return CsvSerializingSession;
}(gridSerializer_1.BaseGridSerializingSession));
exports.CsvSerializingSession = CsvSerializingSession;
var BaseCreator = (function () {
    function BaseCreator() {
    }
    BaseCreator.prototype.export = function (userParams) {
        if (this.isExportSuppressed()) {
            console.warn("ag-grid: Export canceled. Export is not allowed as per your configuration.");
            return "";
        }
        var _a = this.getMergedParamsAndData(userParams), mergedParams = _a.mergedParams, data = _a.data;
        var fileNamePresent = mergedParams && mergedParams.fileName && mergedParams.fileName.length !== 0;
        var fileName = fileNamePresent ? mergedParams.fileName : this.getDefaultFileName();
        if (fileName.indexOf(".") === -1) {
            fileName = fileName + "." + this.getDefaultFileExtension();
        }
        this.downloader.download(fileName, data, this.getMimeType());
        return data;
    };
    BaseCreator.prototype.getData = function (params) {
        return this.getMergedParamsAndData(params).data;
    };
    BaseCreator.prototype.getMergedParamsAndData = function (userParams) {
        var mergedParams = this.mergeDefaultParams(userParams);
        var data = this.gridSerializer.serialize(this.createSerializingSession(mergedParams), mergedParams);
        return { mergedParams: mergedParams, data: data };
    };
    BaseCreator.prototype.mergeDefaultParams = function (userParams) {
        var baseParams = this.gridOptionsWrapper.getDefaultExportParams();
        var params = {};
        utils_1._.assign(params, baseParams);
        utils_1._.assign(params, userParams);
        return params;
    };
    __decorate([
        context_1.Autowired('downloader'),
        __metadata("design:type", downloader_1.Downloader)
    ], BaseCreator.prototype, "downloader", void 0);
    __decorate([
        context_1.Autowired('gridSerializer'),
        __metadata("design:type", gridSerializer_1.GridSerializer)
    ], BaseCreator.prototype, "gridSerializer", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], BaseCreator.prototype, "gridOptionsWrapper", void 0);
    return BaseCreator;
}());
exports.BaseCreator = BaseCreator;
var CsvCreator = (function (_super) {
    __extends(CsvCreator, _super);
    function CsvCreator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CsvCreator.prototype.exportDataAsCsv = function (params) {
        return this.export(params);
    };
    CsvCreator.prototype.getDataAsCsv = function (params) {
        return this.getData(params);
    };
    CsvCreator.prototype.getMimeType = function () {
        return "text/csv;charset=utf-8;";
    };
    CsvCreator.prototype.getDefaultFileName = function () {
        return 'export.csv';
    };
    CsvCreator.prototype.getDefaultFileExtension = function () {
        return 'csv';
    };
    CsvCreator.prototype.createSerializingSession = function (params) {
        return new CsvSerializingSession(this.columnController, this.valueService, this.gridOptionsWrapper, params ? params.processCellCallback : null, params ? params.processHeaderCallback : null, params && params.suppressQuotes, (params && params.columnSeparator) || ',');
    };
    CsvCreator.prototype.isExportSuppressed = function () {
        return this.gridOptionsWrapper.isSuppressCsvExport();
    };
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], CsvCreator.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('valueService'),
        __metadata("design:type", valueService_1.ValueService)
    ], CsvCreator.prototype, "valueService", void 0);
    CsvCreator = __decorate([
        context_1.Bean('csvCreator')
    ], CsvCreator);
    return CsvCreator;
}(BaseCreator));
exports.CsvCreator = CsvCreator;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var logger_1 = __webpack_require__(11);
var utils_1 = __webpack_require__(1);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
/** Adds drag listening onto an element. In ag-Grid this is used twice, first is resizing columns,
 * second is moving the columns and column groups around (ie the 'drag' part of Drag and Drop. */
var DragService = (function () {
    function DragService() {
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
        this.onTouchEndListener = this.onTouchUp.bind(this);
        this.onTouchMoveListener = this.onTouchMove.bind(this);
        this.dragEndFunctions = [];
        this.dragSources = [];
    }
    DragService.prototype.init = function () {
        this.logger = this.loggerFactory.create('DragService');
    };
    DragService.prototype.destroy = function () {
        this.dragSources.forEach(this.removeListener.bind(this));
        this.dragSources.length = 0;
    };
    DragService.prototype.removeListener = function (dragSourceAndListener) {
        var element = dragSourceAndListener.dragSource.eElement;
        var mouseDownListener = dragSourceAndListener.mouseDownListener;
        element.removeEventListener('mousedown', mouseDownListener);
        // remove touch listener only if it exists
        if (dragSourceAndListener.touchEnabled) {
            var touchStartListener = dragSourceAndListener.touchStartListener;
            element.removeEventListener('touchstart', touchStartListener, { passive: true });
        }
    };
    DragService.prototype.removeDragSource = function (params) {
        var dragSourceAndListener = utils_1.Utils.find(this.dragSources, function (item) { return item.dragSource === params; });
        if (!dragSourceAndListener) {
            return;
        }
        this.removeListener(dragSourceAndListener);
        utils_1.Utils.removeFromArray(this.dragSources, dragSourceAndListener);
    };
    DragService.prototype.setNoSelectToBody = function (noSelect) {
        var usrDocument = this.gridOptionsWrapper.getDocument();
        var eBody = usrDocument.querySelector('body');
        if (utils_1.Utils.exists(eBody)) {
            utils_1.Utils.addOrRemoveCssClass(eBody, 'ag-body-no-select', noSelect);
        }
    };
    DragService.prototype.addDragSource = function (params, includeTouch) {
        if (includeTouch === void 0) { includeTouch = false; }
        var mouseListener = this.onMouseDown.bind(this, params);
        params.eElement.addEventListener('mousedown', mouseListener);
        var touchListener = null;
        var suppressTouch = this.gridOptionsWrapper.isSuppressTouch();
        var reallyIncludeTouch = includeTouch && !suppressTouch;
        if (reallyIncludeTouch) {
            touchListener = this.onTouchStart.bind(this, params);
            params.eElement.addEventListener('touchstart', touchListener, { passive: false });
        }
        this.dragSources.push({
            dragSource: params,
            mouseDownListener: mouseListener,
            touchStartListener: touchListener,
            touchEnabled: includeTouch
        });
    };
    // gets called whenever mouse down on any drag source
    DragService.prototype.onTouchStart = function (params, touchEvent) {
        var _this = this;
        this.currentDragParams = params;
        this.dragging = false;
        var touch = touchEvent.touches[0];
        this.touchLastTime = touch;
        this.touchStart = touch;
        touchEvent.preventDefault();
        // we temporally add these listeners, for the duration of the drag, they
        // are removed in touch end handling.
        params.eElement.addEventListener('touchmove', this.onTouchMoveListener, { passive: true });
        params.eElement.addEventListener('touchend', this.onTouchEndListener, { passive: true });
        params.eElement.addEventListener('touchcancel', this.onTouchEndListener, { passive: true });
        this.dragEndFunctions.push(function () {
            params.eElement.removeEventListener('touchmove', _this.onTouchMoveListener, { passive: true });
            params.eElement.removeEventListener('touchend', _this.onTouchEndListener, { passive: true });
            params.eElement.removeEventListener('touchcancel', _this.onTouchEndListener, { passive: true });
        });
        // see if we want to start dragging straight away
        if (params.dragStartPixels === 0) {
            this.onCommonMove(touch, this.touchStart);
        }
    };
    // gets called whenever mouse down on any drag source
    DragService.prototype.onMouseDown = function (params, mouseEvent) {
        var _this = this;
        // only interested in left button clicks
        if (mouseEvent.button !== 0) {
            return;
        }
        this.currentDragParams = params;
        this.dragging = false;
        this.mouseEventLastTime = mouseEvent;
        this.mouseStartEvent = mouseEvent;
        var usrDocument = this.gridOptionsWrapper.getDocument();
        // we temporally add these listeners, for the duration of the drag, they
        // are removed in mouseup handling.
        usrDocument.addEventListener('mousemove', this.onMouseMoveListener);
        usrDocument.addEventListener('mouseup', this.onMouseUpListener);
        this.dragEndFunctions.push(function () {
            usrDocument.removeEventListener('mousemove', _this.onMouseMoveListener);
            usrDocument.removeEventListener('mouseup', _this.onMouseUpListener);
        });
        // see if we want to start dragging straight away
        if (params.dragStartPixels === 0) {
            this.onMouseMove(mouseEvent);
        }
    };
    // returns true if the event is close to the original event by X pixels either vertically or horizontally.
    // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
    DragService.prototype.isEventNearStartEvent = function (currentEvent, startEvent) {
        // by default, we wait 4 pixels before starting the drag
        var requiredPixelDiff = utils_1.Utils.exists(this.currentDragParams.dragStartPixels) ? this.currentDragParams.dragStartPixels : 4;
        return utils_1.Utils.areEventsNear(currentEvent, startEvent, requiredPixelDiff);
    };
    DragService.prototype.getFirstActiveTouch = function (touchList) {
        for (var i = 0; i < touchList.length; i++) {
            var matches = touchList[i].identifier === this.touchStart.identifier;
            if (matches) {
                return touchList[i];
            }
        }
        return null;
    };
    DragService.prototype.onCommonMove = function (currentEvent, startEvent) {
        if (!this.dragging) {
            // if mouse hasn't travelled from the start position enough, do nothing
            var toEarlyToDrag = !this.dragging && this.isEventNearStartEvent(currentEvent, startEvent);
            if (toEarlyToDrag) {
                return;
            }
            else {
                // alert(`started`);
                this.dragging = true;
                var event_1 = {
                    type: events_1.Events.EVENT_DRAG_STARTED,
                    api: this.gridApi,
                    columnApi: this.columnApi
                };
                this.eventService.dispatchEvent(event_1);
                this.currentDragParams.onDragStart(startEvent);
                this.setNoSelectToBody(true);
            }
        }
        this.currentDragParams.onDragging(currentEvent);
    };
    DragService.prototype.onTouchMove = function (touchEvent) {
        var touch = this.getFirstActiveTouch(touchEvent.touches);
        if (!touch) {
            return;
        }
        // this.___statusBar.setInfoText(Math.random() + ' onTouchMove preventDefault stopPropagation');
        // if we don't preview default, then the browser will try and do it's own touch stuff,
        // like do 'back button' (chrome does this) or scroll the page (eg drag column could  be confused
        // with scroll page in the app)
        // touchEvent.preventDefault();
        this.onCommonMove(touch, this.touchStart);
    };
    // only gets called after a mouse down - as this is only added after mouseDown
    // and is removed when mouseUp happens
    DragService.prototype.onMouseMove = function (mouseEvent) {
        this.onCommonMove(mouseEvent, this.mouseStartEvent);
    };
    DragService.prototype.onTouchUp = function (touchEvent) {
        var touch = this.getFirstActiveTouch(touchEvent.targetTouches);
        // i haven't worked this out yet, but there is no matching touch
        // when we get the touch up event. to get around this, we swap in
        // the last touch. this is a hack to 'get it working' while we
        // figure out what's going on, why we are not getting a touch in
        // current event.
        if (!touch) {
            touch = this.touchLastTime;
        }
        // if mouse was left up before we started to move, then this is a tap.
        // we check this before onUpCommon as onUpCommon resets the dragging
        // let tap = !this.dragging;
        // let tapTarget = this.currentDragParams.eElement;
        this.onUpCommon(touch);
        // if tap, tell user
        // console.log(`${Math.random()} tap = ${tap}`);
        // if (tap) {
        //     tapTarget.click();
        // }
    };
    DragService.prototype.onMouseUp = function (mouseEvent) {
        this.onUpCommon(mouseEvent);
    };
    DragService.prototype.onUpCommon = function (eventOrTouch) {
        if (this.dragging) {
            this.dragging = false;
            this.currentDragParams.onDragStop(eventOrTouch);
            var event_2 = {
                type: events_1.Events.EVENT_DRAG_STOPPED,
                api: this.gridApi,
                columnApi: this.columnApi
            };
            this.eventService.dispatchEvent(event_2);
        }
        this.setNoSelectToBody(false);
        this.mouseStartEvent = null;
        this.mouseEventLastTime = null;
        this.touchStart = null;
        this.touchLastTime = null;
        this.currentDragParams = null;
        this.dragEndFunctions.forEach(function (func) { return func(); });
        this.dragEndFunctions.length = 0;
    };
    __decorate([
        context_1.Autowired('loggerFactory'),
        __metadata("design:type", logger_1.LoggerFactory)
    ], DragService.prototype, "loggerFactory", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], DragService.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], DragService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], DragService.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], DragService.prototype, "gridApi", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], DragService.prototype, "init", null);
    __decorate([
        context_1.PreDestroy,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], DragService.prototype, "destroy", null);
    DragService = __decorate([
        context_1.Bean('dragService')
    ], DragService);
    return DragService;
}());
exports.DragService = DragService;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var themes = ['fresh', 'dark', 'blue', 'bootstrap', 'material', 'theme-material'];
var themeCLass = new RegExp("ag-(" + themes.join('|') + ")");
var Environment = (function () {
    function Environment() {
    }
    Environment.prototype.getTheme = function () {
        var themeMatch;
        var element = this.eGridDiv;
        while (element != document.documentElement && themeMatch == null) {
            themeMatch = element.className.match(themeCLass);
            element = element.parentElement;
            if (element == null) {
                break;
            }
        }
        if (themeMatch) {
            return themeMatch[0];
        }
        else {
            return 'ag-fresh';
        }
    };
    __decorate([
        context_1.Autowired('eGridDiv'),
        __metadata("design:type", HTMLElement)
    ], Environment.prototype, "eGridDiv", void 0);
    Environment = __decorate([
        context_1.Bean('environment')
    ], Environment);
    return Environment;
}());
exports.Environment = Environment;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var componentAnnotations_1 = __webpack_require__(12);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(1);
var DEFAULT_TRANSLATIONS = {
    loadingOoo: 'Loading...',
    equals: 'Equals',
    notEqual: 'Not equal',
    lessThan: 'Less than',
    greaterThan: 'Greater than',
    inRange: 'In range',
    lessThanOrEqual: 'Less than or equals',
    greaterThanOrEqual: 'Greater than or equals',
    filterOoo: 'Filter...',
    contains: 'Contains',
    notContains: 'Not contains',
    startsWith: 'Starts with',
    endsWith: 'Ends with',
    searchOoo: 'Search...',
    selectAll: 'Select All',
    applyFilter: 'Apply Filter',
    clearFilter: 'Clear Filter'
};
/**
 * T(ype) The type of this filter. ie in DateFilter T=Date
 * P(arams) The params that this filter can take
 * M(model getModel/setModel) The object that this filter serializes to
 * F Floating filter params
 *
 * Contains common logic to ALL filters.. Translation, apply and clear button
 * get/setModel context wiring....
 */
var BaseFilter = (function (_super) {
    __extends(BaseFilter, _super);
    function BaseFilter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseFilter.prototype.init = function (params) {
        this.filterParams = params;
        this.defaultFilter = this.filterParams.defaultOption;
        if (this.filterParams.filterOptions) {
            if (this.filterParams.filterOptions.lastIndexOf(BaseFilter.EQUALS) < 0) {
                this.defaultFilter = this.filterParams.filterOptions[0];
            }
        }
        this.customInit();
        this.filter = this.defaultFilter;
        this.clearActive = params.clearButton === true;
        //Allowing for old param property apply, even though is not advertised through the interface
        this.applyActive = ((params.applyButton === true) || (params.apply === true));
        this.newRowsActionKeep = params.newRowsAction === 'keep';
        this.setTemplate(this.generateTemplate());
        utils_1._.setVisible(this.eApplyButton, this.applyActive);
        if (this.applyActive) {
            this.addDestroyableEventListener(this.eApplyButton, "click", this.filterParams.filterChangedCallback);
        }
        utils_1._.setVisible(this.eClearButton, this.clearActive);
        if (this.clearActive) {
            this.addDestroyableEventListener(this.eClearButton, "click", this.onClearButton.bind(this));
        }
        var anyButtonVisible = this.applyActive || this.clearActive;
        utils_1._.setVisible(this.eButtonsPanel, anyButtonVisible);
        this.instantiate(this.context);
        this.initialiseFilterBodyUi();
        this.refreshFilterBodyUi();
    };
    BaseFilter.prototype.onClearButton = function () {
        this.setModel(null);
        this.onFilterChanged();
    };
    BaseFilter.prototype.floatingFilter = function (from) {
        if (from !== '') {
            var model = this.modelFromFloatingFilter(from);
            this.setModel(model);
        }
        else {
            this.resetState();
        }
        this.onFilterChanged();
    };
    BaseFilter.prototype.onNewRowsLoaded = function () {
        if (!this.newRowsActionKeep) {
            this.resetState();
        }
    };
    BaseFilter.prototype.getModel = function () {
        if (this.isFilterActive()) {
            return this.serialize();
        }
        else {
            return null;
        }
    };
    BaseFilter.prototype.getNullableModel = function () {
        return this.serialize();
    };
    BaseFilter.prototype.setModel = function (model) {
        if (model) {
            this.parse(model);
        }
        else {
            this.resetState();
        }
        this.refreshFilterBodyUi();
    };
    BaseFilter.prototype.doOnFilterChanged = function (applyNow) {
        if (applyNow === void 0) { applyNow = false; }
        this.filterParams.filterModifiedCallback();
        var requiresApplyAndIsApplying = this.applyActive && applyNow;
        var notRequiresApply = !this.applyActive;
        var shouldFilter = notRequiresApply || requiresApplyAndIsApplying;
        if (shouldFilter) {
            this.filterParams.filterChangedCallback();
        }
        this.refreshFilterBodyUi();
        return shouldFilter;
    };
    BaseFilter.prototype.onFilterChanged = function () {
        this.doOnFilterChanged();
    };
    BaseFilter.prototype.onFloatingFilterChanged = function (change) {
        //It has to be of the type FloatingFilterWithApplyChange if it gets here
        var casted = change;
        this.setModel(casted ? casted.model : null);
        return this.doOnFilterChanged(casted ? casted.apply : false);
    };
    BaseFilter.prototype.generateFilterHeader = function () {
        return '';
    };
    BaseFilter.prototype.generateTemplate = function () {
        var translate = this.translate.bind(this);
        var body = this.bodyTemplate();
        return "<div>\n                    " + this.generateFilterHeader() + "\n                    " + body + "\n                    <div class=\"ag-filter-apply-panel\" id=\"applyPanel\">\n                        <button type=\"button\" id=\"clearButton\">" + translate('clearFilter') + "</button>\n                        <button type=\"button\" id=\"applyButton\">" + translate('applyFilter') + "</button>\n                    </div>\n                </div>";
    };
    BaseFilter.prototype.translate = function (toTranslate) {
        var translate = this.gridOptionsWrapper.getLocaleTextFunc();
        return translate(toTranslate, DEFAULT_TRANSLATIONS[toTranslate]);
    };
    BaseFilter.EQUALS = 'equals';
    BaseFilter.NOT_EQUAL = 'notEqual';
    BaseFilter.LESS_THAN = 'lessThan';
    BaseFilter.LESS_THAN_OR_EQUAL = 'lessThanOrEqual';
    BaseFilter.GREATER_THAN = 'greaterThan';
    BaseFilter.GREATER_THAN_OR_EQUAL = 'greaterThanOrEqual';
    BaseFilter.IN_RANGE = 'inRange';
    BaseFilter.CONTAINS = 'contains'; //1;
    BaseFilter.NOT_CONTAINS = 'notContains'; //1;
    BaseFilter.STARTS_WITH = 'startsWith'; //4;
    BaseFilter.ENDS_WITH = 'endsWith'; //5;
    __decorate([
        componentAnnotations_1.QuerySelector('#applyPanel'),
        __metadata("design:type", HTMLElement)
    ], BaseFilter.prototype, "eButtonsPanel", void 0);
    __decorate([
        componentAnnotations_1.QuerySelector('#applyButton'),
        __metadata("design:type", HTMLElement)
    ], BaseFilter.prototype, "eApplyButton", void 0);
    __decorate([
        componentAnnotations_1.QuerySelector('#clearButton'),
        __metadata("design:type", HTMLElement)
    ], BaseFilter.prototype, "eClearButton", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], BaseFilter.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], BaseFilter.prototype, "gridOptionsWrapper", void 0);
    return BaseFilter;
}(component_1.Component));
exports.BaseFilter = BaseFilter;
/**
 * Every filter with a dropdown where the user can specify a comparing type against the filter values
 */
var ComparableBaseFilter = (function (_super) {
    __extends(ComparableBaseFilter, _super);
    function ComparableBaseFilter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComparableBaseFilter.prototype.init = function (params) {
        _super.prototype.init.call(this, params);
        this.addDestroyableEventListener(this.eTypeSelector, "change", this.onFilterTypeChanged.bind(this));
    };
    ComparableBaseFilter.prototype.customInit = function () {
        if (!this.defaultFilter) {
            this.defaultFilter = this.getDefaultType();
        }
    };
    ComparableBaseFilter.prototype.generateFilterHeader = function () {
        var _this = this;
        var defaultFilterTypes = this.getApplicableFilterTypes();
        var restrictedFilterTypes = this.filterParams.filterOptions;
        var actualFilterTypes = restrictedFilterTypes ? restrictedFilterTypes : defaultFilterTypes;
        var optionsHtml = actualFilterTypes.map(function (filterType) {
            var localeFilterName = _this.translate(filterType);
            return "<option value=\"" + filterType + "\">" + localeFilterName + "</option>";
        });
        var readOnly = optionsHtml.length == 1 ? 'disabled' : '';
        return optionsHtml.length <= 0 ?
            '' :
            "<div>\n                <select class=\"ag-filter-select\" id=\"filterType\" " + readOnly + ">\n                    " + optionsHtml.join('') + "\n                </select>\n            </div>";
    };
    ComparableBaseFilter.prototype.initialiseFilterBodyUi = function () {
        this.setFilterType(this.filter);
    };
    ComparableBaseFilter.prototype.onFilterTypeChanged = function () {
        this.filter = this.eTypeSelector.value;
        this.refreshFilterBodyUi();
        this.onFilterChanged();
    };
    ComparableBaseFilter.prototype.isFilterActive = function () {
        var rawFilterValues = this.filterValues();
        if (this.filter === BaseFilter.IN_RANGE) {
            var filterValueArray = rawFilterValues;
            return filterValueArray[0] != null && filterValueArray[1] != null;
        }
        else {
            return rawFilterValues != null;
        }
    };
    ComparableBaseFilter.prototype.setFilterType = function (filterType) {
        this.filter = filterType;
        this.eTypeSelector.value = filterType;
    };
    __decorate([
        componentAnnotations_1.QuerySelector('#filterType'),
        __metadata("design:type", HTMLSelectElement)
    ], ComparableBaseFilter.prototype, "eTypeSelector", void 0);
    return ComparableBaseFilter;
}(BaseFilter));
exports.ComparableBaseFilter = ComparableBaseFilter;
/**
 * Comparable filter with scalar underlying values (ie numbers and dates. Strings are not scalar so have to extend
 * ComparableBaseFilter)
 */
var ScalarBaseFilter = (function (_super) {
    __extends(ScalarBaseFilter, _super);
    function ScalarBaseFilter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ScalarBaseFilter.prototype.nullComparator = function (type) {
        var _this = this;
        return function (filterValue, gridValue) {
            if (gridValue == null) {
                var nullValue = _this.translateNull(type);
                if (_this.filter === BaseFilter.EQUALS) {
                    return nullValue ? 0 : 1;
                }
                if (_this.filter === BaseFilter.GREATER_THAN) {
                    return nullValue ? 1 : -1;
                }
                if (_this.filter === BaseFilter.GREATER_THAN_OR_EQUAL) {
                    return nullValue ? 1 : -1;
                }
                if (_this.filter === BaseFilter.LESS_THAN_OR_EQUAL) {
                    return nullValue ? -1 : 1;
                }
                if (_this.filter === BaseFilter.LESS_THAN) {
                    return nullValue ? -1 : 1;
                }
                if (_this.filter === BaseFilter.NOT_EQUAL) {
                    return nullValue ? 1 : 0;
                }
            }
            var actualComparator = _this.comparator();
            return actualComparator(filterValue, gridValue);
        };
    };
    ScalarBaseFilter.prototype.getDefaultType = function () {
        return BaseFilter.EQUALS;
    };
    ScalarBaseFilter.prototype.translateNull = function (type) {
        var reducedType = type.indexOf('greater') > -1 ? 'greaterThan' :
            type.indexOf('lessThan') > -1 ? 'lessThan' :
                'equals';
        if (this.filterParams.nullComparator && this.filterParams.nullComparator[reducedType]) {
            return this.filterParams.nullComparator[reducedType];
        }
        ;
        return ScalarBaseFilter.DEFAULT_NULL_COMPARATOR[reducedType];
    };
    ScalarBaseFilter.prototype.doesFilterPass = function (params) {
        var value = this.filterParams.valueGetter(params.node);
        var comparator = this.nullComparator(this.filter);
        var rawFilterValues = this.filterValues();
        var from = Array.isArray(rawFilterValues) ? rawFilterValues[0] : rawFilterValues;
        if (from == null)
            return true;
        var compareResult = comparator(from, value);
        if (this.filter === BaseFilter.EQUALS) {
            return compareResult === 0;
        }
        if (this.filter === BaseFilter.GREATER_THAN) {
            return compareResult > 0;
        }
        if (this.filter === BaseFilter.GREATER_THAN_OR_EQUAL) {
            return compareResult >= 0;
        }
        if (this.filter === BaseFilter.LESS_THAN_OR_EQUAL) {
            return compareResult <= 0;
        }
        if (this.filter === BaseFilter.LESS_THAN) {
            return compareResult < 0;
        }
        if (this.filter === BaseFilter.NOT_EQUAL) {
            return compareResult != 0;
        }
        //From now on the type is a range and rawFilterValues must be an array!
        var compareToResult = comparator(rawFilterValues[1], value);
        if (this.filter === BaseFilter.IN_RANGE) {
            if (!this.filterParams.inRangeInclusive) {
                return compareResult > 0 && compareToResult < 0;
            }
            else {
                return compareResult >= 0 && compareToResult <= 0;
            }
        }
        throw new Error('Unexpected type of date filter!: ' + this.filter);
    };
    ScalarBaseFilter.DEFAULT_NULL_COMPARATOR = {
        equals: false,
        lessThan: false,
        greaterThan: false
    };
    return ScalarBaseFilter;
}(ComparableBaseFilter));
exports.ScalarBaseFilter = ScalarBaseFilter;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var CssClassApplier = (function () {
    function CssClassApplier() {
    }
    CssClassApplier.addHeaderClassesFromColDef = function (abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup) {
        if (utils_1.Utils.missing(abstractColDef)) {
            return;
        }
        this.addColumnClassesFromCollDef(abstractColDef.headerClass, abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup);
    };
    CssClassApplier.addToolPanelClassesFromColDef = function (abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup) {
        if (utils_1.Utils.missing(abstractColDef)) {
            return;
        }
        this.addColumnClassesFromCollDef(abstractColDef.toolPanelClass, abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup);
    };
    CssClassApplier.addColumnClassesFromCollDef = function (classesOrFunc, abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup) {
        if (utils_1.Utils.missing(classesOrFunc)) {
            return;
        }
        var classToUse;
        if (typeof classesOrFunc === 'function') {
            var params = {
                // bad naming, as colDef here can be a group or a column,
                // however most people won't appreciate the difference,
                // so keeping it as colDef to avoid confusion.
                colDef: abstractColDef,
                column: column,
                columnGroup: columnGroup,
                context: gridOptionsWrapper.getContext(),
                api: gridOptionsWrapper.getApi()
            };
            var headerClassFunc = classesOrFunc;
            classToUse = headerClassFunc(params);
        }
        else {
            classToUse = classesOrFunc;
        }
        if (typeof classToUse === 'string') {
            utils_1.Utils.addCssClass(eHeaderCell, classToUse);
        }
        else if (Array.isArray(classToUse)) {
            classToUse.forEach(function (cssClassItem) {
                utils_1.Utils.addCssClass(eHeaderCell, cssClassItem);
            });
        }
    };
    return CssClassApplier;
}());
exports.CssClassApplier = CssClassApplier;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var gridPanel_1 = __webpack_require__(10);
var column_1 = __webpack_require__(9);
var context_1 = __webpack_require__(0);
var headerContainer_1 = __webpack_require__(102);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var scrollVisibleService_1 = __webpack_require__(34);
var HeaderRenderer = (function () {
    function HeaderRenderer() {
    }
    HeaderRenderer.prototype.init = function () {
        var _this = this;
        this.eHeaderViewport = this.gridPanel.getHeaderViewport();
        this.eRoot = this.gridPanel.getRoot();
        this.eHeaderOverlay = this.gridPanel.getHeaderOverlay();
        this.centerContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getHeaderContainer(), this.gridPanel.getHeaderViewport(), this.eRoot, null);
        this.childContainers = [this.centerContainer];
        if (!this.gridOptionsWrapper.isForPrint()) {
            this.pinnedLeftContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getPinnedLeftHeader(), null, this.eRoot, column_1.Column.PINNED_LEFT);
            this.pinnedRightContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getPinnedRightHeader(), null, this.eRoot, column_1.Column.PINNED_RIGHT);
            this.childContainers.push(this.pinnedLeftContainer);
            this.childContainers.push(this.pinnedRightContainer);
        }
        this.childContainers.forEach(function (container) { return _this.context.wireBean(container); });
        // when grid columns change, it means the number of rows in the header has changed and it's all new columns
        this.eventService.addEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
        // shotgun way to get labels to change, eg from sum(amount) to avg(amount)
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.refreshHeader.bind(this));
        // for resized, the individual cells take care of this, so don't need to refresh everything
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.setPinnedColContainerWidth.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.setPinnedColContainerWidth.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));
        if (this.columnController.isReady()) {
            this.refreshHeader();
        }
    };
    HeaderRenderer.prototype.onScrollVisibilityChanged = function () {
        this.setPinnedColContainerWidth();
    };
    HeaderRenderer.prototype.forEachHeaderElement = function (callback) {
        this.childContainers.forEach(function (childContainer) { return childContainer.forEachHeaderElement(callback); });
    };
    HeaderRenderer.prototype.destroy = function () {
        this.childContainers.forEach(function (container) { return container.destroy(); });
    };
    HeaderRenderer.prototype.onGridColumnsChanged = function () {
        this.setHeight();
    };
    HeaderRenderer.prototype.refreshHeader = function () {
        this.setHeight();
        this.childContainers.forEach(function (container) { return container.refresh(); });
        this.setPinnedColContainerWidth();
    };
    HeaderRenderer.prototype.setHeight = function () {
        // if forPrint, overlay is missing
        if (this.eHeaderOverlay) {
            var rowHeight = this.gridOptionsWrapper.getHeaderHeight();
            // we can probably get rid of this when we no longer need the overlay
            var dept = this.columnController.getHeaderRowCount();
            this.eHeaderOverlay.style.height = rowHeight + 'px';
            this.eHeaderOverlay.style.top = ((dept - 1) * rowHeight) + 'px';
        }
    };
    HeaderRenderer.prototype.setPinnedColContainerWidth = function () {
        // pinned col doesn't exist when doing forPrint
        if (this.gridOptionsWrapper.isForPrint()) {
            return;
        }
        var pinnedLeftWidthWithScroll = this.scrollVisibleService.getPinnedLeftWithScrollWidth();
        var pinnedRightWidthWithScroll = this.scrollVisibleService.getPinnedRightWithScrollWidth();
        this.eHeaderViewport.style.marginLeft = pinnedLeftWidthWithScroll + 'px';
        this.eHeaderViewport.style.marginRight = pinnedRightWidthWithScroll + 'px';
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderRenderer.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], HeaderRenderer.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], HeaderRenderer.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], HeaderRenderer.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], HeaderRenderer.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('scrollVisibleService'),
        __metadata("design:type", scrollVisibleService_1.ScrollVisibleService)
    ], HeaderRenderer.prototype, "scrollVisibleService", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeaderRenderer.prototype, "init", null);
    __decorate([
        context_1.PreDestroy,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeaderRenderer.prototype, "destroy", null);
    HeaderRenderer = __decorate([
        context_1.Bean('headerRenderer')
    ], HeaderRenderer);
    return HeaderRenderer;
}());
exports.HeaderRenderer = HeaderRenderer;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var popupEditorWrapper_1 = __webpack_require__(78);
var gridOptionsWrapper_1 = __webpack_require__(2);
var componentResolver_1 = __webpack_require__(22);
var CellEditorFactory = (function () {
    function CellEditorFactory() {
    }
    CellEditorFactory.prototype.init = function () {
    };
    CellEditorFactory.prototype.addCellEditor = function (key, cellEditor) {
        console.warn("ag-grid: since v13.3.1 this method is not supported anymore. If you want to register your own editor check the docs: https://www.ag-grid.com/javascript-grid-cell-editor/");
    };
    // private registerEditorsFromGridOptions(): void {
    //     let userProvidedCellEditors = this.gridOptionsWrapper.getCellEditors();
    //     _.iterateObject(userProvidedCellEditors, (key: string, cellEditor: {new(): ICellEditor})=> {
    //         this.addCellEditor(key, cellEditor);
    //     });
    // }
    CellEditorFactory.prototype.createCellEditor = function (column, params) {
        var _this = this;
        var cellEditorPromise = this.componentResolver.createAgGridComponent(column, params, 'cellEditor');
        return cellEditorPromise.map(function (cellEditor) {
            var isPopup = cellEditor.isPopup && cellEditor.isPopup();
            if (!isPopup) {
                return cellEditor;
            }
            if (_this.gridOptionsWrapper.isFullRowEdit()) {
                console.warn('ag-Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both ' +
                    '- either turn off fullRowEdit, or stop using popup editors.');
            }
            // if a popup, then we wrap in a popup editor and return the popup
            var popupEditorWrapper = new popupEditorWrapper_1.PopupEditorWrapper(cellEditor);
            _this.context.wireBean(popupEditorWrapper);
            popupEditorWrapper.init(params);
            return popupEditorWrapper;
        });
    };
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], CellEditorFactory.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('componentResolver'),
        __metadata("design:type", componentResolver_1.ComponentResolver)
    ], CellEditorFactory.prototype, "componentResolver", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], CellEditorFactory.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CellEditorFactory.prototype, "init", null);
    CellEditorFactory = __decorate([
        context_1.Bean('cellEditorFactory')
    ], CellEditorFactory);
    return CellEditorFactory;
}());
exports.CellEditorFactory = CellEditorFactory;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var eventService_1 = __webpack_require__(4);
var expressionService_1 = __webpack_require__(19);
var animateSlideCellRenderer_1 = __webpack_require__(82);
var animateShowChangeCellRenderer_1 = __webpack_require__(81);
var groupCellRenderer_1 = __webpack_require__(83);
var CellRendererFactory = (function () {
    function CellRendererFactory() {
        this.cellRendererMap = {};
    }
    CellRendererFactory_1 = CellRendererFactory;
    CellRendererFactory.prototype.init = function () {
        this.cellRendererMap[CellRendererFactory_1.ANIMATE_SLIDE] = animateSlideCellRenderer_1.AnimateSlideCellRenderer;
        this.cellRendererMap[CellRendererFactory_1.ANIMATE_SHOW_CHANGE] = animateShowChangeCellRenderer_1.AnimateShowChangeCellRenderer;
        this.cellRendererMap[CellRendererFactory_1.GROUP] = groupCellRenderer_1.GroupCellRenderer;
        // this.registerRenderersFromGridOptions();
    };
    // private registerRenderersFromGridOptions(): void {
    //     let userProvidedCellRenderers = this.gridOptionsWrapper.getCellRenderers();
    //     _.iterateObject(userProvidedCellRenderers, (key: string, cellRenderer: {new(): ICellRenderer} | ICellRendererFunc)=> {
    //         this.addCellRenderer(key, cellRenderer);
    //     });
    // }
    CellRendererFactory.prototype.addCellRenderer = function (key, cellRenderer) {
        this.cellRendererMap[key] = cellRenderer;
    };
    CellRendererFactory.prototype.getCellRenderer = function (key) {
        var result = this.cellRendererMap[key];
        if (utils_1.Utils.missing(result)) {
            console.warn('ag-Grid: unable to find cellRenderer for key ' + key);
            return null;
        }
        return result;
    };
    CellRendererFactory.ANIMATE_SLIDE = 'animateSlide';
    CellRendererFactory.ANIMATE_SHOW_CHANGE = 'animateShowChange';
    CellRendererFactory.GROUP = 'group';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], CellRendererFactory.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'),
        __metadata("design:type", expressionService_1.ExpressionService)
    ], CellRendererFactory.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], CellRendererFactory.prototype, "eventService", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CellRendererFactory.prototype, "init", null);
    CellRendererFactory = CellRendererFactory_1 = __decorate([
        context_1.Bean('cellRendererFactory')
    ], CellRendererFactory);
    return CellRendererFactory;
    var CellRendererFactory_1;
}());
exports.CellRendererFactory = CellRendererFactory;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var componentRecipes_1 = __webpack_require__(27);
var componentResolver_1 = __webpack_require__(22);
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
/** Class to use a cellRenderer. */
var CellRendererService = (function () {
    function CellRendererService() {
    }
    CellRendererService.prototype.useCellRenderer = function (target, eTarget, params) {
        var _this = this;
        var cellRendererPromise = this.componentRecipes.newCellRenderer(target, params);
        if (cellRendererPromise != null) {
            cellRendererPromise.then(function (cellRenderer) {
                if (cellRenderer == null) {
                    eTarget.innerText = params.valueFormatted != null ? params.valueFormatted : params.value;
                }
                else {
                    _this.bindToHtml(cellRendererPromise, eTarget);
                }
            });
        }
        else {
            eTarget.innerText = params.valueFormatted != null ? params.valueFormatted : params.value;
        }
        return cellRendererPromise;
    };
    CellRendererService.prototype.useFilterCellRenderer = function (target, eTarget, params) {
        var cellRendererPromise = this.componentRecipes.newCellRenderer(target.filterParams, params);
        if (cellRendererPromise != null) {
            this.bindToHtml(cellRendererPromise, eTarget);
        }
        else {
            if (params.valueFormatted == null && params.value == null) {
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                eTarget.innerText = '(' + localeTextFunc('blanks', 'Blanks') + ')';
            }
            else {
                eTarget.innerText = params.valueFormatted != null ? params.valueFormatted : params.value;
            }
        }
        return cellRendererPromise;
    };
    CellRendererService.prototype.useRichSelectCellRenderer = function (target, eTarget, params) {
        var cellRendererPromise = this.componentRecipes.newCellRenderer(target.cellEditorParams, params);
        if (cellRendererPromise != null) {
            this.bindToHtml(cellRendererPromise, eTarget);
        }
        else {
            eTarget.innerText = params.valueFormatted != null ? params.valueFormatted : params.value;
        }
        return cellRendererPromise;
    };
    CellRendererService.prototype.useInnerCellRenderer = function (target, originalColumn, eTarget, params) {
        var _this = this;
        var rendererToUsePromise = null;
        var componentToUse = this.componentResolver.getComponentToUse(target, "innerRenderer");
        if (componentToUse && componentToUse.component != null && componentToUse.source != componentResolver_1.ComponentSource.DEFAULT) {
            //THERE IS ONE INNER CELL RENDERER HARDCODED IN THE COLDEF FOR THIS GROUP COLUMN
            rendererToUsePromise = this.componentRecipes.newInnerCellRenderer(target, params);
        }
        else {
            var otherRenderer = this.componentResolver.getComponentToUse(originalColumn, "cellRenderer");
            if (otherRenderer && otherRenderer.source != componentResolver_1.ComponentSource.DEFAULT) {
                //Only if the original column is using an specific renderer, it it is a using a DEFAULT one
                //ignore it
                //THIS COMES FROM A COLUMN WHICH HAS BEEN GROUPED DYNAMICALLY, WE REUSE ITS RENDERER
                rendererToUsePromise = this.componentRecipes.newCellRenderer(originalColumn, params);
            }
            else if (otherRenderer && otherRenderer.source == componentResolver_1.ComponentSource.DEFAULT && (utils_1._.get(originalColumn, 'cellRendererParams.innerRenderer', null))) {
                //EDGE CASE - THIS COMES FROM A COLUMN WHICH HAS BEEN GROUPED DYNAMICALLY, THAT HAS AS RENDERER 'group'
                //AND HAS A INNER CELL RENDERER
                rendererToUsePromise = this.componentRecipes.newInnerCellRenderer(originalColumn.cellRendererParams, params);
            }
            else {
                //This forces the retrieval of the default plain cellRenderer that just renders the values.
                rendererToUsePromise = this.componentRecipes.newCellRenderer({}, params);
            }
        }
        if (rendererToUsePromise != null) {
            rendererToUsePromise.then(function (rendererToUse) {
                if (rendererToUse == null) {
                    eTarget.innerText = params.valueFormatted != null ? params.valueFormatted : params.value;
                    return;
                }
                _this.bindToHtml(rendererToUsePromise, eTarget);
            });
        }
        else {
            eTarget.innerText = params.valueFormatted != null ? params.valueFormatted : params.value;
        }
        return rendererToUsePromise;
    };
    CellRendererService.prototype.useFullWidthGroupRowInnerCellRenderer = function (eTarget, params) {
        var cellRendererPromise = this.componentRecipes.newFullWidthGroupRowInnerCellRenderer(params);
        if (cellRendererPromise != null) {
            this.bindToHtml(cellRendererPromise, eTarget);
        }
        else {
            eTarget.innerText = params.valueFormatted != null ? params.valueFormatted : params.value;
        }
        return cellRendererPromise;
    };
    CellRendererService.prototype.bindToHtml = function (cellRendererPromise, eTarget) {
        cellRendererPromise.then(function (cellRenderer) {
            var gui = cellRenderer.getGui();
            if (gui != null) {
                if (typeof gui == 'object') {
                    eTarget.appendChild(gui);
                }
                else {
                    eTarget.innerHTML = gui;
                }
            }
        });
        return cellRendererPromise;
    };
    __decorate([
        context_1.Autowired('componentRecipes'),
        __metadata("design:type", componentRecipes_1.ComponentRecipes)
    ], CellRendererService.prototype, "componentRecipes", void 0);
    __decorate([
        context_1.Autowired('componentResolver'),
        __metadata("design:type", componentResolver_1.ComponentResolver)
    ], CellRendererService.prototype, "componentResolver", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], CellRendererService.prototype, "gridOptionsWrapper", void 0);
    CellRendererService = __decorate([
        context_1.Bean('cellRendererService')
    ], CellRendererService);
    return CellRendererService;
}());
exports.CellRendererService = CellRendererService;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var cellComp_1 = __webpack_require__(41);
var rowNode_1 = __webpack_require__(15);
var gridOptionsWrapper_1 = __webpack_require__(2);
var column_1 = __webpack_require__(9);
var events_1 = __webpack_require__(5);
var context_1 = __webpack_require__(0);
var component_1 = __webpack_require__(8);
var componentAnnotations_1 = __webpack_require__(12);
var LoadingCellRenderer = (function (_super) {
    __extends(LoadingCellRenderer, _super);
    function LoadingCellRenderer() {
        return _super.call(this, LoadingCellRenderer.TEMPLATE) || this;
    }
    LoadingCellRenderer.prototype.init = function (params) {
        var eLoadingIcon = utils_1._.createIconNoSpan('groupLoading', this.gridOptionsWrapper, null);
        this.eLoadingIcon.appendChild(eLoadingIcon);
        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
        this.eLoadingText.innerText = localeTextFunc('loadingOoo', 'Loading');
    };
    LoadingCellRenderer.prototype.refresh = function (params) {
        return false;
    };
    LoadingCellRenderer.TEMPLATE = "<div class=\"ag-stub-cell\">\n            <span class=\"ag-loading-icon\" ref=\"eLoadingIcon\"></span>\n            <span class=\"ag-loading-text\" ref=\"eLoadingText\"></span>\n        </div>";
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], LoadingCellRenderer.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eLoadingIcon'),
        __metadata("design:type", HTMLElement)
    ], LoadingCellRenderer.prototype, "eLoadingIcon", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eLoadingText'),
        __metadata("design:type", HTMLElement)
    ], LoadingCellRenderer.prototype, "eLoadingText", void 0);
    return LoadingCellRenderer;
}(component_1.Component));
exports.LoadingCellRenderer = LoadingCellRenderer;
var RowComp = (function (_super) {
    __extends(RowComp, _super);
    function RowComp(parentScope, bodyContainerComp, pinnedLeftContainerComp, pinnedRightContainerComp, fullWidthContainerComp, rowNode, beans, animateIn, useAnimationFrameForCreate) {
        var _this = _super.call(this) || this;
        _this.eAllRowContainers = [];
        _this.active = true;
        _this.columnRefreshPending = false;
        _this.cellComps = {};
        // for animations, there are bits we want done in the next VM turn, to all DOM to update first.
        // instead of each row doing a setTimeout(func,0), we put the functions here and the rowRenderer
        // executes them all in one timeout
        _this.createSecondPassFuncs = [];
        // these get called before the row is destroyed - they set up the DOM for the remove animation (ie they
        // set the DOM up for the animation), then the delayedDestroyFunctions get called when the animation is
        // complete (ie removes from the dom).
        _this.removeFirstPassFuncs = [];
        // for animations, these functions get called 400ms after the row is cleared, called by the rowRenderer
        // so each row isn't setting up it's own timeout
        _this.removeSecondPassFuncs = [];
        _this.initialised = false;
        _this.parentScope = parentScope;
        _this.beans = beans;
        _this.bodyContainerComp = bodyContainerComp;
        _this.pinnedLeftContainerComp = pinnedLeftContainerComp;
        _this.pinnedRightContainerComp = pinnedRightContainerComp;
        _this.fullWidthContainerComp = fullWidthContainerComp;
        _this.rowNode = rowNode;
        _this.rowIsEven = _this.rowNode.rowIndex % 2 === 0;
        _this.paginationPage = _this.beans.paginationProxy.getCurrentPage();
        _this.useAnimationFrameForCreate = useAnimationFrameForCreate;
        _this.setAnimateFlags(animateIn);
        return _this;
    }
    RowComp.prototype.init = function () {
        var _this = this;
        this.rowFocused = this.beans.focusedCellController.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
        this.scope = this.createChildScopeOrNull(this.rowNode.data);
        this.setupRowContainers();
        this.addListeners();
        if (this.slideRowIn) {
            this.createSecondPassFuncs.push(function () {
                _this.onTopChanged();
            });
        }
        if (this.fadeRowIn) {
            this.createSecondPassFuncs.push(function () {
                _this.eAllRowContainers.forEach(function (eRow) { return utils_1._.removeCssClass(eRow, 'ag-opacity-zero'); });
            });
        }
        this.executeProcessRowPostCreateFunc();
    };
    RowComp.prototype.createTemplate = function (contents, extraCssClass) {
        if (extraCssClass === void 0) { extraCssClass = null; }
        var templateParts = [];
        var rowHeight = this.rowNode.rowHeight;
        var rowClasses = this.getInitialRowClasses(extraCssClass).join(' ');
        var rowId = this.rowNode.id;
        var userRowStyles = this.preProcessStylesFromGridOptions();
        var businessKey = this.getRowBusinessKey();
        var rowTopStyle = this.getInitialRowTopStyle();
        templateParts.push("<div");
        templateParts.push(" role=\"row\"");
        templateParts.push(" row-index=\"" + this.rowNode.getRowIndexString() + "\"");
        templateParts.push(rowId ? " row-id=\"" + rowId + "\"" : "");
        templateParts.push(businessKey ? " row-business-key=\"" + businessKey + "\"" : "");
        templateParts.push(" comp-id=\"" + this.getCompId() + "\"");
        templateParts.push(" class=\"" + rowClasses + "\"");
        templateParts.push(" style=\"height: " + rowHeight + "px; " + rowTopStyle + " " + userRowStyles + "\">");
        // add in the template for the cells
        templateParts.push(contents);
        templateParts.push("</div>");
        return templateParts.join('');
    };
    RowComp.prototype.getCellForCol = function (column) {
        var cellComp = this.cellComps[column.getColId()];
        if (cellComp) {
            return cellComp.getGui();
        }
        else {
            return null;
        }
    };
    RowComp.prototype.afterFlush = function () {
        if (!this.initialised) {
            this.initialised = true;
            this.executeProcessRowPostCreateFunc();
        }
    };
    RowComp.prototype.executeProcessRowPostCreateFunc = function () {
        var func = this.beans.gridOptionsWrapper.getProcessRowPostCreateFunc();
        if (func) {
            var params = {
                eRow: this.eBodyRow,
                ePinnedLeftRow: this.ePinnedLeftRow,
                ePinnedRightRow: this.ePinnedRightRow,
                node: this.rowNode,
                api: this.beans.gridOptionsWrapper.getApi(),
                rowIndex: this.rowNode.rowIndex,
                addRenderedRowListener: this.addEventListener.bind(this),
                columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
                context: this.beans.gridOptionsWrapper.getContext()
            };
            func(params);
        }
    };
    RowComp.prototype.getInitialRowTopStyle = function () {
        var rowTopStyle = '';
        var setRowTop = !this.beans.forPrint && !this.beans.gridOptionsWrapper.isAutoHeight();
        if (setRowTop) {
            // if sliding in, we take the old row top. otherwise we just set the current row top.
            var pixels = this.slideRowIn ? this.roundRowTopToBounds(this.rowNode.oldRowTop) : this.rowNode.rowTop;
            var pixelsWithOffset = this.applyPixelOffset(pixels);
            // if not setting row top, then below is empty string
            rowTopStyle = "top: " + pixelsWithOffset + "px; ";
        }
        return rowTopStyle;
    };
    RowComp.prototype.getRowBusinessKey = function () {
        if (typeof this.beans.gridOptionsWrapper.getBusinessKeyForNodeFunc() === 'function') {
            var businessKey = this.beans.gridOptionsWrapper.getBusinessKeyForNodeFunc()(this.rowNode);
            return businessKey;
        }
    };
    RowComp.prototype.lazyCreateCells = function (cols, eRow) {
        if (this.active) {
            var cellTemplatesAndComps = this.createCells(cols);
            eRow.innerHTML = cellTemplatesAndComps.template;
            this.callAfterRowAttachedOnCells(cellTemplatesAndComps.cellComps, eRow);
        }
    };
    RowComp.prototype.createRowContainer = function (rowContainerComp, cols, callback) {
        var _this = this;
        var cellTemplatesAndComps;
        if (this.useAnimationFrameForCreate) {
            cellTemplatesAndComps = { cellComps: [], template: '' };
        }
        else {
            cellTemplatesAndComps = this.createCells(cols);
        }
        var rowTemplate = this.createTemplate(cellTemplatesAndComps.template);
        rowContainerComp.appendRowTemplate(rowTemplate, function () {
            var eRow = rowContainerComp.getRowElement(_this.getCompId());
            _this.afterRowAttached(rowContainerComp, eRow);
            callback(eRow);
            if (_this.useAnimationFrameForCreate) {
                _this.beans.taskQueue.addP1Task(_this.lazyCreateCells.bind(_this, cols, eRow));
            }
            else {
                _this.callAfterRowAttachedOnCells(cellTemplatesAndComps.cellComps, eRow);
            }
        });
    };
    RowComp.prototype.createChildScopeOrNull = function (data) {
        if (this.beans.gridOptionsWrapper.isAngularCompileRows()) {
            var newChildScope = this.parentScope.$new();
            newChildScope.data = data;
            newChildScope.rowNode = this.rowNode;
            newChildScope.context = this.beans.gridOptionsWrapper.getContext();
            return newChildScope;
        }
        else {
            return null;
        }
    };
    RowComp.prototype.setupRowStub = function () {
        this.fullWidthRow = true;
        this.fullWidthRowEmbedded = this.beans.gridOptionsWrapper.isEmbedFullWidthRows();
        this.createFullWidthRows(RowComp.LOADING_CELL_RENDERER);
    };
    RowComp.prototype.setupRowContainers = function () {
        var isFullWidthCellFunc = this.beans.gridOptionsWrapper.getIsFullWidthCellFunc();
        var isFullWidthCell = isFullWidthCellFunc ? isFullWidthCellFunc(this.rowNode) : false;
        var isGroupSpanningRow = this.rowNode.group && this.beans.gridOptionsWrapper.isGroupUseEntireRow();
        if (this.rowNode.stub) {
            this.setupRowStub();
        }
        else if (isFullWidthCell) {
            this.setupFullWidthContainers();
        }
        else if (isGroupSpanningRow) {
            this.setupFullWidthGroupContainers();
        }
        else {
            this.setupNormalRowContainers();
        }
    };
    RowComp.prototype.setupFullWidthContainers = function () {
        this.fullWidthRow = true;
        this.fullWidthRowEmbedded = this.beans.gridOptionsWrapper.isEmbedFullWidthRows();
        this.createFullWidthRows(RowComp.FULL_WIDTH_CELL_RENDERER);
    };
    RowComp.prototype.setupFullWidthGroupContainers = function () {
        this.fullWidthRow = true;
        this.fullWidthRowEmbedded = this.beans.gridOptionsWrapper.isEmbedFullWidthRows();
        this.createFullWidthRows(RowComp.GROUP_ROW_RENDERER);
    };
    RowComp.prototype.setupNormalRowContainers = function () {
        var _this = this;
        var centerCols = this.beans.columnController.getAllDisplayedCenterVirtualColumnsForRow(this.rowNode);
        this.createRowContainer(this.bodyContainerComp, centerCols, function (eRow) { return _this.eBodyRow = eRow; });
        if (!this.beans.forPrint) {
            var leftCols = this.beans.columnController.getDisplayedLeftColumnsForRow(this.rowNode);
            var rightCols = this.beans.columnController.getDisplayedRightColumnsForRow(this.rowNode);
            this.createRowContainer(this.pinnedRightContainerComp, rightCols, function (eRow) { return _this.ePinnedRightRow = eRow; });
            this.createRowContainer(this.pinnedLeftContainerComp, leftCols, function (eRow) { return _this.ePinnedLeftRow = eRow; });
        }
    };
    RowComp.prototype.createFullWidthRows = function (type) {
        var _this = this;
        if (this.fullWidthRowEmbedded) {
            this.createFullWidthRowContainer(this.bodyContainerComp, null, null, type, function (eRow) {
                _this.eFullWidthRowBody = eRow;
            }, function (cellRenderer) {
                _this.fullWidthRowComponentBody = cellRenderer;
            });
            this.createFullWidthRowContainer(this.pinnedLeftContainerComp, column_1.Column.PINNED_LEFT, 'ag-cell-last-left-pinned', type, function (eRow) {
                _this.eFullWidthRowLeft = eRow;
            }, function (cellRenderer) {
                _this.fullWidthRowComponentLeft = cellRenderer;
            });
            this.createFullWidthRowContainer(this.pinnedRightContainerComp, column_1.Column.PINNED_RIGHT, 'ag-cell-first-right-pinned', type, function (eRow) {
                _this.eFullWidthRowRight = eRow;
            }, function (cellRenderer) {
                _this.fullWidthRowComponentRight = cellRenderer;
            });
        }
        else {
            // otherwise we add to the fullWidth container as normal
            // let previousFullWidth = ensureDomOrder ? this.lastPlacedElements.eFullWidth : null;
            this.createFullWidthRowContainer(this.fullWidthContainerComp, null, null, type, function (eRow) {
                _this.eFullWidthRow = eRow;
                // and fake the mouse wheel for the fullWidth container
                if (!_this.beans.forPrint) {
                    _this.addMouseWheelListenerToFullWidthRow();
                }
            }, function (cellRenderer) {
                _this.fullWidthRowComponent = cellRenderer;
            });
        }
    };
    RowComp.prototype.addMouseWheelListenerToFullWidthRow = function () {
        var mouseWheelListener = this.beans.gridPanel.genericMouseWheelListener.bind(this.beans.gridPanel);
        // IE9, Chrome, Safari, Opera
        this.addDestroyableEventListener(this.eFullWidthRow, 'mousewheel', mouseWheelListener);
        // Firefox
        this.addDestroyableEventListener(this.eFullWidthRow, 'DOMMouseScroll', mouseWheelListener);
    };
    RowComp.prototype.setAnimateFlags = function (animateIn) {
        if (animateIn) {
            var oldRowTopExists = utils_1._.exists(this.rowNode.oldRowTop);
            // if the row had a previous position, we slide it in (animate row top)
            this.slideRowIn = oldRowTopExists;
            // if the row had no previous position, we fade it in (animate
            this.fadeRowIn = !oldRowTopExists;
        }
        else {
            this.slideRowIn = false;
            this.fadeRowIn = false;
        }
    };
    RowComp.prototype.isEditing = function () {
        return false;
    };
    RowComp.prototype.stopRowEditing = function (cancel) {
        this.stopEditing(cancel);
    };
    RowComp.prototype.isFullWidth = function () {
        return this.fullWidthRow;
    };
    RowComp.prototype.addListeners = function () {
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_HEIGHT_CHANGED, this.onRowHeightChanged.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_TOP_CHANGED, this.onTopChanged.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_EXPANDED_CHANGED, this.onExpandedChanged.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_CELL_CHANGED, this.onRowNodeCellChanged.bind(this));
        var eventService = this.beans.eventService;
        this.addDestroyableEventListener(eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
        this.addDestroyableEventListener(eventService, events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this));
        this.addDestroyableEventListener(eventService, events_1.Events.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this));
        this.addDestroyableEventListener(eventService, events_1.Events.EVENT_CELL_FOCUSED, this.onCellFocusChanged.bind(this));
        this.addDestroyableEventListener(eventService, events_1.Events.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this));
        this.addDestroyableEventListener(eventService, events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
    };
    // when grid columns change, then all cells should be cleaned out,
    // as the new columns could have same id as the previous columns and may conflict
    RowComp.prototype.onGridColumnsChanged = function () {
        var allRenderedCellIds = Object.keys(this.cellComps);
        this.removeRenderedCells(allRenderedCellIds);
    };
    RowComp.prototype.onRowNodeDataChanged = function (event) {
        // if this is an update, we want to refresh, as this will allow the user to put in a transition
        // into the cellRenderer refresh method. otherwise this might be completely new data, in which case
        // we will want to completely replace the cells
        this.forEachCellComp(function (cellComp) {
            return cellComp.refreshCell({
                suppressFlash: !event.update,
                newData: !event.update
            });
        });
        // check for selected also, as this could be after lazy loading of the row data, in which case
        // the id might of just gotten set inside the row and the row selected state may of changed
        // as a result. this is what happens when selected rows are loaded in virtual pagination.
        // - niall note - since moving to the stub component, this may no longer be true, as replacing
        // the stub component now replaces the entire row
        this.onRowSelected();
        // as data has changed, then the style and class needs to be recomputed
        this.postProcessCss();
    };
    RowComp.prototype.onRowNodeCellChanged = function (event) {
        // as data has changed, then the style and class needs to be recomputed
        this.postProcessCss();
    };
    RowComp.prototype.postProcessCss = function () {
        this.postProcessStylesFromGridOptions();
        this.postProcessClassesFromGridOptions();
        this.postProcessRowClassRules();
    };
    RowComp.prototype.onExpandedChanged = function () {
        if (this.rowNode.group && !this.rowNode.footer) {
            var expanded_1 = this.rowNode.expanded;
            this.eAllRowContainers.forEach(function (row) { return utils_1._.addOrRemoveCssClass(row, 'ag-row-group-expanded', expanded_1); });
            this.eAllRowContainers.forEach(function (row) { return utils_1._.addOrRemoveCssClass(row, 'ag-row-group-contracted', !expanded_1); });
        }
    };
    RowComp.prototype.onDisplayedColumnsChanged = function () {
        if (!this.fullWidthRow) {
            this.refreshCells();
        }
    };
    RowComp.prototype.destroyFullWidthComponents = function () {
        if (this.fullWidthRowComponent) {
            if (this.fullWidthRowComponent.destroy) {
                this.fullWidthRowComponent.destroy();
            }
            this.fullWidthRowComponent = null;
        }
        if (this.fullWidthRowComponentBody) {
            if (this.fullWidthRowComponentBody.destroy) {
                this.fullWidthRowComponentBody.destroy();
            }
            this.fullWidthRowComponent = null;
        }
        if (this.fullWidthRowComponentLeft) {
            if (this.fullWidthRowComponentLeft.destroy) {
                this.fullWidthRowComponentLeft.destroy();
            }
            this.fullWidthRowComponentLeft = null;
        }
        if (this.fullWidthRowComponentRight) {
            if (this.fullWidthRowComponentRight.destroy) {
                this.fullWidthRowComponentRight.destroy();
            }
            this.fullWidthRowComponent = null;
        }
    };
    RowComp.prototype.getContainerForCell = function (pinnedType) {
        switch (pinnedType) {
            case column_1.Column.PINNED_LEFT: return this.ePinnedLeftRow;
            case column_1.Column.PINNED_RIGHT: return this.ePinnedRightRow;
            default: return this.eBodyRow;
        }
    };
    RowComp.prototype.onVirtualColumnsChanged = function () {
        if (!this.fullWidthRow) {
            this.refreshCells();
        }
    };
    RowComp.prototype.onColumnResized = function () {
        if (!this.fullWidthRow) {
            this.refreshCells();
        }
    };
    RowComp.prototype.refreshCells = function () {
        if (this.beans.gridOptionsWrapper.isSuppressAnimationFrame()) {
            this.refreshCellsInAnimationFrame();
        }
        else {
            if (this.columnRefreshPending) {
                return;
            }
            this.beans.taskQueue.addP1Task(this.refreshCellsInAnimationFrame.bind(this));
        }
    };
    RowComp.prototype.refreshCellsInAnimationFrame = function () {
        if (!this.active) {
            return;
        }
        this.columnRefreshPending = false;
        var centerCols = this.beans.columnController.getAllDisplayedCenterVirtualColumnsForRow(this.rowNode);
        var leftCols = this.beans.columnController.getDisplayedLeftColumnsForRow(this.rowNode);
        var rightCols = this.beans.columnController.getDisplayedRightColumnsForRow(this.rowNode);
        this.insertCellsIntoContainer(this.eBodyRow, centerCols);
        this.insertCellsIntoContainer(this.ePinnedLeftRow, leftCols);
        this.insertCellsIntoContainer(this.ePinnedRightRow, rightCols);
        var colIdsToRemove = Object.keys(this.cellComps);
        centerCols.forEach(function (col) { return utils_1._.removeFromArray(colIdsToRemove, col.getId()); });
        leftCols.forEach(function (col) { return utils_1._.removeFromArray(colIdsToRemove, col.getId()); });
        rightCols.forEach(function (col) { return utils_1._.removeFromArray(colIdsToRemove, col.getId()); });
        // we never remove editing cells, as this would cause the cells to loose their values while editing
        // as the grid is scrolling horizontally.
        colIdsToRemove = utils_1._.filter(colIdsToRemove, this.isCellEligibleToBeRemoved.bind(this));
        // remove old cells from gui, but we don't destroy them, we might use them again
        this.removeRenderedCells(colIdsToRemove);
    };
    RowComp.prototype.removeRenderedCells = function (colIds) {
        var _this = this;
        colIds.forEach(function (key) {
            var cellComp = _this.cellComps[key];
            // could be old reference, ie removed cell
            if (utils_1._.missing(cellComp)) {
                return;
            }
            cellComp.detach();
            cellComp.destroy();
            _this.cellComps[key] = null;
        });
    };
    RowComp.prototype.isCellEligibleToBeRemoved = function (indexStr) {
        var displayedColumns = this.beans.columnController.getAllDisplayedColumns();
        var REMOVE_CELL = true;
        var KEEP_CELL = false;
        var renderedCell = this.cellComps[indexStr];
        if (!renderedCell) {
            return REMOVE_CELL;
        }
        // always remove the cell if it's in the wrong pinned location
        if (this.isCellInWrongRow(renderedCell)) {
            return REMOVE_CELL;
        }
        // we want to try and keep editing and focused cells
        var editing = renderedCell.isEditing();
        var focused = this.beans.focusedCellController.isCellFocused(renderedCell.getGridCell());
        var mightWantToKeepCell = editing || focused;
        if (mightWantToKeepCell) {
            var column = renderedCell.getColumn();
            var cellStillDisplayed = displayedColumns.indexOf(column) >= 0;
            return cellStillDisplayed ? KEEP_CELL : REMOVE_CELL;
        }
        else {
            return REMOVE_CELL;
        }
    };
    RowComp.prototype.ensureCellInCorrectContainer = function (cellComp) {
        var element = cellComp.getGui();
        var column = cellComp.getColumn();
        var pinnedType = column.getPinned();
        var eContainer = this.getContainerForCell(pinnedType);
        // if in wrong container, remove it
        var eOldContainer = cellComp.getParentRow();
        var inWrongRow = eOldContainer !== eContainer;
        if (inWrongRow) {
            // take out from old row
            if (eOldContainer) {
                eOldContainer.removeChild(element);
            }
            eContainer.appendChild(element);
            cellComp.setParentRow(eContainer);
        }
    };
    RowComp.prototype.isCellInWrongRow = function (cellComp) {
        var column = cellComp.getColumn();
        var rowWeWant = this.getContainerForCell(column.getPinned());
        // if in wrong container, remove it
        var oldRow = cellComp.getParentRow();
        return oldRow !== rowWeWant;
    };
    RowComp.prototype.insertCellsIntoContainer = function (eRow, cols) {
        var _this = this;
        if (!eRow) {
            return;
        }
        var cellTemplates = [];
        var newCellComps = [];
        cols.forEach(function (col) {
            var colId = col.getId();
            var oldCell = _this.cellComps[colId];
            if (oldCell) {
                _this.ensureCellInCorrectContainer(oldCell);
            }
            else {
                _this.createNewCell(col, eRow, cellTemplates, newCellComps);
            }
        });
        if (cellTemplates.length > 0) {
            utils_1._.appendHtml(eRow, cellTemplates.join(''));
            this.callAfterRowAttachedOnCells(newCellComps, eRow);
        }
    };
    RowComp.prototype.addDomData = function (eRowContainer) {
        var gow = this.beans.gridOptionsWrapper;
        gow.setDomData(eRowContainer, RowComp.DOM_DATA_KEY_RENDERED_ROW, this);
        this.addDestroyFunc(function () {
            gow.setDomData(eRowContainer, RowComp.DOM_DATA_KEY_RENDERED_ROW, null);
        });
    };
    RowComp.prototype.createNewCell = function (col, eContainer, cellTemplates, newCellComps) {
        var newCellComp = new cellComp_1.CellComp(this.scope, this.beans, col, this.rowNode, this);
        var cellTemplate = newCellComp.getCreateTemplate();
        cellTemplates.push(cellTemplate);
        newCellComps.push(newCellComp);
        this.cellComps[col.getId()] = newCellComp;
        newCellComp.setParentRow(eContainer);
    };
    RowComp.prototype.onMouseEvent = function (eventName, mouseEvent) {
        switch (eventName) {
            case 'dblclick':
                this.onRowDblClick(mouseEvent);
                break;
            case 'click':
                this.onRowClick(mouseEvent);
                break;
        }
    };
    RowComp.prototype.createRowEvent = function (type, domEvent) {
        return {
            type: type,
            node: this.rowNode,
            data: this.rowNode.data,
            rowIndex: this.rowNode.rowIndex,
            rowPinned: this.rowNode.rowPinned,
            context: this.beans.gridOptionsWrapper.getContext(),
            api: this.beans.gridOptionsWrapper.getApi(),
            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
            event: domEvent
        };
    };
    RowComp.prototype.createRowEventWithSource = function (type, domEvent) {
        var event = this.createRowEvent(type, domEvent);
        // when first developing this, we included the rowComp in the event.
        // this seems very weird. so when introducing the event types, i left the 'source'
        // out of the type, and just include the source in the two places where this event
        // was fired (rowClicked and rowDoubleClicked). it doesn't make sense for any
        // users to be using this, as the rowComp isn't an object we expose, so would be
        // very surprising if a user was using it.
        event.source = this;
        return event;
    };
    RowComp.prototype.onRowDblClick = function (mouseEvent) {
        var agEvent = this.createRowEventWithSource(events_1.Events.EVENT_ROW_DOUBLE_CLICKED, mouseEvent);
        this.beans.eventService.dispatchEvent(agEvent);
    };
    RowComp.prototype.onRowClick = function (mouseEvent) {
        var agEvent = this.createRowEventWithSource(events_1.Events.EVENT_ROW_CLICKED, mouseEvent);
        this.beans.eventService.dispatchEvent(agEvent);
        // ctrlKey for windows, metaKey for Apple
        var multiSelectKeyPressed = mouseEvent.ctrlKey || mouseEvent.metaKey;
        var shiftKeyPressed = mouseEvent.shiftKey;
        // we do not allow selecting groups by clicking (as the click here expands the group)
        // so return if it's a group row
        if (this.rowNode.group) {
            return;
        }
        // we also don't allow selection of pinned rows
        if (this.rowNode.rowPinned) {
            return;
        }
        // if no selection method enabled, do nothing
        if (!this.beans.gridOptionsWrapper.isRowSelection()) {
            return;
        }
        // if click selection suppressed, do nothing
        if (this.beans.gridOptionsWrapper.isSuppressRowClickSelection()) {
            return;
        }
        if (this.rowNode.isSelected()) {
            if (multiSelectKeyPressed) {
                if (this.beans.gridOptionsWrapper.isRowDeselection()) {
                    this.rowNode.setSelectedParams({ newValue: false });
                }
            }
            else {
                // selected with no multi key, must make sure anything else is unselected
                this.rowNode.setSelectedParams({ newValue: true, clearSelection: true });
            }
        }
        else {
            this.rowNode.setSelectedParams({ newValue: true, clearSelection: !multiSelectKeyPressed, rangeSelect: shiftKeyPressed });
        }
    };
    RowComp.prototype.createFullWidthRowContainer = function (rowContainerComp, pinned, extraCssClass, cellRendererType, eRowCallback, cellRendererCallback) {
        var _this = this;
        var rowTemplate = this.createTemplate('', extraCssClass);
        rowContainerComp.appendRowTemplate(rowTemplate, function () {
            var eRow = rowContainerComp.getRowElement(_this.getCompId());
            var params = _this.createFullWidthParams(eRow, pinned);
            var callback = function (cellRenderer) {
                if (_this.isAlive()) {
                    var gui = cellRenderer.getGui();
                    eRow.appendChild(gui);
                    cellRendererCallback(cellRenderer);
                }
                else {
                    if (cellRenderer.destroy) {
                        cellRenderer.destroy();
                    }
                }
            };
            _this.beans.componentResolver.createAgGridComponent(null, params, cellRendererType).then(callback);
            _this.afterRowAttached(rowContainerComp, eRow);
            eRowCallback(eRow);
            _this.angular1Compile(eRow);
        });
    };
    RowComp.prototype.angular1Compile = function (element) {
        if (this.scope) {
            this.beans.$compile(element)(this.scope);
        }
    };
    RowComp.prototype.createFullWidthParams = function (eRow, pinned) {
        var params = {
            fullWidth: true,
            data: this.rowNode.data,
            node: this.rowNode,
            value: this.rowNode.key,
            $scope: this.scope,
            rowIndex: this.rowNode.rowIndex,
            api: this.beans.gridOptionsWrapper.getApi(),
            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
            context: this.beans.gridOptionsWrapper.getContext(),
            // these need to be taken out, as part of 'afterAttached' now
            eGridCell: eRow,
            eParentOfValue: eRow,
            pinned: pinned,
            addRenderedRowListener: this.addEventListener.bind(this)
        };
        return params;
    };
    RowComp.prototype.getInitialRowClasses = function (extraCssClass) {
        var classes = [];
        if (utils_1._.exists(extraCssClass)) {
            classes.push(extraCssClass);
        }
        classes.push('ag-row');
        classes.push(this.rowFocused ? 'ag-row-focus' : 'ag-row-no-focus');
        if (this.fadeRowIn) {
            classes.push('ag-opacity-zero');
        }
        if (this.rowIsEven) {
            classes.push('ag-row-even');
        }
        else {
            classes.push('ag-row-odd');
        }
        if (this.beans.gridOptionsWrapper.isAnimateRows()) {
            classes.push('ag-row-animation');
        }
        else {
            classes.push('ag-row-no-animation');
        }
        if (this.rowNode.isSelected()) {
            classes.push('ag-row-selected');
        }
        if (this.rowNode.group) {
            classes.push('ag-row-group');
            // if a group, put the level of the group in
            classes.push('ag-row-level-' + this.rowNode.level);
            if (this.rowNode.footer) {
                classes.push('ag-row-footer');
            }
        }
        else {
            // if a leaf, and a parent exists, put a level of the parent, else put level of 0 for top level item
            if (this.rowNode.parent) {
                classes.push('ag-row-level-' + (this.rowNode.parent.level + 1));
            }
            else {
                classes.push('ag-row-level-0');
            }
        }
        if (this.rowNode.stub) {
            classes.push('ag-row-stub');
        }
        if (this.fullWidthRow) {
            classes.push('ag-full-width-row');
        }
        if (this.rowNode.group && !this.rowNode.footer) {
            classes.push(this.rowNode.expanded ? 'ag-row-group-expanded' : 'ag-row-group-contracted');
        }
        utils_1._.pushAll(classes, this.processClassesFromGridOptions());
        utils_1._.pushAll(classes, this.preProcessRowClassRules());
        return classes;
    };
    RowComp.prototype.preProcessRowClassRules = function () {
        var res = [];
        this.processRowClassRules(function (className) {
            res.push(className);
        }, function (className) {
            // not catered for, if creating, no need
            // to remove class as it was never there
        });
        return res;
    };
    RowComp.prototype.processRowClassRules = function (onApplicableClass, onNotApplicableClass) {
        this.beans.stylingService.processClassRules(this.beans.gridOptionsWrapper.rowClassRules(), {
            data: this.rowNode.data,
            node: this.rowNode,
            rowIndex: this.rowNode.rowIndex,
            api: this.beans.gridOptionsWrapper.getApi(),
            context: this.beans.gridOptionsWrapper.getContext()
        }, onApplicableClass, onNotApplicableClass);
    };
    RowComp.prototype.stopEditing = function (cancel) {
        if (cancel === void 0) { cancel = false; }
        this.forEachCellComp(function (renderedCell) {
            renderedCell.stopEditing(cancel);
        });
        if (this.editingRow) {
            if (!cancel) {
                var event_1 = this.createRowEvent(events_1.Events.EVENT_ROW_VALUE_CHANGED);
                this.beans.eventService.dispatchEvent(event_1);
            }
            this.setEditingRow(false);
        }
    };
    RowComp.prototype.setEditingRow = function (value) {
        this.editingRow = value;
        this.eAllRowContainers.forEach(function (row) { return utils_1._.addOrRemoveCssClass(row, 'ag-row-editing', value); });
        var event = value ?
            this.createRowEvent(events_1.Events.EVENT_ROW_EDITING_STARTED)
            : this.createRowEvent(events_1.Events.EVENT_ROW_EDITING_STOPPED);
        this.beans.eventService.dispatchEvent(event);
    };
    RowComp.prototype.startRowEditing = function (keyPress, charPress, sourceRenderedCell) {
        if (keyPress === void 0) { keyPress = null; }
        if (charPress === void 0) { charPress = null; }
        if (sourceRenderedCell === void 0) { sourceRenderedCell = null; }
        // don't do it if already editing
        if (this.editingRow) {
            return;
        }
        this.forEachCellComp(function (renderedCell) {
            var cellStartedEdit = renderedCell === sourceRenderedCell;
            if (cellStartedEdit) {
                renderedCell.startEditingIfEnabled(keyPress, charPress, cellStartedEdit);
            }
            else {
                renderedCell.startEditingIfEnabled(null, null, cellStartedEdit);
            }
        });
        this.setEditingRow(true);
    };
    RowComp.prototype.forEachCellComp = function (callback) {
        utils_1._.iterateObject(this.cellComps, function (key, cellComp) {
            if (cellComp) {
                callback(cellComp);
            }
        });
    };
    RowComp.prototype.postProcessClassesFromGridOptions = function () {
        var _this = this;
        var cssClasses = this.processClassesFromGridOptions();
        if (cssClasses) {
            cssClasses.forEach(function (classStr) {
                _this.eAllRowContainers.forEach(function (row) { return utils_1._.addCssClass(row, classStr); });
            });
        }
    };
    RowComp.prototype.postProcessRowClassRules = function () {
        var _this = this;
        this.processRowClassRules(function (className) {
            _this.eAllRowContainers.forEach(function (row) { return utils_1._.addCssClass(row, className); });
        }, function (className) {
            _this.eAllRowContainers.forEach(function (row) { return utils_1._.removeCssClass(row, className); });
        });
    };
    RowComp.prototype.processClassesFromGridOptions = function () {
        var res = [];
        var process = function (rowClass) {
            if (typeof rowClass === 'string') {
                res.push(rowClass);
            }
            else if (Array.isArray(rowClass)) {
                rowClass.forEach(function (e) { return res.push(e); });
            }
        };
        // part 1 - rowClass
        var rowClass = this.beans.gridOptionsWrapper.getRowClass();
        if (rowClass) {
            if (typeof rowClass === 'function') {
                console.warn('ag-Grid: rowClass should not be a function, please use getRowClass instead');
                return;
            }
            process(rowClass);
        }
        // part 2 - rowClassFunc
        var rowClassFunc = this.beans.gridOptionsWrapper.getRowClassFunc();
        if (rowClassFunc) {
            var params = {
                node: this.rowNode,
                data: this.rowNode.data,
                rowIndex: this.rowNode.rowIndex,
                context: this.beans.gridOptionsWrapper.getContext(),
                api: this.beans.gridOptionsWrapper.getApi()
            };
            var rowClassFuncResult = rowClassFunc(params);
            process(rowClassFuncResult);
        }
        return res;
    };
    RowComp.prototype.preProcessStylesFromGridOptions = function () {
        var rowStyles = this.processStylesFromGridOptions();
        return utils_1._.cssStyleObjectToMarkup(rowStyles);
    };
    RowComp.prototype.postProcessStylesFromGridOptions = function () {
        var rowStyles = this.processStylesFromGridOptions();
        this.eAllRowContainers.forEach(function (row) { return utils_1._.addStylesToElement(row, rowStyles); });
    };
    RowComp.prototype.processStylesFromGridOptions = function () {
        // part 1 - rowStyle
        var rowStyle = this.beans.gridOptionsWrapper.getRowStyle();
        if (rowStyle && typeof rowStyle === 'function') {
            console.log('ag-Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead');
            return;
        }
        // part 1 - rowStyleFunc
        var rowStyleFunc = this.beans.gridOptionsWrapper.getRowStyleFunc();
        var rowStyleFuncResult;
        if (rowStyleFunc) {
            var params = {
                data: this.rowNode.data,
                node: this.rowNode,
                api: this.beans.gridOptionsWrapper.getApi(),
                context: this.beans.gridOptionsWrapper.getContext(),
                $scope: this.scope
            };
            rowStyleFuncResult = rowStyleFunc(params);
        }
        return utils_1._.assign({}, rowStyle, rowStyleFuncResult);
    };
    RowComp.prototype.createCells = function (cols) {
        var _this = this;
        var templateParts = [];
        var newCellComps = [];
        cols.forEach(function (col) {
            var newCellComp = new cellComp_1.CellComp(_this.scope, _this.beans, col, _this.rowNode, _this);
            var cellTemplate = newCellComp.getCreateTemplate();
            templateParts.push(cellTemplate);
            newCellComps.push(newCellComp);
            _this.cellComps[col.getId()] = newCellComp;
        });
        var templateAndComps = {
            template: templateParts.join(''),
            cellComps: newCellComps
        };
        return templateAndComps;
    };
    RowComp.prototype.onRowSelected = function () {
        var selected = this.rowNode.isSelected();
        this.eAllRowContainers.forEach(function (row) { return utils_1._.addOrRemoveCssClass(row, 'ag-row-selected', selected); });
    };
    // called:
    // + after row created for first time
    // + after horizontal scroll, so new cells due to column virtualisation
    RowComp.prototype.callAfterRowAttachedOnCells = function (newCellComps, eRow) {
        var _this = this;
        newCellComps.forEach(function (cellComp) {
            cellComp.setParentRow(eRow);
            cellComp.afterAttached();
            // if we are editing the row, then the cell needs to turn
            // into edit mode
            if (_this.editingRow) {
                cellComp.startEditingIfEnabled();
            }
        });
    };
    RowComp.prototype.afterRowAttached = function (rowContainerComp, eRow) {
        var _this = this;
        this.addDomData(eRow);
        this.removeSecondPassFuncs.push(function () {
            // console.log(eRow);
            rowContainerComp.removeRowElement(eRow);
        });
        this.removeFirstPassFuncs.push(function () {
            if (utils_1._.exists(_this.rowNode.rowTop)) {
                // the row top is updated anyway, however we set it here again
                // to something more reasonable for the animation - ie if the
                // row top is 10000px away, the row will flash out, so this
                // gives it a rounded value, so row animates out more slowly
                var rowTop = _this.roundRowTopToBounds(_this.rowNode.rowTop);
                _this.setRowTop(rowTop);
            }
            else {
                utils_1._.addCssClass(eRow, 'ag-opacity-zero');
            }
        });
        this.eAllRowContainers.push(eRow);
        // adding hover functionality adds listener to this row, so we
        // do it lazily in an animation frame
        if (this.useAnimationFrameForCreate) {
            this.beans.taskQueue.addP1Task(this.addHoverFunctionality.bind(this, eRow));
        }
        else {
            this.addHoverFunctionality(eRow);
        }
    };
    RowComp.prototype.addHoverFunctionality = function (eRow) {
        var _this = this;
        // because we use animation frames to do this, it's possible the row no longer exists
        // by the time we get to add it
        if (!this.active) {
            return;
        }
        // because mouseenter and mouseleave do not propagate, we cannot listen on the gridPanel
        // like we do for all the other mouse events.
        // because of the pinning, we cannot simply add / remove the class based on the eRow. we
        // have to check all eRow's (body & pinned). so the trick is if any of the rows gets a
        // mouse hover, it sets such in the rowNode, and then all three reflect the change as
        // all are listening for event on the row node.
        // step 1 - add listener, to set flag on row node
        this.addDestroyableEventListener(eRow, 'mouseenter', function () { return _this.rowNode.onMouseEnter(); });
        this.addDestroyableEventListener(eRow, 'mouseleave', function () { return _this.rowNode.onMouseLeave(); });
        // step 2 - listen for changes on row node (which any eRow can trigger)
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_MOUSE_ENTER, function () {
            utils_1._.addCssClass(eRow, 'ag-row-hover');
        });
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_MOUSE_LEAVE, function () {
            utils_1._.removeCssClass(eRow, 'ag-row-hover');
        });
    };
    // for animation, we don't want to animate entry or exit to a very far away pixel,
    // otherwise the row would move so fast, it would appear to disappear. so this method
    // moves the row closer to the viewport if it is far away, so the row slide in / out
    // at a speed the user can see.
    RowComp.prototype.roundRowTopToBounds = function (rowTop) {
        var range = this.beans.gridPanel.getVerticalPixelRange();
        var minPixel = range.top - 100;
        var maxPixel = range.bottom + 100;
        if (rowTop < minPixel) {
            return minPixel;
        }
        else if (rowTop > maxPixel) {
            return maxPixel;
        }
        else {
            return rowTop;
        }
    };
    RowComp.prototype.onRowHeightChanged = function () {
        // check for exists first - if the user is resetting the row height, then
        // it will be null (or undefined) momentarily until the next time the flatten
        // stage is called where the row will then update again with a new height
        if (utils_1._.exists(this.rowNode.rowHeight)) {
            var heightPx_1 = this.rowNode.rowHeight + 'px';
            this.eAllRowContainers.forEach(function (row) { return row.style.height = heightPx_1; });
        }
    };
    RowComp.prototype.addEventListener = function (eventType, listener) {
        if (eventType === 'renderedRowRemoved' || eventType === 'rowRemoved') {
            eventType = events_1.Events.EVENT_VIRTUAL_ROW_REMOVED;
            console.warn('ag-Grid: Since version 11, event renderedRowRemoved is now called ' + events_1.Events.EVENT_VIRTUAL_ROW_REMOVED);
        }
        _super.prototype.addEventListener.call(this, eventType, listener);
    };
    RowComp.prototype.removeEventListener = function (eventType, listener) {
        if (eventType === 'renderedRowRemoved' || eventType === 'rowRemoved') {
            eventType = events_1.Events.EVENT_VIRTUAL_ROW_REMOVED;
            console.warn('ag-Grid: Since version 11, event renderedRowRemoved and rowRemoved is now called ' + events_1.Events.EVENT_VIRTUAL_ROW_REMOVED);
        }
        _super.prototype.removeEventListener.call(this, eventType, listener);
    };
    RowComp.prototype.destroyScope = function () {
        if (this.scope) {
            this.scope.$destroy();
            this.scope = null;
        }
    };
    RowComp.prototype.destroy = function (animate) {
        if (animate === void 0) { animate = false; }
        _super.prototype.destroy.call(this);
        this.destroyScope();
        this.active = false;
        // why do we have this method? shouldn't everything below be added as a destroy func beside
        // the corresponding create logic?
        this.destroyFullWidthComponents();
        if (animate) {
            this.removeFirstPassFuncs.forEach(function (func) { return func(); });
            this.removeSecondPassFuncs.push(this.destroyContainingCells.bind(this));
        }
        else {
            this.destroyContainingCells();
            // we are not animating, so execute the second stage of removal now.
            // we call getAndClear, so that they are only called once
            var delayedDestroyFunctions = this.getAndClearDelayedDestroyFunctions();
            delayedDestroyFunctions.forEach(function (func) { return func(); });
        }
        var event = this.createRowEvent(events_1.Events.EVENT_VIRTUAL_ROW_REMOVED);
        this.dispatchEvent(event);
        this.beans.eventService.dispatchEvent(event);
    };
    RowComp.prototype.destroyContainingCells = function () {
        this.forEachCellComp(function (renderedCell) { return renderedCell.destroy(); });
        this.destroyFullWidthComponents();
    };
    // we clear so that the functions are never executed twice
    RowComp.prototype.getAndClearDelayedDestroyFunctions = function () {
        var result = this.removeSecondPassFuncs;
        this.removeSecondPassFuncs = [];
        return result;
    };
    RowComp.prototype.onCellFocusChanged = function () {
        var rowFocused = this.beans.focusedCellController.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
        if (rowFocused !== this.rowFocused) {
            this.eAllRowContainers.forEach(function (row) { return utils_1._.addOrRemoveCssClass(row, 'ag-row-focus', rowFocused); });
            this.eAllRowContainers.forEach(function (row) { return utils_1._.addOrRemoveCssClass(row, 'ag-row-no-focus', !rowFocused); });
            this.rowFocused = rowFocused;
        }
        // if we are editing, then moving the focus out of a row will stop editing
        if (!rowFocused && this.editingRow) {
            this.stopEditing(false);
        }
    };
    RowComp.prototype.onPaginationChanged = function () {
        var currentPage = this.beans.paginationProxy.getCurrentPage();
        // it is possible this row is in the new page, but the page number has changed, which means
        // it needs to reposition itself relative to the new page
        if (this.paginationPage !== currentPage) {
            this.paginationPage = currentPage;
            this.onTopChanged();
        }
    };
    RowComp.prototype.onTopChanged = function () {
        // top is not used in forPrint, as the rows are just laid out naturally
        var doNotSetRowTop = this.beans.forPrint || this.beans.gridOptionsWrapper.isAutoHeight();
        if (doNotSetRowTop) {
            return;
        }
        this.setRowTop(this.rowNode.rowTop);
    };
    RowComp.prototype.applyPixelOffset = function (pixels) {
        if (this.rowNode.isRowPinned()) {
            return pixels;
        }
        else {
            return pixels - this.beans.paginationProxy.getPixelOffset();
        }
    };
    RowComp.prototype.setRowTop = function (pixels) {
        // need to make sure rowTop is not null, as this can happen if the node was once
        // visible (ie parent group was expanded) but is now not visible
        if (utils_1._.exists(pixels)) {
            var pixelsWithOffset = this.applyPixelOffset(pixels);
            var topPx_1 = pixelsWithOffset + "px";
            this.eAllRowContainers.forEach(function (row) { return row.style.top = topPx_1; });
        }
    };
    // we clear so that the functions are never executed twice
    RowComp.prototype.getAndClearNextVMTurnFunctions = function () {
        var result = this.createSecondPassFuncs;
        this.createSecondPassFuncs = [];
        return result;
    };
    RowComp.prototype.getRowNode = function () {
        return this.rowNode;
    };
    RowComp.prototype.getRenderedCellForColumn = function (column) {
        return this.cellComps[column.getColId()];
    };
    RowComp.prototype.onRowIndexChanged = function () {
        this.onCellFocusChanged();
        this.updateRowIndexes();
    };
    RowComp.prototype.updateRowIndexes = function () {
        var rowIndexStr = this.rowNode.getRowIndexString();
        var rowIsEven = this.rowNode.rowIndex % 2 === 0;
        var rowIsEvenChanged = this.rowIsEven !== rowIsEven;
        if (rowIsEvenChanged) {
            this.rowIsEven = rowIsEven;
        }
        this.eAllRowContainers.forEach(function (eRow) {
            eRow.setAttribute('index', rowIndexStr);
            if (rowIsEvenChanged) {
                utils_1._.addOrRemoveCssClass(eRow, 'ag-row-even', rowIsEven);
                utils_1._.addOrRemoveCssClass(eRow, 'ag-row-odd', !rowIsEven);
            }
        });
    };
    RowComp.prototype.ensureDomOrder = function () {
        var body = this.getBodyRowElement();
        if (body) {
            this.bodyContainerComp.ensureDomOrder(body);
        }
        var left = this.getPinnedLeftRowElement();
        if (left) {
            this.pinnedLeftContainerComp.ensureDomOrder(left);
        }
        var right = this.getPinnedRightRowElement();
        if (right) {
            this.pinnedRightContainerComp.ensureDomOrder(right);
        }
        var fullWidth = this.getFullWidthRowElement();
        if (fullWidth) {
            this.fullWidthContainerComp.ensureDomOrder(fullWidth);
        }
    };
    // returns the pinned left container, either the normal one, or the embedded full with one if exists
    RowComp.prototype.getPinnedLeftRowElement = function () {
        return this.ePinnedLeftRow ? this.ePinnedLeftRow : this.eFullWidthRowLeft;
    };
    // returns the pinned right container, either the normal one, or the embedded full with one if exists
    RowComp.prototype.getPinnedRightRowElement = function () {
        return this.ePinnedRightRow ? this.ePinnedRightRow : this.eFullWidthRowRight;
    };
    // returns the body container, either the normal one, or the embedded full with one if exists
    RowComp.prototype.getBodyRowElement = function () {
        return this.eBodyRow ? this.eBodyRow : this.eFullWidthRowBody;
    };
    // returns the full width container
    RowComp.prototype.getFullWidthRowElement = function () {
        return this.eFullWidthRow;
    };
    RowComp.DOM_DATA_KEY_RENDERED_ROW = 'renderedRow';
    RowComp.FULL_WIDTH_CELL_RENDERER = 'fullWidthCellRenderer';
    RowComp.GROUP_ROW_RENDERER = 'groupRowRenderer';
    RowComp.LOADING_CELL_RENDERER = 'loadingCellRenderer';
    return RowComp;
}(component_1.Component));
exports.RowComp = RowComp;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var rowNode_1 = __webpack_require__(15);
var beanStub_1 = __webpack_require__(13);
var RowNodeBlock = (function (_super) {
    __extends(RowNodeBlock, _super);
    function RowNodeBlock(blockNumber, rowNodeCacheParams) {
        var _this = _super.call(this) || this;
        _this.version = 0;
        _this.state = RowNodeBlock.STATE_DIRTY;
        _this.rowNodeCacheParams = rowNodeCacheParams;
        _this.blockNumber = blockNumber;
        // we don't need to calculate these now, as the inputs don't change,
        // however it makes the code easier to read if we work them out up front
        _this.startRow = blockNumber * rowNodeCacheParams.blockSize;
        _this.endRow = _this.startRow + rowNodeCacheParams.blockSize;
        return _this;
    }
    RowNodeBlock.prototype.isAnyNodeOpen = function (rowCount) {
        var result = false;
        this.forEachNodeCallback(function (rowNode) {
            if (rowNode.expanded) {
                result = true;
            }
        }, rowCount);
        return result;
    };
    RowNodeBlock.prototype.forEachNodeCallback = function (callback, rowCount) {
        for (var rowIndex = this.startRow; rowIndex < this.endRow; rowIndex++) {
            // we check against rowCount as this page may be the last one, and if it is, then
            // the last rows are not part of the set
            if (rowIndex < rowCount) {
                var rowNode = this.getRowUsingLocalIndex(rowIndex);
                callback(rowNode, rowIndex);
            }
        }
    };
    RowNodeBlock.prototype.forEachNode = function (callback, sequence, rowCount, deep) {
        this.forEachNodeCallback(function (rowNode) {
            callback(rowNode, sequence.next());
            // this will only every happen for enterprise row model, as infinite
            // row model doesn't have groups
            if (deep && rowNode.childrenCache) {
                rowNode.childrenCache.forEachNodeDeep(callback, sequence);
            }
        }, rowCount);
    };
    RowNodeBlock.prototype.forEachNodeDeep = function (callback, sequence, rowCount) {
        this.forEachNode(callback, sequence, rowCount, true);
    };
    RowNodeBlock.prototype.forEachNodeShallow = function (callback, sequence, rowCount) {
        this.forEachNode(callback, sequence, rowCount, false);
    };
    RowNodeBlock.prototype.getVersion = function () {
        return this.version;
    };
    RowNodeBlock.prototype.getLastAccessed = function () {
        return this.lastAccessed;
    };
    RowNodeBlock.prototype.getRowUsingLocalIndex = function (rowIndex) {
        this.lastAccessed = this.rowNodeCacheParams.lastAccessedSequence.next();
        var localIndex = rowIndex - this.startRow;
        return this.rowNodes[localIndex];
    };
    RowNodeBlock.prototype.init = function (beans) {
        this.beans = beans;
        this.createRowNodes();
    };
    RowNodeBlock.prototype.getStartRow = function () {
        return this.startRow;
    };
    RowNodeBlock.prototype.getEndRow = function () {
        return this.endRow;
    };
    RowNodeBlock.prototype.getBlockNumber = function () {
        return this.blockNumber;
    };
    RowNodeBlock.prototype.setDirty = function () {
        // in case any current loads in progress, this will have their results ignored
        this.version++;
        this.state = RowNodeBlock.STATE_DIRTY;
    };
    RowNodeBlock.prototype.setDirtyAndPurge = function () {
        this.setDirty();
        this.rowNodes.forEach(function (rowNode) {
            rowNode.setData(null);
        });
    };
    RowNodeBlock.prototype.getState = function () {
        return this.state;
    };
    RowNodeBlock.prototype.setRowNode = function (rowIndex, rowNode) {
        var localIndex = rowIndex - this.startRow;
        this.rowNodes[localIndex] = rowNode;
    };
    RowNodeBlock.prototype.setBlankRowNode = function (rowIndex) {
        var localIndex = rowIndex - this.startRow;
        var newRowNode = this.createBlankRowNode(rowIndex);
        this.rowNodes[localIndex] = newRowNode;
        return newRowNode;
    };
    RowNodeBlock.prototype.setNewData = function (rowIndex, dataItem) {
        var newRowNode = this.setBlankRowNode(rowIndex);
        this.setDataAndId(newRowNode, dataItem, this.startRow + rowIndex);
        return newRowNode;
    };
    RowNodeBlock.prototype.createBlankRowNode = function (rowIndex) {
        var rowNode = new rowNode_1.RowNode();
        this.beans.context.wireBean(rowNode);
        rowNode.setRowHeight(this.rowNodeCacheParams.rowHeight);
        return rowNode;
    };
    // creates empty row nodes, data is missing as not loaded yet
    RowNodeBlock.prototype.createRowNodes = function () {
        this.rowNodes = [];
        for (var i = 0; i < this.rowNodeCacheParams.blockSize; i++) {
            var rowIndex = this.startRow + i;
            var rowNode = this.createBlankRowNode(rowIndex);
            this.rowNodes.push(rowNode);
        }
    };
    RowNodeBlock.prototype.load = function () {
        this.state = RowNodeBlock.STATE_LOADING;
        this.loadFromDatasource();
    };
    RowNodeBlock.prototype.pageLoadFailed = function () {
        this.state = RowNodeBlock.STATE_FAILED;
        var event = {
            type: RowNodeBlock.EVENT_LOAD_COMPLETE,
            success: false,
            page: this,
            lastRow: null
        };
        this.dispatchEvent(event);
    };
    RowNodeBlock.prototype.populateWithRowData = function (rows) {
        var _this = this;
        var rowNodesToRefresh = [];
        this.rowNodes.forEach(function (rowNode, index) {
            var data = rows[index];
            if (rowNode.stub) {
                rowNodesToRefresh.push(rowNode);
            }
            _this.setDataAndId(rowNode, data, _this.startRow + index);
        });
        if (rowNodesToRefresh.length > 0) {
            this.beans.rowRenderer.redrawRows(rowNodesToRefresh);
        }
    };
    RowNodeBlock.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.rowNodes.forEach(function (rowNode) {
            if (rowNode.childrenCache) {
                rowNode.childrenCache.destroy();
                rowNode.childrenCache = null;
            }
        });
    };
    RowNodeBlock.prototype.pageLoaded = function (version, rows, lastRow) {
        // we need to check the version, in case there was an old request
        // from the server that was sent before we refreshed the cache,
        // if the load was done as a result of a cache refresh
        if (version === this.version) {
            this.state = RowNodeBlock.STATE_LOADED;
            this.populateWithRowData(rows);
        }
        lastRow = utils_1.Utils.cleanNumber(lastRow);
        // check here if lastrow should be set
        var event = {
            type: RowNodeBlock.EVENT_LOAD_COMPLETE,
            success: true,
            page: this,
            lastRow: lastRow
        };
        this.dispatchEvent(event);
    };
    RowNodeBlock.EVENT_LOAD_COMPLETE = 'loadComplete';
    RowNodeBlock.STATE_DIRTY = 'dirty';
    RowNodeBlock.STATE_LOADING = 'loading';
    RowNodeBlock.STATE_LOADED = 'loaded';
    RowNodeBlock.STATE_FAILED = 'failed';
    return RowNodeBlock;
}(beanStub_1.BeanStub));
exports.RowNodeBlock = RowNodeBlock;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var context_2 = __webpack_require__(0);
var TemplateService = (function () {
    function TemplateService() {
        this.templateCache = {};
        this.waitingCallbacks = {};
    }
    // returns the template if it is loaded, or null if it is not loaded
    // but will call the callback when it is loaded
    TemplateService.prototype.getTemplate = function (url, callback) {
        var templateFromCache = this.templateCache[url];
        if (templateFromCache) {
            return templateFromCache;
        }
        var callbackList = this.waitingCallbacks[url];
        var that = this;
        if (!callbackList) {
            // first time this was called, so need a new list for callbacks
            callbackList = [];
            this.waitingCallbacks[url] = callbackList;
            // and also need to do the http request
            var client = new XMLHttpRequest();
            client.onload = function () {
                that.handleHttpResult(this, url);
            };
            client.open("GET", url);
            client.send();
        }
        // add this callback
        if (callback) {
            callbackList.push(callback);
        }
        // caller needs to wait for template to load, so return null
        return null;
    };
    TemplateService.prototype.handleHttpResult = function (httpResult, url) {
        if (httpResult.status !== 200 || httpResult.response === null) {
            console.warn('Unable to get template error ' + httpResult.status + ' - ' + url);
            return;
        }
        // response success, so process it
        // in IE9 the response is in - responseText
        this.templateCache[url] = httpResult.response || httpResult.responseText;
        // inform all listeners that this is now in the cache
        var callbacks = this.waitingCallbacks[url];
        for (var i = 0; i < callbacks.length; i++) {
            var callback = callbacks[i];
            // we could pass the callback the response, however we know the client of this code
            // is the cell renderer, and it passes the 'cellRefresh' method in as the callback
            // which doesn't take any parameters.
            callback();
        }
        if (this.$scope) {
            var that_1 = this;
            setTimeout(function () {
                that_1.$scope.$apply();
            }, 0);
        }
    };
    __decorate([
        context_2.Autowired('$scope'),
        __metadata("design:type", Object)
    ], TemplateService.prototype, "$scope", void 0);
    TemplateService = __decorate([
        context_1.Bean('templateService')
    ], TemplateService);
    return TemplateService;
}());
exports.TemplateService = TemplateService;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var componentAnnotations_1 = __webpack_require__(12);
var utils_1 = __webpack_require__(1);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var AgCheckbox = (function (_super) {
    __extends(AgCheckbox, _super);
    function AgCheckbox() {
        var _this = _super.call(this) || this;
        _this.selected = false;
        _this.readOnly = false;
        _this.passive = false;
        return _this;
    }
    AgCheckbox.prototype.postConstruct = function () {
        this.setTemplate(AgCheckbox.TEMPLATE);
        this.loadIcons();
        this.updateIcons();
    };
    AgCheckbox.prototype.attributesSet = function () {
        _super.prototype.attributesSet.call(this);
        var label = this.getAttribute('label');
        if (label) {
            this.eLabel.innerText = label;
        }
    };
    AgCheckbox.prototype.loadIcons = function () {
        utils_1.Utils.removeAllChildren(this.eChecked);
        utils_1.Utils.removeAllChildren(this.eUnchecked);
        utils_1.Utils.removeAllChildren(this.eIndeterminate);
        if (this.readOnly) {
            this.eChecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxCheckedReadOnly', this.gridOptionsWrapper, null));
            this.eUnchecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxUncheckedReadOnly', this.gridOptionsWrapper, null));
            this.eIndeterminate.appendChild(utils_1.Utils.createIconNoSpan('checkboxIndeterminateReadOnly', this.gridOptionsWrapper, null));
        }
        else {
            this.eChecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxChecked', this.gridOptionsWrapper, null));
            this.eUnchecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxUnchecked', this.gridOptionsWrapper, null));
            this.eIndeterminate.appendChild(utils_1.Utils.createIconNoSpan('checkboxIndeterminate', this.gridOptionsWrapper, null));
        }
    };
    AgCheckbox.prototype.onClick = function () {
        if (!this.readOnly) {
            this.toggle();
        }
    };
    AgCheckbox.prototype.getNextValue = function () {
        if (this.selected === undefined) {
            return true;
        }
        else {
            return !this.selected;
        }
    };
    AgCheckbox.prototype.setPassive = function (passive) {
        this.passive = passive;
    };
    AgCheckbox.prototype.setReadOnly = function (readOnly) {
        this.readOnly = readOnly;
        this.loadIcons();
    };
    AgCheckbox.prototype.isReadOnly = function () {
        return this.readOnly;
    };
    AgCheckbox.prototype.isSelected = function () {
        return this.selected;
    };
    AgCheckbox.prototype.toggle = function () {
        var nextValue = this.getNextValue();
        if (this.passive) {
            var event_1 = {
                type: AgCheckbox.EVENT_CHANGED,
                selected: nextValue
            };
            this.dispatchEvent(event_1);
        }
        else {
            this.setSelected(nextValue);
        }
    };
    AgCheckbox.prototype.setSelected = function (selected) {
        if (this.selected === selected) {
            return;
        }
        if (selected === true) {
            this.selected = true;
        }
        else if (selected === false) {
            this.selected = false;
        }
        else {
            this.selected = undefined;
        }
        this.updateIcons();
        var event = {
            type: AgCheckbox.EVENT_CHANGED,
            selected: this.selected
        };
        this.dispatchEvent(event);
    };
    AgCheckbox.prototype.updateIcons = function () {
        utils_1.Utils.setVisible(this.eChecked, this.selected === true);
        utils_1.Utils.setVisible(this.eUnchecked, this.selected === false);
        utils_1.Utils.setVisible(this.eIndeterminate, this.selected === undefined);
    };
    AgCheckbox.EVENT_CHANGED = 'change';
    AgCheckbox.TEMPLATE = '<span class="ag-checkbox" role="presentation">' +
        '  <span class="ag-checkbox-checked" role="presentation"></span>' +
        '  <span class="ag-checkbox-unchecked" role="presentation"></span>' +
        '  <span class="ag-checkbox-indeterminate" role="presentation"></span>' +
        '  <span class="ag-checkbox-label" role="presentation"></span>' +
        '</span>';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], AgCheckbox.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        componentAnnotations_1.QuerySelector('.ag-checkbox-checked'),
        __metadata("design:type", HTMLElement)
    ], AgCheckbox.prototype, "eChecked", void 0);
    __decorate([
        componentAnnotations_1.QuerySelector('.ag-checkbox-unchecked'),
        __metadata("design:type", HTMLElement)
    ], AgCheckbox.prototype, "eUnchecked", void 0);
    __decorate([
        componentAnnotations_1.QuerySelector('.ag-checkbox-indeterminate'),
        __metadata("design:type", HTMLElement)
    ], AgCheckbox.prototype, "eIndeterminate", void 0);
    __decorate([
        componentAnnotations_1.QuerySelector('.ag-checkbox-label'),
        __metadata("design:type", HTMLElement)
    ], AgCheckbox.prototype, "eLabel", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AgCheckbox.prototype, "postConstruct", null);
    __decorate([
        componentAnnotations_1.Listener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AgCheckbox.prototype, "onClick", null);
    return AgCheckbox;
}(component_1.Component));
exports.AgCheckbox = AgCheckbox;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var eventService_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(1);
var TouchListener = (function () {
    function TouchListener(eElement) {
        var _this = this;
        this.destroyFuncs = [];
        this.touching = false;
        this.eventService = new eventService_1.EventService();
        this.eElement = eElement;
        var startListener = this.onTouchStart.bind(this);
        var moveListener = this.onTouchMove.bind(this);
        var endListener = this.onTouchEnd.bind(this);
        this.eElement.addEventListener('touchstart', startListener, { passive: true });
        this.eElement.addEventListener('touchmove', moveListener, { passive: true });
        this.eElement.addEventListener('touchend', endListener, { passive: true });
        this.destroyFuncs.push(function () {
            _this.eElement.addEventListener('touchstart', startListener, { passive: true });
            _this.eElement.addEventListener('touchmove', moveListener, { passive: true });
            _this.eElement.addEventListener('touchend', endListener, { passive: true });
        });
    }
    TouchListener.prototype.getActiveTouch = function (touchList) {
        for (var i = 0; i < touchList.length; i++) {
            var matches = touchList[i].identifier === this.touchStart.identifier;
            if (matches) {
                return touchList[i];
            }
        }
        return null;
    };
    TouchListener.prototype.addEventListener = function (eventType, listener) {
        this.eventService.addEventListener(eventType, listener);
    };
    TouchListener.prototype.removeEventListener = function (eventType, listener) {
        this.eventService.removeEventListener(eventType, listener);
    };
    TouchListener.prototype.onTouchStart = function (touchEvent) {
        var _this = this;
        // only looking at one touch point at any time
        if (this.touching) {
            return;
        }
        this.touchStart = touchEvent.touches[0];
        this.touching = true;
        this.moved = false;
        var touchStartCopy = this.touchStart;
        setTimeout(function () {
            var touchesMatch = _this.touchStart === touchStartCopy;
            if (_this.touching && touchesMatch && !_this.moved) {
                _this.moved = true;
                var event_1 = {
                    type: TouchListener.EVENT_LONG_TAP,
                    touchStart: _this.touchStart
                };
                _this.eventService.dispatchEvent(event_1);
            }
        }, 500);
    };
    TouchListener.prototype.onTouchMove = function (touchEvent) {
        if (!this.touching) {
            return;
        }
        var touch = this.getActiveTouch(touchEvent.touches);
        if (!touch) {
            return;
        }
        var eventIsFarAway = !utils_1.Utils.areEventsNear(touch, this.touchStart, 4);
        if (eventIsFarAway) {
            this.moved = true;
        }
    };
    TouchListener.prototype.onTouchEnd = function (touchEvent) {
        if (!this.touching) {
            return;
        }
        if (!this.moved) {
            var event_2 = {
                type: TouchListener.EVENT_TAP,
                touchStart: this.touchStart
            };
            this.eventService.dispatchEvent(event_2);
        }
        this.touching = false;
    };
    TouchListener.prototype.destroy = function () {
        this.destroyFuncs.forEach(function (func) { return func(); });
    };
    // private mostRecentTouch: Touch;
    TouchListener.EVENT_TAP = 'tap';
    TouchListener.EVENT_LONG_TAP = 'longTap';
    return TouchListener;
}());
exports.TouchListener = TouchListener;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var globalObj = typeof global === 'undefined' ? {} : global;
globalObj.HTMLElement = typeof HTMLElement === 'undefined' ? {} : HTMLElement;
globalObj.HTMLButtonElement = typeof HTMLButtonElement === 'undefined' ? {} : HTMLButtonElement;
globalObj.HTMLSelectElement = typeof HTMLSelectElement === 'undefined' ? {} : HTMLSelectElement;
globalObj.HTMLInputElement = typeof HTMLInputElement === 'undefined' ? {} : HTMLInputElement;
globalObj.Node = typeof Node === 'undefined' ? {} : Node;
// columnController
var balancedColumnTreeBuilder_1 = __webpack_require__(46);
exports.BalancedColumnTreeBuilder = balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder;
var columnController_1 = __webpack_require__(3);
exports.ColumnController = columnController_1.ColumnController;
var columnKeyCreator_1 = __webpack_require__(95);
exports.ColumnKeyCreator = columnKeyCreator_1.ColumnKeyCreator;
var columnUtils_1 = __webpack_require__(31);
exports.ColumnUtils = columnUtils_1.ColumnUtils;
var displayedGroupCreator_1 = __webpack_require__(47);
exports.DisplayedGroupCreator = displayedGroupCreator_1.DisplayedGroupCreator;
var groupInstanceIdCreator_1 = __webpack_require__(65);
exports.GroupInstanceIdCreator = groupInstanceIdCreator_1.GroupInstanceIdCreator;
// components
var componentUtil_1 = __webpack_require__(66);
exports.ComponentUtil = componentUtil_1.ComponentUtil;
var colDefUtil_1 = __webpack_require__(132);
exports.ColDefUtil = colDefUtil_1.ColDefUtil;
var componentProvider_1 = __webpack_require__(68);
exports.ComponentProvider = componentProvider_1.ComponentProvider;
var agGridNg1_1 = __webpack_require__(130);
exports.initialiseAgGridWithAngular1 = agGridNg1_1.initialiseAgGridWithAngular1;
var agGridWebComponent_1 = __webpack_require__(131);
exports.initialiseAgGridWithWebComponents = agGridWebComponent_1.initialiseAgGridWithWebComponents;
// context
var beanStub_1 = __webpack_require__(13);
exports.BeanStub = beanStub_1.BeanStub;
var context_1 = __webpack_require__(0);
exports.Context = context_1.Context;
exports.Autowired = context_1.Autowired;
exports.PostConstruct = context_1.PostConstruct;
exports.PreConstruct = context_1.PreConstruct;
exports.Optional = context_1.Optional;
exports.Bean = context_1.Bean;
exports.Qualifier = context_1.Qualifier;
exports.PreDestroy = context_1.PreDestroy;
var componentAnnotations_1 = __webpack_require__(12);
exports.QuerySelector = componentAnnotations_1.QuerySelector;
exports.Listener = componentAnnotations_1.Listener;
exports.RefSelector = componentAnnotations_1.RefSelector;
// dragAndDrop
var dragAndDropService_1 = __webpack_require__(21);
exports.DragAndDropService = dragAndDropService_1.DragAndDropService;
exports.DragSourceType = dragAndDropService_1.DragSourceType;
exports.HDirection = dragAndDropService_1.HDirection;
exports.VDirection = dragAndDropService_1.VDirection;
var dragService_1 = __webpack_require__(50);
exports.DragService = dragService_1.DragService;
// entities
var column_1 = __webpack_require__(9);
exports.Column = column_1.Column;
var columnGroup_1 = __webpack_require__(28);
exports.ColumnGroup = columnGroup_1.ColumnGroup;
var gridCell_1 = __webpack_require__(23);
exports.GridCell = gridCell_1.GridCell;
var gridRow_1 = __webpack_require__(70);
exports.GridRow = gridRow_1.GridRow;
var originalColumnGroup_1 = __webpack_require__(32);
exports.OriginalColumnGroup = originalColumnGroup_1.OriginalColumnGroup;
var rowNode_1 = __webpack_require__(15);
exports.RowNode = rowNode_1.RowNode;
// filter
var baseFilter_1 = __webpack_require__(52);
exports.BaseFilter = baseFilter_1.BaseFilter;
var dateFilter_1 = __webpack_require__(71);
exports.DateFilter = dateFilter_1.DateFilter;
var filterManager_1 = __webpack_require__(16);
exports.FilterManager = filterManager_1.FilterManager;
var numberFilter_1 = __webpack_require__(97);
exports.NumberFilter = numberFilter_1.NumberFilter;
var textFilter_1 = __webpack_require__(98);
exports.TextFilter = textFilter_1.TextFilter;
// gridPanel
var gridPanel_1 = __webpack_require__(10);
exports.GridPanel = gridPanel_1.GridPanel;
var scrollVisibleService_1 = __webpack_require__(34);
exports.ScrollVisibleService = scrollVisibleService_1.ScrollVisibleService;
var mouseEventService_1 = __webpack_require__(38);
exports.MouseEventService = mouseEventService_1.MouseEventService;
// headerRendering
var bodyDropPivotTarget_1 = __webpack_require__(100);
exports.BodyDropPivotTarget = bodyDropPivotTarget_1.BodyDropPivotTarget;
var bodyDropTarget_1 = __webpack_require__(101);
exports.BodyDropTarget = bodyDropTarget_1.BodyDropTarget;
var cssClassApplier_1 = __webpack_require__(53);
exports.CssClassApplier = cssClassApplier_1.CssClassApplier;
var headerContainer_1 = __webpack_require__(102);
exports.HeaderContainer = headerContainer_1.HeaderContainer;
var headerRenderer_1 = __webpack_require__(54);
exports.HeaderRenderer = headerRenderer_1.HeaderRenderer;
var headerRowComp_1 = __webpack_require__(103);
exports.HeaderRowComp = headerRowComp_1.HeaderRowComp;
var headerTemplateLoader_1 = __webpack_require__(74);
exports.HeaderTemplateLoader = headerTemplateLoader_1.HeaderTemplateLoader;
var horizontalDragService_1 = __webpack_require__(39);
exports.HorizontalDragService = horizontalDragService_1.HorizontalDragService;
var moveColumnController_1 = __webpack_require__(105);
exports.MoveColumnController = moveColumnController_1.MoveColumnController;
var renderedHeaderCell_1 = __webpack_require__(75);
exports.RenderedHeaderCell = renderedHeaderCell_1.RenderedHeaderCell;
var standardMenu_1 = __webpack_require__(106);
exports.StandardMenuFactory = standardMenu_1.StandardMenuFactory;
// layout
var borderLayout_1 = __webpack_require__(76);
exports.BorderLayout = borderLayout_1.BorderLayout;
var tabbedLayout_1 = __webpack_require__(143);
exports.TabbedLayout = tabbedLayout_1.TabbedLayout;
var verticalStack_1 = __webpack_require__(144);
exports.VerticalStack = verticalStack_1.VerticalStack;
// misc
var simpleHttpRequest_1 = __webpack_require__(146);
exports.simpleHttpRequest = simpleHttpRequest_1.simpleHttpRequest;
var largeTextCellEditor_1 = __webpack_require__(107);
exports.LargeTextCellEditor = largeTextCellEditor_1.LargeTextCellEditor;
var popupEditorWrapper_1 = __webpack_require__(78);
exports.PopupEditorWrapper = popupEditorWrapper_1.PopupEditorWrapper;
var popupSelectCellEditor_1 = __webpack_require__(108);
exports.PopupSelectCellEditor = popupSelectCellEditor_1.PopupSelectCellEditor;
var popupTextCellEditor_1 = __webpack_require__(109);
exports.PopupTextCellEditor = popupTextCellEditor_1.PopupTextCellEditor;
var selectCellEditor_1 = __webpack_require__(79);
exports.SelectCellEditor = selectCellEditor_1.SelectCellEditor;
var textCellEditor_1 = __webpack_require__(80);
exports.TextCellEditor = textCellEditor_1.TextCellEditor;
var animateShowChangeCellRenderer_1 = __webpack_require__(81);
exports.AnimateShowChangeCellRenderer = animateShowChangeCellRenderer_1.AnimateShowChangeCellRenderer;
var animateSlideCellRenderer_1 = __webpack_require__(82);
exports.AnimateSlideCellRenderer = animateSlideCellRenderer_1.AnimateSlideCellRenderer;
var groupCellRenderer_1 = __webpack_require__(83);
exports.GroupCellRenderer = groupCellRenderer_1.GroupCellRenderer;
// features
var setLeftFeature_1 = __webpack_require__(42);
exports.SetLeftFeature = setLeftFeature_1.SetLeftFeature;
// rendering
var autoWidthCalculator_1 = __webpack_require__(77);
exports.AutoWidthCalculator = autoWidthCalculator_1.AutoWidthCalculator;
var cellEditorFactory_1 = __webpack_require__(55);
exports.CellEditorFactory = cellEditorFactory_1.CellEditorFactory;
var cellRendererFactory_1 = __webpack_require__(56);
exports.CellRendererFactory = cellRendererFactory_1.CellRendererFactory;
var cellRendererService_1 = __webpack_require__(57);
exports.CellRendererService = cellRendererService_1.CellRendererService;
var checkboxSelectionComponent_1 = __webpack_require__(84);
exports.CheckboxSelectionComponent = checkboxSelectionComponent_1.CheckboxSelectionComponent;
var cellComp_1 = __webpack_require__(41);
exports.CellComp = cellComp_1.CellComp;
var rowComp_1 = __webpack_require__(58);
exports.RowComp = rowComp_1.RowComp;
var rowRenderer_1 = __webpack_require__(18);
exports.RowRenderer = rowRenderer_1.RowRenderer;
var valueFormatterService_1 = __webpack_require__(43);
exports.ValueFormatterService = valueFormatterService_1.ValueFormatterService;
// rowControllers/inMemory
var filterStage_1 = __webpack_require__(111);
exports.FilterStage = filterStage_1.FilterStage;
var flattenStage_1 = __webpack_require__(112);
exports.FlattenStage = flattenStage_1.FlattenStage;
var sortStage_1 = __webpack_require__(115);
exports.SortStage = sortStage_1.SortStage;
// row models
var pinnedRowModel_1 = __webpack_require__(30);
exports.PinnedRowModel = pinnedRowModel_1.PinnedRowModel;
var inMemoryRowModel_1 = __webpack_require__(114);
exports.InMemoryRowModel = inMemoryRowModel_1.InMemoryRowModel;
var changedPath_1 = __webpack_require__(88);
exports.ChangedPath = changedPath_1.ChangedPath;
var inMemoryNodeManager_1 = __webpack_require__(89);
exports.InMemoryNodeManager = inMemoryNodeManager_1.InMemoryNodeManager;
var infiniteRowModel_1 = __webpack_require__(116);
exports.InfiniteRowModel = infiniteRowModel_1.InfiniteRowModel;
var rowNodeBlock_1 = __webpack_require__(59);
exports.RowNodeBlock = rowNodeBlock_1.RowNodeBlock;
var rowNodeBlockLoader_1 = __webpack_require__(110);
exports.RowNodeBlockLoader = rowNodeBlockLoader_1.RowNodeBlockLoader;
var rowNodeCache_1 = __webpack_require__(87);
exports.RowNodeCache = rowNodeCache_1.RowNodeCache;
//styling
var stylingService_1 = __webpack_require__(90);
exports.StylingService = stylingService_1.StylingService;
// widgets
var agCheckbox_1 = __webpack_require__(61);
exports.AgCheckbox = agCheckbox_1.AgCheckbox;
var component_1 = __webpack_require__(8);
exports.Component = component_1.Component;
var popupService_1 = __webpack_require__(37);
exports.PopupService = popupService_1.PopupService;
var touchListener_1 = __webpack_require__(62);
exports.TouchListener = touchListener_1.TouchListener;
// root
var baseFrameworkFactory_1 = __webpack_require__(93);
exports.BaseFrameworkFactory = baseFrameworkFactory_1.BaseFrameworkFactory;
var cellNavigationService_1 = __webpack_require__(64);
exports.CellNavigationService = cellNavigationService_1.CellNavigationService;
var alignedGridsService_1 = __webpack_require__(45);
exports.AlignedGridsService = alignedGridsService_1.AlignedGridsService;
var constants_1 = __webpack_require__(7);
exports.Constants = constants_1.Constants;
var csvCreator_1 = __webpack_require__(49);
exports.CsvCreator = csvCreator_1.CsvCreator;
exports.BaseCreator = csvCreator_1.BaseCreator;
var downloader_1 = __webpack_require__(69);
exports.Downloader = downloader_1.Downloader;
var grid_1 = __webpack_require__(72);
exports.Grid = grid_1.Grid;
var gridApi_1 = __webpack_require__(6);
exports.GridApi = gridApi_1.GridApi;
var events_1 = __webpack_require__(5);
exports.Events = events_1.Events;
var focusedCellController_1 = __webpack_require__(24);
exports.FocusedCellController = focusedCellController_1.FocusedCellController;
var functions_1 = __webpack_require__(138);
exports.defaultGroupComparator = functions_1.defaultGroupComparator;
var gridOptionsWrapper_1 = __webpack_require__(2);
exports.GridOptionsWrapper = gridOptionsWrapper_1.GridOptionsWrapper;
var eventService_1 = __webpack_require__(4);
exports.EventService = eventService_1.EventService;
var gridCore_1 = __webpack_require__(33);
exports.GridCore = gridCore_1.GridCore;
var logger_1 = __webpack_require__(11);
exports.Logger = logger_1.Logger;
var selectionController_1 = __webpack_require__(17);
exports.SelectionController = selectionController_1.SelectionController;
var sortController_1 = __webpack_require__(25);
exports.SortController = sortController_1.SortController;
var templateService_1 = __webpack_require__(60);
exports.TemplateService = templateService_1.TemplateService;
var utils_1 = __webpack_require__(1);
exports.Utils = utils_1.Utils;
exports.NumberSequence = utils_1.NumberSequence;
exports._ = utils_1._;
exports.Promise = utils_1.Promise;
var valueService_1 = __webpack_require__(20);
exports.ValueService = valueService_1.ValueService;
var expressionService_1 = __webpack_require__(19);
exports.ExpressionService = expressionService_1.ExpressionService;
var xmlFactory_1 = __webpack_require__(119);
exports.XmlFactory = xmlFactory_1.XmlFactory;
var gridSerializer_1 = __webpack_require__(73);
exports.GridSerializer = gridSerializer_1.GridSerializer;
exports.BaseGridSerializingSession = gridSerializer_1.BaseGridSerializingSession;
exports.RowType = gridSerializer_1.RowType;
var logger_2 = __webpack_require__(11);
exports.LoggerFactory = logger_2.LoggerFactory;
var columnController_2 = __webpack_require__(3);
exports.ColumnApi = columnController_2.ColumnApi;
var frameworkComponentWrapper_1 = __webpack_require__(133);
exports.BaseComponentWrapper = frameworkComponentWrapper_1.BaseComponentWrapper;
var environment_1 = __webpack_require__(51);
exports.Environment = environment_1.Environment;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var constants_1 = __webpack_require__(7);
var columnController_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(1);
var gridRow_1 = __webpack_require__(70);
var gridCell_1 = __webpack_require__(23);
var gridOptionsWrapper_1 = __webpack_require__(2);
var pinnedRowModel_1 = __webpack_require__(30);
var CellNavigationService = (function () {
    function CellNavigationService() {
    }
    // returns null if no cell to focus on, ie at the end of the grid
    CellNavigationService.prototype.getNextCellToFocus = function (key, lastCellToFocus) {
        // starting with the provided cell, we keep moving until we find a cell we can
        // focus on.
        var pointer = lastCellToFocus;
        var finished = false;
        // finished will be true when either:
        // a) cell found that we can focus on
        // b) run out of cells (ie the method returns null)
        while (!finished) {
            switch (key) {
                case constants_1.Constants.KEY_UP:
                    pointer = this.getCellAbove(pointer);
                    break;
                case constants_1.Constants.KEY_DOWN:
                    pointer = this.getCellBelow(pointer);
                    break;
                case constants_1.Constants.KEY_RIGHT:
                    if (this.gridOptionsWrapper.isEnableRtl()) {
                        pointer = this.getCellToLeft(pointer);
                    }
                    else {
                        pointer = this.getCellToRight(pointer);
                    }
                    break;
                case constants_1.Constants.KEY_LEFT:
                    if (this.gridOptionsWrapper.isEnableRtl()) {
                        pointer = this.getCellToRight(pointer);
                    }
                    else {
                        pointer = this.getCellToLeft(pointer);
                    }
                    break;
                default:
                    console.log('ag-Grid: unknown key for navigation ' + key);
                    pointer = null;
                    break;
            }
            if (pointer) {
                finished = this.isCellGoodToFocusOn(pointer);
            }
            else {
                finished = true;
            }
        }
        return pointer;
    };
    CellNavigationService.prototype.isCellGoodToFocusOn = function (gridCell) {
        var column = gridCell.column;
        var rowNode;
        switch (gridCell.floating) {
            case constants_1.Constants.PINNED_TOP:
                rowNode = this.pinnedRowModel.getPinnedTopRow(gridCell.rowIndex);
                break;
            case constants_1.Constants.PINNED_BOTTOM:
                rowNode = this.pinnedRowModel.getPinnedBottomRow(gridCell.rowIndex);
                break;
            default:
                rowNode = this.rowModel.getRow(gridCell.rowIndex);
                break;
        }
        var suppressNavigable = column.isSuppressNavigable(rowNode);
        return !suppressNavigable;
    };
    CellNavigationService.prototype.getCellToLeft = function (lastCell) {
        var colToLeft = this.columnController.getDisplayedColBefore(lastCell.column);
        if (!colToLeft) {
            return null;
        }
        else {
            var gridCellDef = { rowIndex: lastCell.rowIndex, column: colToLeft, floating: lastCell.floating };
            return new gridCell_1.GridCell(gridCellDef);
        }
    };
    CellNavigationService.prototype.getCellToRight = function (lastCell) {
        var colToRight = this.columnController.getDisplayedColAfter(lastCell.column);
        // if already on right, do nothing
        if (!colToRight) {
            return null;
        }
        else {
            var gridCellDef = { rowIndex: lastCell.rowIndex, column: colToRight, floating: lastCell.floating };
            return new gridCell_1.GridCell(gridCellDef);
        }
    };
    CellNavigationService.prototype.getRowBelow = function (lastRow) {
        // if already on top row, do nothing
        if (this.isLastRowInContainer(lastRow)) {
            if (lastRow.isFloatingBottom()) {
                return null;
            }
            else if (lastRow.isNotFloating()) {
                if (this.pinnedRowModel.isRowsToRender(constants_1.Constants.PINNED_BOTTOM)) {
                    return new gridRow_1.GridRow(0, constants_1.Constants.PINNED_BOTTOM);
                }
                else {
                    return null;
                }
            }
            else {
                if (this.rowModel.isRowsToRender()) {
                    return new gridRow_1.GridRow(0, null);
                }
                else if (this.pinnedRowModel.isRowsToRender(constants_1.Constants.PINNED_BOTTOM)) {
                    return new gridRow_1.GridRow(0, constants_1.Constants.PINNED_BOTTOM);
                }
                else {
                    return null;
                }
            }
        }
        else {
            return new gridRow_1.GridRow(lastRow.rowIndex + 1, lastRow.floating);
        }
    };
    CellNavigationService.prototype.getCellBelow = function (lastCell) {
        var rowBelow = this.getRowBelow(lastCell.getGridRow());
        if (rowBelow) {
            var gridCellDef = { rowIndex: rowBelow.rowIndex, column: lastCell.column, floating: rowBelow.floating };
            return new gridCell_1.GridCell(gridCellDef);
        }
        else {
            return null;
        }
    };
    CellNavigationService.prototype.isLastRowInContainer = function (gridRow) {
        if (gridRow.isFloatingTop()) {
            var lastTopIndex = this.pinnedRowModel.getPinnedTopRowData().length - 1;
            return lastTopIndex <= gridRow.rowIndex;
        }
        else if (gridRow.isFloatingBottom()) {
            var lastBottomIndex = this.pinnedRowModel.getPinnedBottomRowData().length - 1;
            return lastBottomIndex <= gridRow.rowIndex;
        }
        else {
            var lastBodyIndex = this.rowModel.getPageLastRow();
            return lastBodyIndex <= gridRow.rowIndex;
        }
    };
    CellNavigationService.prototype.getRowAbove = function (lastRow) {
        // if already on top row, do nothing
        if (lastRow.rowIndex === 0) {
            if (lastRow.isFloatingTop()) {
                return null;
            }
            else if (lastRow.isNotFloating()) {
                if (this.pinnedRowModel.isRowsToRender(constants_1.Constants.PINNED_TOP)) {
                    return this.getLastFloatingTopRow();
                }
                else {
                    return null;
                }
            }
            else {
                // last floating bottom
                if (this.rowModel.isRowsToRender()) {
                    return this.getLastBodyCell();
                }
                else if (this.pinnedRowModel.isRowsToRender(constants_1.Constants.PINNED_TOP)) {
                    return this.getLastFloatingTopRow();
                }
                else {
                    return null;
                }
            }
        }
        else {
            return new gridRow_1.GridRow(lastRow.rowIndex - 1, lastRow.floating);
        }
    };
    CellNavigationService.prototype.getCellAbove = function (lastCell) {
        var rowAbove = this.getRowAbove(lastCell.getGridRow());
        if (rowAbove) {
            var gridCellDef = { rowIndex: rowAbove.rowIndex, column: lastCell.column, floating: rowAbove.floating };
            return new gridCell_1.GridCell(gridCellDef);
        }
        else {
            return null;
        }
    };
    CellNavigationService.prototype.getLastBodyCell = function () {
        var lastBodyRow = this.rowModel.getPageLastRow();
        return new gridRow_1.GridRow(lastBodyRow, null);
    };
    CellNavigationService.prototype.getLastFloatingTopRow = function () {
        var lastFloatingRow = this.pinnedRowModel.getPinnedTopRowData().length - 1;
        return new gridRow_1.GridRow(lastFloatingRow, constants_1.Constants.PINNED_TOP);
    };
    CellNavigationService.prototype.getNextTabbedCell = function (gridCell, backwards) {
        if (backwards) {
            return this.getNextTabbedCellBackwards(gridCell);
        }
        else {
            return this.getNextTabbedCellForwards(gridCell);
        }
    };
    CellNavigationService.prototype.getNextTabbedCellForwards = function (gridCell) {
        var displayedColumns = this.columnController.getAllDisplayedColumns();
        var newRowIndex = gridCell.rowIndex;
        var newFloating = gridCell.floating;
        // move along to the next cell
        var newColumn = this.columnController.getDisplayedColAfter(gridCell.column);
        // check if end of the row, and if so, go forward a row
        if (!newColumn) {
            newColumn = displayedColumns[0];
            var rowBelow = this.getRowBelow(gridCell.getGridRow());
            if (utils_1.Utils.missing(rowBelow)) {
                return;
            }
            newRowIndex = rowBelow.rowIndex;
            newFloating = rowBelow.floating;
        }
        var gridCellDef = { rowIndex: newRowIndex, column: newColumn, floating: newFloating };
        return new gridCell_1.GridCell(gridCellDef);
    };
    CellNavigationService.prototype.getNextTabbedCellBackwards = function (gridCell) {
        var displayedColumns = this.columnController.getAllDisplayedColumns();
        var newRowIndex = gridCell.rowIndex;
        var newFloating = gridCell.floating;
        // move along to the next cell
        var newColumn = this.columnController.getDisplayedColBefore(gridCell.column);
        // check if end of the row, and if so, go forward a row
        if (!newColumn) {
            newColumn = displayedColumns[displayedColumns.length - 1];
            var rowAbove = this.getRowAbove(gridCell.getGridRow());
            if (utils_1.Utils.missing(rowAbove)) {
                return;
            }
            newRowIndex = rowAbove.rowIndex;
            newFloating = rowAbove.floating;
        }
        var gridCellDef = { rowIndex: newRowIndex, column: newColumn, floating: newFloating };
        return new gridCell_1.GridCell(gridCellDef);
    };
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], CellNavigationService.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], CellNavigationService.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('pinnedRowModel'),
        __metadata("design:type", pinnedRowModel_1.PinnedRowModel)
    ], CellNavigationService.prototype, "pinnedRowModel", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], CellNavigationService.prototype, "gridOptionsWrapper", void 0);
    CellNavigationService = __decorate([
        context_1.Bean('cellNavigationService')
    ], CellNavigationService);
    return CellNavigationService;
}());
exports.CellNavigationService = CellNavigationService;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
// class returns unique instance id's for columns.
// eg, the following calls (in this order) will result in:
//
// getInstanceIdForKey('country') => 0
// getInstanceIdForKey('country') => 1
// getInstanceIdForKey('country') => 2
// getInstanceIdForKey('country') => 3
// getInstanceIdForKey('age') => 0
// getInstanceIdForKey('age') => 1
// getInstanceIdForKey('country') => 4
var GroupInstanceIdCreator = (function () {
    function GroupInstanceIdCreator() {
        // this map contains keys to numbers, so we remember what the last call was
        this.existingIds = {};
    }
    GroupInstanceIdCreator.prototype.getInstanceIdForKey = function (key) {
        var lastResult = this.existingIds[key];
        var result;
        if (typeof lastResult !== 'number') {
            // first time this key
            result = 0;
        }
        else {
            result = lastResult + 1;
        }
        this.existingIds[key] = result;
        return result;
    };
    return GroupInstanceIdCreator;
}());
exports.GroupInstanceIdCreator = GroupInstanceIdCreator;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(5);
var propertyKeys_1 = __webpack_require__(147);
var utils_1 = __webpack_require__(1);
var ComponentUtil = (function () {
    function ComponentUtil() {
    }
    ComponentUtil.getEventCallbacks = function () {
        if (!ComponentUtil.EVENT_CALLBACKS) {
            ComponentUtil.EVENT_CALLBACKS = [];
            ComponentUtil.EVENTS.forEach(function (eventName) {
                ComponentUtil.EVENT_CALLBACKS.push(ComponentUtil.getCallbackForEvent(eventName));
            });
        }
        return ComponentUtil.EVENT_CALLBACKS;
    };
    ComponentUtil.copyAttributesToGridOptions = function (gridOptions, component) {
        checkForDeprecated(component);
        // create empty grid options if none were passed
        if (typeof gridOptions !== 'object') {
            gridOptions = {};
        }
        // to allow array style lookup in TypeScript, take type away from 'this' and 'gridOptions'
        var pGridOptions = gridOptions;
        // add in all the simple properties
        ComponentUtil.ARRAY_PROPERTIES
            .concat(ComponentUtil.STRING_PROPERTIES)
            .concat(ComponentUtil.OBJECT_PROPERTIES)
            .concat(ComponentUtil.FUNCTION_PROPERTIES)
            .forEach(function (key) {
            if (typeof component[key] !== 'undefined') {
                pGridOptions[key] = component[key];
            }
        });
        ComponentUtil.BOOLEAN_PROPERTIES.forEach(function (key) {
            if (typeof component[key] !== 'undefined') {
                pGridOptions[key] = ComponentUtil.toBoolean(component[key]);
            }
        });
        ComponentUtil.NUMBER_PROPERTIES.forEach(function (key) {
            if (typeof component[key] !== 'undefined') {
                pGridOptions[key] = ComponentUtil.toNumber(component[key]);
            }
        });
        ComponentUtil.getEventCallbacks().forEach(function (funcName) {
            if (typeof component[funcName] !== 'undefined') {
                pGridOptions[funcName] = component[funcName];
            }
        });
        return gridOptions;
    };
    ComponentUtil.getCallbackForEvent = function (eventName) {
        if (!eventName || eventName.length < 2) {
            return eventName;
        }
        else {
            return 'on' + eventName[0].toUpperCase() + eventName.substr(1);
        }
    };
    // change this method, the caller should know if it's initialised or not, plus 'initialised'
    // is not relevant for all component types. maybe pass in the api and columnApi instead???
    ComponentUtil.processOnChange = function (changes, gridOptions, api, columnApi) {
        //if (!component._initialised || !changes) { return; }
        if (!changes) {
            return;
        }
        checkForDeprecated(changes);
        // to allow array style lookup in TypeScript, take type away from 'this' and 'gridOptions'
        var pGridOptions = gridOptions;
        // check if any change for the simple types, and if so, then just copy in the new value
        ComponentUtil.ARRAY_PROPERTIES
            .concat(ComponentUtil.OBJECT_PROPERTIES)
            .concat(ComponentUtil.STRING_PROPERTIES)
            .forEach(function (key) {
            if (changes[key]) {
                pGridOptions[key] = changes[key].currentValue;
            }
        });
        ComponentUtil.BOOLEAN_PROPERTIES.forEach(function (key) {
            if (changes[key]) {
                pGridOptions[key] = ComponentUtil.toBoolean(changes[key].currentValue);
            }
        });
        ComponentUtil.NUMBER_PROPERTIES.forEach(function (key) {
            if (changes[key]) {
                pGridOptions[key] = ComponentUtil.toNumber(changes[key].currentValue);
            }
        });
        ComponentUtil.getEventCallbacks().forEach(function (funcName) {
            if (changes[funcName]) {
                pGridOptions[funcName] = changes[funcName].currentValue;
            }
        });
        if (changes.showToolPanel) {
            api.showToolPanel(ComponentUtil.toBoolean(changes.showToolPanel.currentValue));
        }
        if (changes.quickFilterText) {
            api.setQuickFilter(changes.quickFilterText.currentValue);
        }
        if (changes.rowData) {
            api.setRowData(changes.rowData.currentValue);
        }
        if (changes.pinnedTopRowData) {
            api.setPinnedTopRowData(changes.pinnedTopRowData.currentValue);
        }
        if (changes.pinnedBottomRowData) {
            api.setPinnedBottomRowData(changes.pinnedBottomRowData.currentValue);
        }
        if (changes.columnDefs) {
            api.setColumnDefs(changes.columnDefs.currentValue);
        }
        if (changes.datasource) {
            api.setDatasource(changes.datasource.currentValue);
        }
        if (changes.headerHeight) {
            api.setHeaderHeight(ComponentUtil.toNumber(changes.headerHeight.currentValue));
        }
        if (changes.paginationPageSize) {
            api.paginationSetPageSize(ComponentUtil.toNumber(changes.paginationPageSize.currentValue));
        }
        if (changes.pivotMode) {
            columnApi.setPivotMode(ComponentUtil.toBoolean(changes.pivotMode.currentValue));
        }
        if (changes.groupRemoveSingleChildren) {
            api.setGroupRemoveSingleChildren(ComponentUtil.toBoolean(changes.groupRemoveSingleChildren.currentValue));
        }
        // copy changes into an event for dispatch
        var event = {
            type: events_1.Events.EVENT_COMPONENT_STATE_CHANGED,
            api: gridOptions.api,
            columnApi: gridOptions.columnApi
        };
        utils_1.Utils.iterateObject(changes, function (key, value) {
            event[key] = value;
        });
        api.dispatchEvent(event);
    };
    ComponentUtil.toBoolean = function (value) {
        if (typeof value === 'boolean') {
            return value;
        }
        else if (typeof value === 'string') {
            // for boolean, compare to empty String to allow attributes appearing with
            // not value to be treated as 'true'
            return value.toUpperCase() === 'TRUE' || value == '';
        }
        else {
            return false;
        }
    };
    ComponentUtil.toNumber = function (value) {
        if (typeof value === 'number') {
            return value;
        }
        else if (typeof value === 'string') {
            return Number(value);
        }
        else {
            return undefined;
        }
    };
    // all the events are populated in here AFTER this class (at the bottom of the file).
    ComponentUtil.EVENTS = [];
    ComponentUtil.STRING_PROPERTIES = propertyKeys_1.PropertyKeys.STRING_PROPERTIES;
    ComponentUtil.OBJECT_PROPERTIES = propertyKeys_1.PropertyKeys.OBJECT_PROPERTIES;
    ComponentUtil.ARRAY_PROPERTIES = propertyKeys_1.PropertyKeys.ARRAY_PROPERTIES;
    ComponentUtil.NUMBER_PROPERTIES = propertyKeys_1.PropertyKeys.NUMBER_PROPERTIES;
    ComponentUtil.BOOLEAN_PROPERTIES = propertyKeys_1.PropertyKeys.BOOLEAN_PROPERTIES;
    ComponentUtil.FUNCTION_PROPERTIES = propertyKeys_1.PropertyKeys.FUNCTION_PROPERTIES;
    ComponentUtil.ALL_PROPERTIES = propertyKeys_1.PropertyKeys.ALL_PROPERTIES;
    return ComponentUtil;
}());
exports.ComponentUtil = ComponentUtil;
utils_1.Utils.iterateObject(events_1.Events, function (key, value) {
    ComponentUtil.EVENTS.push(value);
});
function checkForDeprecated(changes) {
    if (changes.rowDeselected || changes.onRowDeselected) {
        console.warn('ag-grid: as of v3.4 rowDeselected no longer exists. Please check the docs.');
    }
}


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var agComponentUtils_1 = __webpack_require__(48);
var ComponentMetadataProvider = (function () {
    function ComponentMetadataProvider() {
    }
    ComponentMetadataProvider.prototype.postConstruct = function () {
        this.componentMetaData = {
            dateComponent: {
                mandatoryMethodList: ['getDate', 'setDate'],
                optionalMethodList: []
            },
            headerComponent: {
                mandatoryMethodList: [],
                optionalMethodList: []
            },
            headerGroupComponent: {
                mandatoryMethodList: [],
                optionalMethodList: []
            },
            floatingFilterComponent: {
                mandatoryMethodList: ['onParentModelChanged'],
                optionalMethodList: ['afterGuiAttached']
            },
            floatingFilterWrapperComponent: {
                mandatoryMethodList: [],
                optionalMethodList: []
            },
            filterComponent: {
                mandatoryMethodList: ['isFilterActive', 'doesFilterPass', 'getModel', 'setModel'],
                optionalMethodList: ['afterGuiAttached', 'onNewRowsLoaded', 'getModelAsString', 'onFloatingFilterChanged']
            },
            cellRenderer: {
                mandatoryMethodList: ['refresh'],
                optionalMethodList: ['afterGuiAttached'],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            cellEditor: {
                mandatoryMethodList: ['getValue'],
                optionalMethodList: ['isPopup', 'isCancelBeforeStart', 'isCancelAfterEnd', 'focusIn', 'focusOut', 'afterGuiAttached']
            },
            innerRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: ['afterGuiAttached'],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            fullWidthCellRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: ['afterGuiAttached'],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            pinnedRowCellRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: ['afterGuiAttached'],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            groupRowInnerRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: ['afterGuiAttached'],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            filter: {
                mandatoryMethodList: ['isFilterActive', 'doesFilterPass', 'getModel', 'setModel'],
                optionalMethodList: ['onNewRowsLoaded', 'onFloatingFilterChanged'],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            }
        };
    };
    ComponentMetadataProvider.prototype.retrieve = function (name) {
        return this.componentMetaData[name];
    };
    __decorate([
        context_1.Autowired("agComponentUtils"),
        __metadata("design:type", agComponentUtils_1.AgComponentUtils)
    ], ComponentMetadataProvider.prototype, "agComponentUtils", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ComponentMetadataProvider.prototype, "postConstruct", null);
    ComponentMetadataProvider = __decorate([
        context_1.Bean("componentMetadataProvider")
    ], ComponentMetadataProvider);
    return ComponentMetadataProvider;
}());
exports.ComponentMetadataProvider = ComponentMetadataProvider;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var textCellEditor_1 = __webpack_require__(80);
var context_1 = __webpack_require__(0);
var dateFilter_1 = __webpack_require__(71);
var headerComp_1 = __webpack_require__(141);
var headerGroupComp_1 = __webpack_require__(139);
var floatingFilter_1 = __webpack_require__(136);
var floatingFilterWrapper_1 = __webpack_require__(137);
var componentResolver_1 = __webpack_require__(22);
var groupCellRenderer_1 = __webpack_require__(83);
var animateShowChangeCellRenderer_1 = __webpack_require__(81);
var animateSlideCellRenderer_1 = __webpack_require__(82);
var rowComp_1 = __webpack_require__(58);
var selectCellEditor_1 = __webpack_require__(79);
var popupTextCellEditor_1 = __webpack_require__(109);
var popupSelectCellEditor_1 = __webpack_require__(108);
var largeTextCellEditor_1 = __webpack_require__(107);
var textFilter_1 = __webpack_require__(98);
var numberFilter_1 = __webpack_require__(97);
var RegisteredComponentSource;
(function (RegisteredComponentSource) {
    RegisteredComponentSource[RegisteredComponentSource["DEFAULT"] = 0] = "DEFAULT";
    RegisteredComponentSource[RegisteredComponentSource["REGISTERED"] = 1] = "REGISTERED";
})(RegisteredComponentSource = exports.RegisteredComponentSource || (exports.RegisteredComponentSource = {}));
var ComponentProvider = (function () {
    function ComponentProvider() {
        this.jsComponents = {};
        this.frameworkComponents = {};
    }
    ComponentProvider.prototype.postConstruct = function () {
        this.agGridDefaults = {
            //THE FOLLOWING COMPONENTS HAVE NO DEFAULTS, THEY NEED TO BE SPECIFIED AS AN SPECIFIC FLAVOUR
            //THERE ARE NO DEFAULTS THAT FIT ALL PURPOSES
            //THEY ARE ADDED HERE TO AVOID THE NOT FOUND WARNING.
            filterComponent: null,
            customFloatingFilterComponent: null,
            //date
            dateComponent: dateFilter_1.DefaultDateComponent,
            //header
            headerComponent: headerComp_1.HeaderComp,
            headerGroupComponent: headerGroupComp_1.HeaderGroupComp,
            //floating filters
            setFloatingFilterComponent: floatingFilter_1.SetFloatingFilterComp,
            textFloatingFilterComponent: floatingFilter_1.TextFloatingFilterComp,
            numberFloatingFilterComponent: floatingFilter_1.NumberFloatingFilterComp,
            dateFloatingFilterComponent: floatingFilter_1.DateFloatingFilterComp,
            readModelAsStringFloatingFilterComponent: floatingFilter_1.ReadModelAsStringFloatingFilterComp,
            floatingFilterWrapperComponent: floatingFilterWrapper_1.FloatingFilterWrapperComp,
            emptyFloatingFilterWrapperComponent: floatingFilterWrapper_1.EmptyFloatingFilterWrapperComp,
            //renderers
            cellRenderer: null,
            fullWidthCellRenderer: null,
            innerRenderer: null,
            groupRowInnerRenderer: null,
            animateShowChange: animateShowChangeCellRenderer_1.AnimateShowChangeCellRenderer,
            animateSlide: animateSlideCellRenderer_1.AnimateSlideCellRenderer,
            group: groupCellRenderer_1.GroupCellRenderer,
            groupRowRenderer: groupCellRenderer_1.GroupCellRenderer,
            loadingCellRenderer: rowComp_1.LoadingCellRenderer,
            pinnedRowCellRenderer: null,
            //editors
            cellEditor: textCellEditor_1.TextCellEditor,
            textCellEditor: textCellEditor_1.TextCellEditor,
            text: textCellEditor_1.TextCellEditor,
            selectCellEditor: selectCellEditor_1.SelectCellEditor,
            select: selectCellEditor_1.SelectCellEditor,
            popupTextCellEditor: popupTextCellEditor_1.PopupTextCellEditor,
            popupText: popupTextCellEditor_1.PopupTextCellEditor,
            popupSelectCellEditor: popupSelectCellEditor_1.PopupSelectCellEditor,
            popupSelect: popupSelectCellEditor_1.PopupSelectCellEditor,
            largeTextCellEditor: largeTextCellEditor_1.LargeTextCellEditor,
            largeText: largeTextCellEditor_1.LargeTextCellEditor,
            //filter
            textColumnFilter: textFilter_1.TextFilter,
            numberColumnFilter: numberFilter_1.NumberFilter,
            dateColumnFilter: dateFilter_1.DateFilter,
        };
    };
    ComponentProvider.prototype.registerComponent = function (name, component) {
        // console.warn(`ag-grid: registering components is a lab feature, is not intended to be used or supported yet.`);
        if (this.frameworkComponents[name]) {
            console.error("Trying to register a component that you have already registered for frameworks: " + name);
            return;
        }
        this.jsComponents[name] = component;
    };
    /**
     * B the business interface (ie IHeader)
     * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid
     */
    ComponentProvider.prototype.registerFwComponent = function (name, component) {
        // console.warn(`ag-grid: registering components is a lab feature, is not intended to be used or supported yet.`);
        if (this.jsComponents[name]) {
            console.error("Trying to register a component that you have already registered for plain javascript: " + name);
            return;
        }
        this.frameworkComponents[name] = component;
    };
    /**
     * B the business interface (ie IHeader)
     * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid
     */
    ComponentProvider.prototype.retrieve = function (name) {
        if (this.frameworkComponents[name]) {
            return {
                type: componentResolver_1.ComponentType.FRAMEWORK,
                component: this.frameworkComponents[name],
                source: RegisteredComponentSource.REGISTERED
            };
        }
        if (this.jsComponents[name]) {
            return {
                type: componentResolver_1.ComponentType.AG_GRID,
                component: this.jsComponents[name],
                source: RegisteredComponentSource.REGISTERED
            };
        }
        if (this.agGridDefaults[name]) {
            return {
                type: componentResolver_1.ComponentType.AG_GRID,
                component: this.agGridDefaults[name],
                source: RegisteredComponentSource.DEFAULT
            };
        }
        if (Object.keys(this.agGridDefaults).indexOf(name) < 0) {
            console.warn("ag-grid: Looking for component [" + name + "] but it wasn't found.");
        }
        return null;
    };
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ComponentProvider.prototype, "postConstruct", null);
    ComponentProvider = __decorate([
        context_1.Bean('componentProvider')
    ], ComponentProvider);
    return ComponentProvider;
}());
exports.ComponentProvider = ComponentProvider;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var Downloader = (function () {
    function Downloader() {
    }
    Downloader.prototype.download = function (fileName, content, mimeType) {
        // for Excel, we need \ufeff at the start
        // http://stackoverflow.com/questions/17879198/adding-utf-8-bom-to-string-blob
        var blobObject = new Blob(["\ufeff", content], {
            type: mimeType
        });
        // Internet Explorer
        if (window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blobObject, fileName);
        }
        else {
            // Chrome
            var downloadLink = document.createElement("a");
            downloadLink.href = window.URL.createObjectURL(blobObject);
            downloadLink.download = fileName;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }
    };
    Downloader = __decorate([
        context_1.Bean('downloader')
    ], Downloader);
    return Downloader;
}());
exports.Downloader = Downloader;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(7);
var utils_1 = __webpack_require__(1);
var gridCell_1 = __webpack_require__(23);
var GridRow = (function () {
    function GridRow(rowIndex, floating) {
        this.rowIndex = rowIndex;
        this.floating = utils_1.Utils.makeNull(floating);
    }
    GridRow.prototype.isFloatingTop = function () {
        return this.floating === constants_1.Constants.PINNED_TOP;
    };
    GridRow.prototype.isFloatingBottom = function () {
        return this.floating === constants_1.Constants.PINNED_BOTTOM;
    };
    GridRow.prototype.isNotFloating = function () {
        return !this.isFloatingBottom() && !this.isFloatingTop();
    };
    GridRow.prototype.equals = function (otherSelection) {
        return this.rowIndex === otherSelection.rowIndex
            && this.floating === otherSelection.floating;
    };
    GridRow.prototype.toString = function () {
        return "rowIndex = " + this.rowIndex + ", floating = " + this.floating;
    };
    GridRow.prototype.getGridCell = function (column) {
        var gridCellDef = { rowIndex: this.rowIndex, floating: this.floating, column: column };
        return new gridCell_1.GridCell(gridCellDef);
    };
    // tests if this row selection is before the other row selection
    GridRow.prototype.before = function (otherSelection) {
        var otherFloating = otherSelection.floating;
        switch (this.floating) {
            case constants_1.Constants.PINNED_TOP:
                // we we are floating top, and other isn't, then we are always before
                if (otherFloating !== constants_1.Constants.PINNED_TOP) {
                    return true;
                }
                break;
            case constants_1.Constants.PINNED_BOTTOM:
                // if we are floating bottom, and the other isn't, then we are never before
                if (otherFloating !== constants_1.Constants.PINNED_BOTTOM) {
                    return false;
                }
                break;
            default:
                // if we are not floating, but the other one is floating...
                if (utils_1.Utils.exists(otherFloating)) {
                    if (otherFloating === constants_1.Constants.PINNED_TOP) {
                        // we are not floating, other is floating top, we are first
                        return false;
                    }
                    else {
                        // we are not floating, other is floating bottom, we are always first
                        return true;
                    }
                }
                break;
        }
        return this.rowIndex < otherSelection.rowIndex;
    };
    return GridRow;
}());
exports.GridRow = GridRow;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var componentAnnotations_1 = __webpack_require__(12);
var utils_1 = __webpack_require__(1);
var baseFilter_1 = __webpack_require__(52);
var context_1 = __webpack_require__(0);
var componentRecipes_1 = __webpack_require__(27);
var DateFilter = (function (_super) {
    __extends(DateFilter, _super);
    function DateFilter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DateFilter.prototype.modelFromFloatingFilter = function (from) {
        return {
            dateFrom: from,
            dateTo: this.getDateTo(),
            type: this.filter,
            filterType: 'date'
        };
    };
    DateFilter.prototype.getApplicableFilterTypes = function () {
        return [baseFilter_1.BaseFilter.EQUALS, baseFilter_1.BaseFilter.GREATER_THAN, baseFilter_1.BaseFilter.LESS_THAN, baseFilter_1.BaseFilter.NOT_EQUAL, baseFilter_1.BaseFilter.IN_RANGE];
    };
    DateFilter.prototype.bodyTemplate = function () {
        return "<div class=\"ag-filter-body\">\n                    <div class=\"ag-filter-date-from\" id=\"filterDateFromPanel\">\n                    </div>\n                    <div class=\"ag-filter-date-to\" id=\"filterDateToPanel\">\n                    </div>\n                </div>";
    };
    DateFilter.prototype.initialiseFilterBodyUi = function () {
        var _this = this;
        var dateComponentParams = {
            onDateChanged: this.onDateChanged.bind(this)
        };
        this.componentRecipes.newDateComponent(dateComponentParams).then(function (dateToComponent) {
            _this.dateToComponent = dateToComponent;
            var dateToElement = _this.dateToComponent.getGui();
            _this.eDateToPanel.appendChild(dateToElement);
            if (_this.dateToComponent.afterGuiAttached) {
                _this.dateToComponent.afterGuiAttached();
            }
        });
        this.componentRecipes.newDateComponent(dateComponentParams).then(function (dateFromComponent) {
            _this.dateFromComponent = dateFromComponent;
            var dateFromElement = _this.dateFromComponent.getGui();
            _this.eDateFromPanel.appendChild(dateFromElement);
            if (_this.dateFromComponent.afterGuiAttached) {
                _this.dateFromComponent.afterGuiAttached();
            }
        });
    };
    DateFilter.prototype.onDateChanged = function () {
        this.dateFrom = DateFilter.removeTimezone(this.dateFromComponent.getDate());
        this.dateTo = DateFilter.removeTimezone(this.dateToComponent.getDate());
        this.onFilterChanged();
    };
    DateFilter.prototype.refreshFilterBodyUi = function () {
        var visible = this.filter === baseFilter_1.BaseFilter.IN_RANGE;
        utils_1.Utils.setVisible(this.eDateToPanel, visible);
    };
    DateFilter.prototype.comparator = function () {
        return this.filterParams.comparator ? this.filterParams.comparator : this.defaultComparator.bind(this);
    };
    DateFilter.prototype.defaultComparator = function (filterDate, cellValue) {
        //The default comparator assumes that the cellValue is a date
        var cellAsDate = cellValue;
        if (cellAsDate < filterDate) {
            return -1;
        }
        if (cellAsDate > filterDate) {
            return 1;
        }
        return cellValue != null ? 0 : -1;
    };
    DateFilter.prototype.serialize = function () {
        return {
            dateTo: utils_1.Utils.serializeDateToYyyyMmDd(this.dateToComponent.getDate(), "-"),
            dateFrom: utils_1.Utils.serializeDateToYyyyMmDd(this.dateFromComponent.getDate(), "-"),
            type: this.filter ? this.filter : this.defaultFilter,
            filterType: 'date'
        };
    };
    DateFilter.prototype.filterValues = function () {
        return this.filter !== baseFilter_1.BaseFilter.IN_RANGE ?
            this.dateFromComponent.getDate() :
            [this.dateFromComponent.getDate(), this.dateToComponent.getDate()];
    };
    // not used by ag-Grid, but exposed as part of the filter API for the client if they want it
    DateFilter.prototype.getDateFrom = function () {
        return utils_1.Utils.serializeDateToYyyyMmDd(this.dateFromComponent.getDate(), "-");
    };
    // not used by ag-Grid, but exposed as part of the filter API for the client if they want it
    DateFilter.prototype.getDateTo = function () {
        return utils_1.Utils.serializeDateToYyyyMmDd(this.dateToComponent.getDate(), "-");
    };
    // not used by ag-Grid, but exposed as part of the filter API for the client if they want it
    DateFilter.prototype.getFilterType = function () {
        return this.filter;
    };
    DateFilter.prototype.setDateFrom = function (date) {
        this.dateFrom = utils_1.Utils.parseYyyyMmDdToDate(date, "-");
        this.dateFromComponent.setDate(this.dateFrom);
    };
    DateFilter.prototype.setDateTo = function (date) {
        this.dateTo = utils_1.Utils.parseYyyyMmDdToDate(date, "-");
        this.dateToComponent.setDate(this.dateTo);
    };
    DateFilter.prototype.resetState = function () {
        this.setDateFrom(null);
        this.setDateTo(null);
        this.setFilterType(this.defaultFilter);
    };
    DateFilter.prototype.parse = function (model) {
        this.setDateFrom(model.dateFrom);
        this.setDateTo(model.dateTo);
        this.setFilterType(model.type);
    };
    DateFilter.prototype.setType = function (filterType) {
        this.setFilterType(filterType);
    };
    DateFilter.removeTimezone = function (from) {
        if (!from)
            return null;
        return new Date(from.getFullYear(), from.getMonth(), from.getDate());
    };
    __decorate([
        context_1.Autowired('componentRecipes'),
        __metadata("design:type", componentRecipes_1.ComponentRecipes)
    ], DateFilter.prototype, "componentRecipes", void 0);
    __decorate([
        componentAnnotations_1.QuerySelector('#filterDateFromPanel'),
        __metadata("design:type", HTMLElement)
    ], DateFilter.prototype, "eDateFromPanel", void 0);
    __decorate([
        componentAnnotations_1.QuerySelector('#filterDateToPanel'),
        __metadata("design:type", HTMLElement)
    ], DateFilter.prototype, "eDateToPanel", void 0);
    return DateFilter;
}(baseFilter_1.ScalarBaseFilter));
exports.DateFilter = DateFilter;
var DefaultDateComponent = (function (_super) {
    __extends(DefaultDateComponent, _super);
    function DefaultDateComponent() {
        return _super.call(this, "<input class=\"ag-filter-filter\" type=\"text\" placeholder=\"yyyy-mm-dd\">") || this;
    }
    DefaultDateComponent.prototype.init = function (params) {
        this.eDateInput = this.getGui();
        if (utils_1.Utils.isBrowserChrome()) {
            this.eDateInput.type = 'date';
        }
        this.listener = params.onDateChanged;
        this.addGuiEventListener('input', this.listener);
    };
    DefaultDateComponent.prototype.getDate = function () {
        return utils_1.Utils.parseYyyyMmDdToDate(this.eDateInput.value, "-");
    };
    DefaultDateComponent.prototype.setDate = function (date) {
        this.eDateInput.value = utils_1.Utils.serializeDateToYyyyMmDd(date, "-");
    };
    return DefaultDateComponent;
}(component_1.Component));
exports.DefaultDateComponent = DefaultDateComponent;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var selectionController_1 = __webpack_require__(17);
var columnController_1 = __webpack_require__(3);
var rowRenderer_1 = __webpack_require__(18);
var headerRenderer_1 = __webpack_require__(54);
var filterManager_1 = __webpack_require__(16);
var valueService_1 = __webpack_require__(20);
var eventService_1 = __webpack_require__(4);
var gridPanel_1 = __webpack_require__(10);
var gridApi_1 = __webpack_require__(6);
var headerTemplateLoader_1 = __webpack_require__(74);
var balancedColumnTreeBuilder_1 = __webpack_require__(46);
var displayedGroupCreator_1 = __webpack_require__(47);
var expressionService_1 = __webpack_require__(19);
var templateService_1 = __webpack_require__(60);
var popupService_1 = __webpack_require__(37);
var logger_1 = __webpack_require__(11);
var columnUtils_1 = __webpack_require__(31);
var autoWidthCalculator_1 = __webpack_require__(77);
var horizontalDragService_1 = __webpack_require__(39);
var context_1 = __webpack_require__(0);
var csvCreator_1 = __webpack_require__(49);
var gridCore_1 = __webpack_require__(33);
var standardMenu_1 = __webpack_require__(106);
var dragAndDropService_1 = __webpack_require__(21);
var dragService_1 = __webpack_require__(50);
var sortController_1 = __webpack_require__(25);
var focusedCellController_1 = __webpack_require__(24);
var mouseEventService_1 = __webpack_require__(38);
var cellNavigationService_1 = __webpack_require__(64);
var utils_1 = __webpack_require__(1);
var filterStage_1 = __webpack_require__(111);
var sortStage_1 = __webpack_require__(115);
var flattenStage_1 = __webpack_require__(112);
var cellEditorFactory_1 = __webpack_require__(55);
var events_1 = __webpack_require__(5);
var infiniteRowModel_1 = __webpack_require__(116);
var inMemoryRowModel_1 = __webpack_require__(114);
var cellRendererFactory_1 = __webpack_require__(56);
var cellRendererService_1 = __webpack_require__(57);
var valueFormatterService_1 = __webpack_require__(43);
var agCheckbox_1 = __webpack_require__(61);
var baseFrameworkFactory_1 = __webpack_require__(93);
var scrollVisibleService_1 = __webpack_require__(34);
var downloader_1 = __webpack_require__(69);
var xmlFactory_1 = __webpack_require__(119);
var gridSerializer_1 = __webpack_require__(73);
var stylingService_1 = __webpack_require__(90);
var columnHoverService_1 = __webpack_require__(86);
var columnAnimationService_1 = __webpack_require__(85);
var sortService_1 = __webpack_require__(118);
var filterService_1 = __webpack_require__(117);
var rowNodeFactory_1 = __webpack_require__(152);
var autoGroupColService_1 = __webpack_require__(94);
var paginationProxy_1 = __webpack_require__(29);
var immutableService_1 = __webpack_require__(113);
var constants_1 = __webpack_require__(7);
var valueCache_1 = __webpack_require__(36);
var changeDetectionService_1 = __webpack_require__(153);
var alignedGridsService_1 = __webpack_require__(45);
var pinnedRowModel_1 = __webpack_require__(30);
var componentResolver_1 = __webpack_require__(22);
var componentRecipes_1 = __webpack_require__(27);
var componentProvider_1 = __webpack_require__(68);
var agComponentUtils_1 = __webpack_require__(48);
var componentMetadataProvider_1 = __webpack_require__(67);
var namedComponentResolver_1 = __webpack_require__(96);
var beans_1 = __webpack_require__(35);
var environment_1 = __webpack_require__(51);
var animationFrameService_1 = __webpack_require__(40);
var navigationService_1 = __webpack_require__(99);
var Grid = (function () {
    function Grid(eGridDiv, gridOptions, params) {
        if (!eGridDiv) {
            console.error('ag-Grid: no div element provided to the grid');
        }
        if (!gridOptions) {
            console.error('ag-Grid: no gridOptions provided to the grid');
        }
        var rowModelClass = this.getRowModelClass(gridOptions);
        var enterprise = utils_1.Utils.exists(Grid.enterpriseBeans);
        var frameworkFactory = params ? params.frameworkFactory : null;
        if (utils_1.Utils.missing(frameworkFactory)) {
            frameworkFactory = new baseFrameworkFactory_1.BaseFrameworkFactory();
        }
        var overrideBeans = [];
        if (Grid.enterpriseBeans) {
            overrideBeans = overrideBeans.concat(Grid.enterpriseBeans);
        }
        if (Grid.frameworkBeans) {
            overrideBeans = overrideBeans.concat(Grid.frameworkBeans);
        }
        var seed = {
            enterprise: enterprise,
            gridOptions: gridOptions,
            eGridDiv: eGridDiv,
            $scope: params ? params.$scope : null,
            $compile: params ? params.$compile : null,
            quickFilterOnScope: params ? params.quickFilterOnScope : null,
            globalEventListener: params ? params.globalEventListener : null,
            frameworkFactory: frameworkFactory
        };
        if (params && params.seedBeanInstances) {
            utils_1.Utils.assign(seed, params.seedBeanInstances);
        }
        var contextParams = {
            overrideBeans: overrideBeans,
            seed: seed,
            //Careful with the order of the beans here, there are dependencies between them that need to be kept
            beans: [rowModelClass, paginationProxy_1.PaginationAutoPageSizeService, gridApi_1.GridApi, componentProvider_1.ComponentProvider, agComponentUtils_1.AgComponentUtils, componentMetadataProvider_1.ComponentMetadataProvider,
                componentProvider_1.ComponentProvider, componentResolver_1.ComponentResolver, componentRecipes_1.ComponentRecipes, namedComponentResolver_1.NamedComponentResolver,
                cellRendererFactory_1.CellRendererFactory, horizontalDragService_1.HorizontalDragService, headerTemplateLoader_1.HeaderTemplateLoader, pinnedRowModel_1.PinnedRowModel, dragService_1.DragService,
                displayedGroupCreator_1.DisplayedGroupCreator, eventService_1.EventService, gridOptionsWrapper_1.GridOptionsWrapper, selectionController_1.SelectionController,
                filterManager_1.FilterManager, columnController_1.ColumnController, paginationProxy_1.PaginationProxy, rowRenderer_1.RowRenderer, headerRenderer_1.HeaderRenderer, expressionService_1.ExpressionService,
                balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder, csvCreator_1.CsvCreator, downloader_1.Downloader, xmlFactory_1.XmlFactory, gridSerializer_1.GridSerializer, templateService_1.TemplateService,
                navigationService_1.NavigationService, gridPanel_1.GridPanel, popupService_1.PopupService, valueCache_1.ValueCache, valueService_1.ValueService, alignedGridsService_1.AlignedGridsService,
                logger_1.LoggerFactory, columnUtils_1.ColumnUtils, autoWidthCalculator_1.AutoWidthCalculator, popupService_1.PopupService, gridCore_1.GridCore, standardMenu_1.StandardMenuFactory,
                dragAndDropService_1.DragAndDropService, columnController_1.ColumnApi, focusedCellController_1.FocusedCellController, mouseEventService_1.MouseEventService,
                cellNavigationService_1.CellNavigationService, filterStage_1.FilterStage, sortStage_1.SortStage, flattenStage_1.FlattenStage, filterService_1.FilterService, rowNodeFactory_1.RowNodeFactory,
                cellEditorFactory_1.CellEditorFactory, cellRendererService_1.CellRendererService, valueFormatterService_1.ValueFormatterService, stylingService_1.StylingService, scrollVisibleService_1.ScrollVisibleService,
                columnHoverService_1.ColumnHoverService, columnAnimationService_1.ColumnAnimationService, sortService_1.SortService, autoGroupColService_1.AutoGroupColService, immutableService_1.ImmutableService,
                changeDetectionService_1.ChangeDetectionService, environment_1.Environment, beans_1.Beans, animationFrameService_1.AnimationFrameService, sortController_1.SortController],
            components: [
                { componentName: 'AgCheckbox', theClass: agCheckbox_1.AgCheckbox }
            ],
            debug: !!gridOptions.debug
        };
        var isLoggingFunc = function () { return contextParams.debug; };
        this.context = new context_1.Context(contextParams, new logger_1.Logger('Context', isLoggingFunc));
        // we do this at the end, after the boot sequence is complete
        this.registerComponents(gridOptions);
        this.setColumnsAndData();
        this.dispatchGridReadyEvent(gridOptions);
        if (gridOptions.debug) {
            console.log('ag-Grid -> initialised successfully, enterprise = ' + enterprise);
        }
    }
    Grid.setEnterpriseBeans = function (enterpriseBeans, rowModelClasses) {
        this.enterpriseBeans = enterpriseBeans;
        // the enterprise can inject additional row models. this is how it injects the viewportRowModel
        utils_1.Utils.iterateObject(rowModelClasses, function (key, value) { return Grid.RowModelClasses[key] = value; });
    };
    Grid.setFrameworkBeans = function (frameworkBeans) {
        this.frameworkBeans = frameworkBeans;
    };
    Grid.prototype.registerComponents = function (gridOptions) {
        var componentProvider = this.context.getBean('componentProvider');
        if (gridOptions.components != null) {
            Object.keys(gridOptions.components).forEach(function (it) {
                componentProvider.registerComponent(it, gridOptions.components[it]);
            });
        }
        if (gridOptions.frameworkComponents != null) {
            Object.keys(gridOptions.frameworkComponents).forEach(function (it) {
                componentProvider.registerFwComponent(it, gridOptions.frameworkComponents[it]);
            });
        }
    };
    Grid.prototype.setColumnsAndData = function () {
        var gridOptionsWrapper = this.context.getBean('gridOptionsWrapper');
        var columnController = this.context.getBean('columnController');
        var rowModel = this.context.getBean('rowModel');
        var columnDefs = gridOptionsWrapper.getColumnDefs();
        var rowData = gridOptionsWrapper.getRowData();
        var nothingToSet = utils_1.Utils.missing(columnDefs) && utils_1.Utils.missing(rowData);
        if (nothingToSet) {
            return;
        }
        var valueService = this.context.getBean('valueService');
        if (utils_1.Utils.exists(columnDefs)) {
            columnController.setColumnDefs(columnDefs);
        }
        if (utils_1.Utils.exists(rowData) && rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY) {
            var inMemoryRowModel = rowModel;
            inMemoryRowModel.setRowData(rowData);
        }
    };
    Grid.prototype.dispatchGridReadyEvent = function (gridOptions) {
        var eventService = this.context.getBean('eventService');
        var readyEvent = {
            type: events_1.Events.EVENT_GRID_READY,
            api: gridOptions.api,
            columnApi: gridOptions.columnApi
        };
        eventService.dispatchEvent(readyEvent);
    };
    Grid.prototype.getRowModelClass = function (gridOptions) {
        var rowModelType = gridOptions.rowModelType;
        if (utils_1.Utils.exists(rowModelType)) {
            var rowModelClass = Grid.RowModelClasses[rowModelType];
            if (utils_1.Utils.exists(rowModelClass)) {
                return rowModelClass;
            }
            else {
                if (rowModelType === 'normal') {
                    console.warn("ag-Grid: normal rowModel deprecated. Should now be called inMemory rowModel instead.");
                    return inMemoryRowModel_1.InMemoryRowModel;
                }
                console.error('ag-Grid: could not find matching row model for rowModelType ' + rowModelType);
                if (rowModelType === 'viewport') {
                    console.error('ag-Grid: rowModelType viewport is only available in ag-Grid Enterprise');
                }
                if (rowModelType === 'enterprise') {
                    console.error('ag-Grid: rowModelType viewport is only available in ag-Grid Enterprise');
                }
            }
        }
        return inMemoryRowModel_1.InMemoryRowModel;
    };
    ;
    Grid.prototype.destroy = function () {
        this.context.destroy();
    };
    // the default is InMemoryRowModel, which is also used for pagination.
    // the enterprise adds viewport to this list.
    Grid.RowModelClasses = {
        infinite: infiniteRowModel_1.InfiniteRowModel,
        inMemory: inMemoryRowModel_1.InMemoryRowModel
    };
    return Grid;
}());
exports.Grid = Grid;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var columnController_1 = __webpack_require__(3);
var constants_1 = __webpack_require__(7);
var utils_1 = __webpack_require__(1);
var selectionController_1 = __webpack_require__(17);
var gridOptionsWrapper_1 = __webpack_require__(2);
var displayedGroupCreator_1 = __webpack_require__(47);
var balancedColumnTreeBuilder_1 = __webpack_require__(46);
var groupInstanceIdCreator_1 = __webpack_require__(65);
var columnGroup_1 = __webpack_require__(28);
var pinnedRowModel_1 = __webpack_require__(30);
var BaseGridSerializingSession = (function () {
    function BaseGridSerializingSession(columnController, valueService, gridOptionsWrapper, processCellCallback, processHeaderCallback, cellAndHeaderEscaper) {
        this.columnController = columnController;
        this.valueService = valueService;
        this.gridOptionsWrapper = gridOptionsWrapper;
        this.processCellCallback = processCellCallback;
        this.processHeaderCallback = processHeaderCallback;
        this.cellAndHeaderEscaper = cellAndHeaderEscaper;
    }
    BaseGridSerializingSession.prototype.extractHeaderValue = function (column) {
        var nameForCol = this.getHeaderName(this.processHeaderCallback, column);
        if (nameForCol === null || nameForCol === undefined) {
            nameForCol = '';
        }
        return this.cellAndHeaderEscaper ? this.cellAndHeaderEscaper(nameForCol) : nameForCol;
    };
    BaseGridSerializingSession.prototype.extractRowCellValue = function (column, index, type, node) {
        var isRowGrouping = this.columnController.getRowGroupColumns().length > 0;
        var valueForCell;
        if (node.group && isRowGrouping && index === 0) {
            valueForCell = this.createValueForGroupNode(node);
        }
        else {
            valueForCell = this.valueService.getValue(column, node);
        }
        valueForCell = this.processCell(node, column, valueForCell, this.processCellCallback, type);
        if (valueForCell === null || valueForCell === undefined) {
            valueForCell = '';
        }
        return this.cellAndHeaderEscaper ? this.cellAndHeaderEscaper(valueForCell) : valueForCell;
    };
    BaseGridSerializingSession.prototype.getHeaderName = function (callback, column) {
        if (callback) {
            return callback({
                column: column,
                api: this.gridOptionsWrapper.getApi(),
                columnApi: this.gridOptionsWrapper.getColumnApi(),
                context: this.gridOptionsWrapper.getContext()
            });
        }
        else {
            return this.columnController.getDisplayNameForColumn(column, 'csv', true);
        }
    };
    BaseGridSerializingSession.prototype.createValueForGroupNode = function (node) {
        var keys = [node.key];
        while (node.parent) {
            node = node.parent;
            keys.push(node.key);
        }
        return keys.reverse().join(' -> ');
    };
    BaseGridSerializingSession.prototype.processCell = function (rowNode, column, value, processCellCallback, type) {
        if (processCellCallback) {
            return processCellCallback({
                column: column,
                node: rowNode,
                value: value,
                api: this.gridOptionsWrapper.getApi(),
                columnApi: this.gridOptionsWrapper.getColumnApi(),
                context: this.gridOptionsWrapper.getContext(),
                type: type
            });
        }
        else {
            return value;
        }
    };
    return BaseGridSerializingSession;
}());
exports.BaseGridSerializingSession = BaseGridSerializingSession;
var GridSerializer = (function () {
    function GridSerializer() {
    }
    GridSerializer.prototype.serialize = function (gridSerializingSession, params) {
        var dontSkipRows = function () { return false; };
        var skipGroups = params && params.skipGroups;
        var skipHeader = params && params.skipHeader;
        var columnGroups = params && params.columnGroups;
        var skipFooters = params && params.skipFooters;
        var skipPinnedTop = params && params.skipPinnedTop;
        var skipPinnedBottom = params && params.skipPinnedBottom;
        var includeCustomHeader = params && params.customHeader;
        var includeCustomFooter = params && params.customFooter;
        var allColumns = params && params.allColumns;
        var onlySelected = params && params.onlySelected;
        var columnKeys = params && params.columnKeys;
        var onlySelectedAllPages = params && params.onlySelectedAllPages;
        var rowSkipper = (params && params.shouldRowBeSkipped) || dontSkipRows;
        var api = this.gridOptionsWrapper.getApi();
        var context = this.gridOptionsWrapper.getContext();
        // when in pivot mode, we always render cols on screen, never 'all columns'
        var isPivotMode = this.columnController.isPivotMode();
        var rowModelNormal = this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY;
        var onlySelectedNonStandardModel = !rowModelNormal && onlySelected;
        var columnsToExport;
        if (utils_1.Utils.existsAndNotEmpty(columnKeys)) {
            columnsToExport = this.columnController.getGridColumns(columnKeys);
        }
        else if (allColumns && !isPivotMode) {
            columnsToExport = this.columnController.getAllPrimaryColumns();
        }
        else {
            columnsToExport = this.columnController.getAllDisplayedColumns();
        }
        if (!columnsToExport || columnsToExport.length === 0) {
            return '';
        }
        gridSerializingSession.prepare(columnsToExport);
        if (includeCustomHeader) {
            gridSerializingSession.addCustomHeader(params.customHeader);
        }
        // first pass, put in the header names of the cols
        if (columnGroups) {
            var groupInstanceIdCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();
            var displayedGroups = this.displayedGroupCreator.createDisplayedGroups(columnsToExport, this.columnController.getGridBalancedTree(), groupInstanceIdCreator);
            this.recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession);
        }
        if (!skipHeader) {
            var gridRowIterator_1 = gridSerializingSession.onNewHeaderRow();
            columnsToExport.forEach(function (column, index) {
                gridRowIterator_1.onColumn(column, index, null);
            });
        }
        this.pinnedRowModel.forEachPinnedTopRow(processRow);
        if (isPivotMode) {
            this.rowModel.forEachPivotNode(processRow);
        }
        else {
            // onlySelectedAllPages: user doing pagination and wants selected items from
            // other pages, so cannot use the standard row model as it won't have rows from
            // other pages.
            // onlySelectedNonStandardModel: if user wants selected in non standard row model
            // (eg viewport) then again rowmodel cannot be used, so need to use selected instead.
            if (onlySelectedAllPages || onlySelectedNonStandardModel) {
                var selectedNodes = this.selectionController.getSelectedNodes();
                selectedNodes.forEach(function (node) {
                    processRow(node);
                });
            }
            else {
                // here is everything else - including standard row model and selected. we don't use
                // the selection model even when just using selected, so that the result is the order
                // of the rows appearing on the screen.
                if (rowModelNormal) {
                    this.rowModel.forEachNodeAfterFilterAndSort(processRow);
                }
                else {
                    this.rowModel.forEachNode(processRow);
                }
            }
        }
        this.pinnedRowModel.forEachPinnedBottomRow(processRow);
        if (includeCustomFooter) {
            gridSerializingSession.addCustomFooter(params.customFooter);
        }
        function processRow(node) {
            if (skipGroups && node.group) {
                return;
            }
            if (skipFooters && node.footer) {
                return;
            }
            if (onlySelected && !node.isSelected()) {
                return;
            }
            if (skipPinnedTop && node.rowPinned === 'top') {
                return;
            }
            if (skipPinnedBottom && node.rowPinned === 'bottom') {
                return;
            }
            // if we are in pivotMode, then the grid will show the root node only
            // if it's not a leaf group
            var nodeIsRootNode = node.level === -1;
            if (nodeIsRootNode && !node.leafGroup) {
                return;
            }
            var shouldRowBeSkipped = rowSkipper({
                node: node,
                api: api,
                context: context
            });
            if (shouldRowBeSkipped)
                return;
            var rowAccumulator = gridSerializingSession.onNewBodyRow();
            columnsToExport.forEach(function (column, index) {
                rowAccumulator.onColumn(column, index, node);
            });
        }
        return gridSerializingSession.parse();
    };
    GridSerializer.prototype.recursivelyAddHeaderGroups = function (displayedGroups, gridSerializingSession) {
        var directChildrenHeaderGroups = [];
        displayedGroups.forEach(function (columnGroupChild) {
            var columnGroup = columnGroupChild;
            if (!columnGroup.getChildren)
                return;
            columnGroup.getChildren().forEach(function (it) { return directChildrenHeaderGroups.push(it); });
        });
        if (displayedGroups.length > 0 && displayedGroups[0] instanceof columnGroup_1.ColumnGroup) {
            this.doAddHeaderHeader(gridSerializingSession, displayedGroups);
        }
        if (directChildrenHeaderGroups && directChildrenHeaderGroups.length > 0) {
            this.recursivelyAddHeaderGroups(directChildrenHeaderGroups, gridSerializingSession);
        }
    };
    GridSerializer.prototype.doAddHeaderHeader = function (gridSerializingSession, displayedGroups) {
        var _this = this;
        var gridRowIterator = gridSerializingSession.onNewHeaderGroupingRow();
        var columnIndex = 0;
        displayedGroups.forEach(function (columnGroupChild) {
            var columnGroup = columnGroupChild;
            var colDef = columnGroup.getDefinition();
            var columnName = _this.columnController.getDisplayNameForColumnGroup(columnGroup, 'header');
            gridRowIterator.onColumn(columnName, columnIndex++, columnGroup.getLeafColumns().length - 1);
        });
    };
    __decorate([
        context_1.Autowired('displayedGroupCreator'),
        __metadata("design:type", displayedGroupCreator_1.DisplayedGroupCreator)
    ], GridSerializer.prototype, "displayedGroupCreator", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], GridSerializer.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], GridSerializer.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('pinnedRowModel'),
        __metadata("design:type", pinnedRowModel_1.PinnedRowModel)
    ], GridSerializer.prototype, "pinnedRowModel", void 0);
    __decorate([
        context_1.Autowired('selectionController'),
        __metadata("design:type", selectionController_1.SelectionController)
    ], GridSerializer.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('balancedColumnTreeBuilder'),
        __metadata("design:type", balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder)
    ], GridSerializer.prototype, "balancedColumnTreeBuilder", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], GridSerializer.prototype, "gridOptionsWrapper", void 0);
    GridSerializer = __decorate([
        context_1.Bean("gridSerializer")
    ], GridSerializer);
    return GridSerializer;
}());
exports.GridSerializer = GridSerializer;
var RowType;
(function (RowType) {
    RowType[RowType["HEADER_GROUPING"] = 0] = "HEADER_GROUPING";
    RowType[RowType["HEADER"] = 1] = "HEADER";
    RowType[RowType["BODY"] = 2] = "BODY";
})(RowType = exports.RowType || (exports.RowType = {}));


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var context_1 = __webpack_require__(0);
var HeaderTemplateLoader = (function () {
    function HeaderTemplateLoader() {
    }
    HeaderTemplateLoader_1 = HeaderTemplateLoader;
    HeaderTemplateLoader.prototype.createHeaderElement = function (column) {
        var params = {
            column: column,
            colDef: column.getColDef,
            context: this.gridOptionsWrapper.getContext(),
            api: this.gridOptionsWrapper.getApi()
        };
        // option 1 - see if user provided a template in colDef
        var userProvidedTemplate = column.getColDef().headerCellTemplate;
        if (typeof userProvidedTemplate === 'function') {
            var colDefFunc = userProvidedTemplate;
            userProvidedTemplate = colDefFunc(params);
        }
        // option 2 - check the gridOptions for cellTemplate
        if (!userProvidedTemplate && this.gridOptionsWrapper.getHeaderCellTemplate()) {
            userProvidedTemplate = this.gridOptionsWrapper.getHeaderCellTemplate();
        }
        // option 3 - check the gridOptions for templateFunction
        if (!userProvidedTemplate && this.gridOptionsWrapper.getHeaderCellTemplateFunc()) {
            var gridOptionsFunc = this.gridOptionsWrapper.getHeaderCellTemplateFunc();
            userProvidedTemplate = gridOptionsFunc(params);
        }
        // finally, if still no template, use the default
        if (!userProvidedTemplate) {
            userProvidedTemplate = this.createDefaultHeaderElement(column);
        }
        // template can be a string or a dom element, if string we need to convert to a dom element
        var result;
        if (typeof userProvidedTemplate === 'string') {
            result = utils_1.Utils.loadTemplate(userProvidedTemplate);
        }
        else if (utils_1.Utils.isNodeOrElement(userProvidedTemplate)) {
            result = userProvidedTemplate;
        }
        else {
            console.error('ag-Grid: header template must be a string or an HTML element');
        }
        return result;
    };
    HeaderTemplateLoader.prototype.createDefaultHeaderElement = function (column) {
        var eTemplate = utils_1.Utils.loadTemplate(HeaderTemplateLoader_1.HEADER_CELL_TEMPLATE);
        this.addInIcon(eTemplate, 'sortAscending', '#agSortAsc', column);
        this.addInIcon(eTemplate, 'sortDescending', '#agSortDesc', column);
        this.addInIcon(eTemplate, 'sortUnSort', '#agNoSort', column);
        this.addInIcon(eTemplate, 'menu', '#agMenu', column);
        this.addInIcon(eTemplate, 'filter', '#agFilter', column);
        return eTemplate;
    };
    HeaderTemplateLoader.prototype.addInIcon = function (eTemplate, iconName, cssSelector, column) {
        var eIcon = utils_1.Utils.createIconNoSpan(iconName, this.gridOptionsWrapper, column);
        eTemplate.querySelector(cssSelector).appendChild(eIcon);
    };
    HeaderTemplateLoader.HEADER_CELL_TEMPLATE = '<div class="ag-header-cell">' +
        '  <div id="agResizeBar" class="ag-header-cell-resize"></div>' +
        '  <span id="agMenu" class="ag-header-icon ag-header-cell-menu-button"></span>' +
        '  <div id="agHeaderCellLabel" class="ag-header-cell-label">' +
        '    <span id="agSortAsc" class="ag-header-icon ag-sort-ascending-icon"></span>' +
        '    <span id="agSortDesc" class="ag-header-icon ag-sort-descending-icon"></span>' +
        '    <span id="agNoSort" class="ag-header-icon ag-sort-none-icon"></span>' +
        '    <span id="agFilter" class="ag-header-icon ag-filter-icon"></span>' +
        '    <span id="agText" class="ag-header-cell-text"></span>' +
        '  </div>' +
        '</div>';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderTemplateLoader.prototype, "gridOptionsWrapper", void 0);
    HeaderTemplateLoader = HeaderTemplateLoader_1 = __decorate([
        context_1.Bean('headerTemplateLoader')
    ], HeaderTemplateLoader);
    return HeaderTemplateLoader;
    var HeaderTemplateLoader_1;
}());
exports.HeaderTemplateLoader = HeaderTemplateLoader;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var column_1 = __webpack_require__(9);
var filterManager_1 = __webpack_require__(16);
var columnController_1 = __webpack_require__(3);
var headerTemplateLoader_1 = __webpack_require__(74);
var gridOptionsWrapper_1 = __webpack_require__(2);
var horizontalDragService_1 = __webpack_require__(39);
var gridCore_1 = __webpack_require__(33);
var context_1 = __webpack_require__(0);
var cssClassApplier_1 = __webpack_require__(53);
var dragAndDropService_1 = __webpack_require__(21);
var sortController_1 = __webpack_require__(25);
var setLeftFeature_1 = __webpack_require__(42);
var touchListener_1 = __webpack_require__(62);
var component_1 = __webpack_require__(8);
var beans_1 = __webpack_require__(35);
var RenderedHeaderCell = (function (_super) {
    __extends(RenderedHeaderCell, _super);
    function RenderedHeaderCell(column, eRoot, dragSourceDropTarget, pinned) {
        var _this = _super.call(this) || this;
        _this.column = column;
        _this.eRoot = eRoot;
        _this.dragSourceDropTarget = dragSourceDropTarget;
        _this.pinned = pinned;
        return _this;
    }
    RenderedHeaderCell.prototype.getColumn = function () {
        return this.column;
    };
    RenderedHeaderCell.prototype.init = function () {
        var eGui = this.headerTemplateLoader.createHeaderElement(this.column);
        this.setGui(eGui);
        this.createScope();
        this.addAttributes();
        cssClassApplier_1.CssClassApplier.addHeaderClassesFromColDef(this.column.getColDef(), eGui, this.gridOptionsWrapper, this.column, null);
        utils_1.Utils.addCssClass(eGui, 'ag-header-cell');
        // label div
        var eHeaderCellLabel = eGui.querySelector('#agHeaderCellLabel');
        this.displayName = this.columnController.getDisplayNameForColumn(this.column, 'header', true);
        this.setupMovingCss();
        this.setupTooltip();
        this.setupResize();
        this.setupTap();
        this.setupMove(eHeaderCellLabel);
        this.setupMenu();
        this.setupSort(eHeaderCellLabel);
        this.setupFilterIcon();
        this.setupText();
        this.setupWidth();
        var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.column, eGui, this.beans);
        setLeftFeature.init();
        this.addDestroyFunc(setLeftFeature.destroy.bind(setLeftFeature));
    };
    RenderedHeaderCell.prototype.setupTooltip = function () {
        var colDef = this.column.getColDef();
        // add tooltip if exists
        if (colDef.headerTooltip) {
            this.getGui().title = colDef.headerTooltip;
        }
    };
    RenderedHeaderCell.prototype.setupText = function () {
        var colDef = this.column.getColDef();
        // render the cell, use a renderer if one is provided
        var headerCellRenderer;
        if (colDef.headerCellRenderer) {
            headerCellRenderer = colDef.headerCellRenderer;
        }
        else if (this.gridOptionsWrapper.getHeaderCellRenderer()) {
            headerCellRenderer = this.gridOptionsWrapper.getHeaderCellRenderer();
        }
        var eText = this.queryForHtmlElement('#agText');
        if (eText) {
            if (headerCellRenderer) {
                this.useRenderer(this.displayName, headerCellRenderer, eText);
            }
            else {
                // no renderer, default text render
                eText.innerHTML = this.displayName;
                // i don't remember why this is here, take it out???
                utils_1.Utils.addCssClass(eText, 'ag-header-cell-text');
            }
        }
    };
    RenderedHeaderCell.prototype.setupFilterIcon = function () {
        this.eFilterIcon = this.queryForHtmlElement('#agFilter');
        if (!this.eFilterIcon) {
            return;
        }
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
        this.onFilterChanged();
    };
    RenderedHeaderCell.prototype.onFilterChanged = function () {
        var filterPresent = this.column.isFilterActive();
        utils_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-header-cell-filtered', filterPresent);
        utils_1.Utils.addOrRemoveCssClass(this.eFilterIcon, 'ag-hidden', !filterPresent);
    };
    RenderedHeaderCell.prototype.setupWidth = function () {
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_WIDTH_CHANGED, this.onColumnWidthChanged.bind(this));
        this.onColumnWidthChanged();
    };
    RenderedHeaderCell.prototype.onColumnWidthChanged = function () {
        this.getGui().style.width = this.column.getActualWidth() + 'px';
    };
    RenderedHeaderCell.prototype.createScope = function () {
        var _this = this;
        if (this.gridOptionsWrapper.isAngularCompileHeaders()) {
            this.childScope = this.$scope.$new();
            this.childScope.colDef = this.column.getColDef();
            this.childScope.colDefWrapper = this.column;
            this.childScope.context = this.gridOptionsWrapper.getContext();
            this.addDestroyFunc(function () {
                _this.childScope.$destroy();
            });
        }
    };
    RenderedHeaderCell.prototype.addAttributes = function () {
        this.getGui().setAttribute("colId", this.column.getColId());
    };
    RenderedHeaderCell.prototype.setupMenu = function () {
        var _this = this;
        var eMenu = this.queryForHtmlElement('#agMenu');
        // if no menu provided in template, do nothing
        if (!eMenu) {
            return;
        }
        var skipMenu = !this.menuFactory.isMenuEnabled(this.column) || this.column.getColDef().suppressMenu;
        if (skipMenu) {
            utils_1.Utils.removeFromParent(eMenu);
            return;
        }
        eMenu.addEventListener('click', function () { return _this.showMenu(eMenu); });
        if (!this.gridOptionsWrapper.isSuppressMenuHide()) {
            eMenu.style.opacity = '0';
            this.addGuiEventListener('mouseover', function () {
                eMenu.style.opacity = '1';
            });
            this.addGuiEventListener('mouseout', function () {
                eMenu.style.opacity = '0';
            });
        }
        var style = eMenu.style;
        style['transition'] = 'opacity 0.2s, border 0.2s';
        style['-webkit-transition'] = 'opacity 0.2s, border 0.2s';
    };
    RenderedHeaderCell.prototype.showMenu = function (eventSource) {
        this.menuFactory.showMenuAfterButtonClick(this.column, eventSource);
    };
    RenderedHeaderCell.prototype.setupMovingCss = function () {
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_MOVING_CHANGED, this.onColumnMovingChanged.bind(this));
        this.onColumnMovingChanged();
    };
    RenderedHeaderCell.prototype.onColumnMovingChanged = function () {
        // this function adds or removes the moving css, based on if the col is moving.
        // this is what makes the header go dark when it is been moved (gives impression to
        // user that the column was picked up).
        if (this.column.isMoving()) {
            utils_1.Utils.addCssClass(this.getGui(), 'ag-header-cell-moving');
        }
        else {
            utils_1.Utils.removeCssClass(this.getGui(), 'ag-header-cell-moving');
        }
    };
    RenderedHeaderCell.prototype.setupMove = function (eHeaderCellLabel) {
        var _this = this;
        var suppressMove = this.gridOptionsWrapper.isSuppressMovableColumns()
            || this.column.getColDef().suppressMovable
            || this.gridOptionsWrapper.isForPrint();
        if (suppressMove) {
            return;
        }
        if (eHeaderCellLabel) {
            var dragSource_1 = {
                type: dragAndDropService_1.DragSourceType.HeaderCell,
                eElement: eHeaderCellLabel,
                dragItemCallback: function () { return _this.createDragItem(); },
                dragItemName: this.displayName,
                dragSourceDropTarget: this.dragSourceDropTarget
            };
            this.dragAndDropService.addDragSource(dragSource_1, true);
            this.addDestroyFunc(function () { return _this.dragAndDropService.removeDragSource(dragSource_1); });
        }
    };
    RenderedHeaderCell.prototype.createDragItem = function () {
        var visibleState = {};
        visibleState[this.column.getId()] = this.column.isVisible();
        return {
            columns: [this.column],
            visibleState: visibleState
        };
    };
    RenderedHeaderCell.prototype.setupTap = function () {
        var _this = this;
        if (this.gridOptionsWrapper.isSuppressTouch()) {
            return;
        }
        var touchListener = new touchListener_1.TouchListener(this.getGui());
        var tapListener = function (event) {
            _this.sortController.progressSort(_this.column, false);
        };
        var longTapListener = function (event) {
            _this.gridOptionsWrapper.getApi().showColumnMenuAfterMouseClick(_this.column, event.touchStart);
        };
        this.addDestroyableEventListener(touchListener, touchListener_1.TouchListener.EVENT_TAP, tapListener);
        this.addDestroyableEventListener(touchListener, touchListener_1.TouchListener.EVENT_LONG_TAP, longTapListener);
        this.addDestroyFunc(function () { return touchListener.destroy(); });
    };
    RenderedHeaderCell.prototype.setupResize = function () {
        var _this = this;
        var colDef = this.column.getColDef();
        var eResize = this.queryForHtmlElement('#agResizeBar');
        // if no eResize in template, do nothing
        if (!eResize) {
            return;
        }
        var weWantResize = this.gridOptionsWrapper.isEnableColResize() && !colDef.suppressResize;
        if (!weWantResize) {
            utils_1.Utils.removeFromParent(eResize);
            return;
        }
        this.horizontalDragService.addDragHandling({
            eDraggableElement: eResize,
            eBody: this.eRoot,
            cursor: 'col-resize',
            startAfterPixels: 0,
            onDragStart: this.onDragStart.bind(this),
            onDragging: this.onDragging.bind(this)
        });
        var weWantAutoSize = !this.gridOptionsWrapper.isSuppressAutoSize() && !colDef.suppressAutoSize;
        if (weWantAutoSize) {
            this.addDestroyableEventListener(eResize, 'dblclick', function () {
                _this.columnController.autoSizeColumn(_this.column);
            });
        }
    };
    RenderedHeaderCell.prototype.useRenderer = function (headerNameValue, headerCellRenderer, eText) {
        // renderer provided, use it
        var cellRendererParams = {
            colDef: this.column.getColDef(),
            $scope: this.childScope,
            context: this.gridOptionsWrapper.getContext(),
            value: headerNameValue,
            api: this.gridOptionsWrapper.getApi(),
            eHeaderCell: this.getGui()
        };
        var cellRendererResult = headerCellRenderer(cellRendererParams);
        var childToAppend;
        if (utils_1.Utils.isNodeOrElement(cellRendererResult)) {
            // a dom node or element was returned, so add child
            childToAppend = cellRendererResult;
        }
        else {
            // otherwise assume it was html, so just insert
            var eTextSpan = document.createElement("span");
            eTextSpan.innerHTML = cellRendererResult;
            childToAppend = eTextSpan;
        }
        // angular compile header if option is turned on
        if (this.gridOptionsWrapper.isAngularCompileHeaders()) {
            var childToAppendCompiled = this.$compile(childToAppend)(this.childScope)[0];
            eText.appendChild(childToAppendCompiled);
        }
        else {
            eText.appendChild(childToAppend);
        }
    };
    RenderedHeaderCell.prototype.setupSort = function (eHeaderCellLabel) {
        var _this = this;
        var enableSorting = this.gridOptionsWrapper.isEnableSorting() && !this.column.getColDef().suppressSorting;
        var element = this.getGui();
        if (!enableSorting) {
            utils_1.Utils.removeFromParent(element.querySelector('#agSortAsc'));
            utils_1.Utils.removeFromParent(element.querySelector('#agSortDesc'));
            utils_1.Utils.removeFromParent(element.querySelector('#agNoSort'));
            return;
        }
        // add sortable class for styling
        utils_1.Utils.addCssClass(element, 'ag-header-cell-sortable');
        // add the event on the header, so when clicked, we do sorting
        if (eHeaderCellLabel) {
            eHeaderCellLabel.addEventListener("click", function (event) {
                _this.sortController.progressSort(_this.column, event.shiftKey);
            });
        }
        // add listener for sort changing, and update the icons accordingly
        this.eSortAsc = this.queryForHtmlElement('#agSortAsc');
        this.eSortDesc = this.queryForHtmlElement('#agSortDesc');
        this.eSortNone = this.queryForHtmlElement('#agNoSort');
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
        this.onSortChanged();
    };
    RenderedHeaderCell.prototype.onSortChanged = function () {
        utils_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-header-cell-sorted-asc', this.column.isSortAscending());
        utils_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-header-cell-sorted-desc', this.column.isSortDescending());
        utils_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-header-cell-sorted-none', this.column.isSortNone());
        if (this.eSortAsc) {
            utils_1.Utils.addOrRemoveCssClass(this.eSortAsc, 'ag-hidden', !this.column.isSortAscending());
        }
        if (this.eSortDesc) {
            utils_1.Utils.addOrRemoveCssClass(this.eSortDesc, 'ag-hidden', !this.column.isSortDescending());
        }
        if (this.eSortNone) {
            var alwaysHideNoSort = !this.column.getColDef().unSortIcon && !this.gridOptionsWrapper.isUnSortIcon();
            utils_1.Utils.addOrRemoveCssClass(this.eSortNone, 'ag-hidden', alwaysHideNoSort || !this.column.isSortNone());
        }
    };
    RenderedHeaderCell.prototype.onDragStart = function () {
        this.startWidth = this.column.getActualWidth();
    };
    // optionally inverts the drag, depending on pinned and RTL
    // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
    RenderedHeaderCell.prototype.normaliseDragChange = function (dragChange) {
        var result = dragChange;
        if (this.gridOptionsWrapper.isEnableRtl()) {
            // for RTL, dragging left makes the col bigger, except when pinning left
            if (this.pinned !== column_1.Column.PINNED_LEFT) {
                result *= -1;
            }
        }
        else {
            // for LTR (ie normal), dragging left makes the col smaller, except when pinning right
            if (this.pinned === column_1.Column.PINNED_RIGHT) {
                result *= -1;
            }
        }
        return result;
    };
    RenderedHeaderCell.prototype.onDragging = function (dragChange, finished) {
        var dragChangeNormalised = this.normaliseDragChange(dragChange);
        var newWidth = this.startWidth + dragChangeNormalised;
        this.columnController.setColumnWidth(this.column, newWidth, finished);
    };
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], RenderedHeaderCell.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('filterManager'),
        __metadata("design:type", filterManager_1.FilterManager)
    ], RenderedHeaderCell.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], RenderedHeaderCell.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('$compile'),
        __metadata("design:type", Object)
    ], RenderedHeaderCell.prototype, "$compile", void 0);
    __decorate([
        context_1.Autowired('gridCore'),
        __metadata("design:type", gridCore_1.GridCore)
    ], RenderedHeaderCell.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('headerTemplateLoader'),
        __metadata("design:type", headerTemplateLoader_1.HeaderTemplateLoader)
    ], RenderedHeaderCell.prototype, "headerTemplateLoader", void 0);
    __decorate([
        context_1.Autowired('horizontalDragService'),
        __metadata("design:type", horizontalDragService_1.HorizontalDragService)
    ], RenderedHeaderCell.prototype, "horizontalDragService", void 0);
    __decorate([
        context_1.Autowired('menuFactory'),
        __metadata("design:type", Object)
    ], RenderedHeaderCell.prototype, "menuFactory", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], RenderedHeaderCell.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'),
        __metadata("design:type", dragAndDropService_1.DragAndDropService)
    ], RenderedHeaderCell.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.Autowired('sortController'),
        __metadata("design:type", sortController_1.SortController)
    ], RenderedHeaderCell.prototype, "sortController", void 0);
    __decorate([
        context_1.Autowired('$scope'),
        __metadata("design:type", Object)
    ], RenderedHeaderCell.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('beans'),
        __metadata("design:type", beans_1.Beans)
    ], RenderedHeaderCell.prototype, "beans", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], RenderedHeaderCell.prototype, "init", null);
    return RenderedHeaderCell;
}(component_1.Component));
exports.RenderedHeaderCell = RenderedHeaderCell;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var BorderLayout = (function () {
    function BorderLayout(params) {
        this.centerHeightLastTime = -1;
        this.centerWidthLastTime = -1;
        this.centerLeftMarginLastTime = -1;
        this.visibleLastTime = false;
        this.sizeChangeListeners = [];
        this.isLayoutPanel = true;
        this.fullHeight = !params.north && !params.south;
        var template;
        if (params.dontFill) {
            template = BorderLayout.TEMPLATE_DONT_FILL;
            this.horizontalLayoutActive = false;
            this.verticalLayoutActive = false;
        }
        else if (params.fillHorizontalOnly) {
            template = BorderLayout.TEMPLATE_DONT_FILL;
            this.horizontalLayoutActive = true;
            this.verticalLayoutActive = false;
        }
        else {
            if (this.fullHeight) {
                template = BorderLayout.TEMPLATE_FULL_HEIGHT;
            }
            else {
                template = BorderLayout.TEMPLATE_NORMAL;
            }
            this.horizontalLayoutActive = true;
            this.verticalLayoutActive = true;
        }
        this.eGui = utils_1.Utils.loadTemplate(template);
        this.id = 'borderLayout';
        if (params.name) {
            this.id += '_' + params.name;
        }
        this.eGui.setAttribute('id', this.id);
        this.childPanels = [];
        if (params) {
            this.setupPanels(params);
        }
        this.overlays = params.overlays;
        this.setupOverlays();
    }
    BorderLayout.prototype.addSizeChangeListener = function (listener) {
        this.sizeChangeListeners.push(listener);
    };
    BorderLayout.prototype.fireSizeChanged = function () {
        this.sizeChangeListeners.forEach(function (listener) {
            listener();
        });
    };
    // this logic is also in Component.ts - the plan is sometime in the future,
    // this layout panel may (or may not) extend the Component class, and somehow
    // act as a component.
    BorderLayout.prototype.getRefElement = function (refName) {
        return this.eGui.querySelector('[ref="' + refName + '"]');
    };
    BorderLayout.prototype.setupPanels = function (params) {
        this.eNorthWrapper = this.getRefElement('north');
        this.eSouthWrapper = this.getRefElement('south');
        this.eEastWrapper = this.getRefElement('east');
        this.eWestWrapper = this.getRefElement('west');
        this.eCenterWrapper = this.getRefElement('center');
        this.eOverlayWrapper = this.getRefElement('overlay');
        this.eCenterRow = this.getRefElement('centerRow');
        this.eNorthChildLayout = this.setupPanel(params.north, this.eNorthWrapper);
        this.eSouthChildLayout = this.setupPanel(params.south, this.eSouthWrapper);
        this.eEastChildLayout = this.setupPanel(params.east, this.eEastWrapper);
        this.eWestChildLayout = this.setupPanel(params.west, this.eWestWrapper);
        this.eCenterChildLayout = this.setupPanel(params.center, this.eCenterWrapper);
    };
    BorderLayout.prototype.setupPanel = function (content, ePanel) {
        if (!ePanel) {
            return;
        }
        if (content) {
            if (content.isLayoutPanel) {
                this.childPanels.push(content);
                ePanel.appendChild(content.getGui());
                return content;
            }
            else {
                ePanel.appendChild(content);
                return null;
            }
        }
        else {
            ePanel.parentNode.removeChild(ePanel);
            return null;
        }
    };
    BorderLayout.prototype.getGui = function () {
        return this.eGui;
    };
    // returns true if any item changed size, otherwise returns false
    BorderLayout.prototype.doLayout = function () {
        var _this = this;
        var isVisible = utils_1.Utils.isVisible(this.eGui);
        if (!isVisible) {
            this.visibleLastTime = false;
            return false;
        }
        var atLeastOneChanged = false;
        if (this.visibleLastTime !== isVisible) {
            atLeastOneChanged = true;
        }
        this.visibleLastTime = true;
        var childLayouts = [this.eNorthChildLayout, this.eSouthChildLayout, this.eEastChildLayout, this.eWestChildLayout];
        childLayouts.forEach(function (childLayout) {
            var childChangedSize = _this.layoutChild(childLayout);
            if (childChangedSize) {
                atLeastOneChanged = true;
            }
        });
        if (this.horizontalLayoutActive) {
            var ourWidthChanged = this.layoutWidth();
            if (ourWidthChanged) {
                atLeastOneChanged = true;
            }
        }
        if (this.verticalLayoutActive) {
            var ourHeightChanged = this.layoutHeight();
            if (ourHeightChanged) {
                atLeastOneChanged = true;
            }
        }
        var centerChanged = this.layoutChild(this.eCenterChildLayout);
        if (centerChanged) {
            atLeastOneChanged = true;
        }
        if (atLeastOneChanged) {
            this.fireSizeChanged();
        }
        return atLeastOneChanged;
    };
    BorderLayout.prototype.layoutChild = function (childPanel) {
        if (childPanel) {
            return childPanel.doLayout();
        }
        else {
            return false;
        }
    };
    BorderLayout.prototype.layoutHeight = function () {
        if (this.fullHeight) {
            return this.layoutHeightFullHeight();
        }
        else {
            return this.layoutHeightNormal();
        }
    };
    // full height never changes the height, because the center is always 100%,
    // however we do check for change, to inform the listeners
    BorderLayout.prototype.layoutHeightFullHeight = function () {
        var centerHeight = utils_1.Utils.offsetHeight(this.eGui);
        if (centerHeight < 0) {
            centerHeight = 0;
        }
        if (this.centerHeightLastTime !== centerHeight) {
            this.centerHeightLastTime = centerHeight;
            return true;
        }
        else {
            return false;
        }
    };
    BorderLayout.prototype.layoutHeightNormal = function () {
        var totalHeight = utils_1.Utils.offsetHeight(this.eGui);
        var northHeight = utils_1.Utils.offsetHeight(this.eNorthWrapper);
        var southHeight = utils_1.Utils.offsetHeight(this.eSouthWrapper);
        var centerHeight = totalHeight - northHeight - southHeight;
        if (centerHeight < 0) {
            centerHeight = 0;
        }
        if (this.centerHeightLastTime !== centerHeight) {
            this.eCenterRow.style.height = centerHeight + 'px';
            this.centerHeightLastTime = centerHeight;
            return true; // return true because there was a change
        }
        else {
            return false;
        }
    };
    BorderLayout.prototype.getCentreHeight = function () {
        return this.centerHeightLastTime;
    };
    BorderLayout.prototype.layoutWidth = function () {
        var totalWidth = utils_1.Utils.offsetWidth(this.eGui);
        var eastWidth = utils_1.Utils.offsetWidth(this.eEastWrapper);
        var westWidth = utils_1.Utils.offsetWidth(this.eWestWrapper);
        var centerWidth = totalWidth - eastWidth - westWidth;
        if (centerWidth < 0) {
            centerWidth = 0;
        }
        var atLeastOneChanged = false;
        if (this.centerLeftMarginLastTime !== westWidth) {
            this.centerLeftMarginLastTime = westWidth;
            this.eCenterWrapper.style.marginLeft = westWidth + 'px';
            atLeastOneChanged = true;
        }
        if (this.centerWidthLastTime !== centerWidth) {
            this.centerWidthLastTime = centerWidth;
            this.eCenterWrapper.style.width = centerWidth + 'px';
            atLeastOneChanged = true;
        }
        return atLeastOneChanged;
    };
    BorderLayout.prototype.setEastVisible = function (visible) {
        if (this.eEastWrapper) {
            this.eEastWrapper.style.display = visible ? '' : 'none';
        }
        this.doLayout();
    };
    BorderLayout.prototype.setupOverlays = function () {
        // if no overlays, just remove the panel
        if (!this.overlays) {
            this.eOverlayWrapper.parentNode.removeChild(this.eOverlayWrapper);
            return;
        }
        this.hideOverlay();
    };
    BorderLayout.prototype.hideOverlay = function () {
        utils_1.Utils.removeAllChildren(this.eOverlayWrapper);
        this.eOverlayWrapper.style.display = 'none';
    };
    BorderLayout.prototype.showOverlay = function (key) {
        var overlay = this.overlays ? this.overlays[key] : null;
        if (overlay) {
            utils_1.Utils.removeAllChildren(this.eOverlayWrapper);
            this.eOverlayWrapper.style.display = '';
            this.eOverlayWrapper.appendChild(overlay);
        }
        else {
            console.log('ag-Grid: unknown overlay');
            this.hideOverlay();
        }
    };
    // this is used if there user has not specified any north or south parts
    BorderLayout.TEMPLATE_FULL_HEIGHT = '<div class="ag-bl ag-bl-full-height">' +
        '  <div class="ag-bl-west ag-bl-full-height-west" ref="west"></div>' +
        '  <div class="ag-bl-east ag-bl-full-height-east" ref="east"></div>' +
        '  <div class="ag-bl-center ag-bl-full-height-center" ref="center"></div>' +
        '  <div class="ag-bl-overlay" ref="overlay"></div>' +
        '</div>';
    BorderLayout.TEMPLATE_NORMAL = '<div class="ag-bl ag-bl-normal">' +
        '  <div ref="north"></div>' +
        '  <div class="ag-bl-center-row ag-bl-normal-center-row" ref="centerRow">' +
        '    <div class="ag-bl-west ag-bl-normal-west" ref="west"></div>' +
        '    <div class="ag-bl-east ag-bl-normal-east" ref="east"></div>' +
        '    <div class="ag-bl-center ag-bl-normal-center" ref="center"></div>' +
        '  </div>' +
        '  <div ref="south"></div>' +
        '  <div class="ag-bl-overlay" ref="overlay"></div>' +
        '</div>';
    BorderLayout.TEMPLATE_DONT_FILL = '<div class="ag-bl ag-bl-dont-fill">' +
        '  <div ref="north"></div>' +
        '  <div ref="centerRow" class="ag-bl-center-row ag-bl-dont-fill-center-row">' +
        '    <div ref="west" class="ag-bl-west ag-bl-dont-fill-west"></div>' +
        '    <div ref="east" class="ag-bl-east ag-bl-dont-fill-east"></div>' +
        '    <div ref="center" class="ag-bl-center ag-bl-dont-fill-center"></div>' +
        '  </div>' +
        '  <div ref="south"></div>' +
        '  <div class="ag-bl-overlay" ref="overlay"></div>' +
        '</div>';
    return BorderLayout;
}());
exports.BorderLayout = BorderLayout;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var rowRenderer_1 = __webpack_require__(18);
var gridPanel_1 = __webpack_require__(10);
var context_1 = __webpack_require__(0);
var context_2 = __webpack_require__(0);
var headerRenderer_1 = __webpack_require__(54);
var renderedHeaderCell_1 = __webpack_require__(75);
var gridOptionsWrapper_1 = __webpack_require__(2);
var headerWrapperComp_1 = __webpack_require__(104);
var AutoWidthCalculator = (function () {
    function AutoWidthCalculator() {
    }
    // this is the trick: we create a dummy container and clone all the cells
    // into the dummy, then check the dummy's width. then destroy the dummy
    // as we don't need it any more.
    // drawback: only the cells visible on the screen are considered
    AutoWidthCalculator.prototype.getPreferredWidthForColumn = function (column) {
        var eHeaderCell = this.getHeaderCellForColumn(column);
        // cell isn't visible
        if (!eHeaderCell) {
            return -1;
        }
        var eDummyContainer = document.createElement('span');
        // position fixed, so it isn't restricted to the boundaries of the parent
        eDummyContainer.style.position = 'fixed';
        // we put the dummy into the body container, so it will inherit all the
        // css styles that the real cells are inheriting
        var eBodyContainer = this.gridPanel.getBodyContainer();
        eBodyContainer.appendChild(eDummyContainer);
        // get all the cells that are currently displayed (this only brings back
        // rendered cells, rows not rendered due to row visualisation will not be here)
        this.putRowCellsIntoDummyContainer(column, eDummyContainer);
        // also put header cell in
        // we only consider the lowest level cell, not the group cell. in 99% of the time, this
        // will be enough. if we consider groups, then it gets to complicated for what it's worth,
        // as the groups can span columns and this class only considers one column at a time.
        this.cloneItemIntoDummy(eHeaderCell, eDummyContainer);
        // at this point, all the clones are lined up vertically with natural widths. the dummy
        // container will have a width wide enough just to fit the largest.
        var dummyContainerWidth = eDummyContainer.offsetWidth;
        // we are finished with the dummy container, so get rid of it
        eBodyContainer.removeChild(eDummyContainer);
        // we add padding as I found without it, the gui still put '...' after some of the texts
        var autoSizePadding = this.gridOptionsWrapper.getAutoSizePadding();
        return dummyContainerWidth + autoSizePadding;
    };
    AutoWidthCalculator.prototype.getHeaderCellForColumn = function (column) {
        var comp = null;
        // find the rendered header cell
        this.headerRenderer.forEachHeaderElement(function (headerElement) {
            if (headerElement instanceof renderedHeaderCell_1.RenderedHeaderCell) {
                var currentCell = headerElement;
                if (currentCell.getColumn() === column) {
                    comp = currentCell;
                }
            }
            else if (headerElement instanceof headerWrapperComp_1.HeaderWrapperComp) {
                var headerWrapperComp = headerElement;
                if (headerWrapperComp.getColumn() === column) {
                    comp = headerWrapperComp;
                }
            }
        });
        return comp ? comp.getGui() : null;
    };
    AutoWidthCalculator.prototype.putRowCellsIntoDummyContainer = function (column, eDummyContainer) {
        var _this = this;
        var eCells = this.rowRenderer.getAllCellsForColumn(column);
        eCells.forEach(function (eCell) { return _this.cloneItemIntoDummy(eCell, eDummyContainer); });
    };
    AutoWidthCalculator.prototype.cloneItemIntoDummy = function (eCell, eDummyContainer) {
        // make a deep clone of the cell
        var eCellClone = eCell.cloneNode(true);
        // the original has a fixed width, we remove this to allow the natural width based on content
        eCellClone.style.width = '';
        // the original has position = absolute, we need to remove this so it's positioned normally
        eCellClone.style.position = 'static';
        eCellClone.style.left = '';
        // we put the cell into a containing div, as otherwise the cells would just line up
        // on the same line, standard flow layout, by putting them into divs, they are laid
        // out one per line
        var eCloneParent = document.createElement('div');
        // table-row, so that each cell is on a row. i also tried display='block', but this
        // didn't work in IE
        eCloneParent.style.display = 'table-row';
        // the twig on the branch, the branch on the tree, the tree in the hole,
        // the hole in the bog, the bog in the clone, the clone in the parent,
        // the parent in the dummy, and the dummy down in the vall-e-ooo, OOOOOOOOO! Oh row the rattling bog....
        eCloneParent.appendChild(eCellClone);
        eDummyContainer.appendChild(eCloneParent);
    };
    __decorate([
        context_2.Autowired('rowRenderer'),
        __metadata("design:type", rowRenderer_1.RowRenderer)
    ], AutoWidthCalculator.prototype, "rowRenderer", void 0);
    __decorate([
        context_2.Autowired('headerRenderer'),
        __metadata("design:type", headerRenderer_1.HeaderRenderer)
    ], AutoWidthCalculator.prototype, "headerRenderer", void 0);
    __decorate([
        context_2.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], AutoWidthCalculator.prototype, "gridPanel", void 0);
    __decorate([
        context_2.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], AutoWidthCalculator.prototype, "gridOptionsWrapper", void 0);
    AutoWidthCalculator = __decorate([
        context_1.Bean('autoWidthCalculator')
    ], AutoWidthCalculator);
    return AutoWidthCalculator;
}());
exports.AutoWidthCalculator = AutoWidthCalculator;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var PopupEditorWrapper = (function (_super) {
    __extends(PopupEditorWrapper, _super);
    function PopupEditorWrapper(cellEditor) {
        var _this = _super.call(this, "<div class=\"ag-popup-editor\" tabindex=\"-1\"/>") || this;
        _this.getGuiCalledOnChild = false;
        _this.cellEditor = cellEditor;
        return _this;
    }
    PopupEditorWrapper.prototype.onKeyDown = function (event) {
        this.params.onKeyDown(event);
    };
    PopupEditorWrapper.prototype.getGui = function () {
        // we call getGui() on child here (rather than in the constructor)
        // as we should wait for 'init' to be called on child first.
        if (!this.getGuiCalledOnChild) {
            this.appendChild(this.cellEditor.getGui());
            this.getGuiCalledOnChild = true;
        }
        return _super.prototype.getGui.call(this);
    };
    PopupEditorWrapper.prototype.init = function (params) {
        var _this = this;
        this.params = params;
        this.gridOptionsWrapper.setDomData(this.getGui(), PopupEditorWrapper.DOM_KEY_POPUP_EDITOR_WRAPPER, true);
        this.addDestroyFunc(function () {
            if (_this.cellEditor.destroy) {
                _this.cellEditor.destroy();
            }
        });
        this.addDestroyableEventListener(
        // this needs to be 'super' and not 'this' as if we call 'this',
        // it ends up called 'getGui()' on the child before 'init' was called,
        // which is not good
        _super.prototype.getGui.call(this), 'keydown', this.onKeyDown.bind(this));
    };
    PopupEditorWrapper.prototype.afterGuiAttached = function () {
        if (this.cellEditor.afterGuiAttached) {
            this.cellEditor.afterGuiAttached();
        }
    };
    PopupEditorWrapper.prototype.getValue = function () {
        return this.cellEditor.getValue();
    };
    PopupEditorWrapper.prototype.isPopup = function () {
        return true;
    };
    PopupEditorWrapper.prototype.isCancelBeforeStart = function () {
        if (this.cellEditor.isCancelBeforeStart) {
            return this.cellEditor.isCancelBeforeStart();
        }
    };
    PopupEditorWrapper.prototype.isCancelAfterEnd = function () {
        if (this.cellEditor.isCancelAfterEnd) {
            return this.cellEditor.isCancelAfterEnd();
        }
    };
    PopupEditorWrapper.prototype.focusIn = function () {
        if (this.cellEditor.focusIn) {
            this.cellEditor.focusIn();
        }
    };
    PopupEditorWrapper.prototype.focusOut = function () {
        if (this.cellEditor.focusOut) {
            this.cellEditor.focusOut();
        }
    };
    PopupEditorWrapper.DOM_KEY_POPUP_EDITOR_WRAPPER = 'popupEditorWrapper';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], PopupEditorWrapper.prototype, "gridOptionsWrapper", void 0);
    return PopupEditorWrapper;
}(component_1.Component));
exports.PopupEditorWrapper = PopupEditorWrapper;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var utils_1 = __webpack_require__(1);
var constants_1 = __webpack_require__(7);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var valueFormatterService_1 = __webpack_require__(43);
var SelectCellEditor = (function (_super) {
    __extends(SelectCellEditor, _super);
    function SelectCellEditor() {
        var _this = _super.call(this, '<div class="ag-cell-edit-input"><select class="ag-cell-edit-input"/></div>') || this;
        _this.eSelect = _this.getGui().querySelector('select');
        return _this;
    }
    SelectCellEditor.prototype.init = function (params) {
        var _this = this;
        this.focusAfterAttached = params.cellStartedEdit;
        if (utils_1.Utils.missing(params.values)) {
            console.log('ag-Grid: no values found for select cellEditor');
            return;
        }
        params.values.forEach(function (value) {
            var option = document.createElement('option');
            option.value = value;
            var valueFormatted = _this.valueFormatterService.formatValue(params.column, null, null, value);
            var valueFormattedExits = valueFormatted !== null && valueFormatted !== undefined;
            option.text = valueFormattedExits ? valueFormatted : value;
            if (params.value === value) {
                option.selected = true;
            }
            _this.eSelect.appendChild(option);
        });
        // we don't want to add this if full row editing, otherwise selecting will stop the
        // full row editing.
        if (!this.gridOptionsWrapper.isFullRowEdit()) {
            this.addDestroyableEventListener(this.eSelect, 'change', function () { return params.stopEditing(); });
        }
        this.addDestroyableEventListener(this.eSelect, 'keydown', function (event) {
            var isNavigationKey = event.keyCode === constants_1.Constants.KEY_UP || event.keyCode === constants_1.Constants.KEY_DOWN;
            if (isNavigationKey) {
                event.stopPropagation();
            }
        });
        this.addDestroyableEventListener(this.eSelect, 'mousedown', function (event) {
            event.stopPropagation();
        });
    };
    SelectCellEditor.prototype.afterGuiAttached = function () {
        if (this.focusAfterAttached) {
            this.eSelect.focus();
        }
    };
    SelectCellEditor.prototype.focusIn = function () {
        this.eSelect.focus();
    };
    SelectCellEditor.prototype.getValue = function () {
        return this.eSelect.value;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], SelectCellEditor.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('valueFormatterService'),
        __metadata("design:type", valueFormatterService_1.ValueFormatterService)
    ], SelectCellEditor.prototype, "valueFormatterService", void 0);
    return SelectCellEditor;
}(component_1.Component));
exports.SelectCellEditor = SelectCellEditor;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(7);
var component_1 = __webpack_require__(8);
var utils_1 = __webpack_require__(1);
var TextCellEditor = (function (_super) {
    __extends(TextCellEditor, _super);
    function TextCellEditor() {
        return _super.call(this, TextCellEditor.TEMPLATE) || this;
    }
    TextCellEditor.prototype.init = function (params) {
        this.params = params;
        var eInput = this.getGui();
        var startValue;
        // cellStartedEdit is only false if we are doing fullRow editing
        if (params.cellStartedEdit) {
            this.focusAfterAttached = true;
            var keyPressBackspaceOrDelete = params.keyPress === constants_1.Constants.KEY_BACKSPACE
                || params.keyPress === constants_1.Constants.KEY_DELETE;
            if (keyPressBackspaceOrDelete) {
                startValue = '';
            }
            else if (params.charPress) {
                startValue = params.charPress;
            }
            else {
                startValue = this.getStartValue(params);
                if (params.keyPress !== constants_1.Constants.KEY_F2) {
                    this.highlightAllOnFocus = true;
                }
            }
        }
        else {
            this.focusAfterAttached = false;
            startValue = this.getStartValue(params);
        }
        if (utils_1.Utils.exists(startValue)) {
            eInput.value = startValue;
        }
        this.addDestroyableEventListener(eInput, 'keydown', function (event) {
            var isNavigationKey = event.keyCode === constants_1.Constants.KEY_LEFT
                || event.keyCode === constants_1.Constants.KEY_RIGHT
                || event.keyCode === constants_1.Constants.KEY_UP
                || event.keyCode === constants_1.Constants.KEY_DOWN
                || event.keyCode === constants_1.Constants.KEY_PAGE_DOWN
                || event.keyCode === constants_1.Constants.KEY_PAGE_UP
                || event.keyCode === constants_1.Constants.KEY_PAGE_HOME
                || event.keyCode === constants_1.Constants.KEY_PAGE_END;
            if (isNavigationKey) {
                // this stops the grid from executing keyboard navigation
                event.stopPropagation();
                if (!(event.keyCode === constants_1.Constants.KEY_LEFT) && !(event.keyCode === constants_1.Constants.KEY_RIGHT)) {
                    // this stops the browser from scrolling
                    event.preventDefault();
                }
            }
        });
    };
    TextCellEditor.prototype.afterGuiAttached = function () {
        if (!this.focusAfterAttached) {
            return;
        }
        var eInput = this.getGui();
        eInput.focus();
        if (this.highlightAllOnFocus) {
            eInput.select();
        }
        else {
            // when we started editing, we want the carot at the end, not the start.
            // this comes into play in two scenarios: a) when user hits F2 and b)
            // when user hits a printable character, then on IE (and only IE) the carot
            // was placed after the first character, thus 'apply' would end up as 'pplea'
            var length_1 = eInput.value ? eInput.value.length : 0;
            if (length_1 > 0) {
                eInput.setSelectionRange(length_1, length_1);
            }
        }
    };
    // gets called when tabbing trough cells and in full row edit mode
    TextCellEditor.prototype.focusIn = function () {
        var eInput = this.getGui();
        eInput.focus();
        eInput.select();
    };
    TextCellEditor.prototype.getValue = function () {
        var eInput = this.getGui();
        return this.params.parseValue(eInput.value);
    };
    TextCellEditor.prototype.getStartValue = function (params) {
        var formatValue = params.useFormatter || params.column.getColDef().refData;
        return formatValue ? params.formatValue(params.value) : params.value;
    };
    TextCellEditor.TEMPLATE = '<input class="ag-cell-edit-input" type="text"/>';
    return TextCellEditor;
}(component_1.Component));
exports.TextCellEditor = TextCellEditor;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var component_1 = __webpack_require__(8);
var ARROW_UP = '&#65514;';
var ARROW_DOWN = '&#65516;';
var AnimateShowChangeCellRenderer = (function (_super) {
    __extends(AnimateShowChangeCellRenderer, _super);
    function AnimateShowChangeCellRenderer() {
        var _this = _super.call(this, AnimateShowChangeCellRenderer.TEMPLATE) || this;
        _this.refreshCount = 0;
        return _this;
    }
    AnimateShowChangeCellRenderer.prototype.init = function (params) {
        // this.params = params;
        this.eValue = this.queryForHtmlElement('.ag-value-change-value');
        this.eDelta = this.queryForHtmlElement('.ag-value-change-delta');
        this.refresh(params);
    };
    AnimateShowChangeCellRenderer.prototype.showDelta = function (params, delta) {
        var absDelta = Math.abs(delta);
        var valueFormatted = params.formatValue(absDelta);
        var valueToUse = utils_1.Utils.exists(valueFormatted) ? valueFormatted : absDelta;
        var deltaUp = (delta >= 0);
        if (deltaUp) {
            this.eDelta.innerHTML = ARROW_UP + valueToUse;
        }
        else {
            // because negative, use ABS to remove sign
            this.eDelta.innerHTML = ARROW_DOWN + valueToUse;
        }
        // class makes it green (in ag-fresh)
        utils_1.Utils.addOrRemoveCssClass(this.eDelta, 'ag-value-change-delta-up', deltaUp);
        // class makes it red (in ag-fresh)
        utils_1.Utils.addOrRemoveCssClass(this.eDelta, 'ag-value-change-delta-down', !deltaUp);
    };
    AnimateShowChangeCellRenderer.prototype.setTimerToRemoveDelta = function () {
        var _this = this;
        // the refreshCount makes sure that if the value updates again while
        // the below timer is waiting, then the below timer will realise it
        // is not the most recent and will not try to remove the delta value.
        this.refreshCount++;
        var refreshCountCopy = this.refreshCount;
        setTimeout(function () {
            if (refreshCountCopy === _this.refreshCount) {
                _this.hideDeltaValue();
            }
        }, 2000);
    };
    AnimateShowChangeCellRenderer.prototype.hideDeltaValue = function () {
        utils_1.Utils.removeCssClass(this.eValue, 'ag-value-change-value-highlight');
        this.eDelta.innerHTML = '';
    };
    AnimateShowChangeCellRenderer.prototype.refresh = function (params) {
        var value = params.value;
        if (value === this.lastValue) {
            return;
        }
        if (utils_1.Utils.exists(params.valueFormatted)) {
            this.eValue.innerHTML = params.valueFormatted;
        }
        else if (utils_1.Utils.exists(params.value)) {
            this.eValue.innerHTML = value;
        }
        else {
            this.eValue.innerHTML = '';
        }
        if (typeof value === 'number' && typeof this.lastValue === 'number') {
            var delta = value - this.lastValue;
            this.showDelta(params, delta);
        }
        // highlight the current value, but only if it's not new, otherwise it
        // would get highlighted first time the value is shown
        if (this.lastValue) {
            utils_1.Utils.addCssClass(this.eValue, 'ag-value-change-value-highlight');
        }
        this.setTimerToRemoveDelta();
        this.lastValue = value;
        return true;
    };
    AnimateShowChangeCellRenderer.TEMPLATE = '<span>' +
        '<span class="ag-value-change-delta"></span>' +
        '<span class="ag-value-change-value"></span>' +
        '</span>';
    return AnimateShowChangeCellRenderer;
}(component_1.Component));
exports.AnimateShowChangeCellRenderer = AnimateShowChangeCellRenderer;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var component_1 = __webpack_require__(8);
var AnimateSlideCellRenderer = (function (_super) {
    __extends(AnimateSlideCellRenderer, _super);
    function AnimateSlideCellRenderer() {
        var _this = _super.call(this, AnimateSlideCellRenderer.TEMPLATE) || this;
        _this.refreshCount = 0;
        _this.eCurrent = _this.queryForHtmlElement('.ag-value-slide-current');
        return _this;
    }
    AnimateSlideCellRenderer.prototype.init = function (params) {
        this.params = params;
        this.refresh(params);
    };
    AnimateSlideCellRenderer.prototype.addSlideAnimation = function () {
        var _this = this;
        this.refreshCount++;
        // below we keep checking this, and stop working on the animation
        // if it no longer matches - this means another animation has started
        // and this one is stale.
        var refreshCountCopy = this.refreshCount;
        // if old animation, remove it
        if (this.ePrevious) {
            this.getGui().removeChild(this.ePrevious);
        }
        this.ePrevious = utils_1.Utils.loadTemplate('<span class="ag-value-slide-previous ag-value-slide-out"></span>');
        this.ePrevious.innerHTML = this.eCurrent.innerHTML;
        this.getGui().insertBefore(this.ePrevious, this.eCurrent);
        // having timeout of 0 allows use to skip to the next css turn,
        // so we know the previous css classes have been applied. so the
        // complex set of setTimeout below creates the animation
        setTimeout(function () {
            if (refreshCountCopy !== _this.refreshCount) {
                return;
            }
            utils_1.Utils.addCssClass(_this.ePrevious, 'ag-value-slide-out-end');
        }, 50);
        setTimeout(function () {
            if (refreshCountCopy !== _this.refreshCount) {
                return;
            }
            _this.getGui().removeChild(_this.ePrevious);
            _this.ePrevious = null;
        }, 3000);
    };
    AnimateSlideCellRenderer.prototype.refresh = function (params) {
        var value = params.value;
        if (utils_1.Utils.missing(value)) {
            value = '';
        }
        if (value === this.lastValue) {
            return;
        }
        this.addSlideAnimation();
        this.lastValue = value;
        if (utils_1.Utils.exists(params.valueFormatted)) {
            this.eCurrent.innerHTML = params.valueFormatted;
        }
        else if (utils_1.Utils.exists(params.value)) {
            this.eCurrent.innerHTML = value;
        }
        else {
            this.eCurrent.innerHTML = '';
        }
        return true;
    };
    AnimateSlideCellRenderer.TEMPLATE = '<span>' +
        '<span class="ag-value-slide-current"></span>' +
        '</span>';
    return AnimateSlideCellRenderer;
}(component_1.Component));
exports.AnimateSlideCellRenderer = AnimateSlideCellRenderer;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var gridOptionsWrapper_1 = __webpack_require__(2);
var expressionService_1 = __webpack_require__(19);
var eventService_1 = __webpack_require__(4);
var constants_1 = __webpack_require__(7);
var utils_1 = __webpack_require__(1);
var context_1 = __webpack_require__(0);
var component_1 = __webpack_require__(8);
var rowNode_1 = __webpack_require__(15);
var cellRendererService_1 = __webpack_require__(57);
var valueFormatterService_1 = __webpack_require__(43);
var checkboxSelectionComponent_1 = __webpack_require__(84);
var columnController_1 = __webpack_require__(3);
var column_1 = __webpack_require__(9);
var componentAnnotations_1 = __webpack_require__(12);
var mouseEventService_1 = __webpack_require__(38);
var GroupCellRenderer = (function (_super) {
    __extends(GroupCellRenderer, _super);
    function GroupCellRenderer() {
        return _super.call(this, GroupCellRenderer.TEMPLATE) || this;
    }
    GroupCellRenderer.prototype.init = function (params) {
        this.params = params;
        var embeddedRowMismatch = this.isEmbeddedRowMismatch();
        // This allows for empty strings to appear as groups since
        // it will only return for null or undefined.
        var cellIsEmpty = params.value == null;
        this.cellIsBlank = embeddedRowMismatch || cellIsEmpty;
        if (this.cellIsBlank) {
            return;
        }
        this.setupDragOpenParents();
        this.addExpandAndContract();
        this.addCheckboxIfNeeded();
        this.addValueElement();
        this.addPadding();
    };
    // if we are doing embedded full width rows, we only show the renderer when
    // in the body, or if pinning in the pinned section, or if pinning and RTL,
    // in the right section. otherwise we would have the cell repeated in each section.
    GroupCellRenderer.prototype.isEmbeddedRowMismatch = function () {
        if (this.gridOptionsWrapper.isEmbedFullWidthRows()) {
            var pinnedLeftCell = this.params.pinned === column_1.Column.PINNED_LEFT;
            var pinnedRightCell = this.params.pinned === column_1.Column.PINNED_RIGHT;
            var bodyCell = !pinnedLeftCell && !pinnedRightCell;
            if (this.gridOptionsWrapper.isEnableRtl()) {
                if (this.columnController.isPinningLeft()) {
                    return !pinnedRightCell;
                }
                else {
                    return !bodyCell;
                }
            }
            else {
                if (this.columnController.isPinningLeft()) {
                    return !pinnedLeftCell;
                }
                else {
                    return !bodyCell;
                }
            }
        }
        else {
            return false;
        }
    };
    GroupCellRenderer.prototype.setPadding = function () {
        if (this.gridOptionsWrapper.isGroupHideOpenParents()) {
            return;
        }
        var params = this.params;
        var rowNode = params.node;
        var paddingPx;
        // never any padding on top level nodes
        if (rowNode.uiLevel <= 0) {
            paddingPx = 0;
        }
        else {
            var paddingFactor = (params.padding >= 0) ? params.padding : this.gridOptionsWrapper.getGroupPaddingSize();
            paddingPx = rowNode.uiLevel * paddingFactor;
            var reducedLeafNode = this.columnController.isPivotMode() && params.node.leafGroup;
            if (rowNode.footer) {
                paddingPx += this.gridOptionsWrapper.getFooterPaddingAddition();
            }
            else if (!rowNode.isExpandable() || reducedLeafNode) {
                paddingPx += this.gridOptionsWrapper.getLeafNodePaddingAddition();
            }
        }
        if (this.gridOptionsWrapper.isEnableRtl()) {
            // if doing rtl, padding is on the right
            this.getGui().style.paddingRight = paddingPx + 'px';
        }
        else {
            // otherwise it is on the left
            this.getGui().style.paddingLeft = paddingPx + 'px';
        }
    };
    GroupCellRenderer.prototype.addPadding = function () {
        // only do this if an indent - as this overwrites the padding that
        // the theme set, which will make things look 'not aligned' for the
        // first group level.
        var node = this.params.node;
        var suppressPadding = this.params.suppressPadding;
        if (!suppressPadding) {
            this.addDestroyableEventListener(node, rowNode_1.RowNode.EVENT_UI_LEVEL_CHANGED, this.setPadding.bind(this));
            this.setPadding();
        }
    };
    GroupCellRenderer.prototype.addValueElement = function () {
        var params = this.params;
        var rowNode = this.displayedGroup;
        if (rowNode.footer) {
            this.createFooterCell();
        }
        else if (rowNode.hasChildren() ||
            utils_1.Utils.get(params.colDef, 'cellRendererParams.innerRenderer', null) ||
            utils_1.Utils.get(params.colDef, 'cellRendererParams.innerRendererFramework', null)) {
            this.createGroupCell();
            if (rowNode.hasChildren()) {
                this.addChildCount();
            }
        }
        else {
            this.createLeafCell();
        }
    };
    GroupCellRenderer.prototype.createFooterCell = function () {
        var footerValue;
        var footerValueGetter = this.params.footerValueGetter;
        if (footerValueGetter) {
            // params is same as we were given, except we set the value as the item to display
            var paramsClone = utils_1.Utils.cloneObject(this.params);
            paramsClone.value = this.params.value;
            if (typeof footerValueGetter === 'function') {
                footerValue = footerValueGetter(paramsClone);
            }
            else if (typeof footerValueGetter === 'string') {
                footerValue = this.expressionService.evaluate(footerValueGetter, paramsClone);
            }
            else {
                console.warn('ag-Grid: footerValueGetter should be either a function or a string (expression)');
            }
        }
        else {
            footerValue = 'Total ' + this.params.value;
        }
        this.eValue.innerHTML = footerValue;
    };
    GroupCellRenderer.prototype.createGroupCell = function () {
        var params = this.params;
        var rowGroupColumn = this.displayedGroup.rowGroupColumn;
        // we try and use the cellRenderer of the column used for the grouping if we can
        var columnToUse = rowGroupColumn ? rowGroupColumn : params.column;
        var groupName = this.params.value;
        var valueFormatted = columnToUse ?
            this.valueFormatterService.formatValue(columnToUse, params.node, params.scope, groupName) : null;
        params.valueFormatted = valueFormatted;
        if (params.fullWidth == true) {
            this.cellRendererService.useFullWidthGroupRowInnerCellRenderer(this.eValue, params);
        }
        else {
            this.cellRendererService.useInnerCellRenderer(this.params.colDef.cellRendererParams, columnToUse.getColDef(), this.eValue, params);
        }
    };
    GroupCellRenderer.prototype.addChildCount = function () {
        // only include the child count if it's included, eg if user doing custom aggregation,
        // then this could be left out, or set to -1, ie no child count
        if (this.params.suppressCount) {
            return;
        }
        this.addDestroyableEventListener(this.displayedGroup, rowNode_1.RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED, this.updateChildCount.bind(this));
        // filtering changes the child count, so need to cater for it
        this.updateChildCount();
    };
    GroupCellRenderer.prototype.updateChildCount = function () {
        var allChildrenCount = this.displayedGroup.allChildrenCount;
        this.eChildCount.innerHTML = allChildrenCount >= 0 ? "(" + allChildrenCount + ")" : "";
    };
    GroupCellRenderer.prototype.createLeafCell = function () {
        if (utils_1.Utils.exists(this.params.value)) {
            this.eValue.innerHTML = this.params.value;
        }
    };
    GroupCellRenderer.prototype.isUserWantsSelected = function () {
        var paramsCheckbox = this.params.checkbox;
        if (typeof paramsCheckbox === 'function') {
            return paramsCheckbox(this.params);
        }
        else {
            return paramsCheckbox === true;
        }
    };
    GroupCellRenderer.prototype.addCheckboxIfNeeded = function () {
        var rowNode = this.params.node;
        var checkboxNeeded = this.isUserWantsSelected()
            && !rowNode.footer
            && !rowNode.rowPinned
            && !rowNode.flower;
        if (checkboxNeeded) {
            var cbSelectionComponent_1 = new checkboxSelectionComponent_1.CheckboxSelectionComponent();
            this.context.wireBean(cbSelectionComponent_1);
            cbSelectionComponent_1.init({ rowNode: rowNode, column: this.params.column });
            this.eCheckbox.appendChild(cbSelectionComponent_1.getGui());
            this.addDestroyFunc(function () { return cbSelectionComponent_1.destroy(); });
        }
    };
    GroupCellRenderer.prototype.addExpandAndContract = function () {
        var params = this.params;
        var eGroupCell = params.eGridCell;
        var eExpandedIcon = utils_1.Utils.createIconNoSpan('groupExpanded', this.gridOptionsWrapper, null);
        var eContractedIcon = utils_1.Utils.createIconNoSpan('groupContracted', this.gridOptionsWrapper, null);
        this.eExpanded.appendChild(eExpandedIcon);
        this.eContracted.appendChild(eContractedIcon);
        this.addDestroyableEventListener(this.eExpanded, 'click', this.onExpandClicked.bind(this));
        this.addDestroyableEventListener(this.eContracted, 'click', this.onExpandClicked.bind(this));
        // expand / contract as the user hits enter
        this.addDestroyableEventListener(eGroupCell, 'keydown', this.onKeyDown.bind(this));
        this.addDestroyableEventListener(params.node, rowNode_1.RowNode.EVENT_EXPANDED_CHANGED, this.showExpandAndContractIcons.bind(this));
        this.showExpandAndContractIcons();
        // because we don't show the expand / contract when there are no children, we need to check every time
        // the number of children change.
        this.addDestroyableEventListener(this.displayedGroup, rowNode_1.RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED, this.showExpandAndContractIcons.bind(this));
        // if editing groups, then double click is to start editing
        if (!this.gridOptionsWrapper.isEnableGroupEdit() && this.isExpandable()) {
            this.addDestroyableEventListener(eGroupCell, 'dblclick', this.onCellDblClicked.bind(this));
        }
    };
    GroupCellRenderer.prototype.onKeyDown = function (event) {
        if (utils_1.Utils.isKeyPressed(event, constants_1.Constants.KEY_ENTER)) {
            var cellEditable = this.params.column.isCellEditable(this.params.node);
            if (cellEditable) {
                return;
            }
            event.preventDefault();
            this.onExpandOrContract();
        }
    };
    GroupCellRenderer.prototype.setupDragOpenParents = function () {
        var column = this.params.column;
        var rowNode = this.params.node;
        if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {
            this.draggedFromHideOpenParents = false;
        }
        else if (!rowNode.hasChildren()) {
            // if we are here, and we are not a group, then we must of been dragged down,
            // as otherwise the cell would be blank, and if cell is blank, this method is never called.
            this.draggedFromHideOpenParents = true;
        }
        else {
            var rowGroupColumn = rowNode.rowGroupColumn;
            // if the displayGroup column for this col matches the rowGroupColumn we grouped by for this node,
            // then nothing was dragged down
            this.draggedFromHideOpenParents = !column.isRowGroupDisplayed(rowGroupColumn.getId());
        }
        if (this.draggedFromHideOpenParents) {
            var pointer = rowNode.parent;
            while (true) {
                if (utils_1.Utils.missing(pointer)) {
                    break;
                }
                if (pointer.rowGroupColumn && column.isRowGroupDisplayed(pointer.rowGroupColumn.getId())) {
                    this.displayedGroup = pointer;
                    break;
                }
                pointer = pointer.parent;
            }
        }
        // if we didn't find a displayed group, set it to the row node
        if (utils_1.Utils.missing(this.displayedGroup)) {
            this.displayedGroup = rowNode;
        }
    };
    GroupCellRenderer.prototype.onExpandClicked = function () {
        this.onExpandOrContract();
    };
    GroupCellRenderer.prototype.onCellDblClicked = function (event) {
        // we want to avoid acting on double click events on the expand / contract icon,
        // as that icons already has expand / collapse functionality on it. otherwise if
        // the icon was double clicked, we would get 'click', 'click', 'dblclick' which
        // is open->close->open, however double click should be open->close only.
        var targetIsExpandIcon = utils_1.Utils.isElementInEventPath(this.eExpanded, event)
            || utils_1.Utils.isElementInEventPath(this.eContracted, event);
        if (!targetIsExpandIcon) {
            this.onExpandOrContract();
        }
    };
    GroupCellRenderer.prototype.onExpandOrContract = function () {
        // must use the displayedGroup, so if data was dragged down, we expand the parent, not this row
        var rowNode = this.displayedGroup;
        rowNode.setExpanded(!rowNode.expanded);
        if (this.gridOptionsWrapper.isGroupIncludeFooter()) {
            this.params.api.redrawRows({ rowNodes: [rowNode] });
        }
    };
    GroupCellRenderer.prototype.isExpandable = function () {
        var rowNode = this.params.node;
        var reducedLeafNode = this.columnController.isPivotMode() && rowNode.leafGroup;
        return this.draggedFromHideOpenParents ||
            (rowNode.isExpandable() && !rowNode.footer && !reducedLeafNode);
    };
    GroupCellRenderer.prototype.showExpandAndContractIcons = function () {
        var rowNode = this.params.node;
        if (this.isExpandable()) {
            // if expandable, show one based on expand state.
            // if we were dragged down, means our parent is always expanded
            var expanded = this.draggedFromHideOpenParents ? true : rowNode.expanded;
            utils_1.Utils.setVisible(this.eContracted, !expanded);
            utils_1.Utils.setVisible(this.eExpanded, expanded);
        }
        else {
            // it not expandable, show neither
            utils_1.Utils.setVisible(this.eExpanded, false);
            utils_1.Utils.setVisible(this.eContracted, false);
        }
    };
    GroupCellRenderer.prototype.refresh = function () {
        return false;
    };
    GroupCellRenderer.TEMPLATE = '<span>' +
        '<span class="ag-group-expanded" ref="eExpanded"></span>' +
        '<span class="ag-group-contracted" ref="eContracted"></span>' +
        '<span class="ag-group-checkbox" ref="eCheckbox"></span>' +
        '<span class="ag-group-value" ref="eValue"></span>' +
        '<span class="ag-group-child-count" ref="eChildCount"></span>' +
        '</span>';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], GroupCellRenderer.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'),
        __metadata("design:type", expressionService_1.ExpressionService)
    ], GroupCellRenderer.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], GroupCellRenderer.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('cellRendererService'),
        __metadata("design:type", cellRendererService_1.CellRendererService)
    ], GroupCellRenderer.prototype, "cellRendererService", void 0);
    __decorate([
        context_1.Autowired('valueFormatterService'),
        __metadata("design:type", valueFormatterService_1.ValueFormatterService)
    ], GroupCellRenderer.prototype, "valueFormatterService", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], GroupCellRenderer.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], GroupCellRenderer.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('mouseEventService'),
        __metadata("design:type", mouseEventService_1.MouseEventService)
    ], GroupCellRenderer.prototype, "mouseEventService", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eExpanded'),
        __metadata("design:type", HTMLElement)
    ], GroupCellRenderer.prototype, "eExpanded", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eContracted'),
        __metadata("design:type", HTMLElement)
    ], GroupCellRenderer.prototype, "eContracted", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eCheckbox'),
        __metadata("design:type", HTMLElement)
    ], GroupCellRenderer.prototype, "eCheckbox", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eValue'),
        __metadata("design:type", HTMLElement)
    ], GroupCellRenderer.prototype, "eValue", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eChildCount'),
        __metadata("design:type", HTMLElement)
    ], GroupCellRenderer.prototype, "eChildCount", void 0);
    return GroupCellRenderer;
}(component_1.Component));
exports.GroupCellRenderer = GroupCellRenderer;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var rowNode_1 = __webpack_require__(15);
var utils_1 = __webpack_require__(1);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var events_1 = __webpack_require__(5);
var eventService_1 = __webpack_require__(4);
var gridApi_1 = __webpack_require__(6);
var columnController_1 = __webpack_require__(3);
var CheckboxSelectionComponent = (function (_super) {
    __extends(CheckboxSelectionComponent, _super);
    function CheckboxSelectionComponent() {
        return _super.call(this, "<span class=\"ag-selection-checkbox\"/>") || this;
    }
    CheckboxSelectionComponent.prototype.createAndAddIcons = function () {
        this.eCheckedIcon = utils_1.Utils.createIconNoSpan('checkboxChecked', this.gridOptionsWrapper, this.column);
        this.eUncheckedIcon = utils_1.Utils.createIconNoSpan('checkboxUnchecked', this.gridOptionsWrapper, this.column);
        this.eIndeterminateIcon = utils_1.Utils.createIconNoSpan('checkboxIndeterminate', this.gridOptionsWrapper, this.column);
        var element = this.getGui();
        element.appendChild(this.eCheckedIcon);
        element.appendChild(this.eUncheckedIcon);
        element.appendChild(this.eIndeterminateIcon);
    };
    CheckboxSelectionComponent.prototype.onSelectionChanged = function () {
        var state = this.rowNode.isSelected();
        utils_1.Utils.setVisible(this.eCheckedIcon, state === true);
        utils_1.Utils.setVisible(this.eUncheckedIcon, state === false);
        utils_1.Utils.setVisible(this.eIndeterminateIcon, typeof state !== 'boolean');
    };
    CheckboxSelectionComponent.prototype.onCheckedClicked = function () {
        var groupSelectsFiltered = this.gridOptionsWrapper.isGroupSelectsFiltered();
        var updatedCount = this.rowNode.setSelectedParams({ newValue: false, groupSelectsFiltered: groupSelectsFiltered });
        return updatedCount;
    };
    CheckboxSelectionComponent.prototype.onUncheckedClicked = function (event) {
        var groupSelectsFiltered = this.gridOptionsWrapper.isGroupSelectsFiltered();
        var updatedCount = this.rowNode.setSelectedParams({ newValue: true, rangeSelect: event.shiftKey, groupSelectsFiltered: groupSelectsFiltered });
        return updatedCount;
    };
    CheckboxSelectionComponent.prototype.onIndeterminateClicked = function (event) {
        var result = this.onUncheckedClicked(event);
        if (result === 0) {
            this.onCheckedClicked();
        }
    };
    CheckboxSelectionComponent.prototype.init = function (params) {
        this.rowNode = params.rowNode;
        this.column = params.column;
        this.visibleFunc = params.visibleFunc;
        this.createAndAddIcons();
        this.onSelectionChanged();
        // we don't want the row clicked event to fire when selecting the checkbox, otherwise the row
        // would possibly get selected twice
        this.addGuiEventListener('click', function (event) { return event.stopPropagation(); });
        // likewise we don't want double click on this icon to open a group
        this.addGuiEventListener('dblclick', function (event) { return event.stopPropagation(); });
        this.addDestroyableEventListener(this.eCheckedIcon, 'click', this.onCheckedClicked.bind(this));
        this.addDestroyableEventListener(this.eUncheckedIcon, 'click', this.onUncheckedClicked.bind(this));
        this.addDestroyableEventListener(this.eIndeterminateIcon, 'click', this.onIndeterminateClicked.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this));
        if (this.visibleFunc) {
            this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.showOrHideSelect.bind(this));
            this.showOrHideSelect();
        }
    };
    CheckboxSelectionComponent.prototype.showOrHideSelect = function () {
        var params = this.createParams();
        var visible = this.visibleFunc(params);
        this.setVisible(visible);
    };
    CheckboxSelectionComponent.prototype.createParams = function () {
        var params = {
            node: this.rowNode,
            data: this.rowNode.data,
            column: this.column,
            colDef: this.column.getColDef(),
            context: this.gridOptionsWrapper.getContext(),
            api: this.gridApi,
            columnApi: this.columnApi
        };
        return params;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], CheckboxSelectionComponent.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], CheckboxSelectionComponent.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], CheckboxSelectionComponent.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], CheckboxSelectionComponent.prototype, "columnApi", void 0);
    return CheckboxSelectionComponent;
}(component_1.Component));
exports.CheckboxSelectionComponent = CheckboxSelectionComponent;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var gridPanel_1 = __webpack_require__(10);
var utils_1 = __webpack_require__(1);
var ColumnAnimationService = (function () {
    function ColumnAnimationService() {
        this.executeNextFuncs = [];
        this.executeLaterFuncs = [];
        this.active = false;
        this.animationThreadCount = 0;
    }
    ColumnAnimationService.prototype.isActive = function () {
        return this.active;
    };
    ColumnAnimationService.prototype.start = function () {
        if (this.active) {
            return;
        }
        if (this.gridOptionsWrapper.isSuppressColumnMoveAnimation()) {
            return;
        }
        // if doing RTL, we don't animate open / close as due to how the pixels are inverted,
        // the animation moves all the row the the right rather than to the left (ie it's the static
        // columns that actually get their coordinates updated)
        if (this.gridOptionsWrapper.isEnableRtl()) {
            return;
        }
        this.ensureAnimationCssClassPresent();
        this.active = true;
    };
    ColumnAnimationService.prototype.finish = function () {
        if (!this.active) {
            return;
        }
        this.flush();
        this.active = false;
    };
    ColumnAnimationService.prototype.executeNextVMTurn = function (func) {
        if (this.active) {
            this.executeNextFuncs.push(func);
        }
        else {
            func();
        }
    };
    ColumnAnimationService.prototype.executeLaterVMTurn = function (func) {
        if (this.active) {
            this.executeLaterFuncs.push(func);
        }
        else {
            func();
        }
    };
    ColumnAnimationService.prototype.ensureAnimationCssClassPresent = function () {
        var _this = this;
        // up the count, so we can tell if someone else has updated the count
        // by the time the 'wait' func executes
        this.animationThreadCount++;
        var animationThreadCountCopy = this.animationThreadCount;
        utils_1.Utils.addCssClass(this.gridPanel.getRoot(), 'ag-column-moving');
        this.executeLaterFuncs.push(function () {
            // only remove the class if this thread was the last one to update it
            if (_this.animationThreadCount === animationThreadCountCopy) {
                utils_1.Utils.removeCssClass(_this.gridPanel.getRoot(), 'ag-column-moving');
            }
        });
    };
    ColumnAnimationService.prototype.flush = function () {
        var nowFuncs = this.executeNextFuncs;
        this.executeNextFuncs = [];
        var waitFuncs = this.executeLaterFuncs;
        this.executeLaterFuncs = [];
        if (nowFuncs.length === 0 && waitFuncs.length === 0) {
            return;
        }
        setTimeout(function () { return nowFuncs.forEach(function (func) { return func(); }); }, 0);
        setTimeout(function () { return waitFuncs.forEach(function (func) { return func(); }); }, 300);
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ColumnAnimationService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], ColumnAnimationService.prototype, "gridPanel", void 0);
    ColumnAnimationService = __decorate([
        context_1.Bean('columnAnimationService')
    ], ColumnAnimationService);
    return ColumnAnimationService;
}());
exports.ColumnAnimationService = ColumnAnimationService;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var eventService_1 = __webpack_require__(4);
var context_1 = __webpack_require__(0);
var events_1 = __webpack_require__(5);
var beanStub_1 = __webpack_require__(13);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
var ColumnHoverService = (function (_super) {
    __extends(ColumnHoverService, _super);
    function ColumnHoverService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ColumnHoverService.prototype.init = function () {
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_CELL_MOUSE_OVER, this.onCellMouseOver.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_CELL_MOUSE_OUT, this.onCellMouseOut.bind(this));
    };
    ColumnHoverService.prototype.onCellMouseOver = function (cellEvent) {
        this.currentlySelectedColumn = cellEvent.column;
        var event = {
            type: events_1.Events.EVENT_COLUMN_HOVER_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    ColumnHoverService.prototype.onCellMouseOut = function () {
        this.currentlySelectedColumn = null;
        var event = {
            type: events_1.Events.EVENT_COLUMN_HOVER_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    ColumnHoverService.prototype.isHovered = function (column) {
        return column == this.currentlySelectedColumn;
    };
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], ColumnHoverService.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], ColumnHoverService.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], ColumnHoverService.prototype, "gridApi", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ColumnHoverService.prototype, "init", null);
    ColumnHoverService = __decorate([
        context_1.Bean('columnHoverService')
    ], ColumnHoverService);
    return ColumnHoverService;
}(beanStub_1.BeanStub));
exports.ColumnHoverService = ColumnHoverService;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var beanStub_1 = __webpack_require__(13);
var rowNodeBlock_1 = __webpack_require__(59);
var RowNodeCache = (function (_super) {
    __extends(RowNodeCache, _super);
    function RowNodeCache(cacheParams) {
        var _this = _super.call(this) || this;
        _this.maxRowFound = false;
        _this.blocks = {};
        _this.blockCount = 0;
        _this.virtualRowCount = cacheParams.initialRowCount;
        _this.cacheParams = cacheParams;
        return _this;
    }
    RowNodeCache.prototype.destroy = function () {
        var _this = this;
        _super.prototype.destroy.call(this);
        this.forEachBlockInOrder(function (block) { return _this.destroyBlock(block); });
    };
    RowNodeCache.prototype.init = function () {
        var _this = this;
        this.active = true;
        this.addDestroyFunc(function () { return _this.active = false; });
    };
    RowNodeCache.prototype.isActive = function () {
        return this.active;
    };
    RowNodeCache.prototype.getVirtualRowCount = function () {
        return this.virtualRowCount;
    };
    RowNodeCache.prototype.hack_setVirtualRowCount = function (virtualRowCount) {
        this.virtualRowCount = virtualRowCount;
    };
    RowNodeCache.prototype.isMaxRowFound = function () {
        return this.maxRowFound;
    };
    // listener on EVENT_LOAD_COMPLETE
    RowNodeCache.prototype.onPageLoaded = function (event) {
        // if we are not active, then we ignore all events, otherwise we could end up getting the
        // grid to refresh even though we are no longer the active cache
        if (!this.isActive()) {
            return;
        }
        this.logger.log("onPageLoaded: page = " + event.page.getBlockNumber() + ", lastRow = " + event.lastRow);
        this.cacheParams.rowNodeBlockLoader.loadComplete();
        this.checkBlockToLoad();
        if (event.success) {
            this.checkVirtualRowCount(event.page, event.lastRow);
        }
    };
    RowNodeCache.prototype.purgeBlocksIfNeeded = function (blockToExclude) {
        var _this = this;
        // no purge if user didn't give maxBlocksInCache
        if (utils_1.Utils.missing(this.cacheParams.maxBlocksInCache)) {
            return;
        }
        // no purge if block count is less than max allowed
        if (this.blockCount <= this.cacheParams.maxBlocksInCache) {
            return;
        }
        // put all candidate blocks into a list for sorting
        var blocksForPurging = [];
        this.forEachBlockInOrder(function (block) {
            // we exclude checking for the page just created, as this has yet to be accessed and hence
            // the lastAccessed stamp will not be updated for the first time yet
            if (block === blockToExclude) {
                return;
            }
            blocksForPurging.push(block);
        });
        // todo: need to verify that this sorts items in the right order
        blocksForPurging.sort(function (a, b) { return b.getLastAccessed() - a.getLastAccessed(); });
        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.
        // in other words, after the splice operation below, we have taken out the blocks
        // we want to keep, which means we are left with blocks that we can potentially purge
        var blocksToKeep = this.cacheParams.maxBlocksInCache - 1;
        blocksForPurging.splice(0, blocksToKeep);
        // try and purge each block
        blocksForPurging.forEach(function (block) {
            // we never purge blocks if they are open, as purging them would mess up with
            // our indexes, it would be very messy to restore the purged block to it's
            // previous state if it had open children (and what if open children of open
            // children, jeeeesus, just thinking about it freaks me out) so best is have a
            // rule, if block is open, we never purge.
            if (block.isAnyNodeOpen(_this.virtualRowCount)) {
                return;
            }
            // at this point, block is not needed, and no open nodes, so burn baby burn
            _this.removeBlockFromCache(block);
        });
    };
    RowNodeCache.prototype.postCreateBlock = function (newBlock) {
        newBlock.addEventListener(rowNodeBlock_1.RowNodeBlock.EVENT_LOAD_COMPLETE, this.onPageLoaded.bind(this));
        this.setBlock(newBlock.getBlockNumber(), newBlock);
        this.purgeBlocksIfNeeded(newBlock);
        this.checkBlockToLoad();
    };
    RowNodeCache.prototype.removeBlockFromCache = function (pageToRemove) {
        if (!pageToRemove) {
            return;
        }
        this.destroyBlock(pageToRemove);
        // we do not want to remove the 'loaded' event listener, as the
        // concurrent loads count needs to be updated when the load is complete
        // if the purged page is in loading state
    };
    // gets called after: 1) block loaded 2) block created 3) cache refresh
    RowNodeCache.prototype.checkBlockToLoad = function () {
        this.cacheParams.rowNodeBlockLoader.checkBlockToLoad();
    };
    RowNodeCache.prototype.checkVirtualRowCount = function (block, lastRow) {
        // if client provided a last row, we always use it, as it could change between server calls
        // if user deleted data and then called refresh on the grid.
        if (typeof lastRow === 'number' && lastRow >= 0) {
            this.virtualRowCount = lastRow;
            this.maxRowFound = true;
            this.onCacheUpdated();
        }
        else if (!this.maxRowFound) {
            // otherwise, see if we need to add some virtual rows
            var lastRowIndex = (block.getBlockNumber() + 1) * this.cacheParams.blockSize;
            var lastRowIndexPlusOverflow = lastRowIndex + this.cacheParams.overflowSize;
            if (this.virtualRowCount < lastRowIndexPlusOverflow) {
                this.virtualRowCount = lastRowIndexPlusOverflow;
                this.onCacheUpdated();
            }
            else if (this.cacheParams.dynamicRowHeight) {
                // the only other time is if dynamic row height, as loading rows
                // will change the height of the block, given the height of the rows
                // is only known after the row is loaded.
                this.onCacheUpdated();
            }
        }
    };
    RowNodeCache.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {
        this.virtualRowCount = rowCount;
        // if undefined is passed, we do not set this value, if one of {true,false}
        // is passed, we do set the value.
        if (utils_1.Utils.exists(maxRowFound)) {
            this.maxRowFound = maxRowFound;
        }
        // if we are still searching, then the row count must not end at the end
        // of a particular page, otherwise the searching will not pop into the
        // next page
        if (!this.maxRowFound) {
            if (this.virtualRowCount % this.cacheParams.blockSize === 0) {
                this.virtualRowCount++;
            }
        }
        this.onCacheUpdated();
    };
    RowNodeCache.prototype.forEachNodeDeep = function (callback, sequence) {
        var _this = this;
        this.forEachBlockInOrder(function (block) {
            block.forEachNodeDeep(callback, sequence, _this.virtualRowCount);
        });
    };
    RowNodeCache.prototype.forEachBlockInOrder = function (callback) {
        var ids = this.getBlockIdsSorted();
        this.forEachBlockId(ids, callback);
    };
    RowNodeCache.prototype.forEachBlockInReverseOrder = function (callback) {
        var ids = this.getBlockIdsSorted().reverse();
        this.forEachBlockId(ids, callback);
    };
    RowNodeCache.prototype.forEachBlockId = function (ids, callback) {
        var _this = this;
        ids.forEach(function (id) {
            var block = _this.blocks[id];
            callback(block, id);
        });
    };
    RowNodeCache.prototype.getBlockIdsSorted = function () {
        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order
        var numberComparator = function (a, b) { return a - b; }; // default comparator for array is string comparison
        var blockIds = Object.keys(this.blocks).map(function (idStr) { return parseInt(idStr); }).sort(numberComparator);
        return blockIds;
    };
    RowNodeCache.prototype.getBlock = function (blockId) {
        return this.blocks[blockId];
    };
    RowNodeCache.prototype.setBlock = function (id, block) {
        this.blocks[id] = block;
        this.blockCount++;
        this.cacheParams.rowNodeBlockLoader.addBlock(block);
    };
    RowNodeCache.prototype.destroyBlock = function (block) {
        delete this.blocks[block.getBlockNumber()];
        block.destroy();
        this.blockCount--;
        this.cacheParams.rowNodeBlockLoader.removeBlock(block);
    };
    // gets called 1) row count changed 2) cache purged 3) items inserted
    RowNodeCache.prototype.onCacheUpdated = function () {
        if (this.isActive()) {
            // this results in both row models (infinite and enterprise) firing ModelUpdated,
            // however enterprise also updates the row indexes first
            var event_1 = {
                type: RowNodeCache.EVENT_CACHE_UPDATED
            };
            this.dispatchEvent(event_1);
        }
    };
    RowNodeCache.prototype.purgeCache = function () {
        var _this = this;
        this.forEachBlockInOrder(function (block) { return _this.removeBlockFromCache(block); });
        this.onCacheUpdated();
    };
    RowNodeCache.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {
        var _this = this;
        var result = [];
        var lastBlockId = -1;
        var inActiveRange = false;
        var numberSequence = new utils_1.NumberSequence();
        // if only one node passed, we start the selection at the top
        if (utils_1.Utils.missing(firstInRange)) {
            inActiveRange = true;
        }
        var foundGapInSelection = false;
        this.forEachBlockInOrder(function (block, id) {
            if (foundGapInSelection)
                return;
            if (inActiveRange && (lastBlockId + 1 !== id)) {
                foundGapInSelection = true;
                return;
            }
            lastBlockId = id;
            block.forEachNodeShallow(function (rowNode) {
                var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;
                if (inActiveRange || hitFirstOrLast) {
                    result.push(rowNode);
                }
                if (hitFirstOrLast) {
                    inActiveRange = !inActiveRange;
                }
            }, numberSequence, _this.virtualRowCount);
        });
        // inActiveRange will be still true if we never hit the second rowNode
        var invalidRange = foundGapInSelection || inActiveRange;
        return invalidRange ? [] : result;
    };
    RowNodeCache.EVENT_CACHE_UPDATED = 'cacheUpdated';
    return RowNodeCache;
}(beanStub_1.BeanStub));
exports.RowNodeCache = RowNodeCache;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var ChangedPath = (function () {
    function ChangedPath(keepingColumns) {
        this.nodeIdsToBoolean = {};
        this.nodeIdsToColumns = {};
        this.keepingColumns = keepingColumns;
    }
    ChangedPath.prototype.addParentNode = function (rowNode, columns) {
        var _this = this;
        var pointer = rowNode;
        while (pointer) {
            // add this item to the path, all the way to parent
            this.nodeIdsToBoolean[pointer.id] = true;
            // if columns, add the columns in all the way to parent, merging
            // in any other columns that might be there already
            if (this.keepingColumns && columns) {
                if (!this.nodeIdsToColumns[pointer.id]) {
                    this.nodeIdsToColumns[pointer.id] = {};
                }
                columns.forEach(function (col) { return _this.nodeIdsToColumns[pointer.id][col.getId()] = true; });
            }
            pointer = pointer.parent;
        }
    };
    ChangedPath.prototype.isInPath = function (rowNode) {
        return this.nodeIdsToBoolean[rowNode.id];
    };
    ChangedPath.prototype.getValueColumnsForNode = function (rowNode, valueColumns) {
        if (!this.keepingColumns) {
            return valueColumns;
        }
        var colsForThisNode = this.nodeIdsToColumns[rowNode.id];
        var result = valueColumns.filter(function (col) { return colsForThisNode[col.getId()]; });
        return result;
    };
    ChangedPath.prototype.getNotValueColumnsForNode = function (rowNode, valueColumns) {
        if (!this.keepingColumns) {
            return null;
        }
        var colsForThisNode = this.nodeIdsToColumns[rowNode.id];
        var result = valueColumns.filter(function (col) { return !colsForThisNode[col.getId()]; });
        return result;
    };
    return ChangedPath;
}());
exports.ChangedPath = ChangedPath;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var rowNode_1 = __webpack_require__(15);
var utils_1 = __webpack_require__(1);
var InMemoryNodeManager = (function () {
    function InMemoryNodeManager(rootNode, gridOptionsWrapper, context, eventService, columnController) {
        this.nextId = 0;
        // when user is provide the id's, we also keep a map of ids to row nodes for convenience
        this.allNodesMap = {};
        this.rootNode = rootNode;
        this.gridOptionsWrapper = gridOptionsWrapper;
        this.context = context;
        this.eventService = eventService;
        this.columnController = columnController;
        this.rootNode.group = true;
        this.rootNode.level = -1;
        this.rootNode.id = InMemoryNodeManager.ROOT_NODE_ID;
        this.rootNode.allLeafChildren = [];
        this.rootNode.childrenAfterGroup = [];
        this.rootNode.childrenAfterSort = [];
        this.rootNode.childrenAfterFilter = [];
    }
    InMemoryNodeManager.prototype.getCopyOfNodesMap = function () {
        var result = utils_1.Utils.cloneObject(this.allNodesMap);
        return result;
    };
    InMemoryNodeManager.prototype.getRowNode = function (id) {
        return this.allNodesMap[id];
    };
    InMemoryNodeManager.prototype.setRowData = function (rowData) {
        this.rootNode.childrenAfterFilter = null;
        this.rootNode.childrenAfterGroup = null;
        this.rootNode.childrenAfterSort = null;
        this.rootNode.childrenMapped = null;
        this.nextId = 0;
        this.allNodesMap = {};
        if (!rowData) {
            this.rootNode.allLeafChildren = [];
            this.rootNode.childrenAfterGroup = [];
            return;
        }
        // func below doesn't have 'this' pointer, so need to pull out these bits
        this.getNodeChildDetails = this.gridOptionsWrapper.getNodeChildDetailsFunc();
        this.suppressParentsInRowNodes = this.gridOptionsWrapper.isSuppressParentsInRowNodes();
        this.doesDataFlower = this.gridOptionsWrapper.getDoesDataFlowerFunc();
        var doingLegacyTreeData = utils_1.Utils.exists(this.getNodeChildDetails);
        // kick off recursion
        var result = this.recursiveFunction(rowData, null, InMemoryNodeManager.TOP_LEVEL);
        if (doingLegacyTreeData) {
            this.rootNode.childrenAfterGroup = result;
            this.setLeafChildren(this.rootNode);
        }
        else {
            this.rootNode.allLeafChildren = result;
        }
    };
    InMemoryNodeManager.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {
        var _this = this;
        if (this.isLegacyTreeData()) {
            return null;
        }
        var add = rowDataTran.add, addIndex = rowDataTran.addIndex, remove = rowDataTran.remove, update = rowDataTran.update;
        var rowNodeTransaction = {
            remove: [],
            update: [],
            add: []
        };
        if (utils_1.Utils.exists(add)) {
            var useIndex = typeof addIndex === 'number' && addIndex >= 0;
            if (useIndex) {
                // items get inserted in reverse order for index insertion
                add.reverse().forEach(function (item) {
                    var newRowNode = _this.addRowNode(item, addIndex);
                    rowNodeTransaction.add.push(newRowNode);
                });
            }
            else {
                add.forEach(function (item) {
                    var newRowNode = _this.addRowNode(item);
                    rowNodeTransaction.add.push(newRowNode);
                });
            }
        }
        if (utils_1.Utils.exists(remove)) {
            remove.forEach(function (item) {
                var removedRowNode = _this.updatedRowNode(item, false);
                if (removedRowNode) {
                    rowNodeTransaction.remove.push(removedRowNode);
                }
            });
        }
        if (utils_1.Utils.exists(update)) {
            update.forEach(function (item) {
                var updatedRowNode = _this.updatedRowNode(item, true);
                if (updatedRowNode) {
                    rowNodeTransaction.update.push(updatedRowNode);
                }
            });
        }
        if (rowNodeOrder) {
            utils_1.Utils.sortRowNodesByOrder(this.rootNode.allLeafChildren, rowNodeOrder);
        }
        return rowNodeTransaction;
    };
    InMemoryNodeManager.prototype.addRowNode = function (data, index) {
        var newNode = this.createNode(data, null, InMemoryNodeManager.TOP_LEVEL);
        if (utils_1.Utils.exists(index)) {
            utils_1.Utils.insertIntoArray(this.rootNode.allLeafChildren, newNode, index);
        }
        else {
            this.rootNode.allLeafChildren.push(newNode);
        }
        return newNode;
    };
    InMemoryNodeManager.prototype.updatedRowNode = function (data, update) {
        var rowNodeIdFunc = this.gridOptionsWrapper.getRowNodeIdFunc();
        var rowNode;
        if (utils_1.Utils.exists(rowNodeIdFunc)) {
            // find rowNode us id
            var id = rowNodeIdFunc(data);
            rowNode = this.allNodesMap[id];
            if (!rowNode) {
                console.error("ag-Grid: could not find row id=" + id + ", data item was not found for this id");
                return null;
            }
        }
        else {
            // find rowNode using object references
            rowNode = utils_1.Utils.find(this.rootNode.allLeafChildren, function (rowNode) { return rowNode.data === data; });
            if (!rowNode) {
                console.error("ag-Grid: could not find data item as object was not found", data);
                return null;
            }
        }
        if (update) {
            // do update
            rowNode.updateData(data);
        }
        else {
            // do delete
            rowNode.setSelected(false);
            utils_1.Utils.removeFromArray(this.rootNode.allLeafChildren, rowNode);
            this.allNodesMap[rowNode.id] = undefined;
        }
        return rowNode;
    };
    InMemoryNodeManager.prototype.recursiveFunction = function (rowData, parent, level) {
        var _this = this;
        // make sure the rowData is an array and not a string of json - this was a commonly reported problem on the forum
        if (typeof rowData === 'string') {
            console.warn('ag-Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first');
            return;
        }
        var rowNodes = [];
        rowData.forEach(function (dataItem) {
            var node = _this.createNode(dataItem, parent, level);
            rowNodes.push(node);
        });
        return rowNodes;
    };
    InMemoryNodeManager.prototype.createNode = function (dataItem, parent, level) {
        var node = new rowNode_1.RowNode();
        this.context.wireBean(node);
        var doingTreeData = this.gridOptionsWrapper.isTreeData();
        var doingLegacyTreeData = !doingTreeData && utils_1.Utils.exists(this.getNodeChildDetails);
        var nodeChildDetails = doingLegacyTreeData ? this.getNodeChildDetails(dataItem) : null;
        if (nodeChildDetails && nodeChildDetails.group) {
            node.group = true;
            node.childrenAfterGroup = this.recursiveFunction(nodeChildDetails.children, node, level + 1);
            node.expanded = nodeChildDetails.expanded === true;
            node.field = nodeChildDetails.field;
            node.key = nodeChildDetails.key;
            node.canFlower = false;
            // pull out all the leaf children and add to our node
            this.setLeafChildren(node);
        }
        else {
            node.group = false;
            if (doingTreeData) {
                node.canFlower = false;
                node.expanded = false;
            }
            else {
                //  this is the default, for when doing grid data
                node.canFlower = this.doesDataFlower ? this.doesDataFlower(dataItem) : false;
                if (node.canFlower) {
                    node.expanded = this.isExpanded(level);
                }
                else {
                    node.expanded = false;
                }
            }
        }
        if (parent && !this.suppressParentsInRowNodes) {
            node.parent = parent;
        }
        node.level = level;
        node.setDataAndId(dataItem, this.nextId.toString());
        this.allNodesMap[node.id] = node;
        this.nextId++;
        return node;
    };
    InMemoryNodeManager.prototype.isExpanded = function (level) {
        var expandByDefault = this.gridOptionsWrapper.getGroupDefaultExpanded();
        if (expandByDefault === -1) {
            return true;
        }
        else {
            return level < expandByDefault;
        }
    };
    // this is only used for doing legacy tree data
    InMemoryNodeManager.prototype.setLeafChildren = function (node) {
        node.allLeafChildren = [];
        if (node.childrenAfterGroup) {
            node.childrenAfterGroup.forEach(function (childAfterGroup) {
                if (childAfterGroup.group) {
                    if (childAfterGroup.allLeafChildren) {
                        childAfterGroup.allLeafChildren.forEach(function (leafChild) { return node.allLeafChildren.push(leafChild); });
                    }
                }
                else {
                    node.allLeafChildren.push(childAfterGroup);
                }
            });
        }
    };
    InMemoryNodeManager.prototype.insertItemsAtIndex = function (index, rowData) {
        if (this.isLegacyTreeData()) {
            return null;
        }
        var nodeList = this.rootNode.allLeafChildren;
        if (index > nodeList.length) {
            console.warn("ag-Grid: invalid index " + index + ", max index is " + nodeList.length);
            return;
        }
        var newNodes = [];
        // go through the items backwards, otherwise they get added in reverse order
        for (var i = rowData.length - 1; i >= 0; i--) {
            var data = rowData[i];
            var newNode = this.createNode(data, null, InMemoryNodeManager.TOP_LEVEL);
            utils_1.Utils.insertIntoArray(nodeList, newNode, index);
            newNodes.push(newNode);
        }
        return newNodes.length > 0 ? newNodes : null;
    };
    InMemoryNodeManager.prototype.removeItems = function (rowNodes) {
        var _this = this;
        if (this.isLegacyTreeData()) {
            return;
        }
        var nodeList = this.rootNode.allLeafChildren;
        var removedNodes = [];
        rowNodes.forEach(function (rowNode) {
            var indexOfNode = nodeList.indexOf(rowNode);
            if (indexOfNode >= 0) {
                rowNode.setSelected(false);
                nodeList.splice(indexOfNode, 1);
                _this.allNodesMap[rowNode.id] = undefined;
            }
            removedNodes.push(rowNode);
        });
        return removedNodes.length > 0 ? removedNodes : null;
    };
    InMemoryNodeManager.prototype.addItems = function (items) {
        var nodeList = this.rootNode.allLeafChildren;
        return this.insertItemsAtIndex(nodeList.length, items);
    };
    InMemoryNodeManager.prototype.isLegacyTreeData = function () {
        var rowsAlreadyGrouped = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
        if (rowsAlreadyGrouped) {
            console.warn('ag-Grid: adding and removing rows is not supported when using nodeChildDetailsFunc, ie it is not ' +
                'supported for legacy tree data. Please see the docs on the new preferred way of providing tree data that works with delta updates.');
            return true;
        }
        else {
            return false;
        }
    };
    InMemoryNodeManager.TOP_LEVEL = 0;
    InMemoryNodeManager.ROOT_NODE_ID = 'ROOT_NODE_ID';
    return InMemoryNodeManager;
}());
exports.InMemoryNodeManager = InMemoryNodeManager;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var expressionService_1 = __webpack_require__(19);
var StylingService = (function () {
    function StylingService() {
    }
    StylingService.prototype.processAllCellClasses = function (colDef, params, onApplicableClass, onNotApplicableClass) {
        this.processClassRules(colDef.cellClassRules, params, onApplicableClass, onNotApplicableClass);
        this.processStaticCellClasses(colDef, params, onApplicableClass);
    };
    StylingService.prototype.processClassRules = function (classRules, params, onApplicableClass, onNotApplicableClass) {
        if (typeof classRules === 'object' && classRules !== null) {
            var classNames = Object.keys(classRules);
            for (var i = 0; i < classNames.length; i++) {
                var className = classNames[i];
                var rule = classRules[className];
                var resultOfRule = void 0;
                if (typeof rule === 'string') {
                    resultOfRule = this.expressionService.evaluate(rule, params);
                }
                else if (typeof rule === 'function') {
                    resultOfRule = rule(params);
                }
                if (resultOfRule) {
                    onApplicableClass(className);
                }
                else if (onNotApplicableClass) {
                    onNotApplicableClass(className);
                }
            }
        }
    };
    StylingService.prototype.processStaticCellClasses = function (colDef, params, onApplicableClass) {
        var cellClass = colDef.cellClass;
        if (cellClass) {
            var classOrClasses = void 0;
            if (typeof colDef.cellClass === 'function') {
                var cellClassFunc = colDef.cellClass;
                classOrClasses = cellClassFunc(params);
            }
            else {
                classOrClasses = colDef.cellClass;
            }
            if (typeof classOrClasses === 'string') {
                onApplicableClass(classOrClasses);
            }
            else if (Array.isArray(classOrClasses)) {
                classOrClasses.forEach(function (cssClassItem) {
                    onApplicableClass(cssClassItem);
                });
            }
        }
    };
    __decorate([
        context_1.Autowired('expressionService'),
        __metadata("design:type", expressionService_1.ExpressionService)
    ], StylingService.prototype, "expressionService", void 0);
    StylingService = __decorate([
        context_1.Bean('stylingService')
    ], StylingService);
    return StylingService;
}());
exports.StylingService = StylingService;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(152);

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ag-grid-react v14.0.0

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var reactFrameworkComponentWrapper_1 = __webpack_require__(128);
var DOM = __webpack_require__(157);
var react_1 = __webpack_require__(26);
var PropTypes = __webpack_require__(164);
var AgGrid = __webpack_require__(63);
var AgGridReact = (function (_super) {
    __extends(AgGridReact, _super);
    function AgGridReact(props, state) {
        var _this = _super.call(this, props, state) || this;
        _this.props = props;
        _this.state = state;
        return _this;
    }
    AgGridReact.prototype.render = function () {
        var _this = this;
        return DOM.div({
            style: this.createStyleForDiv(),
            ref: function (e) {
                _this.eGridDiv = e;
            }
        });
    };
    AgGridReact.prototype.createStyleForDiv = function () {
        var style = { height: '100%' };
        // allow user to override styles
        var containerStyle = this.props.containerStyle;
        if (containerStyle) {
            Object.keys(containerStyle).forEach(function (key) {
                style[key] = containerStyle[key];
            });
        }
        return style;
    };
    AgGridReact.prototype.componentDidMount = function () {
        var gridParams = {
            seedBeanInstances: {
                agGridReact: this
            }
        };
        this.gridOptions = AgGrid.ComponentUtil.copyAttributesToGridOptions(this.props.gridOptions, this.props);
        AgGrid.Grid.setFrameworkBeans([reactFrameworkComponentWrapper_1.ReactFrameworkComponentWrapper]);
        // don't need the return value
        new AgGrid.Grid(this.eGridDiv, this.gridOptions, gridParams);
        this.api = this.gridOptions.api;
        this.columnApi = this.gridOptions.columnApi;
    };
    AgGridReact.prototype.shouldComponentUpdate = function () {
        // we want full control of the dom, as ag-Grid doesn't use React internally,
        // so for performance reasons we tell React we don't need render called after
        // property changes.
        return false;
    };
    AgGridReact.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        var debugLogging = !!nextProps.debug;
        // keeping consistent with web components, put changing
        // values in currentValue and previousValue pairs and
        // not include items that have not changed.
        var changes = {};
        AgGrid.ComponentUtil.ALL_PROPERTIES.forEach(function (propKey) {
            if (!_this.areEquivalent(_this.props[propKey], nextProps[propKey])) {
                if (debugLogging) {
                    console.log("agGridReact: [" + propKey + "] property changed");
                }
                changes[propKey] = {
                    previousValue: _this.props[propKey],
                    currentValue: nextProps[propKey]
                };
            }
        });
        AgGrid.ComponentUtil.getEventCallbacks().forEach(function (funcName) {
            if (_this.props[funcName] !== nextProps[funcName]) {
                if (debugLogging) {
                    console.log("agGridReact: [" + funcName + "] event callback changed");
                }
                changes[funcName] = {
                    previousValue: _this.props[funcName],
                    currentValue: nextProps[funcName]
                };
            }
        });
        AgGrid.ComponentUtil.processOnChange(changes, this.gridOptions, this.api, this.columnApi);
    };
    AgGridReact.prototype.componentWillUnmount = function () {
        if (this.api) {
            this.api.destroy();
        }
    };
    /*
     * deeper object comparison - taken from https://stackoverflow.com/questions/1068834/object-comparison-in-javascript
     */
    AgGridReact.unwrapStringOrNumber = function (obj) {
        return (obj instanceof Number || obj instanceof String
            ? obj.valueOf()
            : obj);
    };
    // sigh, here for ie compatibility
    AgGridReact.prototype.copy = function (value) {
        if (!value) {
            return value;
        }
        if (Array.isArray(value)) {
            return value.slice();
        }
        // for anything without keys (boolean, string etc).
        // Object.keys - chrome will swallow them, IE will fail (correctly, imho)
        if (typeof value !== "object") {
            return value;
        }
        return [{}, value].reduce(function (r, o) {
            Object.keys(o).forEach(function (k) {
                r[k] = o[k];
            });
            return r;
        }, {});
    };
    AgGridReact.prototype.areEquivalent = function (a, b) {
        return AgGridReact.areEquivalent(this.copy(a), this.copy(b));
    };
    AgGridReact.areEquivalent = function (a, b) {
        a = AgGridReact.unwrapStringOrNumber(a);
        b = AgGridReact.unwrapStringOrNumber(b);
        if (a === b)
            return true; //e.g. a and b both null
        if (a === null || b === null || typeof (a) !== typeof (b))
            return false;
        if (a instanceof Date) {
            return b instanceof Date && a.valueOf() === b.valueOf();
        }
        if (typeof a === "function") {
            return a.toString() === b.toString();
        }
        if (typeof (a) !== "object") {
            return a == b; //for boolean, number, string, function, xml
        }
        var newA = (a.areEquivalent_Eq_91_2_34 === undefined), newB = (b.areEquivalent_Eq_91_2_34 === undefined);
        try {
            var prop = void 0;
            if (newA) {
                a.areEquivalent_Eq_91_2_34 = [];
            }
            else if (a.areEquivalent_Eq_91_2_34.some(function (other) {
                return other === b;
            }))
                return true;
            if (newB) {
                b.areEquivalent_Eq_91_2_34 = [];
            }
            else if (b.areEquivalent_Eq_91_2_34.some(function (other) { return other === a; })) {
                return true;
            }
            a.areEquivalent_Eq_91_2_34.push(b);
            b.areEquivalent_Eq_91_2_34.push(a);
            var tmp = {};
            for (prop in a)
                if (prop != "areEquivalent_Eq_91_2_34") {
                    tmp[prop] = null;
                }
            for (prop in b)
                if (prop != "areEquivalent_Eq_91_2_34") {
                    tmp[prop] = null;
                }
            for (prop in tmp) {
                if (!this.areEquivalent(a[prop], b[prop])) {
                    return false;
                }
            }
            return true;
        }
        finally {
            if (newA)
                delete a.areEquivalent_Eq_91_2_34;
            if (newB)
                delete b.areEquivalent_Eq_91_2_34;
        }
    };
    return AgGridReact;
}(react_1.Component));
exports.AgGridReact = AgGridReact;
AgGridReact.propTypes = {
    gridOptions: PropTypes.object,
};
addProperties(AgGrid.ComponentUtil.getEventCallbacks(), PropTypes.func);
addProperties(AgGrid.ComponentUtil.BOOLEAN_PROPERTIES, PropTypes.bool);
addProperties(AgGrid.ComponentUtil.STRING_PROPERTIES, PropTypes.string);
addProperties(AgGrid.ComponentUtil.OBJECT_PROPERTIES, PropTypes.object);
addProperties(AgGrid.ComponentUtil.ARRAY_PROPERTIES, PropTypes.array);
addProperties(AgGrid.ComponentUtil.NUMBER_PROPERTIES, PropTypes.number);
addProperties(AgGrid.ComponentUtil.FUNCTION_PROPERTIES, PropTypes.func);
function addProperties(listOfProps, propType) {
    listOfProps.forEach(function (propKey) {
        AgGridReact[propKey] = propType;
    });
}


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
/** The base frameworks, eg React & Angular 2, override this bean with implementations specific to their requirement. */
var BaseFrameworkFactory = (function () {
    function BaseFrameworkFactory() {
    }
    BaseFrameworkFactory.prototype.dateComponent = function (gridOptions) {
        return gridOptions.dateComponent;
    };
    BaseFrameworkFactory.prototype.colDefFloatingCellRenderer = function (colDef) {
        return colDef.pinnedRowCellRenderer;
    };
    BaseFrameworkFactory.prototype.colDefCellRenderer = function (colDef) {
        return colDef.cellRenderer;
    };
    BaseFrameworkFactory.prototype.colDefCellEditor = function (colDef) {
        return colDef.cellEditor;
    };
    BaseFrameworkFactory.prototype.colDefFilter = function (colDef) {
        return colDef.filter;
    };
    BaseFrameworkFactory.prototype.gridOptionsFullWidthCellRenderer = function (gridOptions) {
        return gridOptions.fullWidthCellRenderer;
    };
    BaseFrameworkFactory.prototype.gridOptionsGroupRowRenderer = function (gridOptions) {
        return gridOptions.groupRowRenderer;
    };
    BaseFrameworkFactory.prototype.gridOptionsGroupRowInnerRenderer = function (gridOptions) {
        return gridOptions.groupRowInnerRenderer;
    };
    BaseFrameworkFactory.prototype.setTimeout = function (action, timeout) {
        setTimeout(action, timeout);
    };
    return BaseFrameworkFactory;
}());
exports.BaseFrameworkFactory = BaseFrameworkFactory;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var column_1 = __webpack_require__(9);
var gridOptionsWrapper_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(1);
var columnController_1 = __webpack_require__(3);
var AutoGroupColService = (function () {
    function AutoGroupColService() {
    }
    AutoGroupColService_1 = AutoGroupColService;
    AutoGroupColService.prototype.createAutoGroupColumns = function (rowGroupColumns) {
        var _this = this;
        var groupAutoColumns = [];
        var doingTreeData = this.gridOptionsWrapper.isTreeData();
        var doingMultiAutoColumn = this.gridOptionsWrapper.isGroupMultiAutoColumn();
        if (doingTreeData && doingMultiAutoColumn) {
            console.log('ag-Grid: you cannot mix groupMultiAutoColumn with treeData, only one column can be used to display groups when doing tree data');
            doingMultiAutoColumn = false;
        }
        // if doing groupMultiAutoColumn, then we call the method multiple times, once
        // for each column we are grouping by
        if (doingMultiAutoColumn) {
            rowGroupColumns.forEach(function (rowGroupCol, index) {
                groupAutoColumns.push(_this.createOneAutoGroupColumn(rowGroupCol, index));
            });
        }
        else {
            groupAutoColumns.push(this.createOneAutoGroupColumn(null));
        }
        return groupAutoColumns;
    };
    // rowGroupCol and index are missing if groupMultiAutoColumn=false
    AutoGroupColService.prototype.createOneAutoGroupColumn = function (rowGroupCol, index) {
        // if one provided by user, use it, otherwise create one
        var defaultAutoColDef = this.generateDefaultColDef(rowGroupCol, index);
        var userAutoColDef = this.gridOptionsWrapper.getAutoGroupColumnDef();
        // if doing multi, set the field
        var colId;
        if (rowGroupCol) {
            colId = AutoGroupColService_1.GROUP_AUTO_COLUMN_ID + "-" + rowGroupCol.getId();
        }
        else {
            colId = AutoGroupColService_1.GROUP_AUTO_COLUMN_BUNDLE_ID;
        }
        utils_1._.mergeDeep(defaultAutoColDef, userAutoColDef);
        defaultAutoColDef.colId = colId;
        var noUserFilterPreferences = userAutoColDef == null || userAutoColDef.suppressFilter == null;
        if (noUserFilterPreferences && !this.gridOptionsWrapper.isTreeData()) {
            var produceLeafNodeValues = defaultAutoColDef.field != null || defaultAutoColDef.valueGetter != null;
            defaultAutoColDef.suppressFilter = !produceLeafNodeValues;
        }
        // if showing many cols, we don't want to show more than one with a checkbox for selection
        if (index > 0) {
            defaultAutoColDef.headerCheckboxSelection = false;
        }
        var newCol = new column_1.Column(defaultAutoColDef, colId, true);
        this.context.wireBean(newCol);
        return newCol;
    };
    AutoGroupColService.prototype.generateDefaultColDef = function (rowGroupCol, index) {
        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
        var defaultAutoColDef = {
            headerName: localeTextFunc('group', 'Group'),
            cellRenderer: 'group'
        };
        // we never allow moving the group column
        defaultAutoColDef.suppressMovable = true;
        if (rowGroupCol) {
            var rowGroupColDef = rowGroupCol.getColDef();
            utils_1._.assign(defaultAutoColDef, {
                // cellRendererParams.groupKey: colDefToCopy.field;
                headerName: this.columnController.getDisplayNameForColumn(rowGroupCol, 'header'),
                headerValueGetter: rowGroupColDef.headerValueGetter
            });
            if (rowGroupColDef.cellRenderer) {
                utils_1._.assign(defaultAutoColDef, {
                    cellRendererParams: {
                        innerRenderer: rowGroupColDef.cellRenderer,
                        innerRendererParams: rowGroupColDef.cellRendererParams
                    }
                });
            }
            defaultAutoColDef.showRowGroup = rowGroupCol.getColId();
        }
        else {
            defaultAutoColDef.showRowGroup = true;
        }
        return defaultAutoColDef;
    };
    AutoGroupColService.GROUP_AUTO_COLUMN_ID = 'ag-Grid-AutoColumn';
    AutoGroupColService.GROUP_AUTO_COLUMN_BUNDLE_ID = AutoGroupColService_1.GROUP_AUTO_COLUMN_ID;
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], AutoGroupColService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], AutoGroupColService.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], AutoGroupColService.prototype, "columnController", void 0);
    AutoGroupColService = AutoGroupColService_1 = __decorate([
        context_1.Bean('autoGroupColService')
    ], AutoGroupColService);
    return AutoGroupColService;
    var AutoGroupColService_1;
}());
exports.AutoGroupColService = AutoGroupColService;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
// class returns a unique id to use for the column. it checks the existing columns, and if the requested
// id is already taken, it will start appending numbers until it gets a unique id.
// eg, if the col field is 'name', it will try ids: {name, name_1, name_2...}
// if no field or id provided in the col, it will try the ids of natural numbers
var utils_1 = __webpack_require__(1);
var ColumnKeyCreator = (function () {
    function ColumnKeyCreator() {
        this.existingKeys = [];
    }
    ColumnKeyCreator.prototype.getUniqueKey = function (colId, colField) {
        // in case user passed in number for colId, convert to string
        colId = utils_1.Utils.toStringOrNull(colId);
        var count = 0;
        while (true) {
            var idToTry = void 0;
            if (colId) {
                idToTry = colId;
                if (count !== 0) {
                    idToTry += '_' + count;
                }
            }
            else if (colField) {
                idToTry = colField;
                if (count !== 0) {
                    idToTry += '_' + count;
                }
            }
            else {
                idToTry = '' + count;
            }
            if (this.existingKeys.indexOf(idToTry) < 0) {
                this.existingKeys.push(idToTry);
                return idToTry;
            }
            count++;
        }
    };
    return ColumnKeyCreator;
}());
exports.ColumnKeyCreator = ColumnKeyCreator;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var componentResolver_1 = __webpack_require__(22);
var context_1 = __webpack_require__(0);
var componentProvider_1 = __webpack_require__(68);
var agComponentUtils_1 = __webpack_require__(48);
var NamedComponentResolver = (function () {
    function NamedComponentResolver() {
    }
    NamedComponentResolver.prototype.resolve = function (propertyName, componentNameOpt) {
        var componentName = componentNameOpt != null ? componentNameOpt : propertyName;
        var registeredComponent = this.componentProvider.retrieve(componentName);
        if (registeredComponent == null)
            return null;
        //If it is a FW it has to be registered as a component
        if (registeredComponent.type == componentResolver_1.ComponentType.FRAMEWORK) {
            return {
                component: registeredComponent.component,
                type: componentResolver_1.ComponentType.FRAMEWORK,
                source: componentResolver_1.ComponentSource.REGISTERED_BY_NAME
            };
        }
        //If it is JS it may be a function or a component
        if (this.agComponentUtils.doesImplementIComponent(registeredComponent.component)) {
            return {
                component: registeredComponent.component,
                type: componentResolver_1.ComponentType.AG_GRID,
                source: (registeredComponent.source == componentProvider_1.RegisteredComponentSource.REGISTERED) ? componentResolver_1.ComponentSource.REGISTERED_BY_NAME : componentResolver_1.ComponentSource.DEFAULT
            };
        }
        // This is a function
        return this.agComponentUtils.adaptFunction(propertyName, registeredComponent.component, registeredComponent.type, (registeredComponent.source == componentProvider_1.RegisteredComponentSource.REGISTERED) ? componentResolver_1.ComponentSource.REGISTERED_BY_NAME : componentResolver_1.ComponentSource.DEFAULT);
    };
    __decorate([
        context_1.Autowired("componentProvider"),
        __metadata("design:type", componentProvider_1.ComponentProvider)
    ], NamedComponentResolver.prototype, "componentProvider", void 0);
    __decorate([
        context_1.Autowired("agComponentUtils"),
        __metadata("design:type", agComponentUtils_1.AgComponentUtils)
    ], NamedComponentResolver.prototype, "agComponentUtils", void 0);
    NamedComponentResolver = __decorate([
        context_1.Bean("namedComponentResolver")
    ], NamedComponentResolver);
    return NamedComponentResolver;
}());
exports.NamedComponentResolver = NamedComponentResolver;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var componentAnnotations_1 = __webpack_require__(12);
var baseFilter_1 = __webpack_require__(52);
var NumberFilter = (function (_super) {
    __extends(NumberFilter, _super);
    function NumberFilter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NumberFilter.prototype.modelFromFloatingFilter = function (from) {
        return {
            type: this.filter,
            filter: Number(from),
            filterTo: this.filterNumberTo,
            filterType: 'number'
        };
    };
    NumberFilter.prototype.getApplicableFilterTypes = function () {
        return [baseFilter_1.BaseFilter.EQUALS, baseFilter_1.BaseFilter.NOT_EQUAL, baseFilter_1.BaseFilter.LESS_THAN, baseFilter_1.BaseFilter.LESS_THAN_OR_EQUAL,
            baseFilter_1.BaseFilter.GREATER_THAN, baseFilter_1.BaseFilter.GREATER_THAN_OR_EQUAL, baseFilter_1.BaseFilter.IN_RANGE];
    };
    NumberFilter.prototype.bodyTemplate = function () {
        var translate = this.translate.bind(this);
        return "<div class=\"ag-filter-body\">\n            <div>\n                <input class=\"ag-filter-filter\" id=\"filterText\" type=\"text\" placeholder=\"" + translate('filterOoo') + "\"/>\n            </div>\n             <div class=\"ag-filter-number-to\" id=\"filterNumberToPanel\">\n                <input class=\"ag-filter-filter\" id=\"filterToText\" type=\"text\" placeholder=\"" + translate('filterOoo') + "\"/>\n            </div>\n        </div>";
    };
    NumberFilter.prototype.initialiseFilterBodyUi = function () {
        this.filterNumber = null;
        this.eFilterTextField = this.queryForHtmlInputElement("#filterText");
        var debounceMs = this.filterParams.debounceMs != null ? this.filterParams.debounceMs : 500;
        var toDebounce = utils_1.Utils.debounce(this.onTextFieldsChanged.bind(this), debounceMs);
        this.addDestroyableEventListener(this.eFilterTextField, "input", toDebounce);
        this.addDestroyableEventListener(this.eFilterToTextField, "input", toDebounce);
    };
    NumberFilter.prototype.afterGuiAttached = function () {
        this.eFilterTextField.focus();
    };
    NumberFilter.prototype.comparator = function () {
        return function (left, right) {
            if (left === right)
                return 0;
            if (left < right)
                return 1;
            if (left > right)
                return -1;
        };
    };
    NumberFilter.prototype.onTextFieldsChanged = function () {
        var newFilter = this.stringToFloat(this.eFilterTextField.value);
        var newFilterTo = this.stringToFloat(this.eFilterToTextField.value);
        if (this.filterNumber !== newFilter || this.filterNumberTo !== newFilterTo) {
            this.filterNumber = newFilter;
            this.filterNumberTo = newFilterTo;
            this.onFilterChanged();
        }
    };
    NumberFilter.prototype.filterValues = function () {
        return this.filter !== baseFilter_1.BaseFilter.IN_RANGE ?
            this.asNumber(this.filterNumber) :
            [this.asNumber(this.filterNumber), this.asNumber(this.filterNumberTo)];
    };
    NumberFilter.prototype.asNumber = function (value) {
        return utils_1.Utils.isNumeric(value) ? value : null;
    };
    NumberFilter.prototype.stringToFloat = function (value) {
        var filterText = utils_1.Utils.makeNull(value);
        if (filterText && filterText.trim() === '') {
            filterText = null;
        }
        var newFilter;
        if (filterText !== null && filterText !== undefined) {
            newFilter = parseFloat(filterText);
        }
        else {
            newFilter = null;
        }
        return newFilter;
    };
    NumberFilter.prototype.setFilter = function (filter) {
        filter = utils_1.Utils.makeNull(filter);
        if (filter !== null && !(typeof filter === 'number')) {
            filter = parseFloat(filter);
        }
        this.filterNumber = filter;
        this.eFilterTextField.value = filter;
    };
    NumberFilter.prototype.setFilterTo = function (filter) {
        filter = utils_1.Utils.makeNull(filter);
        if (filter !== null && !(typeof filter === 'number')) {
            filter = parseFloat(filter);
        }
        this.filterNumberTo = filter;
        this.eFilterToTextField.value = filter;
    };
    NumberFilter.prototype.getFilter = function () {
        return this.filterNumber;
    };
    NumberFilter.prototype.serialize = function () {
        return {
            type: this.filter ? this.filter : this.defaultFilter,
            filter: this.filterNumber,
            filterTo: this.filterNumberTo,
            filterType: 'number'
        };
    };
    NumberFilter.prototype.parse = function (model) {
        this.setFilterType(model.type);
        this.setFilter(model.filter);
        this.setFilterTo(model.filterTo);
    };
    NumberFilter.prototype.refreshFilterBodyUi = function () {
        var visible = this.filter === NumberFilter.IN_RANGE;
        utils_1.Utils.setVisible(this.eNumberToPanel, visible);
    };
    NumberFilter.prototype.resetState = function () {
        this.setFilterType(this.defaultFilter);
        this.setFilter(null);
        this.setFilterTo(null);
    };
    NumberFilter.prototype.setType = function (filterType) {
        this.setFilterType(filterType);
    };
    NumberFilter.LESS_THAN = 'lessThan'; //3;
    __decorate([
        componentAnnotations_1.QuerySelector('#filterNumberToPanel'),
        __metadata("design:type", HTMLElement)
    ], NumberFilter.prototype, "eNumberToPanel", void 0);
    __decorate([
        componentAnnotations_1.QuerySelector('#filterToText'),
        __metadata("design:type", HTMLInputElement)
    ], NumberFilter.prototype, "eFilterToTextField", void 0);
    return NumberFilter;
}(baseFilter_1.ScalarBaseFilter));
exports.NumberFilter = NumberFilter;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var baseFilter_1 = __webpack_require__(52);
var componentAnnotations_1 = __webpack_require__(12);
var TextFilter = (function (_super) {
    __extends(TextFilter, _super);
    function TextFilter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TextFilter.prototype.getDefaultType = function () {
        return baseFilter_1.BaseFilter.CONTAINS;
    };
    TextFilter.prototype.customInit = function () {
        this.comparator = this.filterParams.textCustomComparator ? this.filterParams.textCustomComparator : TextFilter.DEFAULT_COMPARATOR;
        this.formatter =
            this.filterParams.textFormatter ? this.filterParams.textFormatter :
                this.filterParams.caseSensitive == true ? TextFilter.DEFAULT_FORMATTER :
                    TextFilter.DEFAULT_LOWERCASE_FORMATTER;
        _super.prototype.customInit.call(this);
    };
    TextFilter.prototype.modelFromFloatingFilter = function (from) {
        return {
            type: this.filter,
            filter: from,
            filterType: 'text'
        };
    };
    TextFilter.prototype.getApplicableFilterTypes = function () {
        return [baseFilter_1.BaseFilter.EQUALS, baseFilter_1.BaseFilter.NOT_EQUAL, baseFilter_1.BaseFilter.STARTS_WITH, baseFilter_1.BaseFilter.ENDS_WITH,
            baseFilter_1.BaseFilter.CONTAINS, baseFilter_1.BaseFilter.NOT_CONTAINS];
    };
    TextFilter.prototype.bodyTemplate = function () {
        var translate = this.translate.bind(this);
        return "<div class=\"ag-filter-body\">\n            <input class=\"ag-filter-filter\" id=\"filterText\" type=\"text\" placeholder=\"" + translate('filterOoo', 'Filter...') + "\"/>\n        </div>";
    };
    TextFilter.prototype.initialiseFilterBodyUi = function () {
        _super.prototype.initialiseFilterBodyUi.call(this);
        var debounceMs = this.filterParams.debounceMs != null ? this.filterParams.debounceMs : 500;
        var toDebounce = utils_1.Utils.debounce(this.onFilterTextFieldChanged.bind(this), debounceMs);
        this.addDestroyableEventListener(this.eFilterTextField, 'input', toDebounce);
    };
    TextFilter.prototype.refreshFilterBodyUi = function () { };
    TextFilter.prototype.afterGuiAttached = function () {
        this.eFilterTextField.focus();
    };
    TextFilter.prototype.filterValues = function () {
        return this.filterText;
    };
    TextFilter.prototype.doesFilterPass = function (params) {
        if (!this.filterText) {
            return true;
        }
        var value = this.filterParams.valueGetter(params.node);
        if (!value) {
            if (this.filter === baseFilter_1.BaseFilter.NOT_EQUAL || this.filter === baseFilter_1.BaseFilter.NOT_CONTAINS) {
                // if there is no value, but the filter type was 'not equals',
                // then it should pass, as a missing value is not equal whatever
                // the user is filtering on
                return true;
            }
            else {
                // otherwise it's some type of comparison, to which empty value
                // will always fail
                return false;
            }
        }
        var valueFormatted = this.formatter(value);
        return this.comparator(this.filter, valueFormatted, this.filterText);
    };
    TextFilter.prototype.onFilterTextFieldChanged = function () {
        var filterText = utils_1.Utils.makeNull(this.eFilterTextField.value);
        if (filterText && filterText.trim() === '') {
            filterText = null;
        }
        if (this.filterText !== filterText) {
            var newLowerCase = filterText && this.filterParams.caseSensitive != true ? filterText.toLowerCase() :
                filterText;
            var previousLowerCase = this.filterText && this.filterParams.caseSensitive != true ? this.filterText.toLowerCase() :
                this.filterText;
            this.filterText = this.formatter(filterText);
            if (previousLowerCase !== newLowerCase) {
                this.onFilterChanged();
            }
        }
    };
    TextFilter.prototype.setFilter = function (filter) {
        filter = utils_1.Utils.makeNull(filter);
        if (filter) {
            this.filterText = this.formatter(filter);
            this.eFilterTextField.value = filter;
        }
        else {
            this.filterText = null;
            this.eFilterTextField.value = null;
        }
    };
    TextFilter.prototype.getFilter = function () {
        return this.filterText;
    };
    TextFilter.prototype.resetState = function () {
        this.setFilter(null);
        this.setFilterType(this.defaultFilter);
    };
    TextFilter.prototype.serialize = function () {
        return {
            type: this.filter ? this.filter : this.defaultFilter,
            filter: this.filterText,
            filterType: 'text'
        };
    };
    TextFilter.prototype.parse = function (model) {
        this.setFilterType(model.type);
        this.setFilter(model.filter);
    };
    TextFilter.prototype.setType = function (filterType) {
        this.setFilterType(filterType);
    };
    TextFilter.DEFAULT_FORMATTER = function (from) {
        return from;
    };
    TextFilter.DEFAULT_LOWERCASE_FORMATTER = function (from) {
        if (from == null)
            return null;
        return from.toString().toLowerCase();
    };
    TextFilter.DEFAULT_COMPARATOR = function (filter, value, filterText) {
        switch (filter) {
            case TextFilter.CONTAINS:
                return value.indexOf(filterText) >= 0;
            case TextFilter.NOT_CONTAINS:
                return value.indexOf(filterText) === -1;
            case TextFilter.EQUALS:
                return value === filterText;
            case TextFilter.NOT_EQUAL:
                return value != filterText;
            case TextFilter.STARTS_WITH:
                return value.indexOf(filterText) === 0;
            case TextFilter.ENDS_WITH:
                var index = value.lastIndexOf(filterText);
                return index >= 0 && index === (value.length - filterText.length);
            default:
                // should never happen
                console.warn('invalid filter type ' + filter);
                return false;
        }
    };
    __decorate([
        componentAnnotations_1.QuerySelector('#filterText'),
        __metadata("design:type", HTMLInputElement)
    ], TextFilter.prototype, "eFilterTextField", void 0);
    return TextFilter;
}(baseFilter_1.ComparableBaseFilter));
exports.TextFilter = TextFilter;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridCell_1 = __webpack_require__(23);
var constants_1 = __webpack_require__(7);
var mouseEventService_1 = __webpack_require__(38);
var paginationProxy_1 = __webpack_require__(29);
var focusedCellController_1 = __webpack_require__(24);
var utils_1 = __webpack_require__(1);
var gridPanel_1 = __webpack_require__(10);
var animationFrameService_1 = __webpack_require__(40);
var columnController_1 = __webpack_require__(3);
var gridOptionsWrapper_1 = __webpack_require__(2);
var NavigationService = (function () {
    function NavigationService() {
    }
    NavigationService.prototype.init = function () {
        this.scrollWidth = this.gridOptionsWrapper.getScrollbarWidth();
    };
    NavigationService.prototype.handlePageScrollingKey = function (event) {
        var key = event.which || event.keyCode;
        var alt = event.altKey;
        var ctrl = event.ctrlKey;
        var currentCell = this.mouseEventService.getGridCellForEvent(event).getGridCellDef();
        if (!currentCell) {
            return false;
        }
        var processed = false;
        switch (key) {
            case constants_1.Constants.KEY_PAGE_HOME:
            case constants_1.Constants.KEY_PAGE_END:
                // handle home and end when ctrl & alt are NOT pressed
                if (!ctrl && !alt) {
                    this.onHomeOrEndKey(key);
                    processed = true;
                }
                break;
            case constants_1.Constants.KEY_LEFT:
            case constants_1.Constants.KEY_RIGHT:
                // handle left and right when ctrl is pressed only
                if (ctrl && !alt) {
                    this.onCtrlLeftOrRight(key, currentCell);
                    processed = true;
                }
                break;
            case constants_1.Constants.KEY_UP:
            case constants_1.Constants.KEY_DOWN:
                // handle up and down when ctrl is pressed only
                if (ctrl && !alt) {
                    this.onCtrlUpOrDown(key, currentCell);
                    processed = true;
                }
                break;
            case constants_1.Constants.KEY_PAGE_DOWN:
                // handle page up and page down when ctrl & alt are NOT pressed
                if (!ctrl && !alt) {
                    this.onPageDown(currentCell);
                    processed = true;
                }
                break;
            case constants_1.Constants.KEY_PAGE_UP:
                // handle page up and page down when ctrl & alt are NOT pressed
                if (!ctrl && !alt) {
                    this.onPageUp(currentCell);
                    processed = true;
                }
                break;
        }
        if (processed) {
            event.preventDefault();
        }
        return processed;
    };
    NavigationService.prototype.onPageDown = function (gridCell) {
        var viewport = this.gridPanel.getPrimaryScrollViewport();
        var pixelsInOnePage = viewport.offsetHeight;
        if (this.gridPanel.isHorizontalScrollShowing()) {
            pixelsInOnePage -= this.scrollWidth;
        }
        var pagingPixelOffset = this.paginationProxy.getPixelOffset();
        var currentPageBottomPixel = viewport.scrollTop + pixelsInOnePage;
        var currentPageBottomRow = this.paginationProxy.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);
        var scrollIndex = currentPageBottomRow;
        var currentCellPixel = this.paginationProxy.getRow(gridCell.rowIndex).rowTop;
        var nextCellPixel = currentCellPixel + pixelsInOnePage - pagingPixelOffset;
        var focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);
        var pageLastRow = this.paginationProxy.getPageLastRow();
        if (focusIndex > pageLastRow) {
            focusIndex = pageLastRow;
        }
        if (scrollIndex > pageLastRow) {
            scrollIndex = pageLastRow;
        }
        this.navigateTo(scrollIndex, 'top', null, focusIndex, gridCell.column);
    };
    NavigationService.prototype.onPageUp = function (gridCell) {
        var viewport = this.gridPanel.getPrimaryScrollViewport();
        var pixelsInOnePage = viewport.offsetHeight;
        if (this.gridPanel.isHorizontalScrollShowing()) {
            pixelsInOnePage -= this.scrollWidth;
        }
        var pagingPixelOffset = this.paginationProxy.getPixelOffset();
        var currentPageTopPixel = viewport.scrollTop;
        var currentPageTopRow = this.paginationProxy.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);
        var scrollIndex = currentPageTopRow;
        var currentRowNode = this.paginationProxy.getRow(gridCell.rowIndex);
        var nextCellPixel = currentRowNode.rowTop + currentRowNode.rowHeight - pixelsInOnePage - pagingPixelOffset;
        var focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);
        var firstRow = this.paginationProxy.getPageFirstRow();
        if (focusIndex < firstRow) {
            focusIndex = firstRow;
        }
        if (scrollIndex < firstRow) {
            scrollIndex = firstRow;
        }
        this.navigateTo(scrollIndex, 'bottom', null, focusIndex, gridCell.column);
    };
    // common logic to navigate. takes parameters:
    // scrollIndex - what row to vertically scroll to
    // scrollType - what position to put scroll index ie top/bottom
    // scrollColumn - what column to horizontally scroll to
    // focusIndex / focusColumn - for page up / down, we want to scroll to one row/column, but focus another
    NavigationService.prototype.navigateTo = function (scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn) {
        if (utils_1._.exists(scrollColumn)) {
            this.gridPanel.ensureColumnVisible(scrollColumn);
        }
        if (utils_1._.exists(scrollIndex)) {
            this.gridPanel.ensureIndexVisible(scrollIndex, scrollType);
        }
        // make sure the cell is rendered, needed if we are to focus
        this.animationFrameService.flushAllFrames();
        // if we don't do this, the range will be left on the last cell, which will leave the last focused cell
        // highlighted.
        this.focusedCellController.setFocusedCell(focusIndex, focusColumn, null, true);
        if (this.rangeController) {
            var gridCell = new gridCell_1.GridCell({ rowIndex: focusIndex, floating: null, column: focusColumn });
            this.rangeController.setRangeToCell(gridCell);
        }
    };
    // ctrl + up/down will bring focus to same column, first/last row. no horizontal scrolling.
    NavigationService.prototype.onCtrlUpOrDown = function (key, gridCell) {
        var upKey = key === constants_1.Constants.KEY_UP;
        var rowIndexToScrollTo = upKey ? 0 : this.paginationProxy.getPageLastRow();
        this.navigateTo(rowIndexToScrollTo, null, gridCell.column, rowIndexToScrollTo, gridCell.column);
    };
    // ctrl + left/right will bring focus to same row, first/last cell. no vertical scrolling.
    NavigationService.prototype.onCtrlLeftOrRight = function (key, gridCell) {
        var leftKey = key === constants_1.Constants.KEY_LEFT;
        var allColumns = this.columnController.getAllDisplayedColumns();
        var columnToSelect = leftKey ? allColumns[0] : allColumns[allColumns.length - 1];
        this.navigateTo(gridCell.rowIndex, null, columnToSelect, gridCell.rowIndex, columnToSelect);
    };
    // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
    // same cell into view (which means either scroll all the way up, or all the way down).
    NavigationService.prototype.onHomeOrEndKey = function (key) {
        var homeKey = key === constants_1.Constants.KEY_PAGE_HOME;
        var allColumns = this.columnController.getAllDisplayedColumns();
        var columnToSelect = homeKey ? allColumns[0] : allColumns[allColumns.length - 1];
        var rowIndexToScrollTo = homeKey ? 0 : this.paginationProxy.getPageLastRow();
        this.navigateTo(rowIndexToScrollTo, null, columnToSelect, rowIndexToScrollTo, columnToSelect);
    };
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], NavigationService.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('mouseEventService'),
        __metadata("design:type", mouseEventService_1.MouseEventService)
    ], NavigationService.prototype, "mouseEventService", void 0);
    __decorate([
        context_1.Autowired('paginationProxy'),
        __metadata("design:type", paginationProxy_1.PaginationProxy)
    ], NavigationService.prototype, "paginationProxy", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'),
        __metadata("design:type", focusedCellController_1.FocusedCellController)
    ], NavigationService.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Autowired('animationFrameService'),
        __metadata("design:type", animationFrameService_1.AnimationFrameService)
    ], NavigationService.prototype, "animationFrameService", void 0);
    __decorate([
        context_1.Optional('rangeController'),
        __metadata("design:type", Object)
    ], NavigationService.prototype, "rangeController", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], NavigationService.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], NavigationService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], NavigationService.prototype, "init", null);
    NavigationService = __decorate([
        context_1.Bean('navigationService')
    ], NavigationService);
    return NavigationService;
}());
exports.NavigationService = NavigationService;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var dragAndDropService_1 = __webpack_require__(21);
var columnController_1 = __webpack_require__(3);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var BodyDropPivotTarget = (function () {
    function BodyDropPivotTarget(pinned) {
        this.columnsToAggregate = [];
        this.columnsToGroup = [];
        this.columnsToPivot = [];
        this.pinned = pinned;
    }
    /** Callback for when drag enters */
    BodyDropPivotTarget.prototype.onDragEnter = function (draggingEvent) {
        var _this = this;
        this.clearColumnsList();
        // in pivot mode, we don't accept any drops if functions are read only
        if (this.gridOptionsWrapper.isFunctionsReadOnly()) {
            return;
        }
        var dragColumns = draggingEvent.dragItem.columns;
        dragColumns.forEach(function (column) {
            // we don't allow adding secondary columns
            if (!column.isPrimary()) {
                return;
            }
            if (column.isAnyFunctionActive()) {
                return;
            }
            if (column.isAllowValue()) {
                _this.columnsToAggregate.push(column);
            }
            else if (column.isAllowRowGroup()) {
                _this.columnsToGroup.push(column);
            }
            else if (column.isAllowRowGroup()) {
                _this.columnsToPivot.push(column);
            }
        });
    };
    BodyDropPivotTarget.prototype.getIconName = function () {
        var totalColumns = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
        if (totalColumns > 0) {
            return this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;
        }
        else {
            return null;
        }
    };
    /** Callback for when drag leaves */
    BodyDropPivotTarget.prototype.onDragLeave = function (draggingEvent) {
        // if we are taking columns out of the center, then we remove them from the report
        this.clearColumnsList();
    };
    BodyDropPivotTarget.prototype.clearColumnsList = function () {
        this.columnsToAggregate.length = 0;
        this.columnsToGroup.length = 0;
        this.columnsToPivot.length = 0;
    };
    /** Callback for when dragging */
    BodyDropPivotTarget.prototype.onDragging = function (draggingEvent) {
    };
    /** Callback for when drag stops */
    BodyDropPivotTarget.prototype.onDragStop = function (draggingEvent) {
        if (this.columnsToAggregate.length > 0) {
            this.columnController.addValueColumns(this.columnsToAggregate);
        }
        if (this.columnsToGroup.length > 0) {
            this.columnController.addRowGroupColumns(this.columnsToGroup);
        }
        if (this.columnsToPivot.length > 0) {
            this.columnController.addPivotColumns(this.columnsToPivot);
        }
    };
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], BodyDropPivotTarget.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], BodyDropPivotTarget.prototype, "gridOptionsWrapper", void 0);
    return BodyDropPivotTarget;
}());
exports.BodyDropPivotTarget = BodyDropPivotTarget;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var dragAndDropService_1 = __webpack_require__(21);
var context_1 = __webpack_require__(0);
var moveColumnController_1 = __webpack_require__(105);
var column_1 = __webpack_require__(9);
var gridPanel_1 = __webpack_require__(10);
var bodyDropPivotTarget_1 = __webpack_require__(100);
var columnController_1 = __webpack_require__(3);
var BodyDropTarget = (function () {
    function BodyDropTarget(pinned, eContainer) {
        this.pinned = pinned;
        this.eContainer = eContainer;
    }
    BodyDropTarget.prototype.getSecondaryContainers = function () {
        return this.eSecondaryContainers;
    };
    BodyDropTarget.prototype.getContainer = function () {
        return this.eContainer;
    };
    BodyDropTarget.prototype.init = function () {
        this.moveColumnController = new moveColumnController_1.MoveColumnController(this.pinned, this.eContainer);
        this.context.wireBean(this.moveColumnController);
        this.bodyDropPivotTarget = new bodyDropPivotTarget_1.BodyDropPivotTarget(this.pinned);
        this.context.wireBean(this.bodyDropPivotTarget);
        switch (this.pinned) {
            case column_1.Column.PINNED_LEFT:
                this.eSecondaryContainers = this.gridPanel.getDropTargetLeftContainers();
                break;
            case column_1.Column.PINNED_RIGHT:
                this.eSecondaryContainers = this.gridPanel.getDropTargetPinnedRightContainers();
                break;
            default:
                this.eSecondaryContainers = this.gridPanel.getDropTargetBodyContainers();
                break;
        }
        this.dragAndDropService.addDropTarget(this);
    };
    BodyDropTarget.prototype.getIconName = function () {
        return this.currentDropListener.getIconName();
    };
    // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
    // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
    // dropped into the grid's body.
    BodyDropTarget.prototype.isUseBodyDropPivotTarget = function (draggingEvent) {
        // if not in pivot mode, then we never use the pivot drop target
        if (!this.columnController.isPivotMode()) {
            return false;
        }
        // otherwise we use the drop target if the column came from the toolPanel (ie not reordering)
        return draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.ToolPanel;
    };
    BodyDropTarget.prototype.onDragEnter = function (draggingEvent) {
        // we pick the drop listener depending on whether we are in pivot mode are not. if we are
        // in pivot mode, then dropping cols changes the row group, pivot, value stats. otherwise
        // we change visibility state and position.
        // if (this.columnController.isPivotMode()) {
        var useBodyDropPivotTarget = this.isUseBodyDropPivotTarget(draggingEvent);
        if (useBodyDropPivotTarget) {
            this.currentDropListener = this.bodyDropPivotTarget;
        }
        else {
            this.currentDropListener = this.moveColumnController;
        }
        this.currentDropListener.onDragEnter(draggingEvent);
    };
    BodyDropTarget.prototype.onDragLeave = function (params) {
        this.currentDropListener.onDragLeave(params);
    };
    BodyDropTarget.prototype.onDragging = function (params) {
        this.currentDropListener.onDragging(params);
    };
    BodyDropTarget.prototype.onDragStop = function (params) {
        this.currentDropListener.onDragStop(params);
    };
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], BodyDropTarget.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], BodyDropTarget.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'),
        __metadata("design:type", dragAndDropService_1.DragAndDropService)
    ], BodyDropTarget.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], BodyDropTarget.prototype, "columnController", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BodyDropTarget.prototype, "init", null);
    return BodyDropTarget;
}());
exports.BodyDropTarget = BodyDropTarget;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var context_1 = __webpack_require__(0);
var dragAndDropService_1 = __webpack_require__(21);
var columnController_1 = __webpack_require__(3);
var gridPanel_1 = __webpack_require__(10);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var headerRowComp_1 = __webpack_require__(103);
var bodyDropTarget_1 = __webpack_require__(101);
var column_1 = __webpack_require__(9);
var scrollVisibleService_1 = __webpack_require__(34);
var HeaderContainer = (function () {
    function HeaderContainer(eContainer, eViewport, eRoot, pinned) {
        this.headerRowComps = [];
        this.eContainer = eContainer;
        this.eRoot = eRoot;
        this.pinned = pinned;
        this.eViewport = eViewport;
    }
    HeaderContainer.prototype.forEachHeaderElement = function (callback) {
        this.headerRowComps.forEach(function (headerRowComp) { return headerRowComp.forEachHeaderElement(callback); });
    };
    HeaderContainer.prototype.init = function () {
        this.setupDragAndDrop();
        // if value changes, then if not pivoting, we at least need to change the label eg from sum() to avg(),
        // if pivoting, then the columns have changed
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
    };
    // if row group changes, that means we may need to add aggFunc's to the column headers,
    // if the grid goes from no aggregation (ie no grouping) to grouping
    HeaderContainer.prototype.onColumnRowGroupChanged = function () {
        this.onGridColumnsChanged();
    };
    // if the agg func of a column changes, then we may need to update the agg func in columns header
    HeaderContainer.prototype.onColumnValueChanged = function () {
        this.onGridColumnsChanged();
    };
    HeaderContainer.prototype.onColumnResized = function () {
        this.setWidthIfPinnedContainer();
    };
    HeaderContainer.prototype.onDisplayedColumnsChanged = function () {
        this.setWidthIfPinnedContainer();
    };
    HeaderContainer.prototype.onScrollVisibilityChanged = function () {
        this.setWidthIfPinnedContainer();
    };
    HeaderContainer.prototype.setWidthIfPinnedContainer = function () {
        if (this.pinned === column_1.Column.PINNED_LEFT) {
            var pinnedLeftWidthWithScroll = this.scrollVisibleService.getPinnedLeftWithScrollWidth();
            this.eContainer.style.width = pinnedLeftWidthWithScroll + 'px';
        }
        else if (this.pinned === column_1.Column.PINNED_RIGHT) {
            var pinnedRightWidthWithScroll = this.scrollVisibleService.getPinnedRightWithScrollWidth();
            this.eContainer.style.width = pinnedRightWidthWithScroll + 'px';
        }
    };
    HeaderContainer.prototype.destroy = function () {
        this.removeHeaderRowComps();
    };
    // grid cols have changed - this also means the number of rows in the header can have
    // changed. so we remove all the old rows and insert new ones for a complete refresh
    HeaderContainer.prototype.onGridColumnsChanged = function () {
        this.removeHeaderRowComps();
        this.createHeaderRowComps();
    };
    // we expose this for gridOptions.api.refreshHeader() to call
    HeaderContainer.prototype.refresh = function () {
        this.onGridColumnsChanged();
    };
    HeaderContainer.prototype.setupDragAndDrop = function () {
        var dropContainer = this.eViewport ? this.eViewport : this.eContainer;
        var bodyDropTarget = new bodyDropTarget_1.BodyDropTarget(this.pinned, dropContainer);
        this.context.wireBean(bodyDropTarget);
    };
    HeaderContainer.prototype.removeHeaderRowComps = function () {
        this.headerRowComps.forEach(function (headerRowComp) {
            headerRowComp.destroy();
        });
        this.headerRowComps.length = 0;
        utils_1.Utils.removeAllChildren(this.eContainer);
    };
    HeaderContainer.prototype.createHeaderRowComps = function () {
        // if we are displaying header groups, then we have many rows here.
        // go through each row of the header, one by one.
        var rowCount = this.columnController.getHeaderRowCount();
        for (var dept = 0; dept < rowCount; dept++) {
            var groupRow = dept !== (rowCount - 1);
            var type = groupRow ? headerRowComp_1.HeaderRowType.COLUMN_GROUP : headerRowComp_1.HeaderRowType.COLUMN;
            var headerRowComp = new headerRowComp_1.HeaderRowComp(dept, type, this.pinned, this.eRoot, this.dropTarget);
            this.context.wireBean(headerRowComp);
            this.headerRowComps.push(headerRowComp);
            this.eContainer.appendChild(headerRowComp.getGui());
        }
        var includeFloatingFilterRow = this.gridOptionsWrapper.isFloatingFilter() && !this.columnController.isPivotMode();
        if (includeFloatingFilterRow) {
            var headerRowComp = new headerRowComp_1.HeaderRowComp(rowCount, headerRowComp_1.HeaderRowType.FLOATING_FILTER, this.pinned, this.eRoot, this.dropTarget);
            this.context.wireBean(headerRowComp);
            this.headerRowComps.push(headerRowComp);
            this.eContainer.appendChild(headerRowComp.getGui());
        }
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderContainer.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], HeaderContainer.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('$scope'),
        __metadata("design:type", Object)
    ], HeaderContainer.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'),
        __metadata("design:type", dragAndDropService_1.DragAndDropService)
    ], HeaderContainer.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], HeaderContainer.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], HeaderContainer.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], HeaderContainer.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('scrollVisibleService'),
        __metadata("design:type", scrollVisibleService_1.ScrollVisibleService)
    ], HeaderContainer.prototype, "scrollVisibleService", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeaderContainer.prototype, "init", null);
    return HeaderContainer;
}());
exports.HeaderContainer = HeaderContainer;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var column_1 = __webpack_require__(9);
var renderedHeaderCell_1 = __webpack_require__(75);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var utils_1 = __webpack_require__(1);
var headerWrapperComp_1 = __webpack_require__(104);
var headerGroupWrapperComp_1 = __webpack_require__(140);
var filterManager_1 = __webpack_require__(16);
var componentRecipes_1 = __webpack_require__(27);
var HeaderRowType;
(function (HeaderRowType) {
    HeaderRowType[HeaderRowType["COLUMN_GROUP"] = 0] = "COLUMN_GROUP";
    HeaderRowType[HeaderRowType["COLUMN"] = 1] = "COLUMN";
    HeaderRowType[HeaderRowType["FLOATING_FILTER"] = 2] = "FLOATING_FILTER";
})(HeaderRowType = exports.HeaderRowType || (exports.HeaderRowType = {}));
var HeaderRowComp = (function (_super) {
    __extends(HeaderRowComp, _super);
    function HeaderRowComp(dept, type, pinned, eRoot, dropTarget) {
        var _this = _super.call(this, "<div class=\"ag-header-row\" role=\"presentation\"/>") || this;
        _this.headerCompPromises = {};
        _this.warnedUserOnOldHeaderTemplate = false;
        _this.dept = dept;
        _this.type = type;
        _this.pinned = pinned;
        _this.eRoot = eRoot;
        _this.dropTarget = dropTarget;
        return _this;
    }
    HeaderRowComp.prototype.forEachHeaderElement = function (callback) {
        var _this = this;
        var promises = [];
        Object.keys(this.headerCompPromises).forEach(function (key) {
            promises.push(_this.headerCompPromises[key]);
        });
        utils_1.Promise.all(promises).then(function (combined) { return combined.forEach(function (headerElement) { return callback(headerElement); }); });
    };
    HeaderRowComp.prototype.destroy = function () {
        var idsOfAllChildren = Object.keys(this.headerCompPromises);
        this.removeAndDestroyChildComponents(idsOfAllChildren);
        _super.prototype.destroy.call(this);
    };
    HeaderRowComp.prototype.removeAndDestroyChildComponents = function (idsToDestroy) {
        var _this = this;
        idsToDestroy.forEach(function (id) {
            _this.headerCompPromises[id].then(function (childPromise) {
                _this.getGui().removeChild(childPromise.getGui());
                if (childPromise.destroy) {
                    childPromise.destroy();
                }
                delete _this.headerCompPromises[id];
            });
        });
    };
    HeaderRowComp.prototype.onRowHeightChanged = function () {
        var headerRowCount = this.columnController.getHeaderRowCount();
        var sizes = [];
        var numberOfFloating = 0;
        var groupHeight;
        var headerHeight;
        if (!this.columnController.isPivotMode()) {
            if (this.gridOptionsWrapper.isFloatingFilter()) {
                headerRowCount++;
            }
            numberOfFloating = (this.gridOptionsWrapper.isFloatingFilter()) ? 1 : 0;
            groupHeight = this.gridOptionsWrapper.getGroupHeaderHeight();
            headerHeight = this.gridOptionsWrapper.getHeaderHeight();
        }
        else {
            numberOfFloating = 0;
            groupHeight = this.gridOptionsWrapper.getPivotGroupHeaderHeight();
            headerHeight = this.gridOptionsWrapper.getPivotHeaderHeight();
        }
        var numberOfNonGroups = 1 + numberOfFloating;
        var numberOfGroups = headerRowCount - numberOfNonGroups;
        for (var i = 0; i < numberOfGroups; i++)
            sizes.push(groupHeight);
        sizes.push(headerHeight);
        for (var i = 0; i < numberOfFloating; i++)
            sizes.push(this.gridOptionsWrapper.getFloatingFiltersHeight());
        var rowHeight = 0;
        for (var i = 0; i < this.dept; i++)
            rowHeight += sizes[i];
        this.getGui().style.top = rowHeight + 'px';
        this.getGui().style.height = sizes[this.dept] + 'px';
    };
    //noinspection JSUnusedLocalSymbols
    HeaderRowComp.prototype.init = function () {
        this.onRowHeightChanged();
        this.onVirtualColumnsChanged();
        this.setWidth();
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_HEADER_HEIGHT, this.onRowHeightChanged.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_GROUP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this));
        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_FLOATING_FILTERS_HEIGHT, this.onRowHeightChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
    };
    HeaderRowComp.prototype.onColumnResized = function () {
        this.setWidth();
    };
    HeaderRowComp.prototype.setWidth = function () {
        var mainRowWidth = this.columnController.getContainerWidth(this.pinned) + 'px';
        this.getGui().style.width = mainRowWidth;
    };
    HeaderRowComp.prototype.onGridColumnsChanged = function () {
        this.removeAndDestroyAllChildComponents();
    };
    HeaderRowComp.prototype.removeAndDestroyAllChildComponents = function () {
        var idsOfAllChildren = Object.keys(this.headerCompPromises);
        this.removeAndDestroyChildComponents(idsOfAllChildren);
    };
    HeaderRowComp.prototype.onDisplayedColumnsChanged = function () {
        this.onVirtualColumnsChanged();
        this.setWidth();
    };
    HeaderRowComp.prototype.onVirtualColumnsChanged = function () {
        var _this = this;
        var currentChildIds = Object.keys(this.headerCompPromises);
        var itemsAtDepth = this.columnController.getVirtualHeaderGroupRow(this.pinned, this.type == HeaderRowType.FLOATING_FILTER ?
            this.dept - 1 :
            this.dept);
        var ensureDomOrder = this.gridOptionsWrapper.isEnsureDomOrder();
        var eBefore;
        itemsAtDepth.forEach(function (child) {
            // skip groups that have no displayed children. this can happen when the group is broken,
            // and this section happens to have nothing to display for the open / closed state.
            // (a broken group is one that is split, ie columns in the group have a non-group column
            // in between them)
            if (child.isEmptyGroup()) {
                return;
            }
            var idOfChild = child.getUniqueId();
            var eParentContainer = _this.getGui();
            // if we already have this cell rendered, do nothing
            var colAlreadyInDom = currentChildIds.indexOf(idOfChild) >= 0;
            var headerCompPromise;
            var eHeaderCompGui;
            if (colAlreadyInDom) {
                utils_1.Utils.removeFromArray(currentChildIds, idOfChild);
                headerCompPromise = _this.headerCompPromises[idOfChild];
                headerCompPromise.then(function (headerComp) {
                    eBefore = eHeaderCompGui;
                    eHeaderCompGui = headerComp.getGui();
                    if (ensureDomOrder) {
                        utils_1.Utils.ensureDomOrder(eParentContainer, eHeaderCompGui, eBefore);
                    }
                });
            }
            else {
                headerCompPromise = _this.createHeaderComp(child);
                _this.headerCompPromises[idOfChild] = headerCompPromise;
                headerCompPromise.then(function (headerComp) {
                    eBefore = eHeaderCompGui;
                    eHeaderCompGui = headerComp.getGui();
                    if (ensureDomOrder) {
                        utils_1.Utils.insertWithDomOrder(eParentContainer, eHeaderCompGui, eBefore);
                    }
                    else {
                        eParentContainer.appendChild(eHeaderCompGui);
                    }
                });
            }
        });
        // at this point, anything left in currentChildIds is an element that is no longer in the viewport
        this.removeAndDestroyChildComponents(currentChildIds);
    };
    // check if user is using the deprecated
    HeaderRowComp.prototype.isUsingOldHeaderRenderer = function (column) {
        var colDef = column.getColDef();
        var usingOldHeaderRenderer = utils_1.Utils.anyExists([
            // header template
            this.gridOptionsWrapper.getHeaderCellTemplateFunc(),
            this.gridOptionsWrapper.getHeaderCellTemplate(),
            colDef.headerCellTemplate,
            // header cellRenderer
            colDef.headerCellRenderer,
            this.gridOptionsWrapper.getHeaderCellRenderer()
        ]);
        if (usingOldHeaderRenderer && !this.warnedUserOnOldHeaderTemplate) {
            if (this.gridOptionsWrapper.getHeaderCellTemplate() || this.gridOptionsWrapper.getHeaderCellTemplateFunc()) {
                console.warn('ag-Grid: Since ag-Grid v14 you can now specify a template for the default header component. The ability to specify header template using colDef.headerCellTemplate is now deprecated and will be removed in v15. Please change your code to specify the template as colDef.headerComponentParams.template');
            }
            if (this.gridOptionsWrapper.getHeaderCellRenderer()) {
                console.warn('ag-Grid: Using headerCellRenderer is deprecated and will be removed in ag-Grid v15. Please use Header Component instead.');
            }
            this.warnedUserOnOldHeaderTemplate = true;
        }
        return usingOldHeaderRenderer;
    };
    HeaderRowComp.prototype.createHeaderComp = function (columnGroupChild) {
        var _this = this;
        var resultPromise;
        switch (this.type) {
            case HeaderRowType.COLUMN:
                if (this.isUsingOldHeaderRenderer(columnGroupChild)) {
                    resultPromise = utils_1.Promise.resolve(new renderedHeaderCell_1.RenderedHeaderCell(columnGroupChild, this.eRoot, this.dropTarget, this.pinned));
                }
                else {
                    resultPromise = utils_1.Promise.resolve(new headerWrapperComp_1.HeaderWrapperComp(columnGroupChild, this.eRoot, this.dropTarget, this.pinned));
                }
                break;
            case HeaderRowType.COLUMN_GROUP:
                resultPromise = utils_1.Promise.resolve(new headerGroupWrapperComp_1.HeaderGroupWrapperComp(columnGroupChild, this.eRoot, this.dropTarget, this.pinned));
                break;
            case HeaderRowType.FLOATING_FILTER:
                var column = columnGroupChild;
                resultPromise = this.createFloatingFilterWrapper(column);
                break;
        }
        resultPromise.then(function (result) { return _this.context.wireBean(result); });
        return resultPromise;
    };
    HeaderRowComp.prototype.createFloatingFilterWrapper = function (column) {
        var _this = this;
        var floatingFilterParams = this.createFloatingFilterParams(column);
        var floatingFilterWrapperPromise = this.componentRecipes.newFloatingFilterWrapperComponent(column, floatingFilterParams);
        floatingFilterWrapperPromise.then(function (floatingFilterWrapper) {
            _this.addDestroyableEventListener(column, column_1.Column.EVENT_FILTER_CHANGED, function () {
                var filterComponentPromise = _this.filterManager.getFilterComponent(column);
                floatingFilterWrapper.onParentModelChanged(filterComponentPromise.resolveNow(null, function (filter) { return filter.getModel(); }));
            });
            var cachedFilter = _this.filterManager.cachedFilter(column);
            if (cachedFilter) {
                var filterComponentPromise = _this.filterManager.getFilterComponent(column);
                floatingFilterWrapper.onParentModelChanged(filterComponentPromise.resolveNow(null, function (filter) { return filter.getModel(); }));
            }
        });
        return floatingFilterWrapperPromise;
    };
    HeaderRowComp.prototype.createFloatingFilterParams = function (column) {
        var _this = this;
        // We always get the freshest reference to the baseFilter because the filters get sometimes created
        // and destroyed between calls
        //
        // let filterComponent:BaseFilter<any, any, any> = <any>this.filterManager.getFilterComponent(column);
        //
        var baseParams = {
            column: column,
            currentParentModel: function () {
                var filterComponentPromise = _this.filterManager.getFilterComponent(column);
                return filterComponentPromise.resolveNow(null, function (filter) {
                    return (filter.getNullableModel) ?
                        filter.getNullableModel() :
                        filter.getModel();
                });
            },
            onFloatingFilterChanged: function (change) {
                var captureModelChangedResolveFunc;
                var modelChanged = new utils_1.Promise(function (resolve) {
                    captureModelChangedResolveFunc = resolve;
                });
                var filterComponentPromise = _this.filterManager.getFilterComponent(column);
                filterComponentPromise.then(function (filterComponent) {
                    if (filterComponent.onFloatingFilterChanged) {
                        //If going through this branch of code the user MUST
                        //be passing an object of type change that contains
                        //a model propery inside and some other stuff
                        var result = filterComponent.onFloatingFilterChanged(change);
                        captureModelChangedResolveFunc(result);
                    }
                    else {
                        //If going through this branch of code the user MUST
                        //be passing the plain model and delegating to ag-Grid
                        //the responsibility to set the parent model and refresh
                        //the filters
                        filterComponent.setModel(change);
                        _this.filterManager.onFilterChanged();
                        captureModelChangedResolveFunc(true);
                    }
                });
                return modelChanged.resolveNow(true, function (modelChanged) { return modelChanged; });
            },
            //This one might be overriden from the colDef
            suppressFilterButton: false
        };
        return baseParams;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderRowComp.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], HeaderRowComp.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], HeaderRowComp.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], HeaderRowComp.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('filterManager'),
        __metadata("design:type", filterManager_1.FilterManager)
    ], HeaderRowComp.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('componentRecipes'),
        __metadata("design:type", componentRecipes_1.ComponentRecipes)
    ], HeaderRowComp.prototype, "componentRecipes", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeaderRowComp.prototype, "init", null);
    return HeaderRowComp;
}(component_1.Component));
exports.HeaderRowComp = HeaderRowComp;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var context_1 = __webpack_require__(0);
var column_1 = __webpack_require__(9);
var utils_1 = __webpack_require__(1);
var dragAndDropService_1 = __webpack_require__(21);
var columnController_1 = __webpack_require__(3);
var horizontalDragService_1 = __webpack_require__(39);
var gridOptionsWrapper_1 = __webpack_require__(2);
var cssClassApplier_1 = __webpack_require__(53);
var setLeftFeature_1 = __webpack_require__(42);
var gridApi_1 = __webpack_require__(6);
var sortController_1 = __webpack_require__(25);
var eventService_1 = __webpack_require__(4);
var componentRecipes_1 = __webpack_require__(27);
var agCheckbox_1 = __webpack_require__(61);
var componentAnnotations_1 = __webpack_require__(12);
var selectAllFeature_1 = __webpack_require__(142);
var events_1 = __webpack_require__(5);
var columnHoverService_1 = __webpack_require__(86);
var beans_1 = __webpack_require__(35);
var HeaderWrapperComp = (function (_super) {
    __extends(HeaderWrapperComp, _super);
    function HeaderWrapperComp(column, eRoot, dragSourceDropTarget, pinned) {
        var _this = _super.call(this, HeaderWrapperComp.TEMPLATE) || this;
        _this.column = column;
        _this.eRoot = eRoot;
        _this.dragSourceDropTarget = dragSourceDropTarget;
        _this.pinned = pinned;
        return _this;
    }
    HeaderWrapperComp.prototype.getColumn = function () {
        return this.column;
    };
    HeaderWrapperComp.prototype.init = function () {
        this.instantiate(this.context);
        var displayName = this.columnController.getDisplayNameForColumn(this.column, 'header', true);
        var enableSorting = this.gridOptionsWrapper.isEnableSorting() && !this.column.getColDef().suppressSorting;
        var enableMenu = this.menuFactory.isMenuEnabled(this.column) && !this.column.getColDef().suppressMenu;
        this.appendHeaderComp(displayName, enableSorting, enableMenu);
        this.setupWidth();
        this.setupMovingCss();
        this.setupTooltip();
        this.setupResize();
        this.setupMenuClass();
        this.setupSortableClass(enableSorting);
        this.addColumnHoverListener();
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_FILTER_ACTIVE_CHANGED, this.onFilterChanged.bind(this));
        this.onFilterChanged();
        this.addFeature(this.context, new selectAllFeature_1.SelectAllFeature(this.cbSelectAll, this.column));
        var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.column, this.getGui(), this.beans);
        setLeftFeature.init();
        this.addDestroyFunc(setLeftFeature.destroy.bind(setLeftFeature));
        this.addAttributes();
        cssClassApplier_1.CssClassApplier.addHeaderClassesFromColDef(this.column.getColDef(), this.getGui(), this.gridOptionsWrapper, this.column, null);
    };
    HeaderWrapperComp.prototype.addColumnHoverListener = function () {
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_HOVER_CHANGED, this.onColumnHover.bind(this));
        this.onColumnHover();
    };
    HeaderWrapperComp.prototype.onColumnHover = function () {
        var isHovered = this.columnHoverService.isHovered(this.column);
        utils_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-column-hover', isHovered);
    };
    HeaderWrapperComp.prototype.setupSortableClass = function (enableSorting) {
        if (enableSorting) {
            var element = this.getGui();
            utils_1.Utils.addCssClass(element, 'ag-header-cell-sortable');
        }
    };
    HeaderWrapperComp.prototype.onFilterChanged = function () {
        var filterPresent = this.column.isFilterActive();
        utils_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-header-cell-filtered', filterPresent);
    };
    HeaderWrapperComp.prototype.appendHeaderComp = function (displayName, enableSorting, enableMenu) {
        var _this = this;
        var params = {
            column: this.column,
            displayName: displayName,
            enableSorting: enableSorting,
            enableMenu: enableMenu,
            showColumnMenu: function (source) {
                _this.gridApi.showColumnMenuAfterButtonClick(_this.column, source);
            },
            progressSort: function (multiSort) {
                _this.sortController.progressSort(_this.column, !!multiSort);
            },
            setSort: function (sort, multiSort) {
                _this.sortController.setSortForColumn(_this.column, sort, !!multiSort);
            },
            api: this.gridApi,
            columnApi: this.columnApi,
            context: this.gridOptionsWrapper.getContext()
        };
        var callback = this.afterHeaderCompCreated.bind(this, displayName);
        this.componentRecipes.newHeaderComponent(params).then(callback);
    };
    HeaderWrapperComp.prototype.afterHeaderCompCreated = function (displayName, headerComp) {
        this.appendChild(headerComp);
        this.setupMove(headerComp.getGui(), displayName);
        if (headerComp.destroy) {
            this.addDestroyFunc(headerComp.destroy.bind(headerComp));
        }
    };
    HeaderWrapperComp.prototype.onColumnMovingChanged = function () {
        // this function adds or removes the moving css, based on if the col is moving.
        // this is what makes the header go dark when it is been moved (gives impression to
        // user that the column was picked up).
        if (this.column.isMoving()) {
            utils_1.Utils.addCssClass(this.getGui(), 'ag-header-cell-moving');
        }
        else {
            utils_1.Utils.removeCssClass(this.getGui(), 'ag-header-cell-moving');
        }
    };
    HeaderWrapperComp.prototype.setupMove = function (eHeaderCellLabel, displayName) {
        var _this = this;
        var suppressMove = this.gridOptionsWrapper.isSuppressMovableColumns()
            || this.column.getColDef().suppressMovable
            || this.gridOptionsWrapper.isForPrint();
        if (suppressMove) {
            return;
        }
        if (eHeaderCellLabel) {
            var dragSource_1 = {
                type: dragAndDropService_1.DragSourceType.HeaderCell,
                eElement: eHeaderCellLabel,
                dragItemCallback: function () { return _this.createDragItem(); },
                dragItemName: displayName,
                dragSourceDropTarget: this.dragSourceDropTarget
            };
            this.dragAndDropService.addDragSource(dragSource_1, true);
            this.addDestroyFunc(function () { return _this.dragAndDropService.removeDragSource(dragSource_1); });
        }
    };
    HeaderWrapperComp.prototype.createDragItem = function () {
        var visibleState = {};
        visibleState[this.column.getId()] = this.column.isVisible();
        return {
            columns: [this.column],
            visibleState: visibleState
        };
    };
    HeaderWrapperComp.prototype.setupResize = function () {
        var _this = this;
        var colDef = this.column.getColDef();
        // if no eResize in template, do nothing
        if (!this.eResize) {
            return;
        }
        if (!this.column.isResizable()) {
            utils_1.Utils.removeFromParent(this.eResize);
            return;
        }
        this.horizontalDragService.addDragHandling({
            eDraggableElement: this.eResize,
            eBody: this.eRoot,
            cursor: 'col-resize',
            startAfterPixels: 0,
            onDragStart: this.onDragStart.bind(this),
            onDragging: this.onDragging.bind(this)
        });
        var weWantAutoSize = !this.gridOptionsWrapper.isSuppressAutoSize() && !colDef.suppressAutoSize;
        if (weWantAutoSize) {
            this.addDestroyableEventListener(this.eResize, 'dblclick', function () {
                _this.columnController.autoSizeColumn(_this.column);
            });
        }
    };
    HeaderWrapperComp.prototype.onDragging = function (dragChange, finished) {
        var dragChangeNormalised = this.normaliseDragChange(dragChange);
        var newWidth = this.startWidth + dragChangeNormalised;
        this.columnController.setColumnWidth(this.column, newWidth, finished);
    };
    HeaderWrapperComp.prototype.onDragStart = function () {
        this.startWidth = this.column.getActualWidth();
    };
    HeaderWrapperComp.prototype.setupTooltip = function () {
        var colDef = this.column.getColDef();
        // add tooltip if exists
        if (colDef.headerTooltip) {
            this.getGui().title = colDef.headerTooltip;
        }
    };
    HeaderWrapperComp.prototype.setupMovingCss = function () {
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_MOVING_CHANGED, this.onColumnMovingChanged.bind(this));
        this.onColumnMovingChanged();
    };
    HeaderWrapperComp.prototype.addAttributes = function () {
        this.getGui().setAttribute("col-id", this.column.getColId());
    };
    HeaderWrapperComp.prototype.setupWidth = function () {
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_WIDTH_CHANGED, this.onColumnWidthChanged.bind(this));
        this.onColumnWidthChanged();
    };
    HeaderWrapperComp.prototype.setupMenuClass = function () {
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_MENU_VISIBLE_CHANGED, this.onMenuVisible.bind(this));
        this.onColumnWidthChanged();
    };
    HeaderWrapperComp.prototype.onMenuVisible = function () {
        this.addOrRemoveCssClass('ag-column-menu-visible', this.column.isMenuVisible());
    };
    HeaderWrapperComp.prototype.onColumnWidthChanged = function () {
        this.getGui().style.width = this.column.getActualWidth() + 'px';
    };
    // optionally inverts the drag, depending on pinned and RTL
    // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
    HeaderWrapperComp.prototype.normaliseDragChange = function (dragChange) {
        var result = dragChange;
        if (this.gridOptionsWrapper.isEnableRtl()) {
            // for RTL, dragging left makes the col bigger, except when pinning left
            if (this.pinned !== column_1.Column.PINNED_LEFT) {
                result *= -1;
            }
        }
        else {
            // for LTR (ie normal), dragging left makes the col smaller, except when pinning right
            if (this.pinned === column_1.Column.PINNED_RIGHT) {
                result *= -1;
            }
        }
        return result;
    };
    HeaderWrapperComp.TEMPLATE = '<div class="ag-header-cell" role="presentation" >' +
        '<div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>' +
        '<ag-checkbox ref="cbSelectAll" class="ag-header-select-all" role="presentation"></ag-checkbox>' +
        // <inner component goes here>
        '</div>';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderWrapperComp.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'),
        __metadata("design:type", dragAndDropService_1.DragAndDropService)
    ], HeaderWrapperComp.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], HeaderWrapperComp.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('horizontalDragService'),
        __metadata("design:type", horizontalDragService_1.HorizontalDragService)
    ], HeaderWrapperComp.prototype, "horizontalDragService", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], HeaderWrapperComp.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('menuFactory'),
        __metadata("design:type", Object)
    ], HeaderWrapperComp.prototype, "menuFactory", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], HeaderWrapperComp.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], HeaderWrapperComp.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('sortController'),
        __metadata("design:type", sortController_1.SortController)
    ], HeaderWrapperComp.prototype, "sortController", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], HeaderWrapperComp.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('componentRecipes'),
        __metadata("design:type", componentRecipes_1.ComponentRecipes)
    ], HeaderWrapperComp.prototype, "componentRecipes", void 0);
    __decorate([
        context_1.Autowired('columnHoverService'),
        __metadata("design:type", columnHoverService_1.ColumnHoverService)
    ], HeaderWrapperComp.prototype, "columnHoverService", void 0);
    __decorate([
        context_1.Autowired('beans'),
        __metadata("design:type", beans_1.Beans)
    ], HeaderWrapperComp.prototype, "beans", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eResize'),
        __metadata("design:type", HTMLElement)
    ], HeaderWrapperComp.prototype, "eResize", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('cbSelectAll'),
        __metadata("design:type", agCheckbox_1.AgCheckbox)
    ], HeaderWrapperComp.prototype, "cbSelectAll", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeaderWrapperComp.prototype, "init", null);
    return HeaderWrapperComp;
}(component_1.Component));
exports.HeaderWrapperComp = HeaderWrapperComp;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var logger_1 = __webpack_require__(11);
var columnController_1 = __webpack_require__(3);
var column_1 = __webpack_require__(9);
var utils_1 = __webpack_require__(1);
var dragAndDropService_1 = __webpack_require__(21);
var gridPanel_1 = __webpack_require__(10);
var gridOptionsWrapper_1 = __webpack_require__(2);
var MoveColumnController = (function () {
    function MoveColumnController(pinned, eContainer) {
        this.needToMoveLeft = false;
        this.needToMoveRight = false;
        this.pinned = pinned;
        this.eContainer = eContainer;
        this.centerContainer = !utils_1.Utils.exists(pinned);
    }
    MoveColumnController.prototype.init = function () {
        this.logger = this.loggerFactory.create('MoveColumnController');
    };
    MoveColumnController.prototype.getIconName = function () {
        return this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;
    };
    MoveColumnController.prototype.onDragEnter = function (draggingEvent) {
        // we do dummy drag, so make sure column appears in the right location when first placed
        var columns = draggingEvent.dragItem.columns;
        var dragCameFromToolPanel = draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.ToolPanel;
        if (dragCameFromToolPanel) {
            // the if statement doesn't work if drag leaves grid, then enters again
            this.columnController.setColumnsVisible(columns, true);
        }
        else {
            // restore previous state of visible columns upon re-entering
            var visibleState_1 = draggingEvent.dragItem.visibleState;
            var visibleColumns = columns.filter(function (column) { return visibleState_1[column.getId()]; });
            this.columnController.setColumnsVisible(visibleColumns, true);
        }
        this.columnController.setColumnsPinned(columns, this.pinned);
        this.onDragging(draggingEvent, true);
    };
    MoveColumnController.prototype.onDragLeave = function (draggingEvent) {
        var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;
        if (hideColumnOnExit) {
            var dragItem = draggingEvent.dragSource.dragItemCallback();
            var columns = dragItem.columns;
            this.columnController.setColumnsVisible(columns, false);
        }
        this.ensureIntervalCleared();
    };
    MoveColumnController.prototype.onDragStop = function () {
        this.ensureIntervalCleared();
    };
    MoveColumnController.prototype.normaliseX = function (x) {
        // flip the coordinate if doing RTL
        var flipHorizontallyForRtl = this.gridOptionsWrapper.isEnableRtl();
        if (flipHorizontallyForRtl) {
            var clientWidth = this.eContainer.clientWidth;
            x = clientWidth - x;
        }
        // adjust for scroll only if centre container (the pinned containers dont scroll)
        var adjustForScroll = this.centerContainer;
        if (adjustForScroll) {
            x += this.gridPanel.getBodyViewportScrollLeft();
        }
        return x;
    };
    MoveColumnController.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {
        if (this.centerContainer) {
            // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)
            // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen
            var firstVisiblePixel = this.gridPanel.getBodyViewportScrollLeft();
            var lastVisiblePixel = firstVisiblePixel + this.gridPanel.getCenterWidth();
            if (this.gridOptionsWrapper.isEnableRtl()) {
                this.needToMoveRight = xAdjustedForScroll < (firstVisiblePixel + 50);
                this.needToMoveLeft = xAdjustedForScroll > (lastVisiblePixel - 50);
            }
            else {
                this.needToMoveLeft = xAdjustedForScroll < (firstVisiblePixel + 50);
                this.needToMoveRight = xAdjustedForScroll > (lastVisiblePixel - 50);
            }
            if (this.needToMoveLeft || this.needToMoveRight) {
                this.ensureIntervalStarted();
            }
            else {
                this.ensureIntervalCleared();
            }
        }
    };
    MoveColumnController.prototype.onDragging = function (draggingEvent, fromEnter) {
        if (fromEnter === void 0) { fromEnter = false; }
        this.lastDraggingEvent = draggingEvent;
        // if moving up or down (ie not left or right) then do nothing
        if (utils_1.Utils.missing(draggingEvent.hDirection)) {
            return;
        }
        var xNormalised = this.normaliseX(draggingEvent.x);
        // if the user is dragging into the panel, ie coming from the side panel into the main grid,
        // we don't want to scroll the grid this time, it would appear like the table is jumping
        // each time a column is dragged in.
        if (!fromEnter) {
            this.checkCenterForScrolling(xNormalised);
        }
        var hDirectionNormalised = this.normaliseDirection(draggingEvent.hDirection);
        var dragSourceType = draggingEvent.dragSource.type;
        var columnsToMove = draggingEvent.dragSource.dragItemCallback().columns;
        this.attemptMoveColumns(dragSourceType, columnsToMove, hDirectionNormalised, xNormalised, fromEnter);
    };
    MoveColumnController.prototype.normaliseDirection = function (hDirection) {
        if (this.gridOptionsWrapper.isEnableRtl()) {
            switch (hDirection) {
                case dragAndDropService_1.HDirection.Left: return dragAndDropService_1.HDirection.Right;
                case dragAndDropService_1.HDirection.Right: return dragAndDropService_1.HDirection.Left;
                default: console.error("ag-Grid: Unknown direction " + hDirection);
            }
        }
        else {
            return hDirection;
        }
    };
    // returns the index of the first column in the list ONLY if the cols are all beside
    // each other. if the cols are not beside each other, then returns null
    MoveColumnController.prototype.calculateOldIndex = function (movingCols) {
        var gridCols = this.columnController.getAllGridColumns();
        var indexes = [];
        movingCols.forEach(function (col) { return indexes.push(gridCols.indexOf(col)); });
        utils_1.Utils.sortNumberArray(indexes);
        var firstIndex = indexes[0];
        var lastIndex = indexes[indexes.length - 1];
        var spread = lastIndex - firstIndex;
        var gapsExist = spread !== indexes.length - 1;
        return gapsExist ? null : firstIndex;
    };
    MoveColumnController.prototype.attemptMoveColumns = function (dragSourceType, allMovingColumns, hDirection, xAdjusted, fromEnter) {
        var draggingLeft = hDirection === dragAndDropService_1.HDirection.Left;
        var draggingRight = hDirection === dragAndDropService_1.HDirection.Right;
        var validMoves = this.calculateValidMoves(allMovingColumns, draggingRight, xAdjusted);
        // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move
        // (ie left or right) to the mouse direction. however
        var oldIndex = this.calculateOldIndex(allMovingColumns);
        // fromEnter = false;
        for (var i = 0; i < validMoves.length; i++) {
            var newIndex = validMoves[i];
            // the two check below stop an error when the user grabs a group my a middle column, then
            // it is possible the mouse pointer is to the right of a column while been dragged left.
            // so we need to make sure that the mouse pointer is actually left of the left most column
            // if moving left, and right of the right most column if moving right
            // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from
            // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should
            // place the column to the RHS even if the mouse is moving left and the column is already on
            // the LHS. otherwise we stick to the rule described above.
            var constrainDirection = oldIndex !== null && !fromEnter;
            // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag
            if (dragSourceType == dragAndDropService_1.DragSourceType.HeaderCell) {
                constrainDirection = oldIndex !== null;
            }
            if (constrainDirection) {
                // only allow left drag if this column is moving left
                if (draggingLeft && newIndex >= oldIndex) {
                    continue;
                }
                // only allow right drag if this column is moving right
                if (draggingRight && newIndex <= oldIndex) {
                    continue;
                }
            }
            if (!this.columnController.doesMovePassRules(allMovingColumns, newIndex)) {
                continue;
            }
            this.columnController.moveColumns(allMovingColumns, newIndex);
            // important to return here, so once we do the first valid move, we don't try do any more
            return;
        }
    };
    MoveColumnController.prototype.calculateValidMoves = function (movingCols, draggingRight, x) {
        // this is the list of cols on the screen, so it's these we use when comparing the x mouse position
        var allDisplayedCols = this.columnController.getDisplayedColumns(this.pinned);
        // but this list is the list of all cols, when we move a col it's the index within this list that gets used,
        // so the result we return has to be and index location for this list
        var allGridCols = this.columnController.getAllGridColumns();
        var colIsMovingFunc = function (col) { return movingCols.indexOf(col) >= 0; };
        var colIsNotMovingFunc = function (col) { return movingCols.indexOf(col) < 0; };
        var movingDisplayedCols = allDisplayedCols.filter(colIsMovingFunc);
        var otherDisplayedCols = allDisplayedCols.filter(colIsNotMovingFunc);
        var otherGridCols = allGridCols.filter(colIsNotMovingFunc);
        // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.
        // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving
        // col between b and c (so that it is under the mouse position).
        var displayIndex = 0;
        var availableWidth = x;
        // if we are dragging right, then the columns will be to the left of the mouse, so we also want to
        // include the width of the moving columns
        if (draggingRight) {
            var widthOfMovingDisplayedCols_1 = 0;
            movingDisplayedCols.forEach(function (col) { return widthOfMovingDisplayedCols_1 += col.getActualWidth(); });
            availableWidth -= widthOfMovingDisplayedCols_1;
        }
        // now count how many of the displayed columns will fit to the left
        for (var i = 0; i < otherDisplayedCols.length; i++) {
            var col = otherDisplayedCols[i];
            availableWidth -= col.getActualWidth();
            if (availableWidth < 0) {
                break;
            }
            displayIndex++;
        }
        // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works
        if (draggingRight) {
            displayIndex++;
        }
        // the display index is with respect to all the showing columns, however when we move, it's with
        // respect to all grid columns, so we need to translate from display index to grid index
        var gridColIndex;
        if (displayIndex > 0) {
            var leftColumn = otherDisplayedCols[displayIndex - 1];
            gridColIndex = otherGridCols.indexOf(leftColumn) + 1;
        }
        else {
            gridColIndex = 0;
        }
        var validMoves = [gridColIndex];
        // add in all adjacent empty columns as other valid moves. this allows us to try putting the new
        // column in any place of a hidden column, to try different combinations so that we don't break
        // married children. in other words, maybe the new index breaks a group, but only because some
        // columns are hidden, maybe we can reshuffle the hidden columns to find a place that works.
        var nextCol = allGridCols[gridColIndex];
        while (utils_1.Utils.exists(nextCol) && this.isColumnHidden(allDisplayedCols, nextCol)) {
            gridColIndex++;
            validMoves.push(gridColIndex);
            nextCol = allGridCols[gridColIndex];
        }
        return validMoves;
    };
    // isHidden takes into account visible=false and group=closed, ie it is not displayed
    MoveColumnController.prototype.isColumnHidden = function (displayedColumns, col) {
        return displayedColumns.indexOf(col) < 0;
    };
    MoveColumnController.prototype.ensureIntervalStarted = function () {
        if (!this.movingIntervalId) {
            this.intervalCount = 0;
            this.failedMoveAttempts = 0;
            this.movingIntervalId = setInterval(this.moveInterval.bind(this), 100);
            if (this.needToMoveLeft) {
                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_LEFT, true);
            }
            else {
                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_RIGHT, true);
            }
        }
    };
    MoveColumnController.prototype.ensureIntervalCleared = function () {
        if (this.moveInterval) {
            clearInterval(this.movingIntervalId);
            this.movingIntervalId = null;
            this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_MOVE);
        }
    };
    MoveColumnController.prototype.moveInterval = function () {
        var pixelsToMove;
        this.intervalCount++;
        pixelsToMove = 10 + (this.intervalCount * 5);
        if (pixelsToMove > 100) {
            pixelsToMove = 100;
        }
        var pixelsMoved;
        if (this.needToMoveLeft) {
            pixelsMoved = this.gridPanel.scrollHorizontally(-pixelsToMove);
        }
        else if (this.needToMoveRight) {
            pixelsMoved = this.gridPanel.scrollHorizontally(pixelsToMove);
        }
        if (pixelsMoved !== 0) {
            this.onDragging(this.lastDraggingEvent);
            this.failedMoveAttempts = 0;
        }
        else {
            this.failedMoveAttempts++;
            this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_PINNED);
            if (this.failedMoveAttempts > 7) {
                var columns = this.lastDraggingEvent.dragItem.columns;
                var pinType = this.needToMoveLeft ? column_1.Column.PINNED_LEFT : column_1.Column.PINNED_RIGHT;
                this.columnController.setColumnsPinned(columns, pinType);
                this.dragAndDropService.nudge();
            }
        }
    };
    __decorate([
        context_1.Autowired('loggerFactory'),
        __metadata("design:type", logger_1.LoggerFactory)
    ], MoveColumnController.prototype, "loggerFactory", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], MoveColumnController.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridPanel'),
        __metadata("design:type", gridPanel_1.GridPanel)
    ], MoveColumnController.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'),
        __metadata("design:type", dragAndDropService_1.DragAndDropService)
    ], MoveColumnController.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], MoveColumnController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], MoveColumnController.prototype, "init", null);
    return MoveColumnController;
}());
exports.MoveColumnController = MoveColumnController;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var filterManager_1 = __webpack_require__(16);
var utils_1 = __webpack_require__(1);
var popupService_1 = __webpack_require__(37);
var gridOptionsWrapper_1 = __webpack_require__(2);
var eventService_1 = __webpack_require__(4);
var StandardMenuFactory = (function () {
    function StandardMenuFactory() {
    }
    StandardMenuFactory.prototype.showMenuAfterMouseEvent = function (column, mouseEvent) {
        var _this = this;
        this.showPopup(column, function (eMenu) {
            _this.popupService.positionPopupUnderMouseEvent({
                column: column,
                type: 'columnMenu',
                mouseEvent: mouseEvent,
                ePopup: eMenu
            });
        });
    };
    StandardMenuFactory.prototype.showMenuAfterButtonClick = function (column, eventSource) {
        var _this = this;
        this.showPopup(column, function (eMenu) {
            _this.popupService.positionPopupUnderComponent({ type: 'columnMenu', eventSource: eventSource,
                ePopup: eMenu, keepWithinBounds: true, column: column });
        });
    };
    StandardMenuFactory.prototype.showPopup = function (column, positionCallback) {
        var _this = this;
        var filterWrapper = this.filterManager.getOrCreateFilterWrapper(column);
        var eMenu = document.createElement('div');
        utils_1.Utils.addCssClass(eMenu, 'ag-menu');
        filterWrapper.guiPromise.promise.then(function (gui) {
            eMenu.appendChild(gui);
        });
        var hidePopup;
        var bodyScrollListener = function (event) {
            // if h scroll, popup is no longer over the column
            if (event.direction === 'horizontal') {
                hidePopup();
            }
        };
        this.eventService.addEventListener('bodyScroll', bodyScrollListener);
        var closedCallback = function () {
            _this.eventService.removeEventListener('bodyScroll', bodyScrollListener);
            column.setMenuVisible(false);
        };
        // need to show filter before positioning, as only after filter
        // is visible can we find out what the width of it is
        hidePopup = this.popupService.addAsModalPopup(eMenu, true, closedCallback);
        positionCallback(eMenu);
        filterWrapper.filterPromise.then(function (filter) {
            if (filter.afterGuiAttached) {
                var params = {
                    hidePopup: hidePopup
                };
                filter.afterGuiAttached(params);
            }
        });
        column.setMenuVisible(true);
    };
    StandardMenuFactory.prototype.isMenuEnabled = function (column) {
        // for standard, we show menu if filter is enabled, and he menu is not suppressed
        return this.gridOptionsWrapper.isEnableFilter() && column.isFilterAllowed();
    };
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], StandardMenuFactory.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('filterManager'),
        __metadata("design:type", filterManager_1.FilterManager)
    ], StandardMenuFactory.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('popupService'),
        __metadata("design:type", popupService_1.PopupService)
    ], StandardMenuFactory.prototype, "popupService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], StandardMenuFactory.prototype, "gridOptionsWrapper", void 0);
    StandardMenuFactory = __decorate([
        context_1.Bean('menuFactory')
    ], StandardMenuFactory);
    return StandardMenuFactory;
}());
exports.StandardMenuFactory = StandardMenuFactory;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var constants_1 = __webpack_require__(7);
var utils_1 = __webpack_require__(1);
var LargeTextCellEditor = (function (_super) {
    __extends(LargeTextCellEditor, _super);
    function LargeTextCellEditor() {
        return _super.call(this, LargeTextCellEditor.TEMPLATE) || this;
    }
    LargeTextCellEditor.prototype.init = function (params) {
        this.params = params;
        this.focusAfterAttached = params.cellStartedEdit;
        this.textarea = document.createElement("textarea");
        this.textarea.maxLength = params.maxLength ? params.maxLength : "200";
        this.textarea.cols = params.cols ? params.cols : "60";
        this.textarea.rows = params.rows ? params.rows : "10";
        if (utils_1.Utils.exists(params.value)) {
            this.textarea.value = params.value.toString();
        }
        this.getGui().querySelector('.ag-large-textarea').appendChild(this.textarea);
        this.addGuiEventListener('keydown', this.onKeyDown.bind(this));
    };
    LargeTextCellEditor.prototype.onKeyDown = function (event) {
        var key = event.which || event.keyCode;
        if (key == constants_1.Constants.KEY_LEFT ||
            key == constants_1.Constants.KEY_UP ||
            key == constants_1.Constants.KEY_RIGHT ||
            key == constants_1.Constants.KEY_DOWN ||
            (event.shiftKey && key == constants_1.Constants.KEY_ENTER)) {
            event.stopPropagation();
        }
    };
    LargeTextCellEditor.prototype.afterGuiAttached = function () {
        if (this.focusAfterAttached) {
            this.textarea.focus();
        }
    };
    LargeTextCellEditor.prototype.getValue = function () {
        return this.textarea.value;
    };
    LargeTextCellEditor.prototype.isPopup = function () {
        return true;
    };
    LargeTextCellEditor.TEMPLATE = 
    // tab index is needed so we can focus, which is needed for keyboard events
    '<div class="ag-large-text" tabindex="0">' +
        '<div class="ag-large-textarea"></div>' +
        '</div>';
    return LargeTextCellEditor;
}(component_1.Component));
exports.LargeTextCellEditor = LargeTextCellEditor;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var selectCellEditor_1 = __webpack_require__(79);
var PopupSelectCellEditor = (function (_super) {
    __extends(PopupSelectCellEditor, _super);
    function PopupSelectCellEditor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PopupSelectCellEditor.prototype.isPopup = function () {
        return true;
    };
    return PopupSelectCellEditor;
}(selectCellEditor_1.SelectCellEditor));
exports.PopupSelectCellEditor = PopupSelectCellEditor;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var textCellEditor_1 = __webpack_require__(80);
var PopupTextCellEditor = (function (_super) {
    __extends(PopupTextCellEditor, _super);
    function PopupTextCellEditor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PopupTextCellEditor.prototype.isPopup = function () {
        return true;
    };
    return PopupTextCellEditor;
}(textCellEditor_1.TextCellEditor));
exports.PopupTextCellEditor = PopupTextCellEditor;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var rowNodeBlock_1 = __webpack_require__(59);
var logger_1 = __webpack_require__(11);
var context_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(1);
var RowNodeBlockLoader = (function () {
    function RowNodeBlockLoader(maxConcurrentRequests) {
        this.activeBlockLoadsCount = 0;
        this.blocks = [];
        this.active = true;
        this.maxConcurrentRequests = maxConcurrentRequests;
    }
    RowNodeBlockLoader.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('RowNodeBlockLoader');
    };
    RowNodeBlockLoader.prototype.addBlock = function (block) {
        this.blocks.push(block);
    };
    RowNodeBlockLoader.prototype.removeBlock = function (block) {
        utils_1._.removeFromArray(this.blocks, block);
    };
    RowNodeBlockLoader.prototype.destroy = function () {
        this.active = false;
    };
    RowNodeBlockLoader.prototype.loadComplete = function () {
        this.activeBlockLoadsCount--;
    };
    RowNodeBlockLoader.prototype.checkBlockToLoad = function () {
        if (!this.active) {
            return;
        }
        this.printCacheStatus();
        if (this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
            this.logger.log("checkBlockToLoad: max loads exceeded");
            return;
        }
        var blockToLoad = null;
        this.blocks.forEach(function (block) {
            if (block.getState() === rowNodeBlock_1.RowNodeBlock.STATE_DIRTY) {
                blockToLoad = block;
            }
        });
        if (blockToLoad) {
            blockToLoad.load();
            this.activeBlockLoadsCount++;
            this.logger.log("checkBlockToLoad: loading page " + blockToLoad.getBlockNumber());
            this.printCacheStatus();
        }
        else {
            this.logger.log("checkBlockToLoad: no pages to load");
        }
    };
    RowNodeBlockLoader.prototype.getBlockState = function () {
        var result = {};
        this.blocks.forEach(function (block) {
            var nodeIdPrefix = block.getNodeIdPrefix();
            var stateItem = {
                blockNumber: block.getBlockNumber(),
                startRow: block.getStartRow(),
                endRow: block.getEndRow(),
                pageStatus: block.getState()
            };
            if (utils_1._.exists(nodeIdPrefix)) {
                result[nodeIdPrefix + block.getBlockNumber()] = stateItem;
            }
            else {
                result[block.getBlockNumber()] = stateItem;
            }
        });
        return result;
    };
    RowNodeBlockLoader.prototype.printCacheStatus = function () {
        if (this.logger.isLogging()) {
            this.logger.log("printCacheStatus: activePageLoadsCount = " + this.activeBlockLoadsCount + ","
                + (" blocks = " + JSON.stringify(this.getBlockState())));
        }
    };
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], RowNodeBlockLoader.prototype, "setBeans", null);
    return RowNodeBlockLoader;
}());
exports.RowNodeBlockLoader = RowNodeBlockLoader;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var filterService_1 = __webpack_require__(117);
var FilterStage = (function () {
    function FilterStage() {
    }
    FilterStage.prototype.execute = function (params) {
        var rowNode = params.rowNode;
        if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
            this.filterService.filter(rowNode, false);
        }
        else {
            this.filterService.filterAccordingToColumnState(rowNode);
        }
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], FilterStage.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('filterService'),
        __metadata("design:type", filterService_1.FilterService)
    ], FilterStage.prototype, "filterService", void 0);
    FilterStage = __decorate([
        context_1.Bean('filterStage')
    ], FilterStage);
    return FilterStage;
}());
exports.FilterStage = FilterStage;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var rowNode_1 = __webpack_require__(15);
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var selectionController_1 = __webpack_require__(17);
var eventService_1 = __webpack_require__(4);
var columnController_1 = __webpack_require__(3);
var FlattenStage = (function () {
    function FlattenStage() {
    }
    FlattenStage.prototype.execute = function (params) {
        var rootNode = params.rowNode;
        // even if not doing grouping, we do the mapping, as the client might
        // of passed in data that already has a grouping in it somewhere
        var result = [];
        // putting value into a wrapper so it's passed by reference
        var nextRowTop = { value: 0 };
        var skipLeafNodes = this.columnController.isPivotMode();
        // if we are reducing, and not grouping, then we want to show the root node, as that
        // is where the pivot values are
        var showRootNode = skipLeafNodes && rootNode.leafGroup;
        var topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;
        // set all row tops to null, then set row tops on all visible rows. if we don't
        // do this, then the algorithm below only sets row tops, old row tops from old rows
        // will still lie around
        this.resetRowTops(rootNode);
        this.recursivelyAddToRowsToDisplay(topList, result, nextRowTop, skipLeafNodes, 0);
        return result;
    };
    FlattenStage.prototype.resetRowTops = function (rowNode) {
        rowNode.clearRowTop();
        if (rowNode.hasChildren()) {
            if (rowNode.childrenAfterGroup) {
                for (var i = 0; i < rowNode.childrenAfterGroup.length; i++) {
                    this.resetRowTops(rowNode.childrenAfterGroup[i]);
                }
            }
            if (rowNode.sibling) {
                rowNode.sibling.clearRowTop();
            }
        }
    };
    FlattenStage.prototype.recursivelyAddToRowsToDisplay = function (rowsToFlatten, result, nextRowTop, skipLeafNodes, uiLevel) {
        if (utils_1.Utils.missingOrEmpty(rowsToFlatten)) {
            return;
        }
        var groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();
        var hideOpenParents = this.gridOptionsWrapper.isGroupHideOpenParents();
        var groupRemoveSingleChildren = this.gridOptionsWrapper.isGroupRemoveSingleChildren();
        var groupRemoveLowestSingleChildren = this.gridOptionsWrapper.isGroupRemoveLowestSingleChildren();
        for (var i = 0; i < rowsToFlatten.length; i++) {
            var rowNode = rowsToFlatten[i];
            // check all these cases, for working out if this row should be included in the final mapped list
            var isParent = rowNode.hasChildren();
            var isGroupSuppressedNode = groupSuppressRow && isParent;
            var isSkippedLeafNode = skipLeafNodes && !isParent;
            var isRemovedSingleChildrenGroup = groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup.length === 1;
            var isRemovedLowestSingleChildrenGroup = groupRemoveLowestSingleChildren && isParent && rowNode.leafGroup && rowNode.childrenAfterGroup.length === 1;
            // hide open parents means when group is open, we don't show it. we also need to make sure the
            // group is expandable in the first place (as leaf groups are not expandable if pivot mode is on).
            // the UI will never allow expanding leaf  groups, however the user might via the API (or menu option 'expand all')
            var neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;
            var isHiddenOpenParent = hideOpenParents && rowNode.expanded && (!neverAllowToExpand);
            var thisRowShouldBeRendered = !isSkippedLeafNode && !isGroupSuppressedNode && !isHiddenOpenParent && !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;
            if (thisRowShouldBeRendered) {
                this.addRowNodeToRowsToDisplay(rowNode, result, nextRowTop, uiLevel);
            }
            // if we are pivoting, we never map below the leaf group
            if (skipLeafNodes && rowNode.leafGroup) {
                continue;
            }
            if (isParent) {
                // we traverse the group if it is expended, however we always traverse if the parent node
                // was removed (as the group will never be opened if it is not displayed, we show the children instead)
                if (rowNode.expanded || isRemovedSingleChildrenGroup) {
                    // if the parent was excluded, then ui level is that of the parent
                    var uiLevelForChildren = isRemovedSingleChildrenGroup ? uiLevel : uiLevel + 1;
                    this.recursivelyAddToRowsToDisplay(rowNode.childrenAfterSort, result, nextRowTop, skipLeafNodes, uiLevelForChildren);
                    // put a footer in if user is looking for it
                    if (this.gridOptionsWrapper.isGroupIncludeFooter()) {
                        this.ensureFooterNodeExists(rowNode);
                        this.addRowNodeToRowsToDisplay(rowNode.sibling, result, nextRowTop, uiLevel);
                    }
                }
                else {
                }
            }
            else if (rowNode.canFlower && rowNode.expanded) {
                var flowerNode = this.createFlowerNode(rowNode);
                this.addRowNodeToRowsToDisplay(flowerNode, result, nextRowTop, uiLevel);
            }
        }
    };
    // duplicated method, it's also in floatingRowModel
    FlattenStage.prototype.addRowNodeToRowsToDisplay = function (rowNode, result, nextRowTop, uiLevel) {
        result.push(rowNode);
        if (utils_1.Utils.missing(rowNode.rowHeight)) {
            var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);
            rowNode.setRowHeight(rowHeight);
        }
        rowNode.setUiLevel(uiLevel);
        rowNode.setRowTop(nextRowTop.value);
        rowNode.setRowIndex(result.length - 1);
        nextRowTop.value += rowNode.rowHeight;
    };
    FlattenStage.prototype.ensureFooterNodeExists = function (groupNode) {
        // only create footer node once, otherwise we have daemons and
        // the animate screws up with the daemons hanging around
        if (utils_1.Utils.exists(groupNode.sibling)) {
            return;
        }
        var footerNode = new rowNode_1.RowNode();
        this.context.wireBean(footerNode);
        Object.keys(groupNode).forEach(function (key) {
            footerNode[key] = groupNode[key];
        });
        footerNode.footer = true;
        footerNode.rowTop = null;
        footerNode.oldRowTop = null;
        if (utils_1.Utils.exists(footerNode.id)) {
            footerNode.id = 'rowGroupFooter_' + footerNode.id;
        }
        // get both header and footer to reference each other as siblings. this is never undone,
        // only overwritten. so if a group is expanded, then contracted, it will have a ghost
        // sibling - but that's fine, as we can ignore this if the header is contracted.
        footerNode.sibling = groupNode;
        groupNode.sibling = footerNode;
    };
    FlattenStage.prototype.createFlowerNode = function (parentNode) {
        if (utils_1.Utils.exists(parentNode.childFlower)) {
            return parentNode.childFlower;
        }
        else {
            var flowerNode = new rowNode_1.RowNode();
            this.context.wireBean(flowerNode);
            flowerNode.flower = true;
            flowerNode.parent = parentNode;
            if (utils_1.Utils.exists(parentNode.id)) {
                flowerNode.id = 'flowerNode_' + parentNode.id;
            }
            flowerNode.data = parentNode.data;
            flowerNode.level = parentNode.level + 1;
            parentNode.childFlower = flowerNode;
            return flowerNode;
        }
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], FlattenStage.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('selectionController'),
        __metadata("design:type", selectionController_1.SelectionController)
    ], FlattenStage.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], FlattenStage.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], FlattenStage.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], FlattenStage.prototype, "columnController", void 0);
    FlattenStage = __decorate([
        context_1.Bean('flattenStage')
    ], FlattenStage);
    return FlattenStage;
}());
exports.FlattenStage = FlattenStage;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var constants_1 = __webpack_require__(7);
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var ImmutableService = (function () {
    function ImmutableService() {
    }
    ImmutableService.prototype.postConstruct = function () {
        if (this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY) {
            this.inMemoryRowModel = this.rowModel;
        }
    };
    // converts the setRowData() command to a transaction
    ImmutableService.prototype.createTransactionForRowData = function (data) {
        if (utils_1._.missing(this.inMemoryRowModel)) {
            console.error('ag-Grid: ImmutableService only works with InMemoryRowModel');
            return;
        }
        var getRowNodeIdFunc = this.gridOptionsWrapper.getRowNodeIdFunc();
        if (utils_1._.missing(getRowNodeIdFunc)) {
            console.error('ag-Grid: ImmutableService requires getRowNodeId() callback to be implemented, your row data need IDs!');
            return;
        }
        // convert the data into a transaction object by working out adds, removes and updates
        var transaction = {
            remove: [],
            update: [],
            add: []
        };
        var existingNodesMap = this.inMemoryRowModel.getCopyOfNodesMap();
        var orderMap = {};
        if (utils_1._.exists(data)) {
            // split all the new data in the following:
            // if new, push to 'add'
            // if update, push to 'update'
            // if not changed, do not include in the transaction
            data.forEach(function (dataItem, index) {
                var id = getRowNodeIdFunc(dataItem);
                var existingNode = existingNodesMap[id];
                orderMap[id] = index;
                if (existingNode) {
                    var dataHasChanged = existingNode.data !== dataItem;
                    if (dataHasChanged) {
                        transaction.update.push(dataItem);
                    }
                    // otherwise, if data not changed, we just don't include it anywhere, as it's not a delta
                    // remove from list, so we know the item is not to be removed
                    existingNodesMap[id] = undefined;
                }
                else {
                    transaction.add.push(dataItem);
                }
            });
        }
        // at this point, all rows that are left, should be removed
        utils_1._.iterateObject(existingNodesMap, function (id, rowNode) {
            if (rowNode) {
                transaction.remove.push(rowNode.data);
            }
        });
        return [transaction, orderMap];
    };
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], ImmutableService.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ImmutableService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ImmutableService.prototype, "postConstruct", null);
    ImmutableService = __decorate([
        context_1.Bean('immutableService')
    ], ImmutableService);
    return ImmutableService;
}());
exports.ImmutableService = ImmutableService;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var constants_1 = __webpack_require__(7);
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var filterManager_1 = __webpack_require__(16);
var rowNode_1 = __webpack_require__(15);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var context_1 = __webpack_require__(0);
var selectionController_1 = __webpack_require__(17);
var inMemoryNodeManager_1 = __webpack_require__(89);
var changedPath_1 = __webpack_require__(88);
var valueService_1 = __webpack_require__(20);
var valueCache_1 = __webpack_require__(36);
var gridApi_1 = __webpack_require__(6);
var RecursionType;
(function (RecursionType) {
    RecursionType[RecursionType["Normal"] = 0] = "Normal";
    RecursionType[RecursionType["AfterFilter"] = 1] = "AfterFilter";
    RecursionType[RecursionType["AfterFilterAndSort"] = 2] = "AfterFilterAndSort";
    RecursionType[RecursionType["PivotNodes"] = 3] = "PivotNodes";
})(RecursionType || (RecursionType = {}));
;
var InMemoryRowModel = (function () {
    function InMemoryRowModel() {
    }
    InMemoryRowModel.prototype.init = function () {
        var refreshEverythingFunc = this.refreshModel.bind(this, { step: constants_1.Constants.STEP_EVERYTHING });
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, refreshEverythingFunc);
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: constants_1.Constants.STEP_PIVOT }));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);
        var refreshMapFunc = this.refreshModel.bind(this, { step: constants_1.Constants.STEP_MAP, keepRenderedRows: true, animate: true });
        this.gridOptionsWrapper.addEventListener(gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN, refreshMapFunc);
        this.gridOptionsWrapper.addEventListener(gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, refreshMapFunc);
        this.rootNode = new rowNode_1.RowNode();
        this.nodeManager = new inMemoryNodeManager_1.InMemoryNodeManager(this.rootNode, this.gridOptionsWrapper, this.context, this.eventService, this.columnController);
        this.context.wireBean(this.rootNode);
    };
    InMemoryRowModel.prototype.isLastRowFound = function () {
        return true;
    };
    InMemoryRowModel.prototype.getRowCount = function () {
        if (this.rowsToDisplay) {
            return this.rowsToDisplay.length;
        }
        else {
            return 0;
        }
    };
    InMemoryRowModel.prototype.getRowBounds = function (index) {
        if (utils_1.Utils.missing(this.rowsToDisplay)) {
            return null;
        }
        var rowNode = this.rowsToDisplay[index];
        if (rowNode) {
            return {
                rowTop: rowNode.rowTop,
                rowHeight: rowNode.rowHeight
            };
        }
        else {
            return null;
        }
    };
    InMemoryRowModel.prototype.onRowGroupOpened = function () {
        var animate = this.gridOptionsWrapper.isAnimateRows();
        this.refreshModel({ step: constants_1.Constants.STEP_MAP, keepRenderedRows: true, animate: animate });
    };
    InMemoryRowModel.prototype.onFilterChanged = function () {
        var animate = this.gridOptionsWrapper.isAnimateRows();
        this.refreshModel({ step: constants_1.Constants.STEP_FILTER, keepRenderedRows: true, animate: animate });
    };
    InMemoryRowModel.prototype.onSortChanged = function () {
        // we only act on the sort event here if the user is doing in grid sorting.
        // we ignore it if the sorting is happening on the server side.
        if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
            return;
        }
        var animate = this.gridOptionsWrapper.isAnimateRows();
        this.refreshModel({ step: constants_1.Constants.STEP_SORT, keepRenderedRows: true, animate: animate, keepEditingRows: true });
    };
    InMemoryRowModel.prototype.getType = function () {
        return constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY;
    };
    InMemoryRowModel.prototype.onValueChanged = function () {
        if (this.columnController.isPivotActive()) {
            this.refreshModel({ step: constants_1.Constants.STEP_PIVOT });
        }
        else {
            this.refreshModel({ step: constants_1.Constants.STEP_AGGREGATE });
        }
    };
    InMemoryRowModel.prototype.createChangePath = function (transaction) {
        if (!transaction) {
            return null;
        }
        // for updates, if the row is updated at all, then we re-calc all the values
        // in that row. we could compare each value to each old value, however if we
        // did this, we would be calling the valueService twice, once on the old value
        // and once on the new value. so it's less valueGetter calls if we just assume
        // each column is different. that way the changedPath is used so that only
        // the impacted parent rows are recalculated, parents who's children have
        // not changed are not impacted.
        var valueColumns = this.columnController.getValueColumns();
        if (!valueColumns || valueColumns.length === 0) {
            return null;
        }
        var changedPath = new changedPath_1.ChangedPath(false);
        return changedPath;
    };
    InMemoryRowModel.prototype.refreshModel = function (params) {
        // this goes through the pipeline of stages. what's in my head is similar
        // to the diagram on this page:
        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html
        // however we want to keep the results of each stage, hence we manually call
        // each step rather than have them chain each other.
        var _this = this;
        // fallthrough in below switch is on purpose,
        // eg if STEP_FILTER, then all steps below this
        // step get done
        // let start: number;
        // console.log('======= start =======');
        var changedPath = this.createChangePath(params.rowNodeTransaction);
        switch (params.step) {
            case constants_1.Constants.STEP_EVERYTHING:
                // start = new Date().getTime();
                this.doRowGrouping(params.groupState, params.rowNodeTransaction, params.rowNodeOrder, changedPath);
            // console.log('rowGrouping = ' + (new Date().getTime() - start));
            case constants_1.Constants.STEP_FILTER:
                // start = new Date().getTime();
                this.doFilter();
            // console.log('filter = ' + (new Date().getTime() - start));
            case constants_1.Constants.STEP_PIVOT:
                this.doPivot();
            case constants_1.Constants.STEP_AGGREGATE:// depends on agg fields
                // start = new Date().getTime();
                this.doAggregate(changedPath);
            // console.log('aggregation = ' + (new Date().getTime() - start));
            case constants_1.Constants.STEP_SORT:
                // start = new Date().getTime();
                this.doSort();
            // console.log('sort = ' + (new Date().getTime() - start));
            case constants_1.Constants.STEP_MAP:
                // start = new Date().getTime();
                this.doRowsToDisplay();
        }
        var event = {
            type: events_1.Events.EVENT_MODEL_UPDATED,
            api: this.gridApi,
            columnApi: this.columnApi,
            animate: params.animate,
            keepRenderedRows: params.keepRenderedRows,
            newData: params.newData,
            newPage: false
        };
        this.eventService.dispatchEvent(event);
        if (this.$scope) {
            setTimeout(function () {
                _this.$scope.$apply();
            }, 0);
        }
    };
    InMemoryRowModel.prototype.isEmpty = function () {
        var rowsMissing;
        var doingLegacyTreeData = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
        if (doingLegacyTreeData) {
            rowsMissing = utils_1.Utils.missing(this.rootNode.childrenAfterGroup) || this.rootNode.childrenAfterGroup.length === 0;
        }
        else {
            rowsMissing = utils_1.Utils.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
        }
        var empty = utils_1.Utils.missing(this.rootNode) || rowsMissing || !this.columnController.isReady();
        return empty;
    };
    InMemoryRowModel.prototype.isRowsToRender = function () {
        return utils_1.Utils.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
    };
    InMemoryRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {
        // if lastSelectedNode is missing, we start at the first row
        var firstRowHit = !lastInRange;
        var lastRowHit = false;
        var lastRow;
        var result = [];
        var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
        this.forEachNodeAfterFilterAndSort(function (rowNode) {
            var lookingForLastRow = firstRowHit && !lastRowHit;
            // check if we need to flip the select switch
            if (!firstRowHit) {
                if (rowNode === lastInRange || rowNode === firstInRange) {
                    firstRowHit = true;
                }
            }
            var skipThisGroupNode = rowNode.group && groupsSelectChildren;
            if (!skipThisGroupNode) {
                var inRange = firstRowHit && !lastRowHit;
                var childOfLastRow = rowNode.isParentOfNode(lastRow);
                if (inRange || childOfLastRow) {
                    result.push(rowNode);
                }
            }
            if (lookingForLastRow) {
                if (rowNode === lastInRange || rowNode === firstInRange) {
                    lastRowHit = true;
                    if (rowNode === lastInRange) {
                        lastRow = lastInRange;
                    }
                    else {
                        lastRow = firstInRange;
                    }
                }
            }
        });
        return result;
    };
    InMemoryRowModel.prototype.setDatasource = function (datasource) {
        console.error('ag-Grid: should never call setDatasource on inMemoryRowController');
    };
    InMemoryRowModel.prototype.getTopLevelNodes = function () {
        return this.rootNode ? this.rootNode.childrenAfterGroup : null;
    };
    InMemoryRowModel.prototype.getRootNode = function () {
        return this.rootNode;
    };
    InMemoryRowModel.prototype.getRow = function (index) {
        return this.rowsToDisplay[index];
    };
    InMemoryRowModel.prototype.isRowPresent = function (rowNode) {
        return this.rowsToDisplay.indexOf(rowNode) >= 0;
    };
    InMemoryRowModel.prototype.getVirtualRowCount = function () {
        console.warn('ag-Grid: rowModel.getVirtualRowCount() is not longer a function, use rowModel.getRowCount() instead');
        return this.getPageLastRow();
    };
    InMemoryRowModel.prototype.getPageFirstRow = function () {
        return 0;
    };
    InMemoryRowModel.prototype.getPageLastRow = function () {
        if (this.rowsToDisplay) {
            return this.rowsToDisplay.length - 1;
        }
        else {
            return 0;
        }
    };
    InMemoryRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {
        if (this.isEmpty()) {
            return -1;
        }
        // do binary search of tree
        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/
        var bottomPointer = 0;
        var topPointer = this.rowsToDisplay.length - 1;
        // quick check, if the pixel is out of bounds, then return last row
        if (pixelToMatch <= 0) {
            // if pixel is less than or equal zero, it's always the first row
            return 0;
        }
        var lastNode = this.rowsToDisplay[this.rowsToDisplay.length - 1];
        if (lastNode.rowTop <= pixelToMatch) {
            return this.rowsToDisplay.length - 1;
        }
        while (true) {
            var midPointer = Math.floor((bottomPointer + topPointer) / 2);
            var currentRowNode = this.rowsToDisplay[midPointer];
            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {
                return midPointer;
            }
            else if (currentRowNode.rowTop < pixelToMatch) {
                bottomPointer = midPointer + 1;
            }
            else if (currentRowNode.rowTop > pixelToMatch) {
                topPointer = midPointer - 1;
            }
        }
    };
    InMemoryRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {
        var topPixel = rowNode.rowTop;
        var bottomPixel = rowNode.rowTop + rowNode.rowHeight;
        var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
        return pixelInRow;
    };
    InMemoryRowModel.prototype.getCurrentPageHeight = function () {
        if (this.rowsToDisplay && this.rowsToDisplay.length > 0) {
            var lastRow = this.rowsToDisplay[this.rowsToDisplay.length - 1];
            var lastPixel = lastRow.rowTop + lastRow.rowHeight;
            return lastPixel;
        }
        else {
            return 0;
        }
    };
    InMemoryRowModel.prototype.forEachLeafNode = function (callback) {
        if (this.rootNode.allLeafChildren) {
            this.rootNode.allLeafChildren.forEach(function (rowNode, index) { return callback(rowNode, index); });
        }
    };
    InMemoryRowModel.prototype.forEachNode = function (callback) {
        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);
    };
    InMemoryRowModel.prototype.forEachNodeAfterFilter = function (callback) {
        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);
    };
    InMemoryRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {
        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);
    };
    InMemoryRowModel.prototype.forEachPivotNode = function (callback) {
        this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);
    };
    // iterates through each item in memory, and calls the callback function
    // nodes - the rowNodes to traverse
    // callback - the user provided callback
    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
    // index - works similar to the index in forEach in javascripts array function
    InMemoryRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {
        if (nodes) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                callback(node, index++);
                // go to the next level if it is a group
                if (node.hasChildren()) {
                    // depending on the recursion type, we pick a difference set of children
                    var nodeChildren = void 0;
                    switch (recursionType) {
                        case RecursionType.Normal:
                            nodeChildren = node.childrenAfterGroup;
                            break;
                        case RecursionType.AfterFilter:
                            nodeChildren = node.childrenAfterFilter;
                            break;
                        case RecursionType.AfterFilterAndSort:
                            nodeChildren = node.childrenAfterSort;
                            break;
                        case RecursionType.PivotNodes:
                            // for pivot, we don't go below leafGroup levels
                            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;
                            break;
                    }
                    if (nodeChildren) {
                        index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);
                    }
                }
            }
        }
        return index;
    };
    // it's possible to recompute the aggregate without doing the other parts
    // + gridApi.recomputeAggregates()
    InMemoryRowModel.prototype.doAggregate = function (changedPath) {
        if (this.aggregationStage) {
            this.aggregationStage.execute({ rowNode: this.rootNode, changedPath: changedPath });
        }
    };
    // + gridApi.expandAll()
    // + gridApi.collapseAll()
    InMemoryRowModel.prototype.expandOrCollapseAll = function (expand) {
        if (this.rootNode) {
            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);
        }
        function recursiveExpandOrCollapse(rowNodes) {
            if (!rowNodes) {
                return;
            }
            rowNodes.forEach(function (rowNode) {
                if (rowNode.group) {
                    rowNode.expanded = expand;
                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);
                }
            });
        }
        this.refreshModel({ step: constants_1.Constants.STEP_MAP });
    };
    InMemoryRowModel.prototype.doSort = function () {
        this.sortStage.execute({ rowNode: this.rootNode });
    };
    InMemoryRowModel.prototype.doRowGrouping = function (groupState, rowNodeTransaction, rowNodeOrder, changedPath) {
        // grouping is enterprise only, so if service missing, skip the step
        var doingLegacyTreeData = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
        if (doingLegacyTreeData) {
            return;
        }
        if (this.groupStage) {
            if (rowNodeTransaction) {
                this.groupStage.execute({ rowNode: this.rootNode,
                    rowNodeTransaction: rowNodeTransaction,
                    rowNodeOrder: rowNodeOrder,
                    changedPath: changedPath });
            }
            else {
                // groups are about to get disposed, so need to deselect any that are selected
                this.selectionController.removeGroupsFromSelection();
                this.groupStage.execute({ rowNode: this.rootNode });
                // set open/closed state on groups
                this.restoreGroupState(groupState);
            }
            if (this.gridOptionsWrapper.isGroupSelectsChildren()) {
                this.selectionController.updateGroupsFromChildrenSelections();
            }
        }
        else {
            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;
        }
    };
    InMemoryRowModel.prototype.restoreGroupState = function (groupState) {
        if (!groupState) {
            return;
        }
        utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {
            // if the group was open last time, then open it this time. however
            // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'
            // setting will take effect.
            if (typeof groupState[key] === 'boolean') {
                node.expanded = groupState[key];
            }
        });
    };
    InMemoryRowModel.prototype.doFilter = function () {
        this.filterStage.execute({ rowNode: this.rootNode });
    };
    InMemoryRowModel.prototype.doPivot = function () {
        if (this.pivotStage) {
            this.pivotStage.execute({ rowNode: this.rootNode });
        }
    };
    InMemoryRowModel.prototype.getGroupState = function () {
        if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {
            return null;
        }
        var result = {};
        utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) { return result[key] = node.expanded; });
        return result;
    };
    InMemoryRowModel.prototype.getCopyOfNodesMap = function () {
        return this.nodeManager.getCopyOfNodesMap();
    };
    InMemoryRowModel.prototype.getRowNode = function (id) {
        return this.nodeManager.getRowNode(id);
    };
    // rows: the rows to put into the model
    InMemoryRowModel.prototype.setRowData = function (rowData) {
        // no need to invalidate cache, as the cache is stored on the rowNode,
        // so new rowNodes means the cache is wiped anyway.
        // remember group state, so we can expand groups that should be expanded
        var groupState = this.getGroupState();
        this.nodeManager.setRowData(rowData);
        // this event kicks off:
        // - clears selection
        // - updates filters
        // - shows 'no rows' overlay if needed
        var rowDataChangedEvent = {
            type: events_1.Events.EVENT_ROW_DATA_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(rowDataChangedEvent);
        this.refreshModel({
            step: constants_1.Constants.STEP_EVERYTHING,
            groupState: groupState,
            newData: true
        });
    };
    InMemoryRowModel.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {
        this.valueCache.onDataChanged();
        var rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);
        this.refreshModel({
            step: constants_1.Constants.STEP_EVERYTHING,
            rowNodeTransaction: rowNodeTran,
            rowNodeOrder: rowNodeOrder,
            keepRenderedRows: true,
            animate: true,
            keepEditingRows: true
        });
        var event = {
            type: events_1.Events.EVENT_ROW_DATA_UPDATED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
        return rowNodeTran;
    };
    InMemoryRowModel.prototype.doRowsToDisplay = function () {
        this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });
    };
    InMemoryRowModel.prototype.onRowHeightChanged = function () {
        this.refreshModel({ step: constants_1.Constants.STEP_MAP, keepRenderedRows: true, keepEditingRows: true });
    };
    InMemoryRowModel.prototype.resetRowHeights = function () {
        this.forEachNode(function (rowNode) { return rowNode.setRowHeight(null); });
        this.onRowHeightChanged();
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], InMemoryRowModel.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], InMemoryRowModel.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('filterManager'),
        __metadata("design:type", filterManager_1.FilterManager)
    ], InMemoryRowModel.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('$scope'),
        __metadata("design:type", Object)
    ], InMemoryRowModel.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('selectionController'),
        __metadata("design:type", selectionController_1.SelectionController)
    ], InMemoryRowModel.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], InMemoryRowModel.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], InMemoryRowModel.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('valueService'),
        __metadata("design:type", valueService_1.ValueService)
    ], InMemoryRowModel.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('valueCache'),
        __metadata("design:type", valueCache_1.ValueCache)
    ], InMemoryRowModel.prototype, "valueCache", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], InMemoryRowModel.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], InMemoryRowModel.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('filterStage'),
        __metadata("design:type", Object)
    ], InMemoryRowModel.prototype, "filterStage", void 0);
    __decorate([
        context_1.Autowired('sortStage'),
        __metadata("design:type", Object)
    ], InMemoryRowModel.prototype, "sortStage", void 0);
    __decorate([
        context_1.Autowired('flattenStage'),
        __metadata("design:type", Object)
    ], InMemoryRowModel.prototype, "flattenStage", void 0);
    __decorate([
        context_1.Optional('groupStage'),
        __metadata("design:type", Object)
    ], InMemoryRowModel.prototype, "groupStage", void 0);
    __decorate([
        context_1.Optional('aggregationStage'),
        __metadata("design:type", Object)
    ], InMemoryRowModel.prototype, "aggregationStage", void 0);
    __decorate([
        context_1.Optional('pivotStage'),
        __metadata("design:type", Object)
    ], InMemoryRowModel.prototype, "pivotStage", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], InMemoryRowModel.prototype, "init", null);
    InMemoryRowModel = __decorate([
        context_1.Bean('rowModel')
    ], InMemoryRowModel);
    return InMemoryRowModel;
}());
exports.InMemoryRowModel = InMemoryRowModel;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var sortService_1 = __webpack_require__(118);
var SortStage = (function () {
    function SortStage() {
    }
    SortStage.prototype.execute = function (params) {
        // if the sorting is already done by the server, then we should not do it here
        if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
            this.sortService.sort(params.rowNode, null);
        }
        else {
            this.sortService.sortAccordingToColumnsState(params.rowNode);
        }
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], SortStage.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('sortService'),
        __metadata("design:type", sortService_1.SortService)
    ], SortStage.prototype, "sortService", void 0);
    SortStage = __decorate([
        context_1.Bean('sortStage')
    ], SortStage);
    return SortStage;
}());
exports.SortStage = SortStage;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var context_1 = __webpack_require__(0);
var eventService_1 = __webpack_require__(4);
var selectionController_1 = __webpack_require__(17);
var events_1 = __webpack_require__(5);
var sortController_1 = __webpack_require__(25);
var filterManager_1 = __webpack_require__(16);
var constants_1 = __webpack_require__(7);
var infiniteCache_1 = __webpack_require__(150);
var beanStub_1 = __webpack_require__(13);
var rowNodeCache_1 = __webpack_require__(87);
var rowNodeBlockLoader_1 = __webpack_require__(110);
var gridApi_1 = __webpack_require__(6);
var columnController_1 = __webpack_require__(3);
var InfiniteRowModel = (function (_super) {
    __extends(InfiniteRowModel, _super);
    function InfiniteRowModel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InfiniteRowModel.prototype.getRowBounds = function (index) {
        return {
            rowHeight: this.rowHeight,
            rowTop: this.rowHeight * index
        };
    };
    InfiniteRowModel.prototype.init = function () {
        var _this = this;
        if (!this.gridOptionsWrapper.isRowModelInfinite()) {
            return;
        }
        this.rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();
        this.addEventListeners();
        this.setDatasource(this.gridOptionsWrapper.getDatasource());
        this.addDestroyFunc(function () { return _this.destroyCache(); });
    };
    InfiniteRowModel.prototype.isLastRowFound = function () {
        return this.infiniteCache ? this.infiniteCache.isMaxRowFound() : false;
    };
    InfiniteRowModel.prototype.addEventListeners = function () {
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
    };
    InfiniteRowModel.prototype.onFilterChanged = function () {
        if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
            this.reset();
        }
    };
    InfiniteRowModel.prototype.onSortChanged = function () {
        if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
            this.reset();
        }
    };
    InfiniteRowModel.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
    };
    InfiniteRowModel.prototype.getType = function () {
        return constants_1.Constants.ROW_MODEL_TYPE_INFINITE;
    };
    InfiniteRowModel.prototype.setDatasource = function (datasource) {
        this.datasource = datasource;
        // only reset if we have a valid datasource to working with
        if (datasource) {
            this.checkForDeprecated();
            this.reset();
        }
    };
    InfiniteRowModel.prototype.checkForDeprecated = function () {
        var ds = this.datasource;
        // the number of concurrent loads we are allowed to the server
        if (utils_1.Utils.exists(ds.maxConcurrentRequests)) {
            console.error('ag-Grid: since version 5.1.x, maxConcurrentRequests is replaced with grid property maxConcurrentDatasourceRequests');
        }
        if (utils_1.Utils.exists(ds.maxPagesInCache)) {
            console.error('ag-Grid: since version 5.1.x, maxPagesInCache is replaced with grid property maxPagesInPaginationCache');
        }
        if (utils_1.Utils.exists(ds.overflowSize)) {
            console.error('ag-Grid: since version 5.1.x, overflowSize is replaced with grid property paginationOverflowSize');
        }
        if (utils_1.Utils.exists(ds.blockSize)) {
            console.error('ag-Grid: since version 5.1.x, pageSize/blockSize is replaced with grid property infinitePageSize');
        }
    };
    InfiniteRowModel.prototype.isEmpty = function () {
        return utils_1.Utils.missing(this.infiniteCache);
    };
    InfiniteRowModel.prototype.isRowsToRender = function () {
        return utils_1.Utils.exists(this.infiniteCache);
    };
    InfiniteRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {
        return this.infiniteCache.getRowNodesInRange(firstInRange, lastInRange);
    };
    InfiniteRowModel.prototype.reset = function () {
        // important to return here, as the user could be setting filter or sort before
        // data-source is set
        if (utils_1.Utils.missing(this.datasource)) {
            return;
        }
        // if user is providing id's, then this means we can keep the selection between datsource hits,
        // as the rows will keep their unique id's even if, for example, server side sorting or filtering
        // is done.
        var userGeneratingIds = utils_1.Utils.exists(this.gridOptionsWrapper.getRowNodeIdFunc());
        if (!userGeneratingIds) {
            this.selectionController.reset();
        }
        this.resetCache();
        var event = this.createModelUpdatedEvent();
        this.eventService.dispatchEvent(event);
    };
    InfiniteRowModel.prototype.createModelUpdatedEvent = function () {
        return {
            type: events_1.Events.EVENT_MODEL_UPDATED,
            api: this.gridApi,
            columnApi: this.columnApi,
            // not sure if these should all be false - noticed if after implementing,
            // maybe they should be true?
            newPage: false,
            newData: false,
            keepRenderedRows: false,
            animate: false
        };
    };
    InfiniteRowModel.prototype.resetCache = function () {
        // if not first time creating a cache, need to destroy the old one
        this.destroyCache();
        var maxConcurrentRequests = this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests();
        // there is a bi-directional dependency between the loader and the cache,
        // so we create loader here, and then pass dependencies in setDependencies() method later
        this.rowNodeBlockLoader = new rowNodeBlockLoader_1.RowNodeBlockLoader(maxConcurrentRequests);
        this.context.wireBean(this.rowNodeBlockLoader);
        var cacheSettings = {
            // the user provided datasource
            datasource: this.datasource,
            // sort and filter model
            filterModel: this.filterManager.getFilterModel(),
            sortModel: this.sortController.getSortModel(),
            rowNodeBlockLoader: this.rowNodeBlockLoader,
            // properties - this way we take a snapshot of them, so if user changes any, they will be
            // used next time we create a new cache, which is generally after a filter or sort change,
            // or a new datasource is set
            maxConcurrentRequests: maxConcurrentRequests,
            overflowSize: this.gridOptionsWrapper.getCacheOverflowSize(),
            initialRowCount: this.gridOptionsWrapper.getInfiniteInitialRowCount(),
            maxBlocksInCache: this.gridOptionsWrapper.getMaxBlocksInCache(),
            blockSize: this.gridOptionsWrapper.getCacheBlockSize(),
            rowHeight: this.gridOptionsWrapper.getRowHeightAsNumber(),
            // the cache could create this, however it is also used by the pages, so handy to create it
            // here as the settings are also passed to the pages
            lastAccessedSequence: new utils_1.NumberSequence()
        };
        // set defaults
        if (!(cacheSettings.maxConcurrentRequests >= 1)) {
            cacheSettings.maxConcurrentRequests = 2;
        }
        // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
        // server for one page at a time. so the default if not specified is 100.
        if (!(cacheSettings.blockSize >= 1)) {
            cacheSettings.blockSize = 100;
        }
        // if user doesn't give initial rows to display, we assume zero
        if (!(cacheSettings.initialRowCount >= 1)) {
            cacheSettings.initialRowCount = 0;
        }
        // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
        // the current page and request first row of next page
        if (!(cacheSettings.overflowSize >= 1)) {
            cacheSettings.overflowSize = 1;
        }
        this.infiniteCache = new infiniteCache_1.InfiniteCache(cacheSettings);
        this.context.wireBean(this.infiniteCache);
        this.infiniteCache.addEventListener(rowNodeCache_1.RowNodeCache.EVENT_CACHE_UPDATED, this.onCacheUpdated.bind(this));
    };
    InfiniteRowModel.prototype.destroyCache = function () {
        if (this.infiniteCache) {
            this.infiniteCache.destroy();
            this.infiniteCache = null;
        }
        if (this.rowNodeBlockLoader) {
            this.rowNodeBlockLoader.destroy();
            this.rowNodeBlockLoader = null;
        }
    };
    InfiniteRowModel.prototype.onCacheUpdated = function () {
        var event = this.createModelUpdatedEvent();
        this.eventService.dispatchEvent(event);
    };
    InfiniteRowModel.prototype.getRow = function (rowIndex) {
        return this.infiniteCache ? this.infiniteCache.getRow(rowIndex) : null;
    };
    InfiniteRowModel.prototype.forEachNode = function (callback) {
        if (this.infiniteCache) {
            this.infiniteCache.forEachNodeDeep(callback, new utils_1.NumberSequence());
        }
    };
    InfiniteRowModel.prototype.getCurrentPageHeight = function () {
        return this.getRowCount() * this.rowHeight;
    };
    InfiniteRowModel.prototype.getRowIndexAtPixel = function (pixel) {
        if (this.rowHeight !== 0) {
            var rowIndexForPixel = Math.floor(pixel / this.rowHeight);
            if (rowIndexForPixel > this.getPageLastRow()) {
                return this.getPageLastRow();
            }
            else {
                return rowIndexForPixel;
            }
        }
        else {
            return 0;
        }
    };
    InfiniteRowModel.prototype.getPageFirstRow = function () {
        return 0;
    };
    InfiniteRowModel.prototype.getPageLastRow = function () {
        return this.infiniteCache ? this.infiniteCache.getVirtualRowCount() - 1 : 0;
    };
    InfiniteRowModel.prototype.getRowCount = function () {
        return this.infiniteCache ? this.infiniteCache.getVirtualRowCount() : 0;
    };
    InfiniteRowModel.prototype.updateRowData = function (transaction) {
        if (utils_1.Utils.exists(transaction.remove) || utils_1.Utils.exists(transaction.update)) {
            console.warn('ag-Grid: updateRowData for InfiniteRowModel does not support remove or update, only add');
            return;
        }
        if (utils_1.Utils.missing(transaction.addIndex)) {
            console.warn('ag-Grid: updateRowData for InfiniteRowModel requires add and addIndex to be set');
            return;
        }
        if (this.infiniteCache) {
            this.infiniteCache.insertItemsAtIndex(transaction.addIndex, transaction.add);
        }
    };
    InfiniteRowModel.prototype.isRowPresent = function (rowNode) {
        return false;
    };
    InfiniteRowModel.prototype.refreshCache = function () {
        if (this.infiniteCache) {
            this.infiniteCache.refreshCache();
        }
    };
    InfiniteRowModel.prototype.purgeCache = function () {
        if (this.infiniteCache) {
            this.infiniteCache.purgeCache();
        }
    };
    InfiniteRowModel.prototype.getVirtualRowCount = function () {
        if (this.infiniteCache) {
            return this.infiniteCache.getVirtualRowCount();
        }
        else {
            return null;
        }
    };
    InfiniteRowModel.prototype.isMaxRowFound = function () {
        if (this.infiniteCache) {
            return this.infiniteCache.isMaxRowFound();
        }
    };
    InfiniteRowModel.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {
        if (this.infiniteCache) {
            this.infiniteCache.setVirtualRowCount(rowCount, maxRowFound);
        }
    };
    InfiniteRowModel.prototype.getBlockState = function () {
        if (this.rowNodeBlockLoader) {
            return this.rowNodeBlockLoader.getBlockState();
        }
        else {
            return null;
        }
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], InfiniteRowModel.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('filterManager'),
        __metadata("design:type", filterManager_1.FilterManager)
    ], InfiniteRowModel.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('sortController'),
        __metadata("design:type", sortController_1.SortController)
    ], InfiniteRowModel.prototype, "sortController", void 0);
    __decorate([
        context_1.Autowired('selectionController'),
        __metadata("design:type", selectionController_1.SelectionController)
    ], InfiniteRowModel.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], InfiniteRowModel.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], InfiniteRowModel.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], InfiniteRowModel.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], InfiniteRowModel.prototype, "columnApi", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], InfiniteRowModel.prototype, "init", null);
    __decorate([
        context_1.PreDestroy,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], InfiniteRowModel.prototype, "destroy", null);
    InfiniteRowModel = __decorate([
        context_1.Bean('rowModel')
    ], InfiniteRowModel);
    return InfiniteRowModel;
}(beanStub_1.BeanStub));
exports.InfiniteRowModel = InfiniteRowModel;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var filterManager_1 = __webpack_require__(16);
var gridOptionsWrapper_1 = __webpack_require__(2);
var FilterService = (function () {
    function FilterService() {
    }
    FilterService.prototype.postConstruct = function () {
        this.doingTreeData = this.gridOptionsWrapper.isTreeData();
    };
    FilterService.prototype.filterAccordingToColumnState = function (rowNode) {
        var filterActive = this.filterManager.isAnyFilterPresent();
        this.filter(rowNode, filterActive);
    };
    FilterService.prototype.filter = function (rowNode, filterActive) {
        var _this = this;
        // recursively get all children that are groups to also filter
        if (rowNode.hasChildren()) {
            rowNode.childrenAfterGroup.forEach(function (node) { return _this.filter(node, filterActive); });
            // result of filter for this node
            if (filterActive) {
                rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter(function (childNode) {
                    // a group is included in the result if it has any children of it's own.
                    // by this stage, the child groups are already filtered
                    var passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;
                    // both leaf level nodes and tree data nodes have data. these get added if
                    // the data passes the filter
                    var passBecauseDataPasses = childNode.data && _this.filterManager.doesRowPassFilter(childNode);
                    // note - tree data nodes pass either if a) they pass themselves or b) any children of that node pass
                    return passBecauseChildren || passBecauseDataPasses;
                });
            }
            else {
                // if not filtering, the result is the original list
                rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
            }
            this.setAllChildrenCount(rowNode);
        }
        else {
            rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
            rowNode.setAllChildrenCount(null);
        }
    };
    FilterService.prototype.setAllChildrenCountTreeData = function (rowNode) {
        // for tree data, we include all children, groups and leafs
        var allChildrenCount = 0;
        rowNode.childrenAfterFilter.forEach(function (child) {
            // include child itself
            allChildrenCount++;
            // include children of children
            allChildrenCount += child.allChildrenCount;
        });
        rowNode.setAllChildrenCount(allChildrenCount);
    };
    FilterService.prototype.setAllChildrenCountGridGrouping = function (rowNode) {
        // for grid data, we only count the leafs
        var allChildrenCount = 0;
        rowNode.childrenAfterFilter.forEach(function (child) {
            if (child.group) {
                allChildrenCount += child.allChildrenCount;
            }
            else {
                allChildrenCount++;
            }
        });
        rowNode.setAllChildrenCount(allChildrenCount);
    };
    FilterService.prototype.setAllChildrenCount = function (rowNode) {
        if (this.doingTreeData) {
            this.setAllChildrenCountTreeData(rowNode);
        }
        else {
            this.setAllChildrenCountGridGrouping(rowNode);
        }
    };
    __decorate([
        context_1.Autowired('filterManager'),
        __metadata("design:type", filterManager_1.FilterManager)
    ], FilterService.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], FilterService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], FilterService.prototype, "postConstruct", null);
    FilterService = __decorate([
        context_1.Bean("filterService")
    ], FilterService);
    return FilterService;
}());
exports.FilterService = FilterService;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var sortController_1 = __webpack_require__(25);
var utils_1 = __webpack_require__(1);
var valueService_1 = __webpack_require__(20);
var gridOptionsWrapper_1 = __webpack_require__(2);
var columnController_1 = __webpack_require__(3);
var SortService = (function () {
    function SortService() {
    }
    SortService.prototype.sortAccordingToColumnsState = function (rowNode) {
        var sortOptions = this.sortController.getSortForRowController();
        this.sort(rowNode, sortOptions);
    };
    SortService.prototype.sort = function (rowNode, sortOptions) {
        var _this = this;
        rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0);
        // we clear out the 'pull down open parents' first, as the values mix up the sorting
        this.pullDownDataForHideOpenParents(rowNode, true);
        var sortActive = utils_1._.exists(sortOptions) && sortOptions.length > 0;
        if (sortActive) {
            // RE https://ag-grid.atlassian.net/browse/AG-444
            //Javascript sort is non deterministic when all the array items are equals
            //ie Comparator always returns 0, so if you want to ensure the array keeps its
            //order, then you need to add an additional sorting condition manually, in this
            //case we are going to inspect the original array position
            var sortedRowNodes = rowNode.childrenAfterSort.map(function (it, pos) {
                return { currentPos: pos, rowNode: it };
            });
            sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));
            rowNode.childrenAfterSort = sortedRowNodes.map(function (sorted) { return sorted.rowNode; });
        }
        this.updateChildIndexes(rowNode);
        this.pullDownDataForHideOpenParents(rowNode, false);
        // sort any groups recursively
        rowNode.childrenAfterFilter.forEach(function (child) {
            if (child.hasChildren()) {
                _this.sort(child, sortOptions);
            }
        });
    };
    SortService.prototype.compareRowNodes = function (sortOptions, sortedNodeA, sortedNodeB) {
        var nodeA = sortedNodeA.rowNode;
        var nodeB = sortedNodeB.rowNode;
        // Iterate columns, return the first that doesn't match
        for (var i = 0, len = sortOptions.length; i < len; i++) {
            var sortOption = sortOptions[i];
            // let compared = compare(nodeA, nodeB, sortOption.column, sortOption.inverter === -1);
            var isInverted = sortOption.inverter === -1;
            var valueA = this.getValue(nodeA, sortOption.column);
            var valueB = this.getValue(nodeB, sortOption.column);
            var comparatorResult = void 0;
            if (sortOption.column.getColDef().comparator) {
                //if comparator provided, use it
                comparatorResult = sortOption.column.getColDef().comparator(valueA, valueB, nodeA, nodeB, isInverted);
            }
            else {
                //otherwise do our own comparison
                comparatorResult = utils_1._.defaultComparator(valueA, valueB, this.gridOptionsWrapper.isAccentedSort());
            }
            if (comparatorResult !== 0) {
                return comparatorResult * sortOption.inverter;
            }
        }
        // All matched, we make is so that the original sort order is kept:
        return sortedNodeA.currentPos - sortedNodeB.currentPos;
    };
    SortService.prototype.getValue = function (nodeA, column) {
        return this.valueService.getValue(column, nodeA);
    };
    SortService.prototype.updateChildIndexes = function (rowNode) {
        if (utils_1._.missing(rowNode.childrenAfterSort)) {
            return;
        }
        rowNode.childrenAfterSort.forEach(function (child, index) {
            var firstChild = index === 0;
            var lastChild = index === rowNode.childrenAfterSort.length - 1;
            child.setFirstChild(firstChild);
            child.setLastChild(lastChild);
            child.setChildIndex(index);
        });
    };
    SortService.prototype.pullDownDataForHideOpenParents = function (rowNode, clearOperation) {
        var _this = this;
        if (utils_1._.missing(rowNode.childrenAfterSort)) {
            return;
        }
        if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {
            return;
        }
        rowNode.childrenAfterSort.forEach(function (childRowNode) {
            var groupDisplayCols = _this.columnController.getGroupDisplayColumns();
            groupDisplayCols.forEach(function (groupDisplayCol) {
                var showRowGroup = groupDisplayCol.getColDef().showRowGroup;
                if (typeof showRowGroup !== 'string') {
                    console.error('ag-Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup');
                    return;
                }
                var displayingGroupKey = showRowGroup;
                var rowGroupColumn = _this.columnController.getPrimaryColumn(displayingGroupKey);
                var thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;
                if (thisRowNodeMatches) {
                    return;
                }
                if (clearOperation) {
                    // if doing a clear operation, we clear down the value for every possible group column
                    childRowNode.setGroupValue(groupDisplayCol.getId(), null);
                }
                else {
                    // if doing a set operation, we set only where the pull down is to occur
                    var parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);
                    if (parentToStealFrom) {
                        childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);
                    }
                }
            });
        });
    };
    __decorate([
        context_1.Autowired('sortController'),
        __metadata("design:type", sortController_1.SortController)
    ], SortService.prototype, "sortController", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], SortService.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('valueService'),
        __metadata("design:type", valueService_1.ValueService)
    ], SortService.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], SortService.prototype, "gridOptionsWrapper", void 0);
    SortService = __decorate([
        context_1.Bean('sortService')
    ], SortService);
    return SortService;
}());
exports.SortService = SortService;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var LINE_SEPARATOR = '\r\n';
var XmlFactory = (function () {
    function XmlFactory() {
    }
    XmlFactory.prototype.createXml = function (xmlElement, booleanTransformer) {
        var _this = this;
        var props = "";
        if (xmlElement.properties) {
            if (xmlElement.properties.prefixedAttributes) {
                xmlElement.properties.prefixedAttributes.forEach(function (prefixedSet) {
                    Object.keys(prefixedSet.map).forEach(function (key) {
                        props += _this.returnAttributeIfPopulated(prefixedSet.prefix + key, prefixedSet.map[key], booleanTransformer);
                    });
                });
            }
            if (xmlElement.properties.rawMap) {
                Object.keys(xmlElement.properties.rawMap).forEach(function (key) {
                    props += _this.returnAttributeIfPopulated(key, xmlElement.properties.rawMap[key], booleanTransformer);
                });
            }
        }
        var result = "<" + xmlElement.name + props;
        if (!xmlElement.children && xmlElement.textNode == null) {
            return result + "/>" + LINE_SEPARATOR;
        }
        if (xmlElement.textNode != null) {
            return result + ">" + xmlElement.textNode + "</" + xmlElement.name + ">" + LINE_SEPARATOR;
        }
        result += ">" + LINE_SEPARATOR;
        xmlElement.children.forEach(function (it) {
            result += _this.createXml(it, booleanTransformer);
        });
        return result + "</" + xmlElement.name + ">" + LINE_SEPARATOR;
    };
    XmlFactory.prototype.returnAttributeIfPopulated = function (key, value, booleanTransformer) {
        if (!value) {
            return "";
        }
        var xmlValue = value;
        if ((typeof (value) === 'boolean')) {
            if (booleanTransformer) {
                xmlValue = booleanTransformer(value);
            }
        }
        xmlValue = '"' + xmlValue + '"';
        return " " + key + "=" + xmlValue;
    };
    XmlFactory = __decorate([
        context_1.Bean('xmlFactory')
    ], XmlFactory);
    return XmlFactory;
}());
exports.XmlFactory = XmlFactory;


/***/ }),
/* 120 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var react_redux_1 = __webpack_require__(44);
var ClientCommissionListContainer_1 = __webpack_require__(156);
var ClientListComponent_1 = __webpack_require__(155);
var mapStateToProps = function (state) { return ({}); };
exports.ClientListContainer = react_redux_1.connect(mapStateToProps, ClientCommissionListContainer_1.mapDispatchToProps)(ClientListComponent_1.default);


/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ClientCommissionListContainer */
/* unused harmony export mapDispatchToProps */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_redux__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_redux___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react_redux__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ClientCommissionListContainer_css__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ClientCommissionListContainer_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__ClientCommissionListContainer_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ClientListContainer__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ClientListContainer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__ClientListContainer__);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var ClientCommissionListContainer = /** @class */ (function (_super) {
    __extends(ClientCommissionListContainer, _super);
    function ClientCommissionListContainer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ClientCommissionListContainer.prototype.componentDidMount = function () {
        this.props.componentDidMount();
    };
    ClientCommissionListContainer.prototype.render = function () {
        return (__WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement("div", null,
            __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__ClientListContainer__["ClientListContainer"], null)));
    };
    return ClientCommissionListContainer;
}(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]));

var mapStateToProps = function (state) { return ({
    isLoading: state.isLoading
}); };
var mapDispatchToProps = function (dispatch) { return ({
    componentDidMount: function () {
    }
}); };
/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react_redux__["connect"])(mapStateToProps, mapDispatchToProps)(ClientCommissionListContainer));


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var redux_1 = __webpack_require__(165);
var redux_thunk_1 = __webpack_require__(163);
var react_router_redux_1 = __webpack_require__(91);
var store_1 = __webpack_require__(158);
//import { ProspectMiddleWare, errorHandler } from './api/Prospect/ProspectApi';
function configureStore(history, initialState) {
    // Build middleware. These are functions that can process the actions before they reach the store.
    var windowIfDefined = typeof window === 'undefined' ? null : window;
    // If devTools is installed, connect to it
    var devToolsExtension = windowIfDefined && windowIfDefined.devToolsExtension;
    var createStoreWithMiddleware = redux_1.compose(redux_1.applyMiddleware(redux_thunk_1.default, react_router_redux_1.routerMiddleware(history)), devToolsExtension ? devToolsExtension() : function (next) { return next; })(redux_1.createStore);
    // Combine all reducers and instantiate the app-wide store instance
    var allReducers = buildRootReducer(store_1.reducers);
    var store = createStoreWithMiddleware(allReducers, initialState);
    // Enable Webpack hot module replacement for reducers
    if (false) {
        module.hot.accept('./store', function () {
            var nextRootReducer = require('./store');
            store.replaceReducer(buildRootReducer(nextRootReducer.reducers));
        });
    }
    return store;
}
exports.default = configureStore;
function buildRootReducer(allReducers) {
    return redux_1.combineReducers(Object.assign({}, allReducers, { routing: react_router_redux_1.routerReducer }));
}


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(140);

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(147);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(149);

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ag-grid-react v14.0.0

Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(26);
var ReactDOM = __webpack_require__(162);
var AgGrid = __webpack_require__(63);
var ag_grid_1 = __webpack_require__(63);
var AgReactComponent = (function () {
    function AgReactComponent(reactComponent, parentComponent) {
        this.reactComponent = reactComponent;
        this.parentComponent = parentComponent;
    }
    AgReactComponent.prototype.getFrameworkComponentInstance = function () {
        return this.componentRef;
    };
    AgReactComponent.prototype.init = function (params) {
        var _this = this;
        return new ag_grid_1.Promise(function (resolve) {
            _this.eParentElement = document.createElement('div');
            AgGrid.Utils.addCssClass(_this.eParentElement, 'ag-react-container');
            // so user can have access to the react container,
            // to add css class or style
            params.reactContainer = _this.eParentElement;
            var self = _this;
            var ReactComponent = React.createElement(_this.reactComponent, params);
            if (!_this.parentComponent) {
                // MUST be a function, not an arrow function
                ReactDOM.render(ReactComponent, _this.eParentElement, function () {
                    self.componentRef = this;
                    resolve(null);
                });
            }
            else {
                // MUST be a function, not an arrow function
                ReactDOM.unstable_renderSubtreeIntoContainer(_this.parentComponent, ReactComponent, _this.eParentElement, function () {
                    self.componentRef = this;
                    resolve(null);
                });
            }
        });
    };
    AgReactComponent.prototype.getGui = function () {
        return this.eParentElement;
    };
    AgReactComponent.prototype.destroy = function () {
        ReactDOM.unmountComponentAtNode(this.eParentElement);
    };
    return AgReactComponent;
}());
exports.AgReactComponent = AgReactComponent;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ag-grid-react v14.0.0

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var ag_grid_1 = __webpack_require__(63);
var agReactComponent_1 = __webpack_require__(127);
var agGridReact_1 = __webpack_require__(92);
var ReactFrameworkComponentWrapper = (function (_super) {
    __extends(ReactFrameworkComponentWrapper, _super);
    function ReactFrameworkComponentWrapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ReactFrameworkComponentWrapper.prototype.createWrapper = function (ReactComponent) {
        var _self = this;
        var DynamicAgReactComponent = (function (_super) {
            __extends(DynamicAgReactComponent, _super);
            function DynamicAgReactComponent() {
                return _super.call(this, ReactComponent, _self.agGridReact) || this;
            }
            DynamicAgReactComponent.prototype.init = function (params) {
                return _super.prototype.init.call(this, params);
            };
            DynamicAgReactComponent.prototype.hasMethod = function (name) {
                var frameworkComponentInstance = wrapper.getFrameworkComponentInstance();
                if (frameworkComponentInstance == null) {
                    console.debug("ag grid: " + name + " It seems like you are using react fiber (>v16.0.0). Ag-grid has experimental support for it, please if there is any issue that you find let us know");
                    return true;
                }
                return frameworkComponentInstance[name] != null;
            };
            DynamicAgReactComponent.prototype.callMethod = function (name, args) {
                var _this = this;
                var frameworkComponentInstance = this.getFrameworkComponentInstance();
                if (frameworkComponentInstance == null) {
                    setTimeout(function () { return _this.callMethod(name, args); }, 100);
                }
                else {
                    var method = wrapper.getFrameworkComponentInstance()[name];
                    if (method == null)
                        return null;
                    return method.apply(frameworkComponentInstance, args);
                }
            };
            DynamicAgReactComponent.prototype.addMethod = function (name, callback) {
                wrapper[name] = callback;
            };
            return DynamicAgReactComponent;
        }(agReactComponent_1.AgReactComponent));
        var wrapper = new DynamicAgReactComponent();
        return wrapper;
    };
    return ReactFrameworkComponentWrapper;
}(ag_grid_1.BaseComponentWrapper));
__decorate([
    ag_grid_1.Autowired('agGridReact'),
    __metadata("design:type", agGridReact_1.AgGridReact)
], ReactFrameworkComponentWrapper.prototype, "agGridReact", void 0);
ReactFrameworkComponentWrapper = __decorate([
    ag_grid_1.Bean('frameworkComponentWrapper')
], ReactFrameworkComponentWrapper);
exports.ReactFrameworkComponentWrapper = ReactFrameworkComponentWrapper;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

exports.AgGridReact = __webpack_require__(92).AgGridReact;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var grid_1 = __webpack_require__(72);
function initialiseAgGridWithAngular1(angular) {
    var angularModule = angular.module("agGrid", []);
    angularModule.directive("agGrid", function () {
        return {
            restrict: "A",
            controller: ['$element', '$scope', '$compile', '$attrs', AngularDirectiveController],
            scope: true
        };
    });
}
exports.initialiseAgGridWithAngular1 = initialiseAgGridWithAngular1;
function AngularDirectiveController($element, $scope, $compile, $attrs) {
    var gridOptions;
    var quickFilterOnScope;
    var keyOfGridInScope = $attrs.agGrid;
    quickFilterOnScope = keyOfGridInScope + '.quickFilterText';
    gridOptions = $scope.$eval(keyOfGridInScope);
    if (!gridOptions) {
        console.warn("WARNING - grid options for ag-Grid not found. Please ensure the attribute ag-grid points to a valid object on the scope");
        return;
    }
    var eGridDiv = $element[0];
    var gridParams = {
        $scope: $scope,
        $compile: $compile,
        quickFilterOnScope: quickFilterOnScope
    };
    var grid = new grid_1.Grid(eGridDiv, gridOptions, gridParams);
    $scope.$on("$destroy", function () {
        grid.destroy();
    });
}


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var componentUtil_1 = __webpack_require__(66);
var grid_1 = __webpack_require__(72);
var registered = false;
function initialiseAgGridWithWebComponents() {
    console.warn('ag-grid: initialiseAgGridWithWebComponents is deprecated. Please use the ag-grid-webcomponent dependency instead. ');
    // only register to WebComponents once
    if (registered) {
        return;
    }
    registered = true;
    if (typeof document === 'undefined' || !document.registerElement) {
        console.error('ag-Grid: unable to find document.registerElement() function, unable to initialise ag-Grid as a Web Component');
    }
    // i don't think this type of extension is possible in TypeScript, so back to
    // plain Javascript to create this object
    var AgileGridProto = Object.create(HTMLElement.prototype);
    // wrap each property with a get and set method, so we can track when changes are done
    componentUtil_1.ComponentUtil.ALL_PROPERTIES.forEach(function (key) {
        Object.defineProperty(AgileGridProto, key, {
            set: function (v) {
                this.__agGridSetProperty(key, v);
            },
            get: function () {
                return this.__agGridGetProperty(key);
            },
            enumerable: true,
            configurable: true
        });
    });
    var agGridProtoNoType = AgileGridProto;
    agGridProtoNoType.__agGridSetProperty = function (key, value) {
        if (!this.__attributes) {
            this.__attributes = {};
        }
        this.__attributes[key] = value;
        // keeping this consistent with the ng2 onChange, so I can reuse the handling code
        var changeObject = {};
        changeObject[key] = { currentValue: value };
        this.onChange(changeObject);
    };
    agGridProtoNoType.onChange = function (changes) {
        if (this._initialised) {
            componentUtil_1.ComponentUtil.processOnChange(changes, this._gridOptions, this.api, this.columnApi);
        }
    };
    agGridProtoNoType.__agGridGetProperty = function (key) {
        if (!this.__attributes) {
            this.__attributes = {};
        }
        return this.__attributes[key];
    };
    agGridProtoNoType.setGridOptions = function (options) {
        var globalEventListener = this.globalEventListener.bind(this);
        this._gridOptions = componentUtil_1.ComponentUtil.copyAttributesToGridOptions(options, this);
        var gridParams = {
            globalEventListener: globalEventListener
        };
        this._agGrid = new grid_1.Grid(this, this._gridOptions, gridParams);
        this.api = options.api;
        this.columnApi = options.columnApi;
        this._initialised = true;
    };
    // copies all the attributes into this object
    agGridProtoNoType.createdCallback = function () {
        for (var i = 0; i < this.attributes.length; i++) {
            var attribute = this.attributes[i];
            this.setPropertyFromAttribute(attribute);
        }
    };
    agGridProtoNoType.setPropertyFromAttribute = function (attribute) {
        var name = toCamelCase(attribute.nodeName);
        var value = attribute.nodeValue;
        if (componentUtil_1.ComponentUtil.ALL_PROPERTIES.indexOf(name) >= 0) {
            this[name] = value;
        }
    };
    agGridProtoNoType.attachedCallback = function (params) { };
    agGridProtoNoType.detachedCallback = function (params) { };
    agGridProtoNoType.attributeChangedCallback = function (attributeName) {
        var attribute = this.attributes[attributeName];
        this.setPropertyFromAttribute(attribute);
    };
    agGridProtoNoType.globalEventListener = function (eventType, event) {
        var eventLowerCase = eventType.toLowerCase();
        var browserEvent = new Event(eventLowerCase);
        var browserEventNoType = browserEvent;
        browserEventNoType.agGridDetails = event;
        this.dispatchEvent(browserEvent);
        var callbackMethod = 'on' + eventLowerCase;
        if (typeof this[callbackMethod] === 'function') {
            this[callbackMethod](browserEvent);
        }
    };
    // finally, register
    document.registerElement('ag-grid', { prototype: AgileGridProto });
}
exports.initialiseAgGridWithWebComponents = initialiseAgGridWithWebComponents;
function toCamelCase(myString) {
    if (typeof myString === 'string') {
        var result = myString.replace(/-([a-z])/g, function (g) {
            return g[1].toUpperCase();
        });
        return result;
    }
    else {
        return myString;
    }
}


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var ColDefUtil = (function () {
    function ColDefUtil() {
    }
    ColDefUtil.STRING_PROPERTIES = [
        'headerName',
        'columnGroupShow',
        'headerClass',
        'toolPanelClass',
        'headerValueGetter',
        'pivotKeys',
        'groupId',
        'colId',
        'sort',
        'field',
        'type',
        'tooltipField',
        'headerTooltip',
        'cellClass',
        'showRowGroup',
        'template',
        'templateUrl',
        'filter',
        'aggFunc',
        'cellEditor'
    ];
    ColDefUtil.OBJECT_PROPERTIES = [
        'headerGroupComponent',
        'headerGroupComponentFramework',
        'headerGroupComponentParams',
        'cellStyle',
        'cellRendererParams',
        'cellEditorFramework',
        'cellEditorParams',
        'pinnedRowCellRendererFramework',
        'pinnedRowCellRendererParams',
        'filterFramework',
        'filterParams',
        'pivotValueColumn',
        'headerComponent',
        'headerComponentFramework',
        'headerComponentParams',
        'floatingFilterComponent',
        'floatingFilterComponentParams',
        'floatingFilterComponentFramework',
        'refData'
    ];
    ColDefUtil.ARRAY_PROPERTIES = [
        'children',
        'sortingOrder',
        'allowedAggFuncs',
        'menuTabs',
        'pivotTotalColumnIds',
        'cellClassRules',
        'icons'
    ];
    ColDefUtil.NUMBER_PROPERTIES = [
        'sortedAt',
        'width',
        'minWidth',
        'maxWidth',
        'rowGroupIndex',
        'pivotIndex'
    ];
    ColDefUtil.BOOLEAN_PROPERTIES = [
        'suppressToolPanel',
        'openByDefault',
        'marryChildren',
        'hide',
        'pinned',
        'rowGroup',
        'pivot',
        'checkboxSelection',
        'headerCheckboxSelection',
        'headerCheckboxSelectionFilteredOnly',
        'suppressMenu',
        'suppressSorting',
        'suppressMovable',
        'suppressFilter',
        'unSortIcon',
        'suppressSizeToFit',
        'suppressResize',
        'suppressAutoSize',
        'enableRowGroup',
        'enablePivot',
        'enableValue',
        'editable',
        'suppressPaste',
        'suppressNavigable',
        'volatile',
        'enableCellChangeFlash'
    ];
    ColDefUtil.FUNCTION_PROPERTIES = [
        'valueGetter',
        'valueSetter',
        'keyCreator',
        'headerCellRenderer',
        'headerCellTemplate',
        'cellRendererFramework',
        'pinnedRowCellRenderer',
        'valueFormatter',
        'pinnedRowValueFormatter',
        'valueParser',
        'comparator',
        'equals',
        'pivotComparator',
        'suppressKeyboardEvent',
        'colSpan',
        'getQuickFilterText',
        'newValueHandler',
        'onCellValueChanged',
        'onCellClicked',
        'onCellDoubleClicked',
        'onCellContextMenu'
    ];
    ColDefUtil.ALL_PROPERTIES = ColDefUtil.ARRAY_PROPERTIES
        .concat(ColDefUtil.OBJECT_PROPERTIES)
        .concat(ColDefUtil.STRING_PROPERTIES)
        .concat(ColDefUtil.NUMBER_PROPERTIES)
        .concat(ColDefUtil.FUNCTION_PROPERTIES)
        .concat(ColDefUtil.BOOLEAN_PROPERTIES);
    return ColDefUtil;
}());
exports.ColDefUtil = ColDefUtil;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var BaseComponentWrapper = (function () {
    function BaseComponentWrapper() {
    }
    BaseComponentWrapper.prototype.wrap = function (OriginalConstructor, mandatoryMethodList, optionalMethodList, componentName) {
        var _this = this;
        var wrapper = this.createWrapper(OriginalConstructor, componentName);
        mandatoryMethodList.forEach((function (methodName) {
            _this.createMethod(wrapper, methodName, true);
        }));
        if (optionalMethodList) {
            optionalMethodList.forEach((function (methodName) {
                _this.createMethod(wrapper, methodName, false);
            }));
        }
        return wrapper;
    };
    BaseComponentWrapper.prototype.createMethod = function (wrapper, methodName, mandatory) {
        wrapper.addMethod(methodName, this.createMethodProxy(wrapper, methodName, mandatory));
    };
    BaseComponentWrapper.prototype.createMethodProxy = function (wrapper, methodName, mandatory) {
        return function () {
            if (wrapper.hasMethod(methodName)) {
                return wrapper.callMethod(methodName, arguments);
            }
            if (mandatory) {
                console.warn('ag-Grid: Framework component is missing the method ' + methodName + '()');
            }
            return null;
        };
    };
    return BaseComponentWrapper;
}());
exports.BaseComponentWrapper = BaseComponentWrapper;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultColumnTypes = {
    "numericColumn": {
        "headerClass": "ag-numeric-header",
        "cellClass": "ag-numeric-cell"
    }
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var Events = (function () {
    function Events() {
    }
    /** Everything has changed with the columns. Either complete new set of columns set, or user called setState()*/
    Events.EVENT_COLUMN_EVERYTHING_CHANGED = 'columnEverythingChanged';
    /** User has set in new columns. */
    Events.EVENT_NEW_COLUMNS_LOADED = 'newColumnsLoaded';
    /** The pivot mode flag was changed */
    Events.EVENT_COLUMN_PIVOT_MODE_CHANGED = 'columnPivotModeChanged';
    /** A row group column was added, removed or order changed. */
    Events.EVENT_COLUMN_ROW_GROUP_CHANGED = 'columnRowGroupChanged';
    /** A pivot column was added, removed or order changed. */
    Events.EVENT_COLUMN_PIVOT_CHANGED = 'columnPivotChanged';
    /** The list of grid columns has changed. */
    Events.EVENT_GRID_COLUMNS_CHANGED = 'gridColumnsChanged';
    /** A value column was added, removed or agg function was changed. */
    Events.EVENT_COLUMN_VALUE_CHANGED = 'columnValueChanged';
    /** A column was moved */
    Events.EVENT_COLUMN_MOVED = 'columnMoved';
    /** One or more columns was shown / hidden */
    Events.EVENT_COLUMN_VISIBLE = 'columnVisible';
    /** One or more columns was pinned / unpinned*/
    Events.EVENT_COLUMN_PINNED = 'columnPinned';
    /** A column group was opened / closed */
    Events.EVENT_COLUMN_GROUP_OPENED = 'columnGroupOpened';
    /** One or more columns was resized. If just one, the column in the event is set. */
    Events.EVENT_COLUMN_RESIZED = 'columnResized';
    /** The list of displayed columns has changed, can result from columns open / close, column move, pivot, group, etc */
    Events.EVENT_DISPLAYED_COLUMNS_CHANGED = 'displayedColumnsChanged';
    /** The list of virtual columns has changed, results from viewport changing */
    Events.EVENT_VIRTUAL_COLUMNS_CHANGED = 'virtualColumnsChanged';
    /** A row group was opened / closed */
    Events.EVENT_ROW_GROUP_OPENED = 'rowGroupOpened';
    /** The client has set new data into the grid */
    Events.EVENT_ROW_DATA_CHANGED = 'rowDataChanged';
    /** The client has updated data for the grid */
    Events.EVENT_ROW_DATA_UPDATED = 'rowDataUpdated';
    /** The client has set new floating data into the grid */
    Events.EVENT_PINNED_ROW_DATA_CHANGED = 'pinnedRowDataChanged';
    /** Range selection has changed */
    Events.EVENT_RANGE_SELECTION_CHANGED = 'rangeSelectionChanged';
    /** Model was updated - grid updates the drawn rows when this happens */
    Events.EVENT_MODEL_UPDATED = 'modelUpdated';
    Events.EVENT_CELL_CLICKED = 'cellClicked';
    Events.EVENT_CELL_DOUBLE_CLICKED = 'cellDoubleClicked';
    Events.EVENT_CELL_CONTEXT_MENU = 'cellContextMenu';
    Events.EVENT_CELL_VALUE_CHANGED = 'cellValueChanged';
    Events.EVENT_ROW_VALUE_CHANGED = 'rowValueChanged';
    Events.EVENT_CELL_FOCUSED = 'cellFocused';
    Events.EVENT_ROW_SELECTED = 'rowSelected';
    Events.EVENT_SELECTION_CHANGED = 'selectionChanged';
    Events.EVENT_CELL_MOUSE_OVER = 'cellMouseOver';
    Events.EVENT_CELL_MOUSE_OUT = 'cellMouseOut';
    /** 2 events for filtering. The grid LISTENS for filterChanged and afterFilterChanged */
    Events.EVENT_FILTER_CHANGED = 'filterChanged';
    /** Filter was change but not applied. Only useful if apply buttons are used in filters. */
    Events.EVENT_FILTER_MODIFIED = 'filterModified';
    Events.EVENT_SORT_CHANGED = 'sortChanged';
    /** A row was removed from the dom, for any reason. Use to clean up resources (if any) used by the row. */
    Events.EVENT_VIRTUAL_ROW_REMOVED = 'virtualRowRemoved';
    Events.EVENT_ROW_CLICKED = 'rowClicked';
    Events.EVENT_ROW_DOUBLE_CLICKED = 'rowDoubleClicked';
    /** Gets called once after the grid has finished initialising. */
    Events.EVENT_GRID_READY = 'gridReady';
    /** Width of height of the main grid div has changed. Grid listens for this and does layout of grid if it's
     * changed, so always filling the space it was given. */
    Events.EVENT_GRID_SIZE_CHANGED = 'gridSizeChanged';
    /** The indexes of the rows rendered has changed, eg user has scrolled to a new vertical position. */
    Events.EVENT_VIEWPORT_CHANGED = 'viewportChanged';
    /** A column drag has started, either resizing a column or moving a column. */
    Events.EVENT_DRAG_STARTED = 'dragStarted';
    /** A column drag has stopped */
    Events.EVENT_DRAG_STOPPED = 'dragStopped';
    Events.EVENT_ROW_EDITING_STARTED = 'rowEditingStarted';
    Events.EVENT_ROW_EDITING_STOPPED = 'rowEditingStopped';
    Events.EVENT_CELL_EDITING_STARTED = 'cellEditingStarted';
    Events.EVENT_CELL_EDITING_STOPPED = 'cellEditingStopped';
    /** Main body of grid has scrolled, either horizontally or vertically */
    Events.EVENT_BODY_SCROLL = 'bodyScroll';
    /** The displayed page for pagination has changed. For example the data was filtered or sorted,
     * or the user has moved to a different page. */
    Events.EVENT_PAGINATION_CHANGED = 'paginationChanged';
    /** Only used by React, Angular 2+, Web Components, Aurelia and VueJS ag-Grid components
     * (not used if doing plain JavaScript or Angular 1.x). If the grid receives changes due
     * to bound properties, this event fires after the grid has finished processing the change. */
    Events.EVENT_COMPONENT_STATE_CHANGED = 'componentStateChanged';
    /** All items from here down are used internally by the grid, not intended for external use. */
    // not documented, either experimental, or we just don't want users using an ddepending on them
    Events.EVENT_BODY_HEIGHT_CHANGED = 'bodyHeightChanged';
    Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED = 'displayedColumnsWidthChanged';
    Events.EVENT_SCROLL_VISIBILITY_CHANGED = 'scrollVisibilityChanged';
    Events.EVENT_COLUMN_HOVER_CHANGED = 'columnHoverChanged';
    Events.EVENT_FLASH_CELLS = 'flashCells';
    // these are used for server side group and agg - only used by CS with Viewport Row Model - intention is
    // to design these better around server side functions and then release to general public when fully working with
    // all the row models.
    Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST = 'columnRowGroupChangeRequest';
    Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST = 'columnPivotChangeRequest';
    Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST = 'columnValueChangeRequest';
    Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = 'columnAggFuncChangeRequest';
    return Events;
}());
exports.Events = Events;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var dateFilter_1 = __webpack_require__(71);
var componentAnnotations_1 = __webpack_require__(12);
var utils_1 = __webpack_require__(1);
var componentRecipes_1 = __webpack_require__(27);
var component_1 = __webpack_require__(8);
var constants_1 = __webpack_require__(7);
var InputTextFloatingFilterComp = (function (_super) {
    __extends(InputTextFloatingFilterComp, _super);
    function InputTextFloatingFilterComp() {
        var _this = _super.call(this, "<div><input  ref=\"eColumnFloatingFilter\" class=\"ag-floating-filter-input\"></div>") || this;
        _this.lastKnownModel = null;
        return _this;
    }
    InputTextFloatingFilterComp.prototype.init = function (params) {
        this.onFloatingFilterChanged = params.onFloatingFilterChanged;
        this.currentParentModel = params.currentParentModel;
        var debounceMs = params.debounceMs != null ? params.debounceMs : 500;
        var toDebounce = utils_1._.debounce(this.syncUpWithParentFilter.bind(this), debounceMs);
        this.addDestroyableEventListener(this.eColumnFloatingFilter, 'input', toDebounce);
        this.addDestroyableEventListener(this.eColumnFloatingFilter, 'keypress', toDebounce);
        this.addDestroyableEventListener(this.eColumnFloatingFilter, 'keydown', toDebounce);
        var columnDef = params.column.getDefinition();
        if (columnDef.filterParams && columnDef.filterParams.filterOptions && columnDef.filterParams.filterOptions.length === 1 && columnDef.filterParams.filterOptions[0] === 'inRange') {
            this.eColumnFloatingFilter.readOnly = true;
        }
    };
    InputTextFloatingFilterComp.prototype.onParentModelChanged = function (parentModel) {
        if (this.equalModels(this.lastKnownModel, parentModel))
            return;
        this.lastKnownModel = parentModel;
        var incomingTextValue = this.asFloatingFilterText(parentModel);
        if (incomingTextValue === this.eColumnFloatingFilter.value)
            return;
        this.eColumnFloatingFilter.value = incomingTextValue;
    };
    InputTextFloatingFilterComp.prototype.syncUpWithParentFilter = function (e) {
        var model = this.asParentModel();
        if (this.equalModels(this.lastKnownModel, model))
            return;
        var modelUpdated = null;
        if (utils_1._.isKeyPressed(e, constants_1.Constants.KEY_ENTER)) {
            modelUpdated = this.onFloatingFilterChanged({
                model: model,
                apply: true
            });
        }
        else {
            modelUpdated = this.onFloatingFilterChanged({
                model: model,
                apply: false
            });
        }
        if (modelUpdated) {
            this.lastKnownModel = model;
        }
    };
    InputTextFloatingFilterComp.prototype.equalModels = function (left, right) {
        if (utils_1._.referenceCompare(left, right))
            return true;
        if (!left || !right)
            return false;
        if (Array.isArray(left) || Array.isArray(right))
            return false;
        return (utils_1._.referenceCompare(left.type, right.type) &&
            utils_1._.referenceCompare(left.filter, right.filter) &&
            utils_1._.referenceCompare(left.filterTo, right.filterTo) &&
            utils_1._.referenceCompare(left.filterType, right.filterType));
    };
    __decorate([
        componentAnnotations_1.RefSelector('eColumnFloatingFilter'),
        __metadata("design:type", HTMLInputElement)
    ], InputTextFloatingFilterComp.prototype, "eColumnFloatingFilter", void 0);
    return InputTextFloatingFilterComp;
}(component_1.Component));
exports.InputTextFloatingFilterComp = InputTextFloatingFilterComp;
var TextFloatingFilterComp = (function (_super) {
    __extends(TextFloatingFilterComp, _super);
    function TextFloatingFilterComp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TextFloatingFilterComp.prototype.asFloatingFilterText = function (parentModel) {
        if (!parentModel)
            return '';
        return parentModel.filter;
    };
    TextFloatingFilterComp.prototype.asParentModel = function () {
        var currentParentModel = this.currentParentModel();
        return {
            type: currentParentModel.type,
            filter: this.eColumnFloatingFilter.value,
            filterType: 'text'
        };
    };
    return TextFloatingFilterComp;
}(InputTextFloatingFilterComp));
exports.TextFloatingFilterComp = TextFloatingFilterComp;
var DateFloatingFilterComp = (function (_super) {
    __extends(DateFloatingFilterComp, _super);
    function DateFloatingFilterComp() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.lastKnownModel = null;
        return _this;
    }
    DateFloatingFilterComp.prototype.init = function (params) {
        this.onFloatingFilterChanged = params.onFloatingFilterChanged;
        this.currentParentModel = params.currentParentModel;
        var debounceMs = params.debounceMs != null ? params.debounceMs : 500;
        var toDebounce = utils_1._.debounce(this.onDateChanged.bind(this), debounceMs);
        var dateComponentParams = {
            onDateChanged: toDebounce
        };
        this.dateComponentPromise = this.componentRecipes.newDateComponent(dateComponentParams);
        var body = utils_1._.loadTemplate("<div></div>");
        this.dateComponentPromise.then(function (dateComponent) {
            body.appendChild(dateComponent.getGui());
        });
        this.setTemplateFromElement(body);
    };
    DateFloatingFilterComp.prototype.onDateChanged = function () {
        var parentModel = this.currentParentModel();
        var model = this.asParentModel();
        if (this.equalModels(parentModel, model))
            return;
        this.onFloatingFilterChanged({
            model: model,
            apply: true
        });
        this.lastKnownModel = model;
    };
    DateFloatingFilterComp.prototype.equalModels = function (left, right) {
        if (utils_1._.referenceCompare(left, right))
            return true;
        if (!left || !right)
            return false;
        if (Array.isArray(left) || Array.isArray(right))
            return false;
        return (utils_1._.referenceCompare(left.type, right.type) &&
            utils_1._.referenceCompare(left.dateFrom, right.dateFrom) &&
            utils_1._.referenceCompare(left.dateTo, right.dateTo) &&
            utils_1._.referenceCompare(left.filterType, right.filterType));
    };
    DateFloatingFilterComp.prototype.asParentModel = function () {
        var currentParentModel = this.currentParentModel();
        var filterValueDate = this.dateComponentPromise.resolveNow(null, function (dateComponent) { return dateComponent.getDate(); });
        var filterValueText = utils_1._.serializeDateToYyyyMmDd(dateFilter_1.DateFilter.removeTimezone(filterValueDate), "-");
        return {
            type: currentParentModel.type,
            dateFrom: filterValueText,
            dateTo: currentParentModel ? currentParentModel.dateTo : null,
            filterType: 'date'
        };
    };
    DateFloatingFilterComp.prototype.onParentModelChanged = function (parentModel) {
        this.lastKnownModel = parentModel;
        this.dateComponentPromise.then(function (dateComponent) {
            if (!parentModel || !parentModel.dateFrom) {
                dateComponent.setDate(null);
                return;
            }
            dateComponent.setDate(utils_1._.parseYyyyMmDdToDate(parentModel.dateFrom, '-'));
        });
    };
    __decorate([
        context_1.Autowired('componentRecipes'),
        __metadata("design:type", componentRecipes_1.ComponentRecipes)
    ], DateFloatingFilterComp.prototype, "componentRecipes", void 0);
    return DateFloatingFilterComp;
}(component_1.Component));
exports.DateFloatingFilterComp = DateFloatingFilterComp;
var NumberFloatingFilterComp = (function (_super) {
    __extends(NumberFloatingFilterComp, _super);
    function NumberFloatingFilterComp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NumberFloatingFilterComp.prototype.asFloatingFilterText = function (parentModel) {
        var rawParentModel = this.currentParentModel();
        if (parentModel == null && rawParentModel == null)
            return '';
        if (parentModel == null && rawParentModel != null && rawParentModel.type !== 'inRange') {
            this.eColumnFloatingFilter.readOnly = false;
            return '';
        }
        if (rawParentModel != null && rawParentModel.type === 'inRange') {
            this.eColumnFloatingFilter.readOnly = true;
            var number_1 = this.asNumber(rawParentModel.filter);
            var numberTo = this.asNumber(rawParentModel.filterTo);
            return (number_1 ? number_1 + '' : '') +
                '-' +
                (numberTo ? numberTo + '' : '');
        }
        var number = this.asNumber(parentModel.filter);
        this.eColumnFloatingFilter.readOnly = false;
        return number != null ? number + '' : '';
    };
    NumberFloatingFilterComp.prototype.asParentModel = function () {
        var currentParentModel = this.currentParentModel();
        var filterValueNumber = this.asNumber(this.eColumnFloatingFilter.value);
        var filterValueText = this.eColumnFloatingFilter.value;
        var modelFilterValue = null;
        if (filterValueNumber == null && filterValueText === '') {
            modelFilterValue = null;
        }
        else if (filterValueNumber == null) {
            modelFilterValue = currentParentModel.filter;
        }
        else {
            modelFilterValue = filterValueNumber;
        }
        return {
            type: currentParentModel.type,
            filter: modelFilterValue,
            filterTo: !currentParentModel ? null : currentParentModel.filterTo,
            filterType: 'number'
        };
    };
    NumberFloatingFilterComp.prototype.asNumber = function (value) {
        if (value == null)
            return null;
        if (value === '')
            return null;
        var asNumber = Number(value);
        var invalidNumber = !utils_1._.isNumeric(asNumber);
        return invalidNumber ? null : asNumber;
    };
    return NumberFloatingFilterComp;
}(InputTextFloatingFilterComp));
exports.NumberFloatingFilterComp = NumberFloatingFilterComp;
var SetFloatingFilterComp = (function (_super) {
    __extends(SetFloatingFilterComp, _super);
    function SetFloatingFilterComp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SetFloatingFilterComp.prototype.init = function (params) {
        _super.prototype.init.call(this, params);
        this.eColumnFloatingFilter.readOnly = true;
    };
    SetFloatingFilterComp.prototype.asFloatingFilterText = function (parentModel) {
        if (!parentModel || parentModel.length === 0)
            return '';
        var arrayToDisplay = parentModel.length > 10 ? parentModel.slice(0, 10).concat(['...']) : parentModel;
        return "(" + parentModel.length + ") " + arrayToDisplay.join(",");
    };
    SetFloatingFilterComp.prototype.asParentModel = function () {
        if (this.eColumnFloatingFilter.value == null || this.eColumnFloatingFilter.value === '')
            return null;
        return this.eColumnFloatingFilter.value.split(",");
    };
    return SetFloatingFilterComp;
}(InputTextFloatingFilterComp));
exports.SetFloatingFilterComp = SetFloatingFilterComp;
var ReadModelAsStringFloatingFilterComp = (function (_super) {
    __extends(ReadModelAsStringFloatingFilterComp, _super);
    function ReadModelAsStringFloatingFilterComp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ReadModelAsStringFloatingFilterComp.prototype.init = function (params) {
        _super.prototype.init.call(this, params);
        this.eColumnFloatingFilter.readOnly = true;
    };
    ReadModelAsStringFloatingFilterComp.prototype.onParentModelChanged = function (parentModel) {
        this.eColumnFloatingFilter.value = this.asFloatingFilterText(this.currentParentModel());
    };
    ReadModelAsStringFloatingFilterComp.prototype.asFloatingFilterText = function (parentModel) {
        return parentModel;
    };
    ReadModelAsStringFloatingFilterComp.prototype.asParentModel = function () {
        return null;
    };
    return ReadModelAsStringFloatingFilterComp;
}(InputTextFloatingFilterComp));
exports.ReadModelAsStringFloatingFilterComp = ReadModelAsStringFloatingFilterComp;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var column_1 = __webpack_require__(9);
var utils_1 = __webpack_require__(1);
var setLeftFeature_1 = __webpack_require__(42);
var component_1 = __webpack_require__(8);
var componentAnnotations_1 = __webpack_require__(12);
var gridOptionsWrapper_1 = __webpack_require__(2);
var beans_1 = __webpack_require__(35);
var BaseFilterWrapperComp = (function (_super) {
    __extends(BaseFilterWrapperComp, _super);
    function BaseFilterWrapperComp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseFilterWrapperComp.prototype.init = function (params) {
        this.column = params.column;
        var base = utils_1._.loadTemplate("<div class=\"ag-header-cell\" aria-hidden=\"true\"><div class=\"ag-floating-filter-body\" aria-hidden=\"true\"></div></div>");
        this.enrichBody(base);
        this.setTemplateFromElement(base);
        this.setupWidth();
        var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.column, this.getGui(), this.beans);
        setLeftFeature.init();
        this.addDestroyFunc(setLeftFeature.destroy.bind(setLeftFeature));
    };
    BaseFilterWrapperComp.prototype.setupWidth = function () {
        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_WIDTH_CHANGED, this.onColumnWidthChanged.bind(this));
        this.onColumnWidthChanged();
    };
    BaseFilterWrapperComp.prototype.onColumnWidthChanged = function () {
        this.getGui().style.width = this.column.getActualWidth() + 'px';
    };
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], BaseFilterWrapperComp.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('beans'),
        __metadata("design:type", beans_1.Beans)
    ], BaseFilterWrapperComp.prototype, "beans", void 0);
    return BaseFilterWrapperComp;
}(component_1.Component));
exports.BaseFilterWrapperComp = BaseFilterWrapperComp;
var FloatingFilterWrapperComp = (function (_super) {
    __extends(FloatingFilterWrapperComp, _super);
    function FloatingFilterWrapperComp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FloatingFilterWrapperComp.prototype.init = function (params) {
        this.floatingFilterCompPromise = params.floatingFilterComp;
        this.suppressFilterButton = params.suppressFilterButton;
        _super.prototype.init.call(this, params);
        this.addEventListeners();
    };
    FloatingFilterWrapperComp.prototype.addEventListeners = function () {
        if (!this.suppressFilterButton && this.eButtonShowMainFilter) {
            this.addDestroyableEventListener(this.eButtonShowMainFilter, 'click', this.showParentFilter.bind(this));
        }
    };
    FloatingFilterWrapperComp.prototype.enrichBody = function (body) {
        var _this = this;
        this.floatingFilterCompPromise.then(function (floatingFilterComp) {
            var floatingFilterBody = body.querySelector('.ag-floating-filter-body');
            var floatingFilterCompUi = floatingFilterComp.getGui();
            if (_this.suppressFilterButton) {
                floatingFilterBody.appendChild(floatingFilterCompUi);
                utils_1._.removeCssClass(floatingFilterBody, 'ag-floating-filter-body');
                utils_1._.addCssClass(floatingFilterBody, 'ag-floating-filter-full-body');
            }
            else {
                floatingFilterBody.appendChild(floatingFilterCompUi);
                body.appendChild(utils_1._.loadTemplate("<div class=\"ag-floating-filter-button\" aria-hidden=\"true\">\n                        <button ref=\"eButtonShowMainFilter\"></button>\n                </div>"));
                var eIcon = utils_1._.createIconNoSpan('filter', _this.gridOptionsWrapper, _this.column);
                body.querySelector('button').appendChild(eIcon);
            }
            if (floatingFilterComp.afterGuiAttached) {
                floatingFilterComp.afterGuiAttached();
            }
            _this.wireQuerySelectors();
            _this.addEventListeners();
        });
    };
    FloatingFilterWrapperComp.prototype.onParentModelChanged = function (parentModel) {
        this.floatingFilterCompPromise.then(function (floatingFilterComp) {
            floatingFilterComp.onParentModelChanged(parentModel);
        });
    };
    FloatingFilterWrapperComp.prototype.showParentFilter = function () {
        this.menuFactory.showMenuAfterButtonClick(this.column, this.eButtonShowMainFilter, 'filterMenuTab', ['filterMenuTab']);
    };
    __decorate([
        componentAnnotations_1.RefSelector('eButtonShowMainFilter'),
        __metadata("design:type", HTMLInputElement)
    ], FloatingFilterWrapperComp.prototype, "eButtonShowMainFilter", void 0);
    __decorate([
        context_1.Autowired('menuFactory'),
        __metadata("design:type", Object)
    ], FloatingFilterWrapperComp.prototype, "menuFactory", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], FloatingFilterWrapperComp.prototype, "gridOptionsWrapper", void 0);
    return FloatingFilterWrapperComp;
}(BaseFilterWrapperComp));
exports.FloatingFilterWrapperComp = FloatingFilterWrapperComp;
var EmptyFloatingFilterWrapperComp = (function (_super) {
    __extends(EmptyFloatingFilterWrapperComp, _super);
    function EmptyFloatingFilterWrapperComp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EmptyFloatingFilterWrapperComp.prototype.enrichBody = function (body) {
    };
    EmptyFloatingFilterWrapperComp.prototype.onParentModelChanged = function (parentModel) {
    };
    return EmptyFloatingFilterWrapperComp;
}(BaseFilterWrapperComp));
exports.EmptyFloatingFilterWrapperComp = EmptyFloatingFilterWrapperComp;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
function defaultGroupComparator(valueA, valueB, nodeA, nodeB, accentedCompare) {
    if (accentedCompare === void 0) { accentedCompare = false; }
    console.warn('ag-Grid: Since ag-grid 11.0.0 defaultGroupComparator is not necessary. You can remove this from your colDef');
    var nodeAIsGroup = utils_1.Utils.exists(nodeA) && nodeA.group;
    var nodeBIsGroup = utils_1.Utils.exists(nodeB) && nodeB.group;
    var bothAreGroups = nodeAIsGroup && nodeBIsGroup;
    var bothAreNormal = !nodeAIsGroup && !nodeBIsGroup;
    if (bothAreGroups) {
        return utils_1.Utils.defaultComparator(nodeA.key, nodeB.key, accentedCompare);
    }
    else if (bothAreNormal) {
        return utils_1.Utils.defaultComparator(valueA, valueB, accentedCompare);
    }
    else if (nodeAIsGroup) {
        return 1;
    }
    else {
        return -1;
    }
}
exports.defaultGroupComparator = defaultGroupComparator;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var utils_1 = __webpack_require__(1);
var columnController_1 = __webpack_require__(3);
var gridOptionsWrapper_1 = __webpack_require__(2);
var context_1 = __webpack_require__(0);
var touchListener_1 = __webpack_require__(62);
var componentAnnotations_1 = __webpack_require__(12);
var originalColumnGroup_1 = __webpack_require__(32);
var HeaderGroupComp = (function (_super) {
    __extends(HeaderGroupComp, _super);
    function HeaderGroupComp() {
        return _super.call(this, HeaderGroupComp.TEMPLATE) || this;
    }
    HeaderGroupComp.prototype.init = function (params) {
        this.params = params;
        this.setupLabel();
        this.addGroupExpandIcon();
        this.setupExpandIcons();
    };
    HeaderGroupComp.prototype.setupExpandIcons = function () {
        this.addInIcon('columnGroupOpened', 'agOpened');
        this.addInIcon('columnGroupClosed', 'agClosed');
        this.addTouchAndClickListeners(this.eCloseIcon);
        this.addTouchAndClickListeners(this.eOpenIcon);
        this.updateIconVisibility();
        var originalColumnGroup = this.params.columnGroup.getOriginalColumnGroup();
        this.addDestroyableEventListener(originalColumnGroup, originalColumnGroup_1.OriginalColumnGroup.EVENT_EXPANDED_CHANGED, this.updateIconVisibility.bind(this));
        this.addDestroyableEventListener(originalColumnGroup, originalColumnGroup_1.OriginalColumnGroup.EVENT_EXPANDABLE_CHANGED, this.updateIconVisibility.bind(this));
    };
    HeaderGroupComp.prototype.addTouchAndClickListeners = function (eElement) {
        var _this = this;
        var expandAction = function () {
            var newExpandedValue = !_this.params.columnGroup.isExpanded();
            _this.columnController.setColumnGroupOpened(_this.params.columnGroup.getOriginalColumnGroup(), newExpandedValue);
        };
        var touchListener = new touchListener_1.TouchListener(this.eCloseIcon);
        this.addDestroyableEventListener(touchListener, touchListener_1.TouchListener.EVENT_TAP, expandAction);
        this.addDestroyFunc(function () { return touchListener.destroy(); });
        this.addDestroyableEventListener(eElement, 'click', expandAction);
    };
    HeaderGroupComp.prototype.updateIconVisibility = function () {
        var columnGroup = this.params.columnGroup;
        if (columnGroup.isExpandable()) {
            var expanded = this.params.columnGroup.isExpanded();
            utils_1.Utils.setVisible(this.eOpenIcon, !expanded);
            utils_1.Utils.setVisible(this.eCloseIcon, expanded);
        }
        else {
            utils_1.Utils.setVisible(this.eOpenIcon, false);
            utils_1.Utils.setVisible(this.eCloseIcon, false);
        }
    };
    HeaderGroupComp.prototype.addInIcon = function (iconName, refName) {
        var eIcon = utils_1.Utils.createIconNoSpan(iconName, this.gridOptionsWrapper, null);
        this.getRefElement(refName).appendChild(eIcon);
    };
    HeaderGroupComp.prototype.addGroupExpandIcon = function () {
        if (!this.params.columnGroup.isExpandable()) {
            utils_1.Utils.setVisible(this.eOpenIcon, false);
            utils_1.Utils.setVisible(this.eCloseIcon, false);
            return;
        }
    };
    HeaderGroupComp.prototype.setupLabel = function () {
        // no renderer, default text render
        if (this.params.displayName && this.params.displayName !== '') {
            if (utils_1.Utils.isBrowserSafari()) {
                this.getGui().style.display = 'table-cell';
            }
            var eInnerText = this.getRefElement('agLabel');
            eInnerText.innerHTML = this.params.displayName;
        }
    };
    HeaderGroupComp.TEMPLATE = "<div class=\"ag-header-group-cell-label\">" +
        "<span ref=\"agLabel\" class=\"ag-header-group-text\"></span>" +
        "<span ref=\"agOpened\" class=\"ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded\"></span>" +
        "<span ref=\"agClosed\" class=\"ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed\"></span>" +
        "</div>";
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], HeaderGroupComp.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderGroupComp.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('agOpened'),
        __metadata("design:type", HTMLElement)
    ], HeaderGroupComp.prototype, "eOpenIcon", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('agClosed'),
        __metadata("design:type", HTMLElement)
    ], HeaderGroupComp.prototype, "eCloseIcon", void 0);
    return HeaderGroupComp;
}(component_1.Component));
exports.HeaderGroupComp = HeaderGroupComp;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var column_1 = __webpack_require__(9);
var utils_1 = __webpack_require__(1);
var columnGroup_1 = __webpack_require__(28);
var columnController_1 = __webpack_require__(3);
var gridOptionsWrapper_1 = __webpack_require__(2);
var horizontalDragService_1 = __webpack_require__(39);
var context_1 = __webpack_require__(0);
var cssClassApplier_1 = __webpack_require__(53);
var dragAndDropService_1 = __webpack_require__(21);
var setLeftFeature_1 = __webpack_require__(42);
var gridApi_1 = __webpack_require__(6);
var componentRecipes_1 = __webpack_require__(27);
var beans_1 = __webpack_require__(35);
var HeaderGroupWrapperComp = (function (_super) {
    __extends(HeaderGroupWrapperComp, _super);
    function HeaderGroupWrapperComp(columnGroup, eRoot, dragSourceDropTarget, pinned) {
        var _this = _super.call(this, HeaderGroupWrapperComp.TEMPLATE) || this;
        // the children can change, we keep destroy functions related to listening to the children here
        _this.childColumnsDestroyFuncs = [];
        _this.columnGroup = columnGroup;
        _this.eRoot = eRoot;
        _this.dragSourceDropTarget = dragSourceDropTarget;
        _this.pinned = pinned;
        return _this;
    }
    HeaderGroupWrapperComp.prototype.postConstruct = function () {
        cssClassApplier_1.CssClassApplier.addHeaderClassesFromColDef(this.columnGroup.getColGroupDef(), this.getGui(), this.gridOptionsWrapper, null, this.columnGroup);
        var displayName = this.columnController.getDisplayNameForColumnGroup(this.columnGroup, 'header');
        this.appendHeaderGroupComp(displayName);
        this.setupResize();
        this.addClasses();
        this.setupWidth();
        this.addAttributes();
        var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.columnGroup, this.getGui(), this.beans);
        setLeftFeature.init();
        this.addDestroyFunc(setLeftFeature.destroy.bind(setLeftFeature));
    };
    HeaderGroupWrapperComp.prototype.addAttributes = function () {
        this.getGui().setAttribute("col-id", this.columnGroup.getUniqueId());
    };
    HeaderGroupWrapperComp.prototype.appendHeaderGroupComp = function (displayName) {
        var _this = this;
        var params = {
            displayName: displayName,
            columnGroup: this.columnGroup,
            setExpanded: function (expanded) {
                _this.columnController.setColumnGroupOpened(_this.columnGroup.getOriginalColumnGroup(), expanded);
            },
            api: this.gridApi,
            columnApi: this.columnApi,
            context: this.gridOptionsWrapper.getContext()
        };
        var callback = this.afterHeaderCompCreated.bind(this, displayName);
        this.componentRecipes.newHeaderGroupComponent(params).then(callback);
    };
    HeaderGroupWrapperComp.prototype.afterHeaderCompCreated = function (displayName, headerGroupComp) {
        this.appendChild(headerGroupComp);
        this.setupMove(headerGroupComp.getGui(), displayName);
        if (headerGroupComp.destroy) {
            this.addDestroyFunc(headerGroupComp.destroy.bind(headerGroupComp));
        }
    };
    HeaderGroupWrapperComp.prototype.addClasses = function () {
        // having different classes below allows the style to not have a bottom border
        // on the group header, if no group is specified
        // columnGroup.getColGroupDef
        if (this.columnGroup.isPadding()) {
            this.addCssClass('ag-header-group-cell-no-group');
        }
        else {
            this.addCssClass('ag-header-group-cell-with-group');
        }
    };
    HeaderGroupWrapperComp.prototype.setupMove = function (eHeaderGroup, displayName) {
        var _this = this;
        if (!eHeaderGroup) {
            return;
        }
        if (this.isSuppressMoving()) {
            return;
        }
        if (eHeaderGroup) {
            var dragSource_1 = {
                type: dragAndDropService_1.DragSourceType.HeaderCell,
                eElement: eHeaderGroup,
                dragItemName: displayName,
                // we add in the original group leaf columns, so we move both visible and non-visible items
                dragItemCallback: this.getDragItemForGroup.bind(this),
                dragSourceDropTarget: this.dragSourceDropTarget
            };
            this.dragAndDropService.addDragSource(dragSource_1, true);
            this.addDestroyFunc(function () { return _this.dragAndDropService.removeDragSource(dragSource_1); });
        }
    };
    // when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,
    // and in the order they are currently in the screen.
    HeaderGroupWrapperComp.prototype.getDragItemForGroup = function () {
        var allColumnsOriginalOrder = this.columnGroup.getOriginalColumnGroup().getLeafColumns();
        // capture visible state, used when reentering grid to dictate which columns should be visible
        var visibleState = {};
        allColumnsOriginalOrder.forEach(function (column) { return visibleState[column.getId()] = column.isVisible(); });
        var allColumnsCurrentOrder = [];
        this.columnController.getAllDisplayedColumns().forEach(function (column) {
            if (allColumnsOriginalOrder.indexOf(column) >= 0) {
                allColumnsCurrentOrder.push(column);
                utils_1.Utils.removeFromArray(allColumnsOriginalOrder, column);
            }
        });
        // we are left with non-visible columns, stick these in at the end
        allColumnsOriginalOrder.forEach(function (column) { return allColumnsCurrentOrder.push(column); });
        // create and return dragItem
        return {
            columns: allColumnsCurrentOrder,
            visibleState: visibleState
        };
    };
    HeaderGroupWrapperComp.prototype.isSuppressMoving = function () {
        // if any child is fixed, then don't allow moving
        var childSuppressesMoving = false;
        this.columnGroup.getLeafColumns().forEach(function (column) {
            if (column.getColDef().suppressMovable) {
                childSuppressesMoving = true;
            }
        });
        var result = childSuppressesMoving
            || this.gridOptionsWrapper.isSuppressMovableColumns()
            || this.gridOptionsWrapper.isForPrint();
        return result;
    };
    HeaderGroupWrapperComp.prototype.setupWidth = function () {
        // we need to listen to changes in child columns, as they impact our width
        this.addListenersToChildrenColumns();
        // the children belonging to this group can change, so we need to add and remove listeners as they change
        this.addDestroyableEventListener(this.columnGroup, columnGroup_1.ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED, this.onDisplayedChildrenChanged.bind(this));
        this.onWidthChanged();
        // the child listeners are not tied to this components lifecycle, as children can get added and removed
        // to the group - hence they are on a different lifecycle. so we must make sure the existing children
        // listeners are removed when we finally get destroyed
        this.addDestroyFunc(this.destroyListenersOnChildrenColumns.bind(this));
    };
    HeaderGroupWrapperComp.prototype.onDisplayedChildrenChanged = function () {
        this.addListenersToChildrenColumns();
        this.onWidthChanged();
    };
    HeaderGroupWrapperComp.prototype.addListenersToChildrenColumns = function () {
        var _this = this;
        // first destroy any old listeners
        this.destroyListenersOnChildrenColumns();
        // now add new listeners to the new set of children
        var widthChangedListener = this.onWidthChanged.bind(this);
        this.columnGroup.getLeafColumns().forEach(function (column) {
            column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
            column.addEventListener(column_1.Column.EVENT_VISIBLE_CHANGED, widthChangedListener);
            _this.childColumnsDestroyFuncs.push(function () {
                column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
                column.removeEventListener(column_1.Column.EVENT_VISIBLE_CHANGED, widthChangedListener);
            });
        });
    };
    HeaderGroupWrapperComp.prototype.destroyListenersOnChildrenColumns = function () {
        this.childColumnsDestroyFuncs.forEach(function (func) { return func(); });
        this.childColumnsDestroyFuncs = [];
    };
    HeaderGroupWrapperComp.prototype.onWidthChanged = function () {
        this.getGui().style.width = this.columnGroup.getActualWidth() + 'px';
    };
    HeaderGroupWrapperComp.prototype.setupResize = function () {
        var _this = this;
        this.eHeaderCellResize = this.getRefElement('agResize');
        if (!this.columnGroup.isResizable()) {
            utils_1.Utils.removeFromParent(this.eHeaderCellResize);
            return;
        }
        this.dragService.addDragHandling({
            eDraggableElement: this.eHeaderCellResize,
            eBody: this.eRoot,
            cursor: 'col-resize',
            startAfterPixels: 0,
            onDragStart: this.onDragStart.bind(this),
            onDragging: this.onDragging.bind(this)
        });
        if (!this.gridOptionsWrapper.isSuppressAutoSize()) {
            this.eHeaderCellResize.addEventListener('dblclick', function (event) {
                // get list of all the column keys we are responsible for
                var keys = [];
                _this.columnGroup.getDisplayedLeafColumns().forEach(function (column) {
                    // not all cols in the group may be participating with auto-resize
                    if (!column.getColDef().suppressAutoSize) {
                        keys.push(column.getColId());
                    }
                });
                if (keys.length > 0) {
                    _this.columnController.autoSizeColumns(keys);
                }
            });
        }
    };
    HeaderGroupWrapperComp.prototype.onDragStart = function () {
        var _this = this;
        this.groupWidthStart = this.columnGroup.getActualWidth();
        this.childrenWidthStarts = [];
        this.columnGroup.getDisplayedLeafColumns().forEach(function (column) {
            _this.childrenWidthStarts.push(column.getActualWidth());
        });
    };
    HeaderGroupWrapperComp.prototype.onDragging = function (dragChange, finished) {
        var _this = this;
        // this will be the width we have to distribute to the resizable columns
        var widthForResizableCols;
        // this is all the displayed cols in the group less those that we cannot resize
        var resizableCols;
        // a lot of variables defined for the first set of maths, but putting
        // braces in, we localise the variables to this bit of the method
        {
            var dragChangeNormalised = this.normaliseDragChange(dragChange);
            var totalGroupWidth = this.groupWidthStart + dragChangeNormalised;
            var displayedColumns = this.columnGroup.getDisplayedLeafColumns();
            resizableCols = utils_1.Utils.filter(displayedColumns, function (col) { return col.isResizable(); });
            var nonResizableCols = utils_1.Utils.filter(displayedColumns, function (col) { return !col.isResizable(); });
            var nonResizableColsWidth_1 = 0;
            nonResizableCols.forEach(function (col) { return nonResizableColsWidth_1 += col.getActualWidth(); });
            widthForResizableCols = totalGroupWidth - nonResizableColsWidth_1;
            var minWidth_1 = 0;
            resizableCols.forEach(function (col) { return minWidth_1 += col.getMinWidth(); });
            if (widthForResizableCols < minWidth_1) {
                widthForResizableCols = minWidth_1;
            }
        }
        // distribute the new width to the child headers
        var changeRatio = widthForResizableCols / this.groupWidthStart;
        // keep track of pixels used, and last column gets the remaining,
        // to cater for rounding errors, and min width adjustments
        var pixelsToDistribute = widthForResizableCols;
        resizableCols.forEach(function (column, index) {
            var notLastCol = index !== (resizableCols.length - 1);
            var newChildSize;
            if (notLastCol) {
                // if not the last col, calculate the column width as normal
                var startChildSize = _this.childrenWidthStarts[index];
                newChildSize = startChildSize * changeRatio;
                if (newChildSize < column.getMinWidth()) {
                    newChildSize = column.getMinWidth();
                }
                pixelsToDistribute -= newChildSize;
            }
            else {
                // if last col, give it the remaining pixels
                newChildSize = pixelsToDistribute;
            }
            _this.columnController.setColumnWidth(column, newChildSize, finished);
        });
    };
    // optionally inverts the drag, depending on pinned and RTL
    // note - this method is duplicated in RenderedHeaderCell - should refactor out?
    HeaderGroupWrapperComp.prototype.normaliseDragChange = function (dragChange) {
        var result = dragChange;
        if (this.gridOptionsWrapper.isEnableRtl()) {
            // for RTL, dragging left makes the col bigger, except when pinning left
            if (this.pinned !== column_1.Column.PINNED_LEFT) {
                result *= -1;
            }
        }
        else {
            // for LTR (ie normal), dragging left makes the col smaller, except when pinning right
            if (this.pinned === column_1.Column.PINNED_RIGHT) {
                result *= -1;
            }
        }
        return result;
    };
    HeaderGroupWrapperComp.TEMPLATE = '<div class="ag-header-group-cell">' +
        '<div ref="agResize" class="ag-header-cell-resize"></div>' +
        '</div>';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderGroupWrapperComp.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], HeaderGroupWrapperComp.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('horizontalDragService'),
        __metadata("design:type", horizontalDragService_1.HorizontalDragService)
    ], HeaderGroupWrapperComp.prototype, "dragService", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'),
        __metadata("design:type", dragAndDropService_1.DragAndDropService)
    ], HeaderGroupWrapperComp.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], HeaderGroupWrapperComp.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('componentRecipes'),
        __metadata("design:type", componentRecipes_1.ComponentRecipes)
    ], HeaderGroupWrapperComp.prototype, "componentRecipes", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], HeaderGroupWrapperComp.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], HeaderGroupWrapperComp.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('beans'),
        __metadata("design:type", beans_1.Beans)
    ], HeaderGroupWrapperComp.prototype, "beans", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeaderGroupWrapperComp.prototype, "postConstruct", null);
    return HeaderGroupWrapperComp;
}(component_1.Component));
exports.HeaderGroupWrapperComp = HeaderGroupWrapperComp;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var column_1 = __webpack_require__(9);
var utils_1 = __webpack_require__(1);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var sortController_1 = __webpack_require__(25);
var touchListener_1 = __webpack_require__(62);
var eventService_1 = __webpack_require__(4);
var componentAnnotations_1 = __webpack_require__(12);
var events_1 = __webpack_require__(5);
var HeaderComp = (function (_super) {
    __extends(HeaderComp, _super);
    function HeaderComp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HeaderComp.prototype.init = function (params) {
        var template = utils_1.Utils.firstExistingValue(params.template, HeaderComp.TEMPLATE);
        this.setTemplate(template);
        this.params = params;
        this.setupTap();
        this.setupIcons(params.column);
        this.setupMenu();
        this.setupSort();
        this.setupFilterIcon();
        this.setupText(params.displayName);
    };
    HeaderComp.prototype.setupText = function (displayName) {
        if (this.eText) {
            this.eText.innerHTML = displayName;
        }
    };
    HeaderComp.prototype.setupIcons = function (column) {
        this.addInIcon('sortAscending', this.eSortAsc, column);
        this.addInIcon('sortDescending', this.eSortDesc, column);
        this.addInIcon('sortUnSort', this.eSortNone, column);
        this.addInIcon('menu', this.eMenu, column);
        this.addInIcon('filter', this.eFilter, column);
    };
    HeaderComp.prototype.addInIcon = function (iconName, eParent, column) {
        if (eParent == null)
            return;
        var eIcon = utils_1.Utils.createIconNoSpan(iconName, this.gridOptionsWrapper, column);
        eParent.appendChild(eIcon);
    };
    HeaderComp.prototype.setupTap = function () {
        var _this = this;
        if (this.gridOptionsWrapper.isSuppressTouch()) {
            return;
        }
        var touchListener = new touchListener_1.TouchListener(this.getGui());
        if (this.params.enableMenu) {
            var longTapListener = function (event) {
                _this.gridOptionsWrapper.getApi().showColumnMenuAfterMouseClick(_this.params.column, event.touchStart);
            };
            this.addDestroyableEventListener(touchListener, touchListener_1.TouchListener.EVENT_LONG_TAP, longTapListener);
        }
        if (this.params.enableSorting) {
            var tapListener = function () {
                _this.sortController.progressSort(_this.params.column, false);
            };
            this.addDestroyableEventListener(touchListener, touchListener_1.TouchListener.EVENT_TAP, tapListener);
        }
        this.addDestroyFunc(function () { return touchListener.destroy(); });
    };
    HeaderComp.prototype.setupMenu = function () {
        var _this = this;
        // if no menu provided in template, do nothing
        if (!this.eMenu) {
            return;
        }
        if (!this.params.enableMenu) {
            utils_1.Utils.removeFromParent(this.eMenu);
            return;
        }
        this.eMenu.addEventListener('click', function () { return _this.showMenu(_this.eMenu); });
        if (!this.gridOptionsWrapper.isSuppressMenuHide()) {
            this.eMenu.style.opacity = '0';
            this.addGuiEventListener('mouseover', function () {
                _this.eMenu.style.opacity = '1';
            });
            this.addGuiEventListener('mouseout', function () {
                _this.eMenu.style.opacity = '0';
            });
        }
        var style = this.eMenu.style;
        style['transition'] = 'opacity 0.2s, border 0.2s';
        style['-webkit-transition'] = 'opacity 0.2s, border 0.2s';
    };
    HeaderComp.prototype.showMenu = function (eventSource) {
        this.menuFactory.showMenuAfterButtonClick(this.params.column, eventSource);
    };
    HeaderComp.prototype.removeSortIcons = function () {
        utils_1.Utils.removeFromParent(this.eSortAsc);
        utils_1.Utils.removeFromParent(this.eSortDesc);
        utils_1.Utils.removeFromParent(this.eSortNone);
        utils_1.Utils.removeFromParent(this.eSortOrder);
    };
    HeaderComp.prototype.setupSort = function () {
        var _this = this;
        var enableSorting = this.params.enableSorting;
        if (!enableSorting) {
            this.removeSortIcons();
            return;
        }
        // add the event on the header, so when clicked, we do sorting
        if (this.eLabel) {
            this.addDestroyableEventListener(this.eLabel, 'click', function (event) {
                _this.params.progressSort(event.shiftKey);
            });
        }
        this.addDestroyableEventListener(this.params.column, column_1.Column.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
        this.onSortChanged();
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_SORT_CHANGED, this.setMultiSortOrder.bind(this));
        this.setMultiSortOrder();
    };
    HeaderComp.prototype.onSortChanged = function () {
        utils_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-header-cell-sorted-asc', this.params.column.isSortAscending());
        utils_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-header-cell-sorted-desc', this.params.column.isSortDescending());
        utils_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-header-cell-sorted-none', this.params.column.isSortNone());
        if (this.eSortAsc) {
            utils_1.Utils.addOrRemoveCssClass(this.eSortAsc, 'ag-hidden', !this.params.column.isSortAscending());
        }
        if (this.eSortDesc) {
            utils_1.Utils.addOrRemoveCssClass(this.eSortDesc, 'ag-hidden', !this.params.column.isSortDescending());
        }
        if (this.eSortNone) {
            var alwaysHideNoSort = !this.params.column.getColDef().unSortIcon && !this.gridOptionsWrapper.isUnSortIcon();
            utils_1.Utils.addOrRemoveCssClass(this.eSortNone, 'ag-hidden', alwaysHideNoSort || !this.params.column.isSortNone());
        }
    };
    // we listen here for global sort events, NOT column sort events, as we want to do this
    // when sorting has been set on all column (if we listened just for our col (where we
    // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
    HeaderComp.prototype.setMultiSortOrder = function () {
        if (!this.eSortOrder) {
            return;
        }
        var col = this.params.column;
        var allColumnsWithSorting = this.sortController.getColumnsWithSortingOrdered();
        var indexThisCol = allColumnsWithSorting.indexOf(col);
        var moreThanOneColSorting = allColumnsWithSorting.length > 1;
        var showIndex = col.isSorting() && moreThanOneColSorting;
        utils_1.Utils.setVisible(this.eSortOrder, showIndex);
        if (indexThisCol >= 0) {
            this.eSortOrder.innerHTML = (indexThisCol + 1).toString();
        }
        else {
            this.eSortOrder.innerHTML = '';
        }
    };
    HeaderComp.prototype.setupFilterIcon = function () {
        if (!this.eFilter) {
            return;
        }
        this.addDestroyableEventListener(this.params.column, column_1.Column.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
        this.onFilterChanged();
    };
    HeaderComp.prototype.onFilterChanged = function () {
        var filterPresent = this.params.column.isFilterActive();
        utils_1.Utils.addOrRemoveCssClass(this.eFilter, 'ag-hidden', !filterPresent);
    };
    HeaderComp.TEMPLATE = '<div class="ag-cell-label-container" role="presentation">' +
        '  <span ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>' +
        '  <div ref="eLabel" class="ag-header-cell-label" role="presentation">' +
        '    <span ref="eText" class="ag-header-cell-text" role="columnheader"></span>' +
        '    <span ref="eFilter" class="ag-header-icon ag-filter-icon" aria-hidden="true"></span>' +
        '    <span ref="eSortOrder" class="ag-header-icon ag-sort-order" aria-hidden="true"></span>' +
        '    <span ref="eSortAsc" class="ag-header-icon ag-sort-ascending-icon" aria-hidden="true"></span>' +
        '    <span ref="eSortDesc" class="ag-header-icon ag-sort-descending-icon" aria-hidden="true"></span>' +
        '    <span ref="eSortNone" class="ag-header-icon ag-sort-none-icon" aria-hidden="true"></span>' +
        '  </div>' +
        '</div>';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderComp.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('sortController'),
        __metadata("design:type", sortController_1.SortController)
    ], HeaderComp.prototype, "sortController", void 0);
    __decorate([
        context_1.Autowired('menuFactory'),
        __metadata("design:type", Object)
    ], HeaderComp.prototype, "menuFactory", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], HeaderComp.prototype, "eventService", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eFilter'),
        __metadata("design:type", HTMLElement)
    ], HeaderComp.prototype, "eFilter", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eSortAsc'),
        __metadata("design:type", HTMLElement)
    ], HeaderComp.prototype, "eSortAsc", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eSortDesc'),
        __metadata("design:type", HTMLElement)
    ], HeaderComp.prototype, "eSortDesc", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eSortNone'),
        __metadata("design:type", HTMLElement)
    ], HeaderComp.prototype, "eSortNone", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eSortOrder'),
        __metadata("design:type", HTMLElement)
    ], HeaderComp.prototype, "eSortOrder", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eMenu'),
        __metadata("design:type", HTMLElement)
    ], HeaderComp.prototype, "eMenu", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eLabel'),
        __metadata("design:type", HTMLElement)
    ], HeaderComp.prototype, "eLabel", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eText'),
        __metadata("design:type", HTMLElement)
    ], HeaderComp.prototype, "eText", void 0);
    return HeaderComp;
}(component_1.Component));
exports.HeaderComp = HeaderComp;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var agCheckbox_1 = __webpack_require__(61);
var beanStub_1 = __webpack_require__(13);
var context_1 = __webpack_require__(0);
var columnController_1 = __webpack_require__(3);
var gridApi_1 = __webpack_require__(6);
var events_1 = __webpack_require__(5);
var eventService_1 = __webpack_require__(4);
var constants_1 = __webpack_require__(7);
var selectionController_1 = __webpack_require__(17);
var gridOptionsWrapper_1 = __webpack_require__(2);
var SelectAllFeature = (function (_super) {
    __extends(SelectAllFeature, _super);
    function SelectAllFeature(cbSelectAll, column) {
        var _this = _super.call(this) || this;
        _this.cbSelectAllVisible = false;
        _this.processingEventFromCheckbox = false;
        _this.cbSelectAll = cbSelectAll;
        _this.column = column;
        var colDef = column.getColDef();
        _this.filteredOnly = colDef ? !!colDef.headerCheckboxSelectionFilteredOnly : false;
        return _this;
    }
    SelectAllFeature.prototype.postConstruct = function () {
        this.showOrHideSelectAll();
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.showOrHideSelectAll.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_SELECTION_CHANGED, this.onSelectionChanged.bind(this));
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_MODEL_UPDATED, this.onModelChanged.bind(this));
        this.addDestroyableEventListener(this.cbSelectAll, agCheckbox_1.AgCheckbox.EVENT_CHANGED, this.onCbSelectAll.bind(this));
    };
    SelectAllFeature.prototype.showOrHideSelectAll = function () {
        this.cbSelectAllVisible = this.isCheckboxSelection();
        this.cbSelectAll.setVisible(this.cbSelectAllVisible);
        if (this.cbSelectAllVisible) {
            // in case user is trying this feature with the wrong model type
            this.checkRightRowModelType();
            // make sure checkbox is showing the right state
            this.updateStateOfCheckbox();
        }
    };
    SelectAllFeature.prototype.onModelChanged = function () {
        if (!this.cbSelectAllVisible) {
            return;
        }
        this.updateStateOfCheckbox();
    };
    SelectAllFeature.prototype.onSelectionChanged = function () {
        if (!this.cbSelectAllVisible) {
            return;
        }
        this.updateStateOfCheckbox();
    };
    SelectAllFeature.prototype.getNextCheckboxState = function (selectionCount) {
        if (selectionCount.selected === 0 && selectionCount.notSelected === 0) {
            // if no rows, always have it unselected
            return false;
        }
        else if (selectionCount.selected > 0 && selectionCount.notSelected > 0) {
            // if mix of selected and unselected, this is the tri-state
            return null;
        }
        else if (selectionCount.selected > 0) {
            // only selected
            return true;
        }
        else {
            // nothing selected
            return false;
        }
    };
    SelectAllFeature.prototype.updateStateOfCheckbox = function () {
        if (this.processingEventFromCheckbox) {
            return;
        }
        this.processingEventFromCheckbox = true;
        var selectionCount = this.getSelectionCount();
        var allSelected = this.getNextCheckboxState(selectionCount);
        this.cbSelectAll.setSelected(allSelected);
        this.processingEventFromCheckbox = false;
    };
    SelectAllFeature.prototype.getSelectionCount = function () {
        var selectedCount = 0;
        var notSelectedCount = 0;
        var callback = function (node) {
            if (node.isSelected()) {
                selectedCount++;
            }
            else {
                notSelectedCount++;
            }
        };
        if (this.filteredOnly) {
            this.gridApi.forEachNodeAfterFilter(callback);
        }
        else {
            this.gridApi.forEachNode(callback);
        }
        return {
            notSelected: notSelectedCount,
            selected: selectedCount
        };
    };
    SelectAllFeature.prototype.checkRightRowModelType = function () {
        var rowModelType = this.rowModel.getType();
        var rowModelMatches = rowModelType === constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY;
        if (!rowModelMatches) {
            console.log("ag-Grid: selectAllCheckbox is only available if using normal row model, you are using " + rowModelType);
        }
    };
    SelectAllFeature.prototype.onCbSelectAll = function () {
        if (this.processingEventFromCheckbox) {
            return;
        }
        if (!this.cbSelectAllVisible) {
            return;
        }
        var value = this.cbSelectAll.isSelected();
        if (value) {
            this.selectionController.selectAllRowNodes(this.filteredOnly);
        }
        else {
            this.selectionController.deselectAllRowNodes(this.filteredOnly);
        }
    };
    SelectAllFeature.prototype.isCheckboxSelection = function () {
        var result = this.column.getColDef().headerCheckboxSelection;
        if (typeof result === 'function') {
            var func = result;
            result = func({
                column: this.column,
                colDef: this.column.getColDef(),
                columnApi: this.columnApi,
                api: this.gridApi
            });
        }
        if (result) {
            if (this.gridOptionsWrapper.isRowModelEnterprise()) {
                console.warn('headerCheckboxSelection is not supported for Enterprise Row Model');
                return false;
            }
            if (this.gridOptionsWrapper.isRowModelInfinite()) {
                console.warn('headerCheckboxSelection is not supported for Infinite Row Model');
                return false;
            }
            if (this.gridOptionsWrapper.isRowModelViewport()) {
                console.warn('headerCheckboxSelection is not supported for Viewport Row Model');
                return false;
            }
            // otherwise the row model is compatible, so return true
            return true;
        }
        else {
            return false;
        }
    };
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], SelectAllFeature.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], SelectAllFeature.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], SelectAllFeature.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], SelectAllFeature.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('selectionController'),
        __metadata("design:type", selectionController_1.SelectionController)
    ], SelectAllFeature.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], SelectAllFeature.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], SelectAllFeature.prototype, "postConstruct", null);
    return SelectAllFeature;
}(beanStub_1.BeanStub));
exports.SelectAllFeature = SelectAllFeature;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var TabbedLayout = (function () {
    function TabbedLayout(params) {
        var _this = this;
        this.items = [];
        this.params = params;
        this.eGui = document.createElement('div');
        this.eGui.innerHTML = TabbedLayout.TEMPLATE;
        this.eHeader = this.eGui.querySelector('#tabHeader');
        this.eBody = this.eGui.querySelector('#tabBody');
        utils_1.Utils.addCssClass(this.eGui, params.cssClass);
        if (params.items) {
            params.items.forEach(function (item) { return _this.addItem(item); });
        }
    }
    TabbedLayout.prototype.setAfterAttachedParams = function (params) {
        this.afterAttachedParams = params;
    };
    TabbedLayout.prototype.getMinWidth = function () {
        var eDummyContainer = document.createElement('span');
        // position fixed, so it isn't restricted to the boundaries of the parent
        eDummyContainer.style.position = 'fixed';
        // we put the dummy into the body container, so it will inherit all the
        // css styles that the real cells are inheriting
        this.eGui.appendChild(eDummyContainer);
        var minWidth = 0;
        this.items.forEach(function (itemWrapper) {
            utils_1.Utils.removeAllChildren(eDummyContainer);
            var eClone = itemWrapper.tabbedItem.bodyPromise.resolveNow(null, function (body) { return body.cloneNode(true); });
            if (eClone == null)
                return;
            eDummyContainer.appendChild(eClone);
            if (minWidth < eDummyContainer.offsetWidth) {
                minWidth = eDummyContainer.offsetWidth;
            }
        });
        this.eGui.removeChild(eDummyContainer);
        return minWidth;
    };
    TabbedLayout.prototype.showFirstItem = function () {
        if (this.items.length > 0) {
            this.showItemWrapper(this.items[0]);
        }
    };
    TabbedLayout.prototype.addItem = function (item) {
        var eHeaderButton = document.createElement('span');
        eHeaderButton.appendChild(item.title);
        utils_1.Utils.addCssClass(eHeaderButton, 'ag-tab');
        this.eHeader.appendChild(eHeaderButton);
        var wrapper = {
            tabbedItem: item,
            eHeaderButton: eHeaderButton
        };
        this.items.push(wrapper);
        eHeaderButton.addEventListener('click', this.showItemWrapper.bind(this, wrapper));
    };
    TabbedLayout.prototype.showItem = function (tabbedItem) {
        var itemWrapper = utils_1.Utils.find(this.items, function (itemWrapper) {
            return itemWrapper.tabbedItem === tabbedItem;
        });
        if (itemWrapper) {
            this.showItemWrapper(itemWrapper);
        }
    };
    TabbedLayout.prototype.showItemWrapper = function (wrapper) {
        var _this = this;
        if (this.params.onItemClicked) {
            this.params.onItemClicked({ item: wrapper.tabbedItem });
        }
        if (this.activeItem === wrapper) {
            utils_1.Utils.callIfPresent(this.params.onActiveItemClicked);
            return;
        }
        utils_1.Utils.removeAllChildren(this.eBody);
        wrapper.tabbedItem.bodyPromise.then(function (body) {
            _this.eBody.appendChild(body);
        });
        if (this.activeItem) {
            utils_1.Utils.removeCssClass(this.activeItem.eHeaderButton, 'ag-tab-selected');
        }
        utils_1.Utils.addCssClass(wrapper.eHeaderButton, 'ag-tab-selected');
        this.activeItem = wrapper;
        if (wrapper.tabbedItem.afterAttachedCallback) {
            wrapper.tabbedItem.afterAttachedCallback(this.afterAttachedParams);
        }
    };
    TabbedLayout.prototype.getGui = function () {
        return this.eGui;
    };
    TabbedLayout.TEMPLATE = '<div>' +
        '<div id="tabHeader" class="ag-tab-header"></div>' +
        '<div id="tabBody" class="ag-tab-body"></div>' +
        '</div>';
    return TabbedLayout;
}());
exports.TabbedLayout = TabbedLayout;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var VerticalStack = (function () {
    function VerticalStack() {
        this.isLayoutPanel = true;
        this.childPanels = [];
        this.eGui = document.createElement('div');
        this.eGui.style.height = '100%';
    }
    VerticalStack.prototype.addPanel = function (panel, height) {
        var component;
        if (panel.isLayoutPanel) {
            this.childPanels.push(panel);
            component = panel.getGui();
        }
        else {
            component = panel;
        }
        if (height) {
            component.style.height = height;
        }
        this.eGui.appendChild(component);
    };
    VerticalStack.prototype.getGui = function () {
        return this.eGui;
    };
    VerticalStack.prototype.doLayout = function () {
        for (var i = 0; i < this.childPanels.length; i++) {
            this.childPanels[i].doLayout();
        }
    };
    return VerticalStack;
}());
exports.VerticalStack = VerticalStack;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var LinkedList = (function () {
    function LinkedList() {
        this.first = null;
        this.last = null;
    }
    LinkedList.prototype.add = function (item) {
        var entry = {
            item: item,
            next: null
        };
        if (this.last) {
            this.last.next = entry;
        }
        else {
            this.first = entry;
        }
        this.last = entry;
    };
    LinkedList.prototype.remove = function () {
        var result = this.first;
        if (result) {
            this.first = result.next;
            if (!this.first) {
                this.last = null;
            }
        }
        return result.item;
    };
    LinkedList.prototype.isEmpty = function () {
        return !this.first;
    };
    return LinkedList;
}());
exports.LinkedList = LinkedList;
var LinkedListItem = (function () {
    function LinkedListItem() {
    }
    return LinkedListItem;
}());


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
function simpleHttpRequest(params) {
    return new utils_1.Promise(function (resolve) {
        var httpRequest = new XMLHttpRequest();
        httpRequest.open('GET', params.url);
        httpRequest.send();
        httpRequest.onreadystatechange = function () {
            if (httpRequest.readyState == 4 && httpRequest.status == 200) {
                var httpResponse = JSON.parse(httpRequest.responseText);
                resolve(httpResponse);
            }
        };
    });
}
exports.simpleHttpRequest = simpleHttpRequest;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

Object.defineProperty(exports, "__esModule", { value: true });
var PropertyKeys = (function () {
    function PropertyKeys() {
    }
    PropertyKeys.STRING_PROPERTIES = [
        'sortingOrder', 'rowClass', 'rowSelection', 'overlayLoadingTemplate',
        'overlayNoRowsTemplate', 'headerCellTemplate', 'quickFilterText', 'rowModelType',
        'editType', 'domLayout', 'clipboardDeliminator', 'rowGroupPanelShow'
    ];
    PropertyKeys.OBJECT_PROPERTIES = [
        'components', 'frameworkComponents', 'rowStyle', 'context', 'autoGroupColumnDef', 'groupColumnDef', 'localeText',
        'icons', 'datasource', 'enterpriseDatasource', 'viewportDatasource', 'groupRowRendererParams', 'aggFuncs',
        'fullWidthCellRendererParams', 'defaultColGroupDef', 'defaultColDef', 'defaultExportParams', 'columnTypes',
        'rowClassRules'
        //,'cellRenderers','cellEditors'
    ];
    PropertyKeys.ARRAY_PROPERTIES = [
        'slaveGrids', 'alignedGrids', 'rowData',
        'columnDefs', 'excelStyles', 'pinnedTopRowData', 'pinnedBottomRowData'
        // deprecated
    ];
    PropertyKeys.NUMBER_PROPERTIES = [
        'rowHeight', 'rowBuffer', 'colWidth', 'headerHeight', 'groupHeaderHeight', 'floatingFiltersHeight',
        'pivotHeaderHeight', 'pivotGroupHeaderHeight', 'groupDefaultExpanded',
        'minColWidth', 'maxColWidth', 'viewportRowModelPageSize', 'viewportRowModelBufferSize',
        'layoutInterval', 'autoSizePadding', 'maxBlocksInCache', 'maxConcurrentDatasourceRequests',
        'cacheOverflowSize', 'paginationPageSize', 'cacheBlockSize', 'infiniteInitialRowCount',
        'scrollbarWidth', 'paginationStartPage', 'infiniteBlockSize'
    ];
    PropertyKeys.BOOLEAN_PROPERTIES = [
        'toolPanelSuppressRowGroups', 'toolPanelSuppressValues', 'toolPanelSuppressPivots', 'toolPanelSuppressPivotMode',
        'suppressRowClickSelection', 'suppressCellSelection', 'suppressHorizontalScroll', 'debug',
        'enableColResize', 'enableCellExpressions', 'enableSorting', 'enableServerSideSorting',
        'enableFilter', 'enableServerSideFilter', 'angularCompileRows', 'angularCompileFilters',
        'angularCompileHeaders', 'groupSuppressAutoColumn', 'groupSelectsChildren',
        'groupIncludeFooter', 'groupUseEntireRow', 'groupSuppressRow', 'groupSuppressBlankHeader', 'forPrint',
        'suppressMenuHide', 'rowDeselection', 'unSortIcon', 'suppressMultiSort',
        'singleClickEdit', 'suppressLoadingOverlay', 'suppressNoRowsOverlay', 'suppressAutoSize',
        'suppressParentsInRowNodes', 'showToolPanel', 'suppressColumnMoveAnimation', 'suppressMovableColumns',
        'suppressFieldDotNotation', 'enableRangeSelection',
        'pivotPanelShow', 'suppressTouch', 'suppressAsyncEvents', 'allowContextMenuWithControlKey',
        'suppressContextMenu', 'suppressMenuFilterPanel', 'suppressMenuMainPanel', 'suppressMenuColumnPanel',
        'enableStatusBar', 'alwaysShowStatusBar', 'rememberGroupStateWhenNewData', 'enableCellChangeFlash', 'suppressDragLeaveHidesColumns',
        'suppressMiddleClickScrolls', 'suppressPreventDefaultOnMouseWheel', 'suppressUseColIdForGroups',
        'suppressCopyRowsToClipboard', 'pivotMode', 'suppressAggFuncInHeader', 'suppressColumnVirtualisation', 'suppressAggAtRootLevel',
        'suppressFocusAfterRefresh', 'functionsPassive', 'functionsReadOnly',
        'animateRows', 'groupSelectsFiltered', 'groupRemoveSingleChildren', 'groupRemoveLowestSingleChildren',
        'enableRtl', 'suppressClickEdit',
        'enableGroupEdit', 'embedFullWidthRows', 'suppressTabbing', 'suppressPaginationPanel', 'floatingFilter',
        'groupHideOpenParents', 'groupMultiAutoColumn', 'pagination', 'stopEditingWhenGridLosesFocus',
        'paginationAutoPageSize', 'suppressScrollOnNewData', 'purgeClosedRowNodes', 'cacheQuickFilter',
        'deltaRowDataMode', 'ensureDomOrder', 'accentedSort', 'pivotTotals', 'suppressChangeDetection',
        'valueCache', 'valueCacheNeverExpires', 'aggregateOnlyChangedColumns', 'suppressAnimationFrame',
        'suppressExcelExport', 'suppressCsvExport', 'treeData'
    ];
    PropertyKeys.FUNCTION_PROPERTIES = ['headerCellRenderer', 'localeTextFunc', 'groupRowInnerRenderer', 'groupRowInnerRendererFramework',
        'dateComponent', 'dateComponentFramework', 'groupRowRenderer', 'groupRowRendererFramework', 'isExternalFilterPresent',
        'getRowHeight', 'doesExternalFilterPass', 'getRowClass', 'getRowStyle', 'getRowClassRules', 'getHeaderCellTemplate',
        'traverseNode', 'getContextMenuItems', 'getMainMenuItems', 'processRowPostCreate', 'processCellForClipboard',
        'getNodeChildDetails', 'groupRowAggNodes', 'getRowNodeId', 'isFullWidthCell', 'fullWidthCellRenderer',
        'fullWidthCellRendererFramework', 'doesDataFlower', 'processSecondaryColDef', 'processSecondaryColGroupDef',
        'getBusinessKeyForNode', 'sendToClipboard', 'navigateToNextCell', 'tabToNextCell',
        'processCellFromClipboard', 'getDocument', 'postProcessPopup', 'getChildCount', 'getDataPath'];
    PropertyKeys.ALL_PROPERTIES = PropertyKeys.ARRAY_PROPERTIES
        .concat(PropertyKeys.OBJECT_PROPERTIES)
        .concat(PropertyKeys.STRING_PROPERTIES)
        .concat(PropertyKeys.NUMBER_PROPERTIES)
        .concat(PropertyKeys.FUNCTION_PROPERTIES)
        .concat(PropertyKeys.BOOLEAN_PROPERTIES);
    return PropertyKeys;
}());
exports.PropertyKeys = PropertyKeys;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
/**
 * There are many instances of this component covering each of the areas a row can be entered
 * eg body, pinned left, fullWidth. The component differs from others in that it's given the
 * elements, there is no template. All of the elements are part of the GridPanel.
 */
var RowContainerComponent = (function () {
    function RowContainerComponent(params) {
        this.childCount = 0;
        this.rowTemplatesToAdd = [];
        this.afterGuiAttachedCallbacks = [];
        this.eContainer = params.eContainer;
        this.eViewport = params.eViewport;
        this.hideWhenNoChildren = params.hideWhenNoChildren;
    }
    RowContainerComponent.prototype.postConstruct = function () {
        this.domOrder = this.gridOptionsWrapper.isEnsureDomOrder() && !this.gridOptionsWrapper.isForPrint();
        this.checkVisibility();
    };
    RowContainerComponent.prototype.getRowElement = function (compId) {
        return this.eContainer.querySelector("[comp-id=\"" + compId + "\"]");
    };
    RowContainerComponent.prototype.setHeight = function (height) {
        this.eContainer.style.height = height + "px";
    };
    RowContainerComponent.prototype.flushRowTemplates = function () {
        // if doing dom order, then rowTemplates will be empty,
        // or if now rows added since last time also empty.
        if (this.rowTemplatesToAdd.length !== 0) {
            var htmlToAdd = this.rowTemplatesToAdd.join('');
            utils_1.Utils.appendHtml(this.eContainer, htmlToAdd);
            this.rowTemplatesToAdd.length = 0;
        }
        // this only empty if no rows since last time, as when
        // doing dom order, we still have callbacks to process
        this.afterGuiAttachedCallbacks.forEach(function (func) { return func(); });
        this.afterGuiAttachedCallbacks.length = 0;
        this.lastPlacedElement = null;
    };
    RowContainerComponent.prototype.appendRowTemplate = function (rowTemplate, callback) {
        if (this.domOrder) {
            this.lastPlacedElement = utils_1.Utils.insertTemplateWithDomOrder(this.eContainer, rowTemplate, this.lastPlacedElement);
        }
        else {
            this.rowTemplatesToAdd.push(rowTemplate);
        }
        this.afterGuiAttachedCallbacks.push(callback);
        // it is important we put items in in order, so that when we open a row group,
        // the new rows are inserted after the opened group, but before the rows below.
        // that way, the rows below are over the new rows (as dom renders last in dom over
        // items previous in dom), otherwise the child rows would cover the row below and
        // that meant the user doesn't see the rows below slide away.
        this.childCount++;
        this.checkVisibility();
    };
    RowContainerComponent.prototype.ensureDomOrder = function (eRow) {
        if (this.domOrder) {
            utils_1.Utils.ensureDomOrder(this.eContainer, eRow, this.lastPlacedElement);
            this.lastPlacedElement = eRow;
        }
    };
    RowContainerComponent.prototype.removeRowElement = function (eRow) {
        this.eContainer.removeChild(eRow);
        this.childCount--;
        this.checkVisibility();
    };
    RowContainerComponent.prototype.checkVisibility = function () {
        if (!this.hideWhenNoChildren) {
            return;
        }
        var eGui = this.eViewport ? this.eViewport : this.eContainer;
        var visible = this.childCount > 0;
        if (this.visible !== visible) {
            this.visible = visible;
            utils_1.Utils.setVisible(eGui, visible);
        }
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], RowContainerComponent.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], RowContainerComponent.prototype, "postConstruct", null);
    return RowContainerComponent;
}());
exports.RowContainerComponent = RowContainerComponent;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(1);
var gridOptionsWrapper_1 = __webpack_require__(2);
var context_1 = __webpack_require__(0);
var rowNodeBlock_1 = __webpack_require__(59);
var rowRenderer_1 = __webpack_require__(18);
var InfiniteBlock = (function (_super) {
    __extends(InfiniteBlock, _super);
    function InfiniteBlock(pageNumber, params) {
        var _this = _super.call(this, pageNumber, params) || this;
        _this.cacheParams = params;
        return _this;
    }
    InfiniteBlock.prototype.createBlankRowNode = function (rowIndex) {
        var rowNode = _super.prototype.createBlankRowNode.call(this, rowIndex);
        rowNode.uiLevel = 0;
        this.setIndexAndTopOnRowNode(rowNode, rowIndex);
        return rowNode;
    };
    InfiniteBlock.prototype.setDataAndId = function (rowNode, data, index) {
        if (utils_1.Utils.exists(data)) {
            // this means if the user is not providing id's we just use the
            // index for the row. this will allow selection to work (that is based
            // on index) as long user is not inserting or deleting rows,
            // or wanting to keep selection between server side sorting or filtering
            rowNode.setDataAndId(data, index.toString());
        }
        else {
            rowNode.setDataAndId(undefined, undefined);
        }
    };
    InfiniteBlock.prototype.setRowNode = function (rowIndex, rowNode) {
        _super.prototype.setRowNode.call(this, rowIndex, rowNode);
        this.setIndexAndTopOnRowNode(rowNode, rowIndex);
    };
    InfiniteBlock.prototype.init = function () {
        _super.prototype.init.call(this, {
            context: this.context,
            rowRenderer: this.rowRenderer
        });
    };
    InfiniteBlock.prototype.getNodeIdPrefix = function () {
        return null;
    };
    InfiniteBlock.prototype.getRow = function (displayIndex) {
        return this.getRowUsingLocalIndex(displayIndex);
    };
    InfiniteBlock.prototype.setIndexAndTopOnRowNode = function (rowNode, rowIndex) {
        rowNode.setRowIndex(rowIndex);
        rowNode.rowTop = this.cacheParams.rowHeight * rowIndex;
    };
    InfiniteBlock.prototype.loadFromDatasource = function () {
        var _this = this;
        // PROBLEM . . . . when the user sets sort via colDef.sort, then this code
        // is executing before the sort is set up, so server is not getting the sort
        // model. need to change with regards order - so the server side request is
        // AFTER thus it gets the right sort model.
        var params = {
            startRow: this.getStartRow(),
            endRow: this.getEndRow(),
            successCallback: this.pageLoaded.bind(this, this.getVersion()),
            failCallback: this.pageLoadFailed.bind(this),
            sortModel: this.cacheParams.sortModel,
            filterModel: this.cacheParams.filterModel,
            context: this.gridOptionsWrapper.getContext()
        };
        if (utils_1.Utils.missing(this.cacheParams.datasource.getRows)) {
            console.warn("ag-Grid: datasource is missing getRows method");
            return;
        }
        // check if old version of datasource used
        var getRowsParams = utils_1.Utils.getFunctionParameters(this.cacheParams.datasource.getRows);
        if (getRowsParams.length > 1) {
            console.warn('ag-grid: It looks like your paging datasource is of the old type, taking more than one parameter.');
            console.warn('ag-grid: From ag-grid 1.9.0, now the getRows takes one parameter. See the documentation for details.');
        }
        // put in timeout, to force result to be async
        setTimeout(function () {
            _this.cacheParams.datasource.getRows(params);
        }, 0);
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], InfiniteBlock.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], InfiniteBlock.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'),
        __metadata("design:type", rowRenderer_1.RowRenderer)
    ], InfiniteBlock.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], InfiniteBlock.prototype, "init", null);
    return InfiniteBlock;
}(rowNodeBlock_1.RowNodeBlock));
exports.InfiniteBlock = InfiniteBlock;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var logger_1 = __webpack_require__(11);
var infiniteBlock_1 = __webpack_require__(149);
var rowNodeCache_1 = __webpack_require__(87);
var gridApi_1 = __webpack_require__(6);
var columnController_1 = __webpack_require__(3);
var InfiniteCache = (function (_super) {
    __extends(InfiniteCache, _super);
    function InfiniteCache(params) {
        return _super.call(this, params) || this;
    }
    InfiniteCache.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('InfiniteCache');
    };
    InfiniteCache.prototype.init = function () {
        _super.prototype.init.call(this);
        // start load of data, as the virtualRowCount will remain at 0 otherwise,
        // so we need this to kick things off, otherwise grid would never call getRow()
        this.getRow(0);
    };
    InfiniteCache.prototype.moveItemsDown = function (page, moveFromIndex, moveCount) {
        var startRow = page.getStartRow();
        var endRow = page.getEndRow();
        var indexOfLastRowToMove = moveFromIndex + moveCount;
        // all rows need to be moved down below the insertion index
        for (var currentRowIndex = endRow - 1; currentRowIndex >= startRow; currentRowIndex--) {
            // don't move rows at or before the insertion index
            if (currentRowIndex < indexOfLastRowToMove) {
                continue;
            }
            var indexOfNodeWeWant = currentRowIndex - moveCount;
            var nodeForThisIndex = this.getRow(indexOfNodeWeWant, true);
            if (nodeForThisIndex) {
                page.setRowNode(currentRowIndex, nodeForThisIndex);
            }
            else {
                page.setBlankRowNode(currentRowIndex);
                page.setDirty();
            }
        }
    };
    InfiniteCache.prototype.insertItems = function (block, indexToInsert, items) {
        var pageStartRow = block.getStartRow();
        var pageEndRow = block.getEndRow();
        var newRowNodes = [];
        // next stage is insert the rows into this page, if applicable
        for (var index = 0; index < items.length; index++) {
            var rowIndex = indexToInsert + index;
            var currentRowInThisPage = rowIndex >= pageStartRow && rowIndex < pageEndRow;
            if (currentRowInThisPage) {
                var dataItem = items[index];
                var newRowNode = block.setNewData(rowIndex, dataItem);
                newRowNodes.push(newRowNode);
            }
        }
        return newRowNodes;
    };
    InfiniteCache.prototype.insertItemsAtIndex = function (indexToInsert, items) {
        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order
        var _this = this;
        var newNodes = [];
        this.forEachBlockInReverseOrder(function (block) {
            var pageEndRow = block.getEndRow();
            // if the insertion is after this page, then this page is not impacted
            if (pageEndRow <= indexToInsert) {
                return;
            }
            _this.moveItemsDown(block, indexToInsert, items.length);
            var newNodesThisPage = _this.insertItems(block, indexToInsert, items);
            newNodesThisPage.forEach(function (rowNode) { return newNodes.push(rowNode); });
        });
        if (this.isMaxRowFound()) {
            this.hack_setVirtualRowCount(this.getVirtualRowCount() + items.length);
        }
        this.onCacheUpdated();
        var event = {
            type: events_1.Events.EVENT_ROW_DATA_UPDATED,
            api: this.gridApi,
            columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(event);
    };
    // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
    // it will want new pages in the cache as it asks for rows. only when we are inserting /
    // removing rows via the api is dontCreatePage set, where we move rows between the pages.
    InfiniteCache.prototype.getRow = function (rowIndex, dontCreatePage) {
        if (dontCreatePage === void 0) { dontCreatePage = false; }
        var blockId = Math.floor(rowIndex / this.cacheParams.blockSize);
        var block = this.getBlock(blockId);
        if (!block) {
            if (dontCreatePage) {
                return null;
            }
            else {
                block = this.createBlock(blockId);
            }
        }
        return block.getRow(rowIndex);
    };
    InfiniteCache.prototype.createBlock = function (blockNumber) {
        var newBlock = new infiniteBlock_1.InfiniteBlock(blockNumber, this.cacheParams);
        this.context.wireBean(newBlock);
        this.postCreateBlock(newBlock);
        return newBlock;
    };
    // we have this on infinite row model only, not enterprise row model,
    // because for enterprise, it would leave the children in inconsistent
    // state - eg if a node had children, but after the refresh it had data
    // for a different row, then the children would be with the wrong row node.
    InfiniteCache.prototype.refreshCache = function () {
        this.forEachBlockInOrder(function (block) { return block.setDirty(); });
        this.checkBlockToLoad();
    };
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], InfiniteCache.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], InfiniteCache.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnApi'),
        __metadata("design:type", columnController_1.ColumnApi)
    ], InfiniteCache.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'),
        __metadata("design:type", gridApi_1.GridApi)
    ], InfiniteCache.prototype, "gridApi", void 0);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [logger_1.LoggerFactory]),
        __metadata("design:returntype", void 0)
    ], InfiniteCache.prototype, "setBeans", null);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], InfiniteCache.prototype, "init", null);
    return InfiniteCache;
}(rowNodeCache_1.RowNodeCache));
exports.InfiniteCache = InfiniteCache;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var component_1 = __webpack_require__(8);
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var componentAnnotations_1 = __webpack_require__(12);
var utils_1 = __webpack_require__(1);
var eventService_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var rowRenderer_1 = __webpack_require__(18);
var paginationProxy_1 = __webpack_require__(29);
var PaginationComp = (function (_super) {
    __extends(PaginationComp, _super);
    function PaginationComp() {
        return _super.call(this) || this;
    }
    PaginationComp.prototype.postConstruct = function () {
        this.setTemplate(this.getTemplate());
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this));
        this.addDestroyableEventListener(this.btFirst, 'click', this.onBtFirst.bind(this));
        this.addDestroyableEventListener(this.btLast, 'click', this.onBtLast.bind(this));
        this.addDestroyableEventListener(this.btNext, 'click', this.onBtNext.bind(this));
        this.addDestroyableEventListener(this.btPrevious, 'click', this.onBtPrevious.bind(this));
        this.onPaginationChanged();
    };
    PaginationComp.prototype.onPaginationChanged = function () {
        this.enableOrDisableButtons();
        this.updateRowLabels();
        this.setCurrentPageLabel();
        this.setTotalLabels();
    };
    PaginationComp.prototype.setCurrentPageLabel = function () {
        var currentPage = this.paginationProxy.getCurrentPage();
        this.lbCurrent.innerHTML = this.formatNumber(currentPage + 1);
    };
    PaginationComp.prototype.formatNumber = function (value) {
        var userFunc = this.gridOptionsWrapper.getPaginationNumberFormatterFunc();
        if (userFunc) {
            return userFunc({ value: value });
        }
        else {
            return utils_1._.formatNumberCommas(value);
        }
    };
    PaginationComp.prototype.getTemplate = function () {
        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
        var strPage = localeTextFunc('page', 'Page');
        var strTo = localeTextFunc('to', 'to');
        var strOf = localeTextFunc('of', 'of');
        var strFirst = localeTextFunc('first', 'First');
        var strPrevious = localeTextFunc('previous', 'Previous');
        var strNext = localeTextFunc('next', 'Next');
        var strLast = localeTextFunc('last', 'Last');
        return "<div class=\"ag-paging-panel ag-font-style\">\n                <span ref=\"eSummaryPanel\" class=\"ag-paging-row-summary-panel\">\n                    <span ref=\"lbFirstRowOnPage\"></span> " + strTo + " <span ref=\"lbLastRowOnPage\"></span> " + strOf + " <span ref=\"lbRecordCount\"></span>\n                </span>\n                <span class=\"ag-paging-page-summary-panel\">\n                    <button class=\"ag-paging-button\" ref=\"btFirst\">" + strFirst + "</button>\n                    <button class=\"ag-paging-button\" ref=\"btPrevious\">" + strPrevious + "</button>\n                    " + strPage + " <span ref=\"lbCurrent\"></span> " + strOf + " <span ref=\"lbTotal\"></span>\n                    <button class=\"ag-paging-button\" ref=\"btNext\">" + strNext + "</button>\n                    <button class=\"ag-paging-button\" ref=\"btLast\">" + strLast + "</button>\n                </span>\n            </div>";
    };
    PaginationComp.prototype.onBtNext = function () {
        this.paginationProxy.goToNextPage();
    };
    PaginationComp.prototype.onBtPrevious = function () {
        this.paginationProxy.goToPreviousPage();
    };
    PaginationComp.prototype.onBtFirst = function () {
        this.paginationProxy.goToFirstPage();
    };
    PaginationComp.prototype.onBtLast = function () {
        this.paginationProxy.goToLastPage();
    };
    PaginationComp.prototype.enableOrDisableButtons = function () {
        var currentPage = this.paginationProxy.getCurrentPage();
        var maxRowFound = this.paginationProxy.isLastPageFound();
        var totalPages = this.paginationProxy.getTotalPages();
        var disablePreviousAndFirst = currentPage === 0;
        this.btPrevious.disabled = disablePreviousAndFirst;
        this.btFirst.disabled = disablePreviousAndFirst;
        var zeroPagesToDisplay = this.isZeroPagesToDisplay();
        var onLastPage = maxRowFound && currentPage === (totalPages - 1);
        var disableNext = onLastPage || zeroPagesToDisplay;
        this.btNext.disabled = disableNext;
        var disableLast = !maxRowFound || zeroPagesToDisplay || currentPage === (totalPages - 1);
        this.btLast.disabled = disableLast;
    };
    PaginationComp.prototype.updateRowLabels = function () {
        var currentPage = this.paginationProxy.getCurrentPage();
        var pageSize = this.paginationProxy.getPageSize();
        var maxRowFound = this.paginationProxy.isLastPageFound();
        var rowCount = this.paginationProxy.isLastPageFound() ?
            this.paginationProxy.getTotalRowCount() : null;
        var startRow;
        var endRow;
        if (this.isZeroPagesToDisplay()) {
            startRow = 0;
            endRow = 0;
        }
        else {
            startRow = (pageSize * currentPage) + 1;
            endRow = startRow + pageSize - 1;
            if (maxRowFound && endRow > rowCount) {
                endRow = rowCount;
            }
        }
        this.lbFirstRowOnPage.innerHTML = this.formatNumber(startRow);
        this.lbLastRowOnPage.innerHTML = this.formatNumber(endRow);
    };
    PaginationComp.prototype.isZeroPagesToDisplay = function () {
        var maxRowFound = this.paginationProxy.isLastPageFound();
        var totalPages = this.paginationProxy.getTotalPages();
        return maxRowFound && totalPages === 0;
    };
    PaginationComp.prototype.setTotalLabels = function () {
        var lastPageFound = this.paginationProxy.isLastPageFound();
        var totalPages = this.paginationProxy.getTotalPages();
        var rowCount = this.paginationProxy.isLastPageFound() ?
            this.paginationProxy.getTotalRowCount() : null;
        if (lastPageFound) {
            this.lbTotal.innerHTML = this.formatNumber(totalPages);
            this.lbRecordCount.innerHTML = this.formatNumber(rowCount);
        }
        else {
            var moreText = this.gridOptionsWrapper.getLocaleTextFunc()('more', 'more');
            this.lbTotal.innerHTML = moreText;
            this.lbRecordCount.innerHTML = moreText;
        }
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], PaginationComp.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], PaginationComp.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('paginationProxy'),
        __metadata("design:type", paginationProxy_1.PaginationProxy)
    ], PaginationComp.prototype, "paginationProxy", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'),
        __metadata("design:type", rowRenderer_1.RowRenderer)
    ], PaginationComp.prototype, "rowRenderer", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('btFirst'),
        __metadata("design:type", HTMLButtonElement)
    ], PaginationComp.prototype, "btFirst", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('btPrevious'),
        __metadata("design:type", HTMLButtonElement)
    ], PaginationComp.prototype, "btPrevious", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('btNext'),
        __metadata("design:type", HTMLButtonElement)
    ], PaginationComp.prototype, "btNext", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('btLast'),
        __metadata("design:type", HTMLButtonElement)
    ], PaginationComp.prototype, "btLast", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('lbRecordCount'),
        __metadata("design:type", Object)
    ], PaginationComp.prototype, "lbRecordCount", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('lbFirstRowOnPage'),
        __metadata("design:type", Object)
    ], PaginationComp.prototype, "lbFirstRowOnPage", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('lbLastRowOnPage'),
        __metadata("design:type", Object)
    ], PaginationComp.prototype, "lbLastRowOnPage", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('eSummaryPanel'),
        __metadata("design:type", Object)
    ], PaginationComp.prototype, "eSummaryPanel", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('lbCurrent'),
        __metadata("design:type", Object)
    ], PaginationComp.prototype, "lbCurrent", void 0);
    __decorate([
        componentAnnotations_1.RefSelector('lbTotal'),
        __metadata("design:type", Object)
    ], PaginationComp.prototype, "lbTotal", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], PaginationComp.prototype, "postConstruct", null);
    return PaginationComp;
}(component_1.Component));
exports.PaginationComp = PaginationComp;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var rowNode_1 = __webpack_require__(15);
var inMemoryNodeManager_1 = __webpack_require__(89);
var gridOptionsWrapper_1 = __webpack_require__(2);
var eventService_1 = __webpack_require__(4);
var context_1 = __webpack_require__(0);
var columnController_1 = __webpack_require__(3);
var RowNodeFactory = (function () {
    function RowNodeFactory() {
    }
    RowNodeFactory.prototype.create = function (data) {
        var rootNode = new rowNode_1.RowNode();
        var nodeManager = new inMemoryNodeManager_1.InMemoryNodeManager(rootNode, this.gridOptionsWrapper, this.context, this.eventService, this.columnController);
        this.context.wireBean(rootNode);
        nodeManager.setRowData(data);
        return rootNode;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], RowNodeFactory.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], RowNodeFactory.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('context'),
        __metadata("design:type", context_1.Context)
    ], RowNodeFactory.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnController'),
        __metadata("design:type", columnController_1.ColumnController)
    ], RowNodeFactory.prototype, "columnController", void 0);
    RowNodeFactory = __decorate([
        context_1.Bean("rowNodeFactory")
    ], RowNodeFactory);
    return RowNodeFactory;
}());
exports.RowNodeFactory = RowNodeFactory;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v14.0.1
 * @link http://www.ag-grid.com/
 * @license MIT
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var context_1 = __webpack_require__(0);
var gridOptionsWrapper_1 = __webpack_require__(2);
var changedPath_1 = __webpack_require__(88);
var rowRenderer_1 = __webpack_require__(18);
var eventService_1 = __webpack_require__(4);
var constants_1 = __webpack_require__(7);
var beanStub_1 = __webpack_require__(13);
var events_1 = __webpack_require__(5);
var ChangeDetectionService = (function (_super) {
    __extends(ChangeDetectionService, _super);
    function ChangeDetectionService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ChangeDetectionService.prototype.init = function () {
        if (this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_IN_MEMORY) {
            this.inMemoryRowModel = this.rowModel;
        }
        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this));
    };
    ChangeDetectionService.prototype.onCellValueChanged = function (event) {
        this.doChangeDetection(event.node, event.column);
    };
    ChangeDetectionService.prototype.doChangeDetection = function (rowNode, column) {
        if (this.gridOptionsWrapper.isSuppressChangeDetection()) {
            return;
        }
        // step 1 of change detection is to update the aggregated values
        if (this.inMemoryRowModel) {
            var changedPath = void 0;
            if (rowNode.parent) {
                var onlyChangedColumns = this.gridOptionsWrapper.isAggregateOnlyChangedColumns();
                changedPath = new changedPath_1.ChangedPath(onlyChangedColumns);
                changedPath.addParentNode(rowNode.parent, [column]);
            }
            this.inMemoryRowModel.doAggregate(changedPath);
        }
        // step 2 of change detection is to refresh the cells
        this.rowRenderer.refreshCells();
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'),
        __metadata("design:type", gridOptionsWrapper_1.GridOptionsWrapper)
    ], ChangeDetectionService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('rowModel'),
        __metadata("design:type", Object)
    ], ChangeDetectionService.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'),
        __metadata("design:type", rowRenderer_1.RowRenderer)
    ], ChangeDetectionService.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('eventService'),
        __metadata("design:type", eventService_1.EventService)
    ], ChangeDetectionService.prototype, "eventService", void 0);
    __decorate([
        context_1.PostConstruct,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ChangeDetectionService.prototype, "init", null);
    ChangeDetectionService = __decorate([
        context_1.Bean('changeDetectionService')
    ], ChangeDetectionService);
    return ChangeDetectionService;
}(beanStub_1.BeanStub));
exports.ChangeDetectionService = ChangeDetectionService;


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_redux__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_redux___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_redux__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_dom_server__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_dom_server___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react_dom_server__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_react_router_redux__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_react_router_redux___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_react_router_redux__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_history__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_aspnet_prerendering__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_aspnet_prerendering___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_aspnet_prerendering__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__configureStore__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__configureStore___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__configureStore__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__containers_clientCommissionListContainer_clientCommissionListContainer__ = __webpack_require__(122);








/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_aspnet_prerendering__["createServerRenderer"])(function (params) {
    return new Promise(function (resolve, reject) {
        // Prepare Redux store with in-memory history, and dispatch a navigation event
        // corresponding to the incoming URL
        var basename = params.baseUrl.substring(0, params.baseUrl.length - 1); // Remove trailing slash
        var urlAfterBasename = params.url.substring(basename.length);
        var store = __WEBPACK_IMPORTED_MODULE_6__configureStore___default()(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_history__["createMemoryHistory"])());
        store.dispatch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_react_router_redux__["replace"])(urlAfterBasename));
        // Prepare an instance of the application and perform an inital render that will
        // cause any async tasks (e.g., data access) to begin
        var routerContext = {};
        var app = (__WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_1_react_redux__["Provider"], { store: store },
            __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_7__containers_clientCommissionListContainer_clientCommissionListContainer__["a" /* default */], null)));
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_react_dom_server__["renderToString"])(app);
        // If there's a redirection, just send this information back to the host application
        if (routerContext.url) {
            resolve({ redirectUrl: routerContext.url });
            return;
        }
        // Once any async tasks are done, we can perform the final render
        // We also send the redux store state, so the client can continue execution where the server left off
        params.domainTasks.then(function () {
            resolve({
                html: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_react_dom_server__["renderToString"])(app),
                globals: { initialReduxState: store.getState() }
            });
        }, reject); // Also propagate any errors back into the host application
    });
}));


/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ag_grid_dist_styles_ag_grid_css__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ag_grid_dist_styles_ag_grid_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_ag_grid_dist_styles_ag_grid_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ag_grid_dist_styles_theme_fresh_css__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ag_grid_dist_styles_theme_fresh_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_ag_grid_dist_styles_theme_fresh_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ag_grid_react__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ag_grid_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_ag_grid_react__);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var ClientListComponent = /** @class */ (function (_super) {
    __extends(ClientListComponent, _super);
    function ClientListComponent(props) {
        var _this = _super.call(this, props) || this;
        //this.props.reactContainer.style.display = "inline-block";
        // change the background color of the containing div to be red
        //this.props.reactContainer.style.backgroundColor = "red";
        _this.onGridReady = _this.onGridReady.bind(_this);
        //        this.exportDataAsExcel= this.exportDataAsExcel.bind(this);
        //this.getRowNodeId = this.getRowNodeId.bind(this);
        _this.state = {
            columnDefs: _this.createColumnDefs(),
            rowData: _this.createRowData()
        };
        return _this;
    }
    ClientListComponent.prototype.createColumnDefs = function () {
        return [
            { headerName: "Name", field: "make" },
            { headerName: "Client Id", field: "model" },
            { headerName: "Client Assets", field: "price" },
            { headerName: "Age", field: "make" },
            { headerName: "Birth Month", field: "model" },
            { headerName: "Gender", field: "price" },
            { headerName: "Client Acquisition Date", field: "make" },
            { headerName: "Advisory Service (GPS M/A)", field: "model" },
            { headerName: "Client Review Month", field: "model" },
            { headerName: "Last Client Review Date", field: "price" }
        ];
    };
    ClientListComponent.prototype.createRowData = function () {
        return [
            { make: "Toyota", model: "Celica", price: 35000 },
            { make: "Ford", model: "Mondeo", price: 32000 },
            { make: "Porsche", model: "Boxter", price: 72000 },
            { make: "Toyota", model: "Celica", price: 35000 },
            { make: "Ford", model: "Mondeo", price: 32000 },
            { make: "Porsche", model: "Boxter", price: 72000 },
            { make: "Toyota", model: "Celica", price: 35000 },
            { make: "Ford", model: "Mondeo", price: 32000 },
            { make: "Porsche", model: "Boxter", price: 72000 }
        ];
    };
    ClientListComponent.prototype.onGridReady = function (params) {
        //this.api = params.api;
        //this.columnApi = params.columnApi;
        this.gridApi = params.api;
        this.columnApi = params.columnApi;
        this.gridApi.sizeColumnsToFit();
        this.gridApi.exportDataAsExcel();
    };
    ClientListComponent.prototype.getRowNodeId = function (data) {
        return data.symbol;
    };
    ClientListComponent.prototype.render = function () {
        //return (<div className="ag-fresh">
        //    <AgGridReact
        //        columnDefs={this.props.columnDefs}
        //    rowData={this.props.rowData} rowSelection="multiple"
        //    enableSorting=true
        //    enableFilter=true
        //    rowHeight="22"
        //    enableImmutableMode="true"
        //    getRowNodeId={this.getRowNodeId} 
        //    onGridReady={this.onGridReady} /> </div>);
        var containerStyle = {
            height: 500,
            width: 800
        };
        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", { style: containerStyle, className: "ag-fresh" },
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("h1", null, "Client List:"),
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_ag_grid_react__["AgGridReact"], { columnDefs: this.state.columnDefs, rowData: this.state.rowData, enableFilter: true, enableSorting: true, rowSelection: "Multiple", enableColResize: true, animateRows: true, enableRangeSelection: true, pagination: true, paginationPageSize: 5, onGridReady: this.onGridReady })));
    };
    return ClientListComponent;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (ClientListComponent);


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClientCommissionListContainer", function() { return ClientCommissionListContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapDispatchToProps", function() { return mapDispatchToProps; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_redux__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_redux___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react_redux__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ClientCommissionListContainer_css__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ClientCommissionListContainer_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__ClientCommissionListContainer_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ClientListContainer__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ClientListContainer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__ClientListContainer__);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var ClientCommissionListContainer = /** @class */ (function (_super) {
    __extends(ClientCommissionListContainer, _super);
    function ClientCommissionListContainer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ClientCommissionListContainer.prototype.componentDidMount = function () {
        this.props.componentDidMount();
    };
    ClientCommissionListContainer.prototype.render = function () {
        return (__WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement("div", null,
            __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__ClientListContainer__["ClientListContainer"], null)));
    };
    return ClientCommissionListContainer;
}(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]));

var mapStateToProps = function (state) { return ({
    isLoading: state.isLoading
}); };
var mapDispatchToProps = function (dispatch) { return ({
    componentDidMount: function () {
    }
}); };
/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react_redux__["connect"])(mapStateToProps, mapDispatchToProps)(ClientCommissionListContainer));


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function(f) {
  if (true) {
    module.exports = f(__webpack_require__(26));
    /* global define */
  } else if (typeof define === 'function' && define.amd) {
    define(['react'], f);
  } else {
    var g;
    if (typeof window !== 'undefined') {
      g = window;
    } else if (typeof global !== 'undefined') {
      g = global;
    } else if (typeof self !== 'undefined') {
      g = self;
    } else {
      g = this;
    }

    if (typeof g.React === 'undefined') {
      throw Error('React module should be required before ReactDOMFactories');
    }

    g.ReactDOMFactories = f(g.React);
  }
})(function(React) {
  /**
   * Create a factory that creates HTML tag elements.
   */
  function createDOMFactory(type) {
    var factory = React.createElement.bind(null, type);
    // Expose the type on the factory and the prototype so that it can be
    // easily accessed on elements. E.g. `<Foo />.type === Foo`.
    // This should not be named `constructor` since this may not be the function
    // that created the element, and it may not even be a constructor.
    factory.type = type;
    return factory;
  };

  /**
   * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
   */
  var ReactDOMFactories = {
    a: createDOMFactory('a'),
    abbr: createDOMFactory('abbr'),
    address: createDOMFactory('address'),
    area: createDOMFactory('area'),
    article: createDOMFactory('article'),
    aside: createDOMFactory('aside'),
    audio: createDOMFactory('audio'),
    b: createDOMFactory('b'),
    base: createDOMFactory('base'),
    bdi: createDOMFactory('bdi'),
    bdo: createDOMFactory('bdo'),
    big: createDOMFactory('big'),
    blockquote: createDOMFactory('blockquote'),
    body: createDOMFactory('body'),
    br: createDOMFactory('br'),
    button: createDOMFactory('button'),
    canvas: createDOMFactory('canvas'),
    caption: createDOMFactory('caption'),
    cite: createDOMFactory('cite'),
    code: createDOMFactory('code'),
    col: createDOMFactory('col'),
    colgroup: createDOMFactory('colgroup'),
    data: createDOMFactory('data'),
    datalist: createDOMFactory('datalist'),
    dd: createDOMFactory('dd'),
    del: createDOMFactory('del'),
    details: createDOMFactory('details'),
    dfn: createDOMFactory('dfn'),
    dialog: createDOMFactory('dialog'),
    div: createDOMFactory('div'),
    dl: createDOMFactory('dl'),
    dt: createDOMFactory('dt'),
    em: createDOMFactory('em'),
    embed: createDOMFactory('embed'),
    fieldset: createDOMFactory('fieldset'),
    figcaption: createDOMFactory('figcaption'),
    figure: createDOMFactory('figure'),
    footer: createDOMFactory('footer'),
    form: createDOMFactory('form'),
    h1: createDOMFactory('h1'),
    h2: createDOMFactory('h2'),
    h3: createDOMFactory('h3'),
    h4: createDOMFactory('h4'),
    h5: createDOMFactory('h5'),
    h6: createDOMFactory('h6'),
    head: createDOMFactory('head'),
    header: createDOMFactory('header'),
    hgroup: createDOMFactory('hgroup'),
    hr: createDOMFactory('hr'),
    html: createDOMFactory('html'),
    i: createDOMFactory('i'),
    iframe: createDOMFactory('iframe'),
    img: createDOMFactory('img'),
    input: createDOMFactory('input'),
    ins: createDOMFactory('ins'),
    kbd: createDOMFactory('kbd'),
    keygen: createDOMFactory('keygen'),
    label: createDOMFactory('label'),
    legend: createDOMFactory('legend'),
    li: createDOMFactory('li'),
    link: createDOMFactory('link'),
    main: createDOMFactory('main'),
    map: createDOMFactory('map'),
    mark: createDOMFactory('mark'),
    menu: createDOMFactory('menu'),
    menuitem: createDOMFactory('menuitem'),
    meta: createDOMFactory('meta'),
    meter: createDOMFactory('meter'),
    nav: createDOMFactory('nav'),
    noscript: createDOMFactory('noscript'),
    object: createDOMFactory('object'),
    ol: createDOMFactory('ol'),
    optgroup: createDOMFactory('optgroup'),
    option: createDOMFactory('option'),
    output: createDOMFactory('output'),
    p: createDOMFactory('p'),
    param: createDOMFactory('param'),
    picture: createDOMFactory('picture'),
    pre: createDOMFactory('pre'),
    progress: createDOMFactory('progress'),
    q: createDOMFactory('q'),
    rp: createDOMFactory('rp'),
    rt: createDOMFactory('rt'),
    ruby: createDOMFactory('ruby'),
    s: createDOMFactory('s'),
    samp: createDOMFactory('samp'),
    script: createDOMFactory('script'),
    section: createDOMFactory('section'),
    select: createDOMFactory('select'),
    small: createDOMFactory('small'),
    source: createDOMFactory('source'),
    span: createDOMFactory('span'),
    strong: createDOMFactory('strong'),
    style: createDOMFactory('style'),
    sub: createDOMFactory('sub'),
    summary: createDOMFactory('summary'),
    sup: createDOMFactory('sup'),
    table: createDOMFactory('table'),
    tbody: createDOMFactory('tbody'),
    td: createDOMFactory('td'),
    textarea: createDOMFactory('textarea'),
    tfoot: createDOMFactory('tfoot'),
    th: createDOMFactory('th'),
    thead: createDOMFactory('thead'),
    time: createDOMFactory('time'),
    title: createDOMFactory('title'),
    tr: createDOMFactory('tr'),
    track: createDOMFactory('track'),
    u: createDOMFactory('u'),
    ul: createDOMFactory('ul'),
    var: createDOMFactory('var'),
    video: createDOMFactory('video'),
    wbr: createDOMFactory('wbr'),

    // SVG
    circle: createDOMFactory('circle'),
    clipPath: createDOMFactory('clipPath'),
    defs: createDOMFactory('defs'),
    ellipse: createDOMFactory('ellipse'),
    g: createDOMFactory('g'),
    image: createDOMFactory('image'),
    line: createDOMFactory('line'),
    linearGradient: createDOMFactory('linearGradient'),
    mask: createDOMFactory('mask'),
    path: createDOMFactory('path'),
    pattern: createDOMFactory('pattern'),
    polygon: createDOMFactory('polygon'),
    polyline: createDOMFactory('polyline'),
    radialGradient: createDOMFactory('radialGradient'),
    rect: createDOMFactory('rect'),
    stop: createDOMFactory('stop'),
    svg: createDOMFactory('svg'),
    text: createDOMFactory('text'),
    tspan: createDOMFactory('tspan'),
  };

  // due to wrapper and conditionals at the top, this will either become
  // `module.exports ReactDOMFactories` if that is available,
  // otherwise it will be defined via `define(['react'], ReactDOMFactories)`
  // if that is available,
  // otherwise it will be defined as global variable.
  return ReactDOMFactories;
});



/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

//import * as WeatherForecasts from './WeatherForecasts';
//import * as Counter from './Counter';
Object.defineProperty(exports, "__esModule", { value: true });
var Loader = __webpack_require__(159);
// Whenever an action is dispatched, Redux will update each top-level application state property using
// the reducer with the matching name. It's important that the names match exactly, and that the reducer
// acts on the corresponding ApplicationState property type.
exports.reducers = {
    isLoading: Loader.reducer
};


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.actionCreators = {
    loaderBegin: function () { return ({ type: 'LOADER_BEGIN' }); },
    loaderEnd: function () { return ({ type: 'LOADER_END' }); }
};
exports.reducer = function (state, action) {
    switch (action.type) {
        case 'LOADER_BEGIN':
            return true;
        case 'LOADER_END':
            return false;
        default:
            // The following line guarantees that every action in the KnownAction union has been covered by a case above
            var exhaustiveCheck = action;
    }
    // For unrecognized actions (or in cases where actions have no effect), must return the existing state
    //  (or default initial state if none was supplied)
    return state === undefined ? false : state;
};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(142);

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(143);

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(148);

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(153);

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(7);

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(14))(75);

/***/ })
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNzk3OThhZDczNWMzODQzMDRmZjciLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbnRleHQvY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2dyaWRPcHRpb25zV3JhcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9ldmVudFNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZ3JpZEFwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi93aWRnZXRzL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZW50aXRpZXMvY29sdW1uLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9ncmlkUGFuZWwvZ3JpZFBhbmVsLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3dpZGdldHMvY29tcG9uZW50QW5ub3RhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbnRleHQvYmVhblN0dWIuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiLi92ZW5kb3JcIiIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZW50aXRpZXMvcm93Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZmlsdGVyL2ZpbHRlck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3NlbGVjdGlvbkNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9yb3dSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvdmFsdWVTZXJ2aWNlL2V4cHJlc3Npb25TZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi92YWx1ZVNlcnZpY2UvdmFsdWVTZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9kcmFnQW5kRHJvcC9kcmFnQW5kRHJvcFNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbXBvbmVudHMvZnJhbWV3b3JrL2NvbXBvbmVudFJlc29sdmVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9lbnRpdGllcy9ncmlkQ2VsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZm9jdXNlZENlbGxDb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9zb3J0Q29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UmVjaXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZW50aXRpZXMvY29sdW1uR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9wYWdpbmF0aW9uUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9waW5uZWRSb3dNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9jb2x1bW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZW50aXRpZXMvb3JpZ2luYWxDb2x1bW5Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZ3JpZENvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2dyaWRQYW5lbC9zY3JvbGxWaXNpYmxlU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2JlYW5zLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi92YWx1ZVNlcnZpY2UvdmFsdWVDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvd2lkZ2V0cy9wb3B1cFNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2dyaWRQYW5lbC9tb3VzZUV2ZW50U2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2hvcml6b250YWxEcmFnU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvbWlzYy9hbmltYXRpb25GcmFtZVNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsQ29tcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2ZlYXR1cmVzL3NldExlZnRGZWF0dXJlLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvdmFsdWVGb3JtYXR0ZXJTZXJ2aWNlLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvYWxpZ25lZEdyaWRzU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9iYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9jb2x1bW5Db250cm9sbGVyL2Rpc3BsYXllZEdyb3VwQ3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY29tcG9uZW50cy9mcmFtZXdvcmsvYWdDb21wb25lbnRVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY3N2Q3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZHJhZ0FuZERyb3AvZHJhZ1NlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2Vudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9maWx0ZXIvYmFzZUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2Nzc0NsYXNzQXBwbGllci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2hlYWRlclJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbEVkaXRvckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsUmVuZGVyZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbFJlbmRlcmVyU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL3Jvd0NvbXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9jYWNoZS9yb3dOb2RlQmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3RlbXBsYXRlU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvd2lkZ2V0cy9hZ0NoZWNrYm94LmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi93aWRnZXRzL3RvdWNoTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2NlbGxOYXZpZ2F0aW9uU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9ncm91cEluc3RhbmNlSWRDcmVhdG9yLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9jb21wb25lbnRzL2NvbXBvbmVudFV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbXBvbmVudHMvZnJhbWV3b3JrL2NvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbXBvbmVudHMvZnJhbWV3b3JrL2NvbXBvbmVudFByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9kb3dubG9hZGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9lbnRpdGllcy9ncmlkUm93LmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9maWx0ZXIvZGF0ZUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZ3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZ3JpZFNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9kZXByZWNhdGVkL2hlYWRlclRlbXBsYXRlTG9hZGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvZGVwcmVjYXRlZC9yZW5kZXJlZEhlYWRlckNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2xheW91dC9ib3JkZXJMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9hdXRvV2lkdGhDYWxjdWxhdG9yLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbEVkaXRvcnMvcG9wdXBFZGl0b3JXcmFwcGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbEVkaXRvcnMvc2VsZWN0Q2VsbEVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxFZGl0b3JzL3RleHRDZWxsRWRpdG9yLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbFJlbmRlcmVycy9hbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxSZW5kZXJlcnMvYW5pbWF0ZVNsaWRlQ2VsbFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbFJlbmRlcmVycy9ncm91cENlbGxSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY29sdW1uQW5pbWF0aW9uU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NvbHVtbkhvdmVyU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2NhY2hlL3Jvd05vZGVDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2luTWVtb3J5L2NoYW5nZWRQYXRoLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dNb2RlbHMvaW5NZW1vcnkvaW5NZW1vcnlOb2RlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvc3R5bGluZy9zdHlsaW5nU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1yZWR1eC9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkLXJlYWN0L2xpYi9hZ0dyaWRSZWFjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvYmFzZUZyYW1ld29ya0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbHVtbkNvbnRyb2xsZXIvYXV0b0dyb3VwQ29sU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9jb2x1bW5LZXlDcmVhdG9yLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9jb21wb25lbnRzL2ZyYW1ld29yay9uYW1lZENvbXBvbmVudFJlc29sdmVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9maWx0ZXIvbnVtYmVyRmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9maWx0ZXIvdGV4dEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZ3JpZFBhbmVsL25hdmlnYXRpb25TZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvYm9keURyb3BQaXZvdFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2JvZHlEcm9wVGFyZ2V0LmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyUm93Q29tcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2hlYWRlci9oZWFkZXJXcmFwcGVyQ29tcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL21vdmVDb2x1bW5Db250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvc3RhbmRhcmRNZW51LmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbEVkaXRvcnMvbGFyZ2VUZXh0Q2VsbEVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxFZGl0b3JzL3BvcHVwU2VsZWN0Q2VsbEVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxFZGl0b3JzL3BvcHVwVGV4dENlbGxFZGl0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9jYWNoZS9yb3dOb2RlQmxvY2tMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9pbk1lbW9yeS9maWx0ZXJTdGFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2luTWVtb3J5L2ZsYXR0ZW5TdGFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2luTWVtb3J5L2ltbXV0YWJsZVNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9pbk1lbW9yeS9pbk1lbW9yeVJvd01vZGVsLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dNb2RlbHMvaW5NZW1vcnkvc29ydFN0YWdlLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dNb2RlbHMvaW5maW5pdGUvaW5maW5pdGVSb3dNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93Tm9kZXMvZmlsdGVyU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93Tm9kZXMvc29ydFNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3htbEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRhaW5lcnMvY2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXIvQ2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXIuY3NzIiwid2VicGFjazovLy8uL3NyYy9jb250YWluZXJzL2NsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyL0NsaWVudExpc3RDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRhaW5lcnMvY2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXIvY2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXIudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb25maWd1cmVTdG9yZS5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2FzcG5ldC1wcmVyZW5kZXJpbmcvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQtcmVhY3QvbGliL2FnUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkLXJlYWN0L2xpYi9yZWFjdEZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkLXJlYWN0L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbXBvbmVudHMvYWdHcmlkTmcxLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9jb21wb25lbnRzL2FnR3JpZFdlYkNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvY29tcG9uZW50cy9jb2xEZWZVdGlsLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9jb21wb25lbnRzL2ZyYW1ld29yay9mcmFtZXdvcmtDb21wb25lbnRXcmFwcGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9lbnRpdGllcy9kZWZhdWx0Q29sdW1uVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2V2ZW50S2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvZmlsdGVyL2Zsb2F0aW5nRmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9maWx0ZXIvZmxvYXRpbmdGaWx0ZXJXcmFwcGVyLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9oZWFkZXJHcm91cC9oZWFkZXJHcm91cENvbXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9oZWFkZXJHcm91cC9oZWFkZXJHcm91cFdyYXBwZXJDb21wLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyL2hlYWRlckNvbXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9oZWFkZXIvc2VsZWN0QWxsRmVhdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvbGF5b3V0L3RhYmJlZExheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvbGF5b3V0L3ZlcnRpY2FsU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL21pc2MvbGlua2VkTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvbWlzYy9zaW1wbGVIdHRwUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcHJvcGVydHlLZXlzLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvcm93Q29udGFpbmVyQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dNb2RlbHMvaW5maW5pdGUvaW5maW5pdGVCbG9jay5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2luZmluaXRlL2luZmluaXRlQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9wYWdpbmF0aW9uL3BhZ2luYXRpb25Db21wLmpzIiwid2VicGFjazovLy8uL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dOb2Rlcy9yb3dOb2RlRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FnLWdyaWQvZGlzdC9saWIvdmFsdWVTZXJ2aWNlL2NoYW5nZURldGVjdGlvblNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Jvb3Qtc2VydmVyLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DbGllbnRMaXN0Q29tcG9uZW50L0NsaWVudExpc3RDb21wb25lbnQudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb250YWluZXJzL2NsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyL0NsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyLnRzeCIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS1mYWN0b3JpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0b3JlL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zdG9yZS9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9hZy1ncmlkL2Rpc3Qvc3R5bGVzL2FnLWdyaWQuY3NzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2FnLWdyaWQvZGlzdC9zdHlsZXMvdGhlbWUtZnJlc2guY3NzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLCtCQUErQixFQUFFO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwwQ0FBMEMsRUFBRTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUNBQWlDLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJJQUEySSwyQkFBMkIsRUFBRTtBQUN4SztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLDJCQUEyQixFQUFFO0FBQ2xJO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsMkJBQTJCLEVBQUU7QUFDaEk7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsOEJBQThCLEVBQUU7QUFDekY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBCQUEwQixFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4QkFBOEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMENBQTBDLEVBQUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYyxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlDQUF5Qyx5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxFQUFFO0FBQ2hGO0FBQ0EsMkRBQTJELHlCQUF5QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlDQUFpQyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwyQkFBMkIsRUFBRTtBQUNuRjtBQUNBLDZCQUE2Qiw0QkFBNEIsOEJBQThCLFdBQVc7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwQkFBMEIsRUFBRTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWUsRUFBRTtBQUNoRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsZ0JBQWdCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUdBQXVHLEVBQUU7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUhBQWlILGdCQUFnQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRCw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzRUFBc0U7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QixFQUFFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHNCQUFzQixFQUFFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDMThDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3QkFBd0I7QUFDckYsK0RBQStELG1HQUFtRztBQUNsSyxpRUFBaUUsZ0RBQWdEO0FBQ2pILG9FQUFvRSxxREFBcUQ7QUFDekgsMkRBQTJELGlDQUFpQztBQUM1Riw0REFBNEQsMkNBQTJDO0FBQ3ZHLDhEQUE4RCw2Q0FBNkM7QUFDM0csbUVBQW1FLHdGQUF3RjtBQUMzSixtRUFBbUUsd0ZBQXdGO0FBQzNKLHFFQUFxRSwwRkFBMEY7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnREFBZ0Q7QUFDOUcsNEVBQTRFLDJEQUEyRDtBQUN2SSxnRUFBZ0UsK0NBQStDO0FBQy9HLDBFQUEwRSx5REFBeUQ7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQ0FBK0M7QUFDL0csK0RBQStELHNEQUFzRDtBQUNySCx3RUFBd0UsdURBQXVEO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNEQUFzRDtBQUM3SCx1RUFBdUUsc0RBQXNEO0FBQzdIO0FBQ0EsdUVBQXVFLHVHQUF1RztBQUM5Syw0RUFBNEUsMkRBQTJEO0FBQ3ZJLGtGQUFrRixpRUFBaUU7QUFDbkoscUVBQXFFLG9EQUFvRDtBQUN6SCwyRUFBMkUsMERBQTBEO0FBQ3JJLDRFQUE0RSwyREFBMkQ7QUFDdkksd0VBQXdFLHVEQUF1RDtBQUMvSCxvRUFBb0UsbURBQW1EO0FBQ3ZILDBFQUEwRSx5REFBeUQ7QUFDbkksZ0ZBQWdGLCtEQUErRDtBQUMvSSwwRUFBMEUseURBQXlEO0FBQ25JLDJEQUEyRCxrREFBa0Q7QUFDN0csNkRBQTZELG9EQUFvRDtBQUNqSCwyRUFBMkUsMERBQTBEO0FBQ3JJLHlFQUF5RSx3REFBd0Q7QUFDakksd0VBQXdFLHVEQUF1RDtBQUMvSCwyRUFBMkUsMERBQTBEO0FBQ3JJLG9FQUFvRSwwQ0FBMEM7QUFDOUcsdUVBQXVFLDZDQUE2QztBQUNwSCxtRUFBbUUsa0RBQWtEO0FBQ3JILGtFQUFrRSxpREFBaUQ7QUFDbkgsMEVBQTBFLHlEQUF5RDtBQUNuSSx5RUFBeUUsd0RBQXdEO0FBQ2pJLG1FQUFtRSx5Q0FBeUM7QUFDNUcsbUVBQW1FLGtEQUFrRDtBQUNySCw2REFBNkQsNENBQTRDO0FBQ3pHLG1FQUFtRSxrREFBa0Q7QUFDckgsNERBQTRELGtDQUFrQztBQUM5Riw0REFBNEQsa0NBQWtDO0FBQzlGLGdFQUFnRSxxQ0FBcUM7QUFDckcsZ0VBQWdFLHFDQUFxQztBQUNyRyw4REFBOEQsdUNBQXVDO0FBQ3JHLHdFQUF3RSwwQ0FBMEM7QUFDbEgsc0VBQXNFLHdDQUF3QztBQUM5RyxpRkFBaUYsbURBQW1EO0FBQ3BJLGtFQUFrRSx1Q0FBdUM7QUFDekcsdUVBQXVFLHlDQUF5QztBQUNoSCwrRUFBK0UscURBQXFEO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLCtDQUErQztBQUN6SCxzRUFBc0UsNENBQTRDO0FBQ2xILHVEQUF1RCw2QkFBNkI7QUFDcEYsNkRBQTZELG1DQUFtQztBQUNoRyxtRUFBbUUsa0RBQWtEO0FBQ3JILGlFQUFpRSxnREFBZ0Q7QUFDakgsa0VBQWtFLGlEQUFpRDtBQUNuSCxrRUFBa0UsaURBQWlEO0FBQ25ILG9FQUFvRSxtREFBbUQ7QUFDdkgsZ0ZBQWdGLCtEQUErRDtBQUMvSSx3RUFBd0UsOENBQThDO0FBQ3RILG1GQUFtRix5REFBeUQ7QUFDNUksb0VBQW9FLDBDQUEwQztBQUM5RyxxRUFBcUUsMkNBQTJDO0FBQ2hILHNFQUFzRSw0Q0FBNEM7QUFDbEgsa0VBQWtFLHdDQUF3QztBQUMxRywyRUFBMkUsaURBQWlEO0FBQzVILHNFQUFzRSxxREFBcUQ7QUFDM0gsMEVBQTBFLHlEQUF5RDtBQUNuSSwyREFBMkQsaUNBQWlDO0FBQzVGLG9FQUFvRSxtREFBbUQ7QUFDdkgsNERBQTRELDJDQUEyQztBQUN2RyxzRUFBc0UsNENBQTRDO0FBQ2xILG1FQUFtRSxrREFBa0Q7QUFDckgscUVBQXFFLDJDQUEyQztBQUNoSCxrRUFBa0Usd0NBQXdDO0FBQzFHLHFFQUFxRSxvREFBb0Q7QUFDekgsd0VBQXdFLHVEQUF1RDtBQUMvSCx3RUFBd0UsdURBQXVEO0FBQy9ILHdEQUF3RCx1Q0FBdUM7QUFDL0YsOERBQThELG9DQUFvQztBQUNsRywrREFBK0QscUNBQXFDO0FBQ3BHLDhEQUE4RCxvQ0FBb0M7QUFDbEcsc0VBQXNFLDRDQUE0QztBQUNsSCx3RUFBd0UsOENBQThDO0FBQ3RILGdFQUFnRSxtR0FBbUc7QUFDbkssK0RBQStELDhDQUE4QztBQUM3Ryx3RUFBd0UsdURBQXVEO0FBQy9ILGtFQUFrRSxpREFBaUQ7QUFDbkgsNkVBQTZFLDREQUE0RDtBQUN6SSxxRkFBcUYsb0VBQW9FO0FBQ3pKLCtFQUErRSw4REFBOEQ7QUFDN0ksc0VBQXNFLHFEQUFxRDtBQUMzSCxpRkFBaUYsZ0VBQWdFO0FBQ2pKLDhFQUE4RSw2REFBNkQ7QUFDM0ksK0RBQStELGlHQUFpRztBQUNoSyw2REFBNkQsNENBQTRDO0FBQ3pHO0FBQ0EseUVBQXlFLGdEQUFnRDtBQUN6SCwwRUFBMEUseURBQXlEO0FBQ25JLHlFQUF5RSx3REFBd0Q7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLDBFQUEwRSx5REFBeUQ7QUFDbkkseUVBQXlFLHdEQUF3RDtBQUNqSSx1RUFBdUUsc0RBQXNEO0FBQzdILHlFQUF5RSx3REFBd0Q7QUFDakksZ0ZBQWdGLCtEQUErRDtBQUMvSSx5REFBeUQsK0JBQStCO0FBQ3hGLDREQUE0RCxrQ0FBa0M7QUFDOUYsZ0VBQWdFLHNDQUFzQztBQUN0RyxnRUFBZ0Usc0NBQXNDO0FBQ3RHLDBFQUEwRSxnREFBZ0Q7QUFDMUgsMEVBQTBFLGdEQUFnRDtBQUMxSCx5RUFBeUUsK0NBQStDO0FBQ3hILG1FQUFtRSxrREFBa0Q7QUFDckgsNEVBQTRFLDJEQUEyRDtBQUN2SSxrRUFBa0UsaURBQWlEO0FBQ25ILHNFQUFzRSxxREFBcUQ7QUFDM0gsb0VBQW9FLG1EQUFtRDtBQUN2SCxpRUFBaUUsd0NBQXdDO0FBQ3pHLDJDQUEyQyxhQUFhO0FBQ3hELGlFQUFpRSx1Q0FBdUM7QUFDeEcsc0VBQXNFLDRDQUE0QztBQUNsSCx1RUFBdUUsNkNBQTZDO0FBQ3BILG9FQUFvRSxtREFBbUQ7QUFDdkgsc0VBQXNFLHFEQUFxRDtBQUMzSCxzRUFBc0UsNENBQTRDO0FBQ2xILDBFQUEwRSwrQ0FBK0M7QUFDekgsd0VBQXdFLDZDQUE2QztBQUNySCxnRUFBZ0UscUNBQXFDO0FBQ3JHLDhEQUE4RDtBQUM5RCx3RUFBd0UsMENBQTBDO0FBQ2xILHdFQUF3RSw2Q0FBNkM7QUFDckgscUVBQXFFLDBDQUEwQztBQUMvRyxpRUFBaUUsc0NBQXNDO0FBQ3ZHLDBFQUEwRSw0Q0FBNEM7QUFDdEgscUVBQXFFLHVDQUF1QztBQUM1RywyREFBMkQsMENBQTBDO0FBQ3JHLDZEQUE2RCw0Q0FBNEM7QUFDekcseUVBQXlFLHdEQUF3RDtBQUNqSSw4RUFBOEUsNkRBQTZEO0FBQzNJLDhFQUE4RSxnREFBZ0Q7QUFDOUgsbUZBQW1GLHFEQUFxRDtBQUN4SSx1RUFBdUUseUNBQXlDO0FBQ2hILDRFQUE0RSw4Q0FBOEM7QUFDMUgsK0VBQStFLGlEQUFpRDtBQUNoSSxnRkFBZ0Ysa0RBQWtEO0FBQ2xJLDRFQUE0RSxzR0FBc0c7QUFDbEwsOEVBQThFLDJHQUEyRztBQUN6TCxtQ0FBbUMsZ0JBQWdCLHFCQUFxQixxQkFBcUIsRUFBRSx1Q0FBdUM7QUFDdEksaUNBQWlDLGdCQUFnQixvQkFBb0IsRUFBRSxxQ0FBcUM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDenJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG9EQUFvRDtBQUNySCwyRUFBMkUsOERBQThEO0FBQ3pJLHNFQUFzRSxnRUFBZ0U7QUFDdEksa0VBQWtFLDREQUE0RDtBQUM5SCwrRUFBK0UseUVBQXlFO0FBQ3hKLHlGQUF5RixtRkFBbUY7QUFDNUssb0RBQW9ELHFEQUFxRDtBQUN6RyxpRUFBaUUsMkRBQTJEO0FBQzVILHNEQUFzRCxnREFBZ0Q7QUFDdEcsd0RBQXdELDJDQUEyQztBQUNuRywyREFBMkQscURBQXFEO0FBQ2hILHFFQUFxRSx3REFBd0Q7QUFDN0gsNkRBQTZELGdEQUFnRDtBQUM3RyxpREFBaUQsMEZBQTBGO0FBQzNJLHFEQUFxRCwrQ0FBK0M7QUFDcEcsc0RBQXNELGdEQUFnRDtBQUN0RywrREFBK0QseURBQXlEO0FBQ3hILGdFQUFnRSwwREFBMEQ7QUFDMUgsb0VBQW9FLHVEQUF1RDtBQUMzSCxzRUFBc0UseURBQXlEO0FBQy9ILGtFQUFrRSxxREFBcUQ7QUFDdkgsb0VBQW9FLHVEQUF1RDtBQUMzSCxxREFBcUQsc0RBQXNEO0FBQzNHLHlEQUF5RCxtREFBbUQ7QUFDNUcsK0RBQStELHlEQUF5RDtBQUN4SCxpRUFBaUUsMkRBQTJEO0FBQzVILGdFQUFnRSwwREFBMEQ7QUFDMUgsOERBQThELHdEQUF3RDtBQUN0SCxxRUFBcUUsK0RBQStEO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLDhEQUE4RDtBQUN6SSw2RUFBNkUsZ0VBQWdFO0FBQzdJLDRFQUE0RSwrREFBK0Q7QUFDM0ksdUVBQXVFLDBEQUEwRDtBQUNqSTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLDZEQUE2RCxnREFBZ0Q7QUFDN0csbURBQW1ELDZDQUE2QztBQUNoRyxxRkFBcUYsK0VBQStFO0FBQ3BLLDhEQUE4RCxpREFBaUQ7QUFDL0csdURBQXVELGlEQUFpRDtBQUN4RywrREFBK0Qsa0RBQWtEO0FBQ2pILGlFQUFpRSxvREFBb0Q7QUFDckgsNERBQTRELCtDQUErQztBQUMzRyw4REFBOEQsaURBQWlEO0FBQy9HLGlFQUFpRSxvREFBb0Q7QUFDckgsa0VBQWtFLHFEQUFxRDtBQUN2SCxvRUFBb0UsdURBQXVEO0FBQzNILCtEQUErRCxrREFBa0Q7QUFDakgsaUVBQWlFLG9EQUFvRDtBQUNySCwwREFBMEQsb0RBQW9EO0FBQzlHLDhEQUE4RCxpREFBaUQ7QUFDL0csK0RBQStELGtEQUFrRDtBQUNqSCxpRUFBaUUsb0RBQW9EO0FBQ3JILDREQUE0RCwrQ0FBK0M7QUFDM0csOERBQThELGlEQUFpRDtBQUMvRyx1REFBdUQsaURBQWlEO0FBQ3hHLG9FQUFvRSw4REFBOEQ7QUFDbEksc0VBQXNFLGdFQUFnRTtBQUN0SSxxRUFBcUUsK0RBQStEO0FBQ3BJLG1FQUFtRSw2REFBNkQ7QUFDaEkseURBQXlELG1EQUFtRDtBQUM1RywyREFBMkQscURBQXFEO0FBQ2hILDBEQUEwRCw2Q0FBNkM7QUFDdkcsa0VBQWtFLHFEQUFxRDtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsdUJBQXVCLEVBQUU7QUFDN0c7QUFDQSxtRkFBbUYsdUJBQXVCLEVBQUU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkNBQTJDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixvQ0FBb0MsRUFBRTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLHFDQUFxQyxFQUFFO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVMsZUFBZSxTQUFTLGFBQWEsT0FBTyxnQkFBZ0IsVUFBVSxXQUFXLG1CQUFtQjtBQUN0SjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQseUJBQXlCLEVBQUU7QUFDckY7QUFDQTtBQUNBLDZEQUE2RCw0QkFBNEIsRUFBRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDBCQUEwQixFQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usd0JBQXdCLEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx3Q0FBd0MsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUNBQXVDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDJCQUEyQixFQUFFO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFDQUFxQyxFQUFFO0FBQzVGO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ25pRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsSUFBSSxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsd0JBQXdCLEVBQUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHdCQUF3QixFQUFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpREFBaUQsbUNBQW1DLEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWUsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZSxpQkFBaUIsZUFBZTtBQUNoSiwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUNBQXVDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRCx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRDQUE0QztBQUM1RTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2Q0FBNkM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLG1CQUFtQixFQUFFO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw2Q0FBNkMsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQSw0QkFBNEIsMERBQTBEO0FBQ3RGO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0EsNERBQTRELHFCQUFxQixFQUFFO0FBQ25GLDRCQUE0QixnRUFBZ0U7QUFDNUY7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQSw0QkFBNEIseURBQXlEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUMvK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx5REFBeUQ7QUFDakgsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlDQUFpQyxFQUFFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0REFBNEQsRUFBRTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0IsR0FBRyxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN6Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxtREFBbUQsRUFBRTtBQUNuRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJDQUEyQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsa0NBQWtDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRix5Q0FBeUM7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLDRDQUE0QztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxpRUFBaUU7QUFDMUksOEVBQThFLDZHQUE2RztBQUMzTCwrRUFBK0UscUZBQXFGO0FBQ3BLLGdGQUFnRix1RkFBdUY7QUFDdkssZ0ZBQWdGLHlDQUF5QztBQUN6SCwwRkFBMEYsMENBQTBDO0FBQ3BJLDJGQUEyRiwyQ0FBMkM7QUFDdEkseUZBQXlGLGdGQUFnRjtBQUN6SyxtRkFBbUYsNENBQTRDO0FBQy9ILDZGQUE2Riw2Q0FBNkM7QUFDMUksOEZBQThGLDhDQUE4QztBQUM1SSwyRkFBMkYsbUZBQW1GO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFEQUFxRDtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvREFBb0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDaGlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxlQUFlLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUNBQW1DLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7O0FDaEZBLHFDOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx5Q0FBeUMsRUFBRTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEUsK0NBQStDLCtCQUErQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDam1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxlQUFlLEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGdDQUFnQyxFQUFFO0FBQ25IO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csZ0NBQWdDLEVBQUU7QUFDbEk7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixlQUFlLEVBQUU7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0RBQWdEO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSUFBK0k7QUFDL0k7QUFDQSxTQUFTLEVBQUUsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzVmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsc0VBQXNFO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQ0FBcUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNENBQTRDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUNBQXlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxvQkFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVDQUF1QyxFQUFFO0FBQ3pGO0FBQ0EsdUZBQXVGLGlDQUFpQyxFQUFFO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLGNBQWMsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZDQUE2Qyw2QkFBNkIsRUFBRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QixFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlEQUF5RDtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9GQUFvRjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0ZBQW9GO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUM1OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RCx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlFQUF5RTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkRBQTZEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2REFBNkQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5Q0FBeUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHVDQUF1QyxFQUFFO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCLEVBQUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdDQUFnQyxFQUFFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVyxvQkFBb0IsWUFBWSxvQkFBb0IsWUFBWSxvQkFBb0IsY0FBYztBQUN2SjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3BYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0VBQXNFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRFQUE0RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseURBQXlELGtCQUFrQixFQUFFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csMkJBQTJCLEVBQUU7QUFDL0g7QUFDQSxpREFBaUQsZ0NBQWdDLEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7QUMxTUEsOEM7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxpRkFBaUYsRUFBRTtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDBCQUEwQixFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpSEFBaUgsRUFBRTtBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHNEQUFzRCxFQUFFO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0REFBNEQsRUFBRTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxlQUFlLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQ0FBc0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQzVHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxzQkFBc0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlDQUF5QyxFQUFFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFDckMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx5REFBeUQsRUFBRTtBQUN2SDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNEJBQTRCLEVBQUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVFQUF1RSxFQUFFO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCxtQ0FBbUMsa0JBQWtCO0FBQ3JELHlDQUF5Qyx5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQkFBMkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUVBQXVFO0FBQ2hILDZDQUE2Qyx5Q0FBeUMsRUFBRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBMEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNqekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7QUMzRUEsZ0Q7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw4QkFBOEIsRUFBRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGdCQUFnQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsbUNBQW1DLEVBQUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsaUJBQWlCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsZ0JBQWdCO0FBQ2pHLCtFQUErRSxnQkFBZ0I7QUFDL0Ysa0ZBQWtGLGdCQUFnQjtBQUNsRztBQUNBLHlGQUF5RixnQkFBZ0I7QUFDekcsdUZBQXVGLGdCQUFnQjtBQUN2RywwRkFBMEYsZ0JBQWdCO0FBQzFHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYyxTQUFTLElBQUk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWUsRUFBRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDbldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDBDQUEwQyxFQUFFO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNEQUFzRCxFQUFFO0FBQ3hIO0FBQ0E7QUFDQSwyREFBMkQsNEJBQTRCLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDRCQUE0QixFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsbUJBQW1CO0FBQ2xHO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYscUJBQXFCO0FBQ3hHO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwREFBMEQsRUFBRTtBQUM3SCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRiw4QkFBOEIsRUFBRTtBQUNySDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YscUNBQXFDLEVBQUU7QUFDdEksNkZBQTZGLG9DQUFvQyxFQUFFO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdGQUFnRixFQUFFO0FBQzdJLDJEQUEyRCxtRkFBbUYsRUFBRTtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrREFBK0QsRUFBRTtBQUM1Ryx5Q0FBeUMsK0RBQStELEVBQUU7QUFDMUcsMENBQTBDLCtEQUErRCxFQUFFO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1Q0FBdUM7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVGQUF1RjtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsb0VBQW9FLEVBQUU7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCxtQ0FBbUMsa0JBQWtCO0FBQ3JELDRDQUE0QywyQkFBMkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw2Q0FBNkMsRUFBRTtBQUMvRyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw4Q0FBOEMsRUFBRTtBQUM1RyxTQUFTO0FBQ1QsNERBQTRELGlEQUFpRCxFQUFFO0FBQy9HLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9CQUFvQixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscURBQXFELEVBQUU7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3RUFBd0UsRUFBRTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUscUNBQXFDLEVBQUU7QUFDakgsMEVBQTBFLHFDQUFxQyxFQUFFO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHNDQUFzQyxFQUFFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGVBQWUsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxlQUFlLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELCtCQUErQixFQUFFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsdUVBQXVFLEVBQUU7QUFDcEksMkRBQTJELDJFQUEyRSxFQUFFO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0NBQWdDLEVBQUU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDaHFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1Q0FBdUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRixtRUFBbUUsZ0JBQWdCO0FBQ25GLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQSwwRUFBMEUsZ0JBQWdCO0FBQzFGLHdFQUF3RSxnQkFBZ0I7QUFDeEYsc0VBQXNFLGdCQUFnQjtBQUN0RixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWUsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELGtEQUFrRDtBQUNsRCwrREFBK0Q7QUFDL0QsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwR0FBMEc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwwQ0FBMEMsRUFBRTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsNENBQTRDLEVBQUU7QUFDM0csU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDs7Ozs7Ozs7QUM3UnJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDhCQUE4QixFQUFFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywrQkFBK0IsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnRUFBZ0UsRUFBRTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0NBQWdDLEVBQUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNsYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ25SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlEQUF5RCxFQUFFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsNkJBQTZCLEVBQUU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQ0FBK0M7QUFDeEY7QUFDQSw2Q0FBNkMseUNBQXlDLEVBQUU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw4REFBOEQ7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMEZBQTBGO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdDQUFnQyxFQUFFO0FBQzlGO0FBQ0EsK0RBQStELGdDQUFnQyxFQUFFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBMEMsZUFBZSxFQUFFLEVBQUUsRUFBRTtBQUMvRixnQ0FBZ0MsMkNBQTJDLGVBQWUsRUFBRSxFQUFFLEVBQUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0NBQWtDLEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkJBQTZCLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQ0FBK0Msa0RBQWtELEVBQUU7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYyxHQUFHO0FBQ2pFLHNFQUFzRSx3QkFBd0IsRUFBRTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBDQUEwQyxFQUFFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsK0RBQStELEVBQUU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFDQUFxQyxFQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHNDQUFzQyxFQUFFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Riw4QkFBOEIsRUFBRTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsNkNBQTZDLEVBQUU7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7O0FDOUVBLGdEOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG9CQUFvQixFQUFFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNERBQTREO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxxREFBcUQsRUFBRTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNFQUFzRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0VBQWdFLG1EQUFtRCxnQ0FBZ0MsRUFBRSxFQUFFLEVBQUU7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDLEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNILDBCQUEwQixFQUFFO0FBQ2xKLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsMEJBQTBCLEVBQUU7QUFDbEo7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDhFQUE4RSxxQkFBcUIsRUFBRTtBQUNyRyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsK0JBQStCLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0VBQWdFLEVBQUU7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHVDQUF1QyxFQUFFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNENBQTRDLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFDQUFxQztBQUNuRixpREFBaUQsb0NBQW9DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2REFBNkQsRUFBRTtBQUN2SDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN6VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsdUVBQXVFO0FBQ3ZFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVDQUF1QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSw4Q0FBOEM7QUFDaEg7QUFDQTtBQUNBO0FBQ0Esa0lBQWtJLHlDQUF5QztBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw4RUFBOEU7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUZBQWlGO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvRkFBb0Y7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5R0FBeUc7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlDQUF5QztBQUN4RTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxpQ0FBaUMsRUFBRTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtREFBbUQ7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDJCQUEyQix1Q0FBdUM7QUFDbEU7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsb0NBQW9DLEVBQUU7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQTtBQUNBLDJCQUEyQixzRkFBc0Y7QUFDakg7QUFDQTtBQUNBLDZDQUE2QyxtQ0FBbUMsRUFBRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzlrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2QkFBNkIsRUFBRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UseUNBQXlDLEVBQUU7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQSw4RUFBOEUsdUJBQXVCLEVBQUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7OztBQ25FQSx5Qzs7Ozs7OztBQ0FBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVcsRUFBRTtBQUNyRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ051QztBQUVFO0FBR0k7QUFHYTtBQUcxRDtJQUFtRCxpREFBbUI7SUFBdEU7O0lBVUEsQ0FBQztJQVRHLHlEQUFpQixHQUFqQjtRQUNJLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUNuQyxDQUFDO0lBQ0QsOENBQU0sR0FBTjtRQUNJLE1BQU0sQ0FBQyxDQUNiO1lBQ1UsNERBQUMseUVBQW1CLE9BQUcsQ0FBTSxDQUNoQyxDQUFDO0lBQ04sQ0FBQztJQUNMLG9DQUFDO0FBQUQsQ0FBQyxDQVZrRCxnREFBUyxHQVUzRDs7QUFDRCxJQUFNLGVBQWUsR0FBRyxVQUFDLEtBQXVCLElBQUssUUFBQztJQUNsRCxTQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVM7Q0FDN0IsQ0FBQyxFQUZtRCxDQUVuRDtBQUNLLElBQU0sa0JBQWtCLEdBQUcsVUFBQyxRQUFRLElBQUssUUFBQztJQUM3QyxpQkFBaUIsRUFBRTtJQUVuQixDQUFDO0NBQ0osQ0FBQyxFQUo4QyxDQUk5QztBQUVGLHlEQUFlLDJFQUFPLENBQUMsZUFBZSxFQUFFLGtCQUFrQixDQUFDLENBQUMsNkJBQTZCLENBQXlDLEVBQUM7Ozs7Ozs7O0FDL0JuSTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQ0FBbUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtNQUErTSxhQUFhLEVBQUU7QUFDOU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQiw4Q0FBOEM7QUFDakg7Ozs7Ozs7QUM1QkEsZ0Q7Ozs7OztBQ0FBLGdEOzs7Ozs7QUNBQSxnRDs7Ozs7OztBQ0FBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFDQUFxQyxFQUFFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOUVBOzs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDRCQUE0QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZ0NBQWdDLEVBQUU7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdDQUFnQyxFQUFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdFQUFnRSxFQUFFO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMERBQTBELEVBQUU7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkRBQTJELDRDQUE0QyxFQUFFO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSwrREFBK0QsZUFBZSxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiwwQkFBMEIsRUFBRTtBQUMvRywwRkFBMEYsMkJBQTJCLEVBQUU7QUFDdkg7QUFDQSxxREFBcUQsd0RBQXdELEVBQUU7QUFDL0c7QUFDQTtBQUNBLGtEQUFrRCx3Q0FBd0MsRUFBRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0NBQWdDLEVBQUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxvQ0FBb0MsRUFBRTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDRCQUE0QixFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4Riw2QkFBNkIsRUFBRTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQzlDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsZUFBZSxFQUFFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNkJBQTZCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELCtCQUErQixFQUFFO0FBQzFGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQseUJBQXlCLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RitCO0FBQ1E7QUFDVztBQUVMO0FBQ0M7QUFDMkI7QUFFM0I7QUFDdUU7QUFFckgsK0RBQWUsZ0dBQW9CLENBQUMsZ0JBQU07SUFDdEMsTUFBTSxDQUFDLElBQUksT0FBTyxDQUFlLFVBQUMsT0FBTyxFQUFFLE1BQU07UUFDN0MsOEVBQThFO1FBQzlFLG9DQUFvQztRQUNwQyxJQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFDakcsSUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDL0QsSUFBTSxLQUFLLEdBQUcsdURBQWMsQ0FBQyxtRkFBbUIsRUFBRSxDQUFDLENBQUM7UUFDcEQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxrRkFBTyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQztRQUUxQyxnRkFBZ0Y7UUFDaEYscURBQXFEO1FBQ3JELElBQU0sYUFBYSxHQUFRLEVBQUUsQ0FBQztRQUM5QixJQUFNLEdBQUcsR0FBRyxDQUNSLHFEQUFDLHFEQUFRLElBQUMsS0FBSyxFQUFHLEtBQUs7WUFDcEIscURBQUMsd0hBQTZCLE9BQUcsQ0FDekIsQ0FDZCxDQUFDO1FBQ0YsdUZBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVwQixvRkFBb0Y7UUFDcEYsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDcEIsT0FBTyxDQUFDLEVBQUUsV0FBVyxFQUFFLGFBQWEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQzVDLE1BQU0sQ0FBQztRQUNYLENBQUM7UUFFRCxpRUFBaUU7UUFDakUscUdBQXFHO1FBQ3JHLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO1lBQ3BCLE9BQU8sQ0FBQztnQkFDSixJQUFJLEVBQUUsdUZBQWMsQ0FBQyxHQUFHLENBQUM7Z0JBQ3pCLE9BQU8sRUFBRSxFQUFFLGlCQUFpQixFQUFFLEtBQUssQ0FBQyxRQUFRLEVBQUUsRUFBRTthQUNuRCxDQUFDLENBQUM7UUFDUCxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQywyREFBMkQ7SUFDM0UsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0N1QjtBQUVlO0FBQ0k7QUFDRDtBQU01QztJQUFpRCx1Q0FBb0M7SUFHakYsNkJBQVksS0FBVTtRQUF0QixZQUNJLGtCQUFNLEtBQUssQ0FBQyxTQVdmO1FBVkcsMkRBQTJEO1FBQzNELDhEQUE4RDtRQUM5RCwwREFBMEQ7UUFDMUQsS0FBSSxDQUFDLFdBQVcsR0FBRyxLQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsQ0FBQztRQUN2RCxvRUFBb0U7UUFDNUQsbURBQW1EO1FBQ25ELEtBQUksQ0FBQyxLQUFLLEdBQUc7WUFDVCxVQUFVLEVBQUUsS0FBSSxDQUFDLGdCQUFnQixFQUFFO1lBQ25DLE9BQU8sRUFBRSxLQUFJLENBQUMsYUFBYSxFQUFFO1NBQ2hDOztJQUNMLENBQUM7SUFDRCw4Q0FBZ0IsR0FBaEI7UUFDSSxNQUFNLENBQUM7WUFDSCxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtZQUNyQyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRTtZQUMzQyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRTtZQUMvQyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtZQUNwQyxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRTtZQUM3QyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRTtZQUN4QyxFQUFFLFVBQVUsRUFBRSx5QkFBeUIsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO1lBQ3hELEVBQUUsVUFBVSxFQUFFLDRCQUE0QixFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUU7WUFDNUQsRUFBRSxVQUFVLEVBQUUscUJBQXFCLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRTtZQUNyRCxFQUFFLFVBQVUsRUFBRSx5QkFBeUIsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFO1NBQzVELENBQUM7SUFDTixDQUFDO0lBRUQsMkNBQWEsR0FBYjtRQUNJLE1BQU0sQ0FBQztZQUNILEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7WUFDakQsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtZQUMvQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO1lBQ2xELEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7WUFDakQsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtZQUMvQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO1lBQ2xELEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7WUFDakQsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtZQUMvQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO1NBRXJELENBQUM7SUFDTixDQUFDO0lBRUQseUNBQVcsR0FBWCxVQUFZLE1BQVc7UUFDbkIsd0JBQXdCO1FBQ3hCLG9DQUFvQztRQUNwQyxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7UUFDMUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO1FBRWxDLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUNoQyxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDckMsQ0FBQztJQUNELDBDQUFZLEdBQVosVUFBYSxJQUFJO1FBQ2IsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDdkIsQ0FBQztJQUNELG9DQUFNLEdBQU47UUFDSSxvQ0FBb0M7UUFDcEMsa0JBQWtCO1FBQ2xCLDRDQUE0QztRQUM1QywwREFBMEQ7UUFDMUQsd0JBQXdCO1FBQ3hCLHVCQUF1QjtRQUN2QixvQkFBb0I7UUFDcEIsZ0NBQWdDO1FBQ2hDLHVDQUF1QztRQUN2QyxnREFBZ0Q7UUFDaEQsSUFBSSxjQUFjLEdBQUc7WUFDakIsTUFBTSxFQUFFLEdBQUc7WUFDWCxLQUFLLEVBQUUsR0FBRztTQUNiLENBQUM7UUFFRixNQUFNLENBQUMsQ0FDSCxxRUFBSyxLQUFLLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBQyxVQUFVO1lBQzVDLHVGQUFxQjtZQUNyQiw0REFBQywwREFBVyxJQUNSLFVBQVUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFDakMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUMvQyxZQUFZLEVBQUUsSUFBSSxFQUNsQixhQUFhLEVBQUUsSUFBSSxFQUNuQixZQUFZLEVBQUUsVUFBVSxFQUN4QixlQUFlLEVBQUksSUFBSSxFQUN2QixXQUFXLEVBQUUsSUFBSSxFQUNqQixvQkFBb0IsRUFBRSxJQUFJLEVBQzFCLFVBQVUsRUFBRyxJQUFJLEVBQ2pCLGtCQUFrQixFQUFHLENBQUMsRUFFRixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVcsR0FDbkIsQ0FDWixDQUNUO0lBQ0wsQ0FBQztJQUNMLDBCQUFDO0FBQUQsQ0FBQyxDQTlGZ0QsNkNBQUssQ0FBQyxTQUFTLEdBOEYvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEdzQztBQUVFO0FBR0k7QUFHYTtBQUcxRDtJQUFtRCxpREFBbUI7SUFBdEU7O0lBVUEsQ0FBQztJQVRHLHlEQUFpQixHQUFqQjtRQUNJLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUNuQyxDQUFDO0lBQ0QsOENBQU0sR0FBTjtRQUNJLE1BQU0sQ0FBQyxDQUNiO1lBQ1UsNERBQUMseUVBQW1CLE9BQUcsQ0FBTSxDQUNoQyxDQUFDO0lBQ04sQ0FBQztJQUNMLG9DQUFDO0FBQUQsQ0FBQyxDQVZrRCxnREFBUyxHQVUzRDs7QUFDRCxJQUFNLGVBQWUsR0FBRyxVQUFDLEtBQXVCLElBQUssUUFBQztJQUNsRCxTQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVM7Q0FDN0IsQ0FBQyxFQUZtRCxDQUVuRDtBQUNLLElBQU0sa0JBQWtCLEdBQUcsVUFBQyxRQUFRLElBQUssUUFBQztJQUM3QyxpQkFBaUIsRUFBRTtJQUVuQixDQUFDO0NBQ0osQ0FBQyxFQUo4QyxDQUk5QztBQUVGLCtEQUFlLDJFQUFPLENBQUMsZUFBZSxFQUFFLGtCQUFrQixDQUFDLENBQUMsNkJBQTZCLENBQXlDLEVBQUM7Ozs7Ozs7O0FDL0JuSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7O0FDak1EO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1ZBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSw4QkFBOEIsVUFBVSx1QkFBdUIsRUFBRSxFQUFFO0FBQ25FLDRCQUE0QixVQUFVLHFCQUFxQixFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25CQSxnRDs7Ozs7O0FDQUEsZ0Q7Ozs7OztBQ0FBLGdEOzs7Ozs7QUNBQSxnRDs7Ozs7O0FDQUEsOEM7Ozs7OztBQ0FBLCtDIiwiZmlsZSI6Im1haW4tc2VydmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJkaXN0L1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDE1NCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNzk3OThhZDczNWMzODQzMDRmZjciLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0KHBhcmFtcywgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuYmVhbnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzTWFwcGVkQnlOYW1lID0ge307XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXMuYmVhbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHRQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJz4+IGNyZWF0aW5nIGFnLUFwcGxpY2F0aW9uIENvbnRleHQnKTtcbiAgICAgICAgdGhpcy5zZXR1cENvbXBvbmVudHMoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVCZWFucygpO1xuICAgICAgICB2YXIgYmVhbnMgPSB1dGlsc18xLlV0aWxzLm1hcE9iamVjdCh0aGlzLmJlYW5zLCBmdW5jdGlvbiAoYmVhbkVudHJ5KSB7IHJldHVybiBiZWFuRW50cnkuYmVhbkluc3RhbmNlOyB9KTtcbiAgICAgICAgdGhpcy53aXJlQmVhbnMoYmVhbnMpO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJz4+IGFnLUFwcGxpY2F0aW9uIENvbnRleHQgcmVhZHkgLSBjb21wb25lbnQgaXMgYWxpdmUnKTtcbiAgICB9XG4gICAgQ29udGV4dC5wcm90b3R5cGUuc2V0dXBDb21wb25lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0UGFyYW1zLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dFBhcmFtcy5jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudE1ldGEpIHsgcmV0dXJuIF90aGlzLmFkZENvbXBvbmVudChjb21wb25lbnRNZXRhKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRleHQucHJvdG90eXBlLmFkZENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRNZXRhKSB7XG4gICAgICAgIC8vIGdldCBuYW1lIG9mIHRoZSBjbGFzcyBhcyBhIHN0cmluZ1xuICAgICAgICAvLyBsZXQgY2xhc3NOYW1lID0gXy5nZXROYW1lT2ZDbGFzcyhDb21wb25lbnRDbGFzcyk7XG4gICAgICAgIC8vIGluc2VydCBhIGRhc2ggYWZ0ZXIgZXZlcnkgY2FwaXRhbCBsZXR0ZXJcbiAgICAgICAgLy8gbGV0IGNsYXNzRXNjYXBlZCA9IGNsYXNzTmFtZS5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBjbGFzc0VzY2FwZWQgPSBjb21wb25lbnRNZXRhLmNvbXBvbmVudE5hbWUucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gcHV0IGFsbCB0byB1cHBlciBjYXNlXG4gICAgICAgIHZhciBjbGFzc1VwcGVyQ2FzZSA9IGNsYXNzRXNjYXBlZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAvLyBmaW5hbGx5IHN0b3JlXG4gICAgICAgIHRoaXMuY29tcG9uZW50c01hcHBlZEJ5TmFtZVtjbGFzc1VwcGVyQ2FzZV0gPSBjb21wb25lbnRNZXRhLnRoZUNsYXNzO1xuICAgIH07XG4gICAgQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHNNYXBwZWRCeU5hbWUgJiYgdGhpcy5jb21wb25lbnRzTWFwcGVkQnlOYW1lW2tleV0pIHtcbiAgICAgICAgICAgIHZhciBuZXdDb21wb25lbnQgPSBuZXcgdGhpcy5jb21wb25lbnRzTWFwcGVkQnlOYW1lW2tleV07XG4gICAgICAgICAgICB0aGlzLndpcmVCZWFuKG5ld0NvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmNvcHlBdHRyaWJ1dGVzRnJvbU5vZGUoZWxlbWVudCwgbmV3Q29tcG9uZW50LmdldEd1aSgpKTtcbiAgICAgICAgICAgIG5ld0NvbXBvbmVudC5hdHRyaWJ1dGVzU2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3Q29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRleHQucHJvdG90eXBlLmNvcHlBdHRyaWJ1dGVzRnJvbU5vZGUgPSBmdW5jdGlvbiAoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgICAgICBpZiAoZnJvbU5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gZnJvbU5vZGUuYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGZyb21Ob2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgdG9Ob2RlLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS53aXJlQmVhbiA9IGZ1bmN0aW9uIChiZWFuKSB7XG4gICAgICAgIGlmICghYmVhbilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQ2FuJ3Qgd2lyZSB0byBiZWFuIHNpbmNlIGl0IGlzIG51bGxcIik7XG4gICAgICAgIHRoaXMud2lyZUJlYW5zKFtiZWFuXSk7XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS53aXJlQmVhbnMgPSBmdW5jdGlvbiAoYmVhbnMpIHtcbiAgICAgICAgdGhpcy5hdXRvV2lyZUJlYW5zKGJlYW5zKTtcbiAgICAgICAgdGhpcy5tZXRob2RXaXJlQmVhbnMoYmVhbnMpO1xuICAgICAgICB0aGlzLnByZUNvbnN0cnVjdChiZWFucyk7XG4gICAgICAgIHRoaXMucG9zdENvbnN0cnVjdChiZWFucyk7XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVCZWFucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gcmVnaXN0ZXIgYWxsIG5vcm1hbCBiZWFuc1xuICAgICAgICB0aGlzLmNvbnRleHRQYXJhbXMuYmVhbnMuZm9yRWFjaCh0aGlzLmNyZWF0ZUJlYW5FbnRyeS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gcmVnaXN0ZXIgb3ZlcnJpZGUgYmVhbnMsIHRoZXNlIHdpbGwgb3ZlcndyaXRlIGJlYW5zIGFib3ZlIG9mIHNhbWUgbmFtZVxuICAgICAgICBpZiAodGhpcy5jb250ZXh0UGFyYW1zLm92ZXJyaWRlQmVhbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dFBhcmFtcy5vdmVycmlkZUJlYW5zLmZvckVhY2godGhpcy5jcmVhdGVCZWFuRW50cnkuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5zdGFudGlhdGUgYWxsIGJlYW5zIC0gb3ZlcnJpZGRlbiBiZWFucyB3aWxsIGJlIGxlZnQgb3V0XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuaXRlcmF0ZU9iamVjdCh0aGlzLmJlYW5zLCBmdW5jdGlvbiAoa2V5LCBiZWFuRW50cnkpIHtcbiAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvclBhcmFtc01ldGE7XG4gICAgICAgICAgICBpZiAoYmVhbkVudHJ5LmJlYW4uX19hZ0JlYW5NZXRhRGF0YVxuICAgICAgICAgICAgICAgICYmIGJlYW5FbnRyeS5iZWFuLl9fYWdCZWFuTWV0YURhdGEuYXV0b3dpcmVNZXRob2RzXG4gICAgICAgICAgICAgICAgJiYgYmVhbkVudHJ5LmJlYW4uX19hZ0JlYW5NZXRhRGF0YS5hdXRvd2lyZU1ldGhvZHMuYWdDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yUGFyYW1zTWV0YSA9IGJlYW5FbnRyeS5iZWFuLl9fYWdCZWFuTWV0YURhdGEuYXV0b3dpcmVNZXRob2RzLmFnQ29uc3RydWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3JQYXJhbXMgPSBfdGhpcy5nZXRCZWFuc0ZvclBhcmFtZXRlcnMoY29uc3RydWN0b3JQYXJhbXNNZXRhLCBiZWFuRW50cnkuYmVhbi5uYW1lKTtcbiAgICAgICAgICAgIHZhciBuZXdJbnN0YW5jZSA9IGFwcGx5VG9Db25zdHJ1Y3RvcihiZWFuRW50cnkuYmVhbiwgY29uc3RydWN0b3JQYXJhbXMpO1xuICAgICAgICAgICAgYmVhbkVudHJ5LmJlYW5JbnN0YW5jZSA9IG5ld0luc3RhbmNlO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZygnYmVhbiAnICsgX3RoaXMuZ2V0QmVhbk5hbWUobmV3SW5zdGFuY2UpICsgJyBjcmVhdGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQmVhbkVudHJ5ID0gZnVuY3Rpb24gKEJlYW4pIHtcbiAgICAgICAgdmFyIG1ldGFEYXRhID0gQmVhbi5fX2FnQmVhbk1ldGFEYXRhO1xuICAgICAgICBpZiAoIW1ldGFEYXRhKSB7XG4gICAgICAgICAgICB2YXIgYmVhbk5hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoQmVhbi5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBiZWFuTmFtZSA9IEJlYW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiZWFuTmFtZSA9ICcnICsgQmVhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2NvbnRleHQgaXRlbSAnICsgYmVhbk5hbWUgKyAnIGlzIG5vdCBhIGJlYW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVhbkVudHJ5ID0ge1xuICAgICAgICAgICAgYmVhbjogQmVhbixcbiAgICAgICAgICAgIGJlYW5JbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgIGJlYW5OYW1lOiBtZXRhRGF0YS5iZWFuTmFtZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJlYW5zW21ldGFEYXRhLmJlYW5OYW1lXSA9IGJlYW5FbnRyeTtcbiAgICB9O1xuICAgIENvbnRleHQucHJvdG90eXBlLmF1dG9XaXJlQmVhbnMgPSBmdW5jdGlvbiAoYmVhbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYmVhbnMuZm9yRWFjaChmdW5jdGlvbiAoYmVhbikgeyByZXR1cm4gX3RoaXMuYXV0b1dpcmVCZWFuKGJlYW4pOyB9KTtcbiAgICB9O1xuICAgIENvbnRleHQucHJvdG90eXBlLm1ldGhvZFdpcmVCZWFucyA9IGZ1bmN0aW9uIChiZWFucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBiZWFucy5mb3JFYWNoKGZ1bmN0aW9uIChiZWFuKSB7XG4gICAgICAgICAgICBpZiAoIWJlYW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW4ndCB3aXJlIHRvIGJlYW4gc2luY2UgaXQgaXMgbnVsbFwiKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5tZXRob2RXaXJlQmVhbihiZWFuKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS5hdXRvV2lyZUJlYW4gPSBmdW5jdGlvbiAoYmVhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY3VycmVudEJlYW4gPSBiZWFuO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q29uc3RydWN0b3IgPSBjdXJyZW50QmVhbi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29uc3RydWN0b3IuX19hZ0JlYW5NZXRhRGF0YVxuICAgICAgICAgICAgICAgICYmIGN1cnJlbnRDb25zdHJ1Y3Rvci5fX2FnQmVhbk1ldGFEYXRhLmFnQ2xhc3NBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBjdXJyZW50Q29uc3RydWN0b3IuX19hZ0JlYW5NZXRhRGF0YS5hZ0NsYXNzQXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYmVhbk5hbWVfMSA9IHRoaXNfMS5nZXRCZWFuTmFtZShjdXJyZW50Q29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckJlYW4gPSBfdGhpcy5sb29rdXBCZWFuSW5zdGFuY2UoYmVhbk5hbWVfMSwgYXR0cmlidXRlLmJlYW5OYW1lLCBhdHRyaWJ1dGUub3B0aW9uYWwpO1xuICAgICAgICAgICAgICAgICAgICBiZWFuW2F0dHJpYnV0ZS5hdHRyaWJ1dGVOYW1lXSA9IG90aGVyQmVhbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCZWFuID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnRCZWFuKSA/IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50QmVhbikgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRCZWFuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZV8xLnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS5nZXRCZWFuTmFtZSA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAoY29uc3RydWN0b3IuX19hZ0JlYW5NZXRhRGF0YSAmJiBjb25zdHJ1Y3Rvci5fX2FnQmVhbk1ldGFEYXRhLmJlYW5OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3IuX19hZ0JlYW5NZXRhRGF0YS5iZWFuTmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uc3RydWN0b3JTdHJpbmcgPSBjb25zdHJ1Y3Rvci50b1N0cmluZygpO1xuICAgICAgICB2YXIgYmVhbk5hbWUgPSBjb25zdHJ1Y3RvclN0cmluZy5zdWJzdHJpbmcoOSwgY29uc3RydWN0b3JTdHJpbmcuaW5kZXhPZignKCcpKTtcbiAgICAgICAgcmV0dXJuIGJlYW5OYW1lO1xuICAgIH07XG4gICAgQ29udGV4dC5wcm90b3R5cGUubWV0aG9kV2lyZUJlYW4gPSBmdW5jdGlvbiAoYmVhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXV0b3dpcmVkTWV0aG9kcztcbiAgICAgICAgaWYgKGJlYW4uY29uc3RydWN0b3IuX19hZ0JlYW5NZXRhRGF0YSAmJiBiZWFuLmNvbnN0cnVjdG9yLl9fYWdCZWFuTWV0YURhdGEuYXV0b3dpcmVNZXRob2RzKSB7XG4gICAgICAgICAgICBhdXRvd2lyZWRNZXRob2RzID0gYmVhbi5jb25zdHJ1Y3Rvci5fX2FnQmVhbk1ldGFEYXRhLmF1dG93aXJlTWV0aG9kcztcbiAgICAgICAgfVxuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QoYXV0b3dpcmVkTWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZE5hbWUsIHdpcmVQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIHNraXAgY29uc3RydWN0b3IsIGFzIHRoaXMgaXMgZGVhbHQgd2l0aCBlbHNld2hlcmVcbiAgICAgICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnYWdDb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmVhbk5hbWUgPSBfdGhpcy5nZXRCZWFuTmFtZShiZWFuLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIHZhciBpbml0UGFyYW1zID0gX3RoaXMuZ2V0QmVhbnNGb3JQYXJhbWV0ZXJzKHdpcmVQYXJhbXMsIGJlYW5OYW1lKTtcbiAgICAgICAgICAgIGJlYW5bbWV0aG9kTmFtZV0uYXBwbHkoYmVhbiwgaW5pdFBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGV4dC5wcm90b3R5cGUuZ2V0QmVhbnNGb3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMsIGJlYW5OYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBiZWFuc0xpc3QgPSBbXTtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuaXRlcmF0ZU9iamVjdChwYXJhbWV0ZXJzLCBmdW5jdGlvbiAocGFyYW1JbmRleCwgb3RoZXJCZWFuTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckJlYW4gPSBfdGhpcy5sb29rdXBCZWFuSW5zdGFuY2UoYmVhbk5hbWUsIG90aGVyQmVhbk5hbWUpO1xuICAgICAgICAgICAgICAgIGJlYW5zTGlzdFtOdW1iZXIocGFyYW1JbmRleCldID0gb3RoZXJCZWFuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlYW5zTGlzdDtcbiAgICB9O1xuICAgIENvbnRleHQucHJvdG90eXBlLmxvb2t1cEJlYW5JbnN0YW5jZSA9IGZ1bmN0aW9uICh3aXJpbmdCZWFuLCBiZWFuTmFtZSwgb3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKG9wdGlvbmFsID09PSB2b2lkIDApIHsgb3B0aW9uYWwgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoYmVhbk5hbWUgPT09ICdjb250ZXh0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0UGFyYW1zLnNlZWQgJiYgdGhpcy5jb250ZXh0UGFyYW1zLnNlZWQuaGFzT3duUHJvcGVydHkoYmVhbk5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0UGFyYW1zLnNlZWRbYmVhbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJlYW5FbnRyeSA9IHRoaXMuYmVhbnNbYmVhbk5hbWVdO1xuICAgICAgICAgICAgaWYgKGJlYW5FbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiZWFuRW50cnkuYmVhbkluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FnLUdyaWQ6IHVuYWJsZSB0byBmaW5kIGJlYW4gcmVmZXJlbmNlICcgKyBiZWFuTmFtZSArICcgd2hpbGUgaW5pdGlhbGlzaW5nICcgKyB3aXJpbmdCZWFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS5wb3N0Q29uc3RydWN0ID0gZnVuY3Rpb24gKGJlYW5zKSB7XG4gICAgICAgIGJlYW5zLmZvckVhY2goZnVuY3Rpb24gKGJlYW4pIHtcbiAgICAgICAgICAgIC8vIHRyeSBjYWxsaW5nIGluaXQgbWV0aG9kc1xuICAgICAgICAgICAgaWYgKGJlYW4uY29uc3RydWN0b3IuX19hZ0JlYW5NZXRhRGF0YSAmJiBiZWFuLmNvbnN0cnVjdG9yLl9fYWdCZWFuTWV0YURhdGEucG9zdENvbnN0cnVjdE1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBiZWFuLmNvbnN0cnVjdG9yLl9fYWdCZWFuTWV0YURhdGEgJiYgYmVhbi5jb25zdHJ1Y3Rvci5fX2FnQmVhbk1ldGFEYXRhLnBvc3RDb25zdHJ1Y3RNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHsgcmV0dXJuIGJlYW5bbWV0aG9kTmFtZV0oKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGV4dC5wcm90b3R5cGUucHJlQ29uc3RydWN0ID0gZnVuY3Rpb24gKGJlYW5zKSB7XG4gICAgICAgIGJlYW5zLmZvckVhY2goZnVuY3Rpb24gKGJlYW4pIHtcbiAgICAgICAgICAgIC8vIHRyeSBjYWxsaW5nIGluaXQgbWV0aG9kc1xuICAgICAgICAgICAgaWYgKGJlYW4uY29uc3RydWN0b3IuX19hZ0JlYW5NZXRhRGF0YSAmJiBiZWFuLmNvbnN0cnVjdG9yLl9fYWdCZWFuTWV0YURhdGEucHJlQ29uc3RydWN0TWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGJlYW4uY29uc3RydWN0b3IuX19hZ0JlYW5NZXRhRGF0YS5wcmVDb25zdHJ1Y3RNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHsgcmV0dXJuIGJlYW5bbWV0aG9kTmFtZV0oKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGV4dC5wcm90b3R5cGUuZ2V0QmVhbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cEJlYW5JbnN0YW5jZSgnZ2V0QmVhbicsIG5hbWUsIHRydWUpO1xuICAgIH07XG4gICAgQ29udGV4dC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgYmUgYWJsZSB0byBkZXN0cm95IG9uY2VcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCc+PiBTaHV0dGluZyBkb3duIGFnLUFwcGxpY2F0aW9uIENvbnRleHQnKTtcbiAgICAgICAgLy8gdHJ5IGNhbGxpbmcgZGVzdHJveSBtZXRob2RzXG4gICAgICAgIHV0aWxzXzEuVXRpbHMuaXRlcmF0ZU9iamVjdCh0aGlzLmJlYW5zLCBmdW5jdGlvbiAoa2V5LCBiZWFuRW50cnkpIHtcbiAgICAgICAgICAgIHZhciBiZWFuID0gYmVhbkVudHJ5LmJlYW5JbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChiZWFuLmNvbnN0cnVjdG9yLl9fYWdCZWFuTWV0YURhdGEgJiYgYmVhbi5jb25zdHJ1Y3Rvci5fX2FnQmVhbk1ldGFEYXRhLnByZURlc3Ryb3lNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgYmVhbi5jb25zdHJ1Y3Rvci5fX2FnQmVhbk1ldGFEYXRhLnByZURlc3Ryb3lNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHsgcmV0dXJuIGJlYW5bbWV0aG9kTmFtZV0oKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnPj4gYWctQXBwbGljYXRpb24gQ29udGV4dCBzaHV0IGRvd24gLSBjb21wb25lbnQgaXMgZGVhZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5Db250ZXh0ID0gQ29udGV4dDtcbi8vIHRha2VuIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzM2MjQ3MS9ob3ctY2FuLWktY2FsbC1hLWphdmFzY3JpcHQtY29uc3RydWN0b3ItdXNpbmctY2FsbC1vci1hcHBseVxuLy8gYWxsb3dzIGNhbGxpbmcgJ2FwcGx5JyBvbiBhIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBhcHBseVRvQ29uc3RydWN0b3IoY29uc3RydWN0b3IsIGFyZ0FycmF5KSB7XG4gICAgdmFyIGFyZ3MgPSBbbnVsbF0uY29uY2F0KGFyZ0FycmF5KTtcbiAgICB2YXIgZmFjdG9yeUZ1bmN0aW9uID0gY29uc3RydWN0b3IuYmluZC5hcHBseShjb25zdHJ1Y3RvciwgYXJncyk7XG4gICAgcmV0dXJuIG5ldyBmYWN0b3J5RnVuY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIFByZUNvbnN0cnVjdCh0YXJnZXQsIG1ldGhvZE5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgcHJvcHMgPSBnZXRPckNyZWF0ZVByb3BzKHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgaWYgKCFwcm9wcy5wb3N0Q29uc3RydWN0TWV0aG9kcykge1xuICAgICAgICBwcm9wcy5wcmVDb25zdHJ1Y3RNZXRob2RzID0gW107XG4gICAgfVxuICAgIHByb3BzLnByZUNvbnN0cnVjdE1ldGhvZHMucHVzaChtZXRob2ROYW1lKTtcbn1cbmV4cG9ydHMuUHJlQ29uc3RydWN0ID0gUHJlQ29uc3RydWN0O1xuZnVuY3Rpb24gUG9zdENvbnN0cnVjdCh0YXJnZXQsIG1ldGhvZE5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgcHJvcHMgPSBnZXRPckNyZWF0ZVByb3BzKHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgaWYgKCFwcm9wcy5wb3N0Q29uc3RydWN0TWV0aG9kcykge1xuICAgICAgICBwcm9wcy5wb3N0Q29uc3RydWN0TWV0aG9kcyA9IFtdO1xuICAgIH1cbiAgICBwcm9wcy5wb3N0Q29uc3RydWN0TWV0aG9kcy5wdXNoKG1ldGhvZE5hbWUpO1xufVxuZXhwb3J0cy5Qb3N0Q29uc3RydWN0ID0gUG9zdENvbnN0cnVjdDtcbmZ1bmN0aW9uIFByZURlc3Ryb3kodGFyZ2V0LCBtZXRob2ROYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgdmFyIHByb3BzID0gZ2V0T3JDcmVhdGVQcm9wcyh0YXJnZXQuY29uc3RydWN0b3IpO1xuICAgIGlmICghcHJvcHMucHJlRGVzdHJveU1ldGhvZHMpIHtcbiAgICAgICAgcHJvcHMucHJlRGVzdHJveU1ldGhvZHMgPSBbXTtcbiAgICB9XG4gICAgcHJvcHMucHJlRGVzdHJveU1ldGhvZHMucHVzaChtZXRob2ROYW1lKTtcbn1cbmV4cG9ydHMuUHJlRGVzdHJveSA9IFByZURlc3Ryb3k7XG5mdW5jdGlvbiBCZWFuKGJlYW5OYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGdldE9yQ3JlYXRlUHJvcHMoY2xhc3NDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHByb3BzLmJlYW5OYW1lID0gYmVhbk5hbWU7XG4gICAgfTtcbn1cbmV4cG9ydHMuQmVhbiA9IEJlYW47XG5mdW5jdGlvbiBBdXRvd2lyZWQobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICBhdXRvd2lyZWRGdW5jKHRhcmdldCwgbmFtZSwgZmFsc2UsIHRhcmdldCwgcHJvcGVydHlLZXksIG51bGwpO1xuICAgIH07XG59XG5leHBvcnRzLkF1dG93aXJlZCA9IEF1dG93aXJlZDtcbmZ1bmN0aW9uIE9wdGlvbmFsKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgYXV0b3dpcmVkRnVuYyh0YXJnZXQsIG5hbWUsIHRydWUsIHRhcmdldCwgcHJvcGVydHlLZXksIG51bGwpO1xuICAgIH07XG59XG5leHBvcnRzLk9wdGlvbmFsID0gT3B0aW9uYWw7XG5mdW5jdGlvbiBhdXRvd2lyZWRGdW5jKHRhcmdldCwgbmFtZSwgb3B0aW9uYWwsIGNsYXNzUHJvdG90eXBlLCBtZXRob2RPckF0dHJpYnV0ZU5hbWUsIGluZGV4KSB7XG4gICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogQXV0b3dpcmVkIG5hbWUgc2hvdWxkIG5vdCBiZSBudWxsJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogQXV0b3dpcmVkIHNob3VsZCBiZSBvbiBhbiBhdHRyaWJ1dGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpdCdzIGFuIGF0dHJpYnV0ZSBvbiB0aGUgY2xhc3NcbiAgICB2YXIgcHJvcHMgPSBnZXRPckNyZWF0ZVByb3BzKHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgaWYgKCFwcm9wcy5hZ0NsYXNzQXR0cmlidXRlcykge1xuICAgICAgICBwcm9wcy5hZ0NsYXNzQXR0cmlidXRlcyA9IFtdO1xuICAgIH1cbiAgICBwcm9wcy5hZ0NsYXNzQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbWV0aG9kT3JBdHRyaWJ1dGVOYW1lLFxuICAgICAgICBiZWFuTmFtZTogbmFtZSxcbiAgICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBRdWFsaWZpZXIobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2xhc3NQcm90b3R5cGUsIG1ldGhvZE9yQXR0cmlidXRlTmFtZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gKHR5cGVvZiBjbGFzc1Byb3RvdHlwZSA9PSAnZnVuY3Rpb24nKSA/IGNsYXNzUHJvdG90eXBlIDogY2xhc3NQcm90b3R5cGUuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBwcm9wcztcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGl0J3MgYSBwYXJhbWV0ZXIgb24gYSBtZXRob2RcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG1ldGhvZE9yQXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgICAgICAgIHByb3BzID0gZ2V0T3JDcmVhdGVQcm9wcyhjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9IG1ldGhvZE9yQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BzID0gZ2V0T3JDcmVhdGVQcm9wcyhjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdhZ0NvbnN0cnVjdG9yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJvcHMuYXV0b3dpcmVNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuYXV0b3dpcmVNZXRob2RzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByb3BzLmF1dG93aXJlTWV0aG9kc1ttZXRob2ROYW1lXSkge1xuICAgICAgICAgICAgICAgIHByb3BzLmF1dG93aXJlTWV0aG9kc1ttZXRob2ROYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMuYXV0b3dpcmVNZXRob2RzW21ldGhvZE5hbWVdW2luZGV4XSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5RdWFsaWZpZXIgPSBRdWFsaWZpZXI7XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVByb3BzKHRhcmdldCkge1xuICAgIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KCdfX2FnQmVhbk1ldGFEYXRhJykpIHtcbiAgICAgICAgdGFyZ2V0Ll9fYWdCZWFuTWV0YURhdGEgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5fX2FnQmVhbk1ldGFEYXRhO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29udGV4dC9jb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBGVU5DVElPTl9TVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcbnZhciBGVU5DVElPTl9BUkdVTUVOVF9OQU1FUyA9IC8oW15cXHMsXSspL2c7XG4vLyB1dGlsIGNsYXNzLCBvbmx5IHVzZWQgd2hlbiBkZWJ1Z2dpbmcsIGZvciBwcmludGluZyB0aW1lIHRvIGNvbnNvbGVcbnZhciBUaW1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZXIoKSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIFRpbWVyLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAtIHRoaXMudGltZXN0YW1wO1xuICAgICAgICBjb25zb2xlLmxvZyhtc2cgKyBcIiA9IFwiICsgZHVyYXRpb24pO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVyO1xufSgpKTtcbmV4cG9ydHMuVGltZXIgPSBUaW1lcjtcbi8qKiBIVE1MIEVzY2FwZXMuICovXG52YXIgSFRNTF9FU0NBUEVTID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xufTtcbnZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZztcbnZhciBVdGlscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXRpbHMoKSB7XG4gICAgfVxuICAgIFV0aWxzLm1pbWljQXN5bmMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiB0aGUgZXZlbnQgaXMgY2xvc2UgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IGJ5IFggcGl4ZWxzIGVpdGhlciB2ZXJ0aWNhbGx5IG9yIGhvcml6b250YWxseS5cbiAgICAvLyB3ZSBvbmx5IHN0YXJ0IGRyYWdnaW5nIGFmdGVyIFggcGl4ZWxzIHNvIHRoaXMgYWxsb3dzIHVzIHRvIGtub3cgaWYgd2Ugc2hvdWxkIHN0YXJ0IGRyYWdnaW5nIHlldC5cbiAgICBVdGlscy5hcmVFdmVudHNOZWFyID0gZnVuY3Rpb24gKGUxLCBlMiwgcGl4ZWxDb3VudCkge1xuICAgICAgICAvLyBieSBkZWZhdWx0LCB3ZSB3YWl0IDQgcGl4ZWxzIGJlZm9yZSBzdGFydGluZyB0aGUgZHJhZ1xuICAgICAgICBpZiAocGl4ZWxDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWZmWCA9IE1hdGguYWJzKGUxLmNsaWVudFggLSBlMi5jbGllbnRYKTtcbiAgICAgICAgdmFyIGRpZmZZID0gTWF0aC5hYnMoZTEuY2xpZW50WSAtIGUyLmNsaWVudFkpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZGlmZlgsIGRpZmZZKSA8PSBwaXhlbENvdW50O1xuICAgIH07XG4gICAgVXRpbHMuc2hhbGxvd0NvbXBhcmUgPSBmdW5jdGlvbiAoYXJyMSwgYXJyMikge1xuICAgICAgICAvLyBpZiBib3RoIGFyZSBtaXNzaW5nLCB0aGVuIHRoZXkgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmICh0aGlzLm1pc3NpbmcoYXJyMSkgJiYgdGhpcy5taXNzaW5nKGFycjIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBvbmUgaXMgcHJlc2VudCwgYnV0IG90aGVyIGlzIG1pc3NpbmcsIHRoZW4gdGhlbiBhcmUgZGlmZmVyZW50XG4gICAgICAgIGlmICh0aGlzLm1pc3NpbmcoYXJyMSkgfHwgdGhpcy5taXNzaW5nKGFycjIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBVdGlscy5nZXROYW1lT2ZDbGFzcyA9IGZ1bmN0aW9uIChUaGVDbGFzcykge1xuICAgICAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvbiAoLnsxLH0pXFwoLztcbiAgICAgICAgdmFyIGZ1bmNBc1N0cmluZyA9IFRoZUNsYXNzLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciByZXN1bHRzID0gKGZ1bmNOYW1lUmVnZXgpLmV4ZWMoZnVuY0FzU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSkgPyByZXN1bHRzWzFdIDogXCJcIjtcbiAgICB9O1xuICAgIFV0aWxzLnZhbHVlcyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJhdGVPYmplY3Qob2JqZWN0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFV0aWxzLmdldFZhbHVlVXNpbmdGaWVsZCA9IGZ1bmN0aW9uIChkYXRhLCBmaWVsZCwgZmllbGRDb250YWluc0RvdHMpIHtcbiAgICAgICAgaWYgKCFmaWVsZCB8fCAhZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vICcuJywgdGhlbiBpdCdzIG5vdCBhIGRlZXAgdmFsdWVcbiAgICAgICAgaWYgKCFmaWVsZENvbnRhaW5zRG90cykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IGlzIGEgZGVlcCB2YWx1ZSwgc28gbmVlZCB0byBkaWcgZm9yIGl0XG4gICAgICAgICAgICB2YXIgZmllbGRzID0gZmllbGQuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50T2JqZWN0ID0gZGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE9iamVjdCA9IGN1cnJlbnRPYmplY3RbZmllbGRzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXNzaW5nKGN1cnJlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVdGlscy5nZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHJ0bCkge1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgLy8gQWJzb2x1dGUgdmFsdWUgLSBmb3IgRkYgdGhhdCByZXBvcnRzIFJUTCBzY3JvbGxzIGluIG5lZ2F0aXZlIG51bWJlcnNcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSBNYXRoLmFicyhzY3JvbGxMZWZ0KTtcbiAgICAgICAgICAgIC8vIEdldCBDaHJvbWUgYW5kIFNhZmFyaSB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgYXMgd2VsbFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNCcm93c2VyU2FmYXJpKCkgfHwgdGhpcy5pc0Jyb3dzZXJDaHJvbWUoKSkge1xuICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCAtIHNjcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjcm9sbExlZnQ7XG4gICAgfTtcbiAgICBVdGlscy5jbGVhbk51bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgVXRpbHMuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZSwgcnRsKSB7XG4gICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpIHdoZW4gZG9pbmcgUlRMIGhhdmUgdGhlIEVORCBwb3NpdGlvbiBvZiB0aGUgc2Nyb2xsIGFzIHplcm8sIG5vdCB0aGUgc3RhcnRcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQnJvd3NlclNhZmFyaSgpIHx8IHRoaXMuaXNCcm93c2VyQ2hyb21lKCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50LmNsaWVudFdpZHRoIC0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXJlZm94IHVzZXMgbmVnYXRpdmUgbnVtYmVycyB3aGVuIGRvaW5nIFJUTCBzY3JvbGxpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQnJvd3NlckZpcmVmb3goKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHZhbHVlO1xuICAgIH07XG4gICAgVXRpbHMuaXRlcmF0ZU9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1pc3Npbmcob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgY2FsbGJhY2soa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLmNsb25lT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICB2YXIgY29weSA9IHt9O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH07XG4gICAgVXRpbHMubWFwID0gZnVuY3Rpb24gKGFycmF5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICAgICAgICB2YXIgbWFwcGVkSXRlbSA9IGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwcGVkSXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFV0aWxzLm1hcE9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgVXRpbHMuaXRlcmF0ZU9iamVjdChvYmplY3QsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjayh2YWx1ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFV0aWxzLmZvckVhY2ggPSBmdW5jdGlvbiAoYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHZhbHVlLCBpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMuZmlsdGVyID0gZnVuY3Rpb24gKGFycmF5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFV0aWxzLmdldEFsbEtleXNJbk9iamVjdHMgPSBmdW5jdGlvbiAob2JqZWN0cykge1xuICAgICAgICB2YXIgYWxsVmFsdWVzID0ge307XG4gICAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFsbFZhbHVlc1trZXldID0gbnVsbDsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxsVmFsdWVzKTtcbiAgICB9O1xuICAgIFV0aWxzLm1lcmdlRGVlcCA9IGZ1bmN0aW9uIChkZXN0LCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhpc3RzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlcmF0ZU9iamVjdChzb3VyY2UsIGZ1bmN0aW9uIChrZXksIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZGVzdFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9sZFZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLm1lcmdlRGVlcChvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5leGlzdHMoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLml0ZXJhdGVPYmplY3Qoc291cmNlLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuICAgIFV0aWxzLnBhcnNlWXl5eU1tRGRUb0RhdGUgPSBmdW5jdGlvbiAoeXl5eU1tRGQsIHNlcGFyYXRvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF5eXl5TW1EZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh5eXl5TW1EZC5pbmRleE9mKHNlcGFyYXRvcikgPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHl5eXlNbURkLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihmaWVsZHNbMF0pLCBOdW1iZXIoZmllbGRzWzFdKSAtIDEsIE51bWJlcihmaWVsZHNbMl0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLnNlcmlhbGl6ZURhdGVUb1l5eXlNbURkID0gZnVuY3Rpb24gKGRhdGUsIHNlcGFyYXRvcikge1xuICAgICAgICBpZiAoIWRhdGUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSArIHNlcGFyYXRvciArIFV0aWxzLnBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAyKSArIHNlcGFyYXRvciArIFV0aWxzLnBhZChkYXRlLmdldERhdGUoKSwgMik7XG4gICAgfTtcbiAgICBVdGlscy5wYWQgPSBmdW5jdGlvbiAobnVtLCB0b3RhbFN0cmluZ1NpemUpIHtcbiAgICAgICAgdmFyIGFzU3RyaW5nID0gbnVtICsgXCJcIjtcbiAgICAgICAgd2hpbGUgKGFzU3RyaW5nLmxlbmd0aCA8IHRvdGFsU3RyaW5nU2l6ZSlcbiAgICAgICAgICAgIGFzU3RyaW5nID0gXCIwXCIgKyBhc1N0cmluZztcbiAgICAgICAgcmV0dXJuIGFzU3RyaW5nO1xuICAgIH07XG4gICAgVXRpbHMucHVzaEFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy5taXNzaW5nKHNvdXJjZSkgfHwgdGhpcy5taXNzaW5nKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gdGFyZ2V0LnB1c2goZnVuYyk7IH0pO1xuICAgIH07XG4gICAgVXRpbHMuY3JlYXRlQXJyYXlPZk51bWJlcnMgPSBmdW5jdGlvbiAoZmlyc3QsIGxhc3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3Q7IGkgPD0gbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgVXRpbHMuZ2V0RnVuY3Rpb25QYXJhbWV0ZXJzID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgdmFyIGZuU3RyID0gZnVuYy50b1N0cmluZygpLnJlcGxhY2UoRlVOQ1RJT05fU1RSSVBfQ09NTUVOVFMsICcnKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZuU3RyLnNsaWNlKGZuU3RyLmluZGV4T2YoJygnKSArIDEsIGZuU3RyLmluZGV4T2YoJyknKSkubWF0Y2goRlVOQ1RJT05fQVJHVU1FTlRfTkFNRVMpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVdGlscy5maW5kID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT09IG51bGwgfHwgY29sbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBvYmpUb0FycmF5ID0gdGhpcy52YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kKG9ialRvQXJyYXksIHByZWRpY2F0ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xsZWN0aW9uQXNBcnJheSA9IGNvbGxlY3Rpb247XG4gICAgICAgIHZhciBmaXJzdE1hdGNoaW5nSXRlbTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uQXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBjb2xsZWN0aW9uQXNBcnJheVtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtW3ByZWRpY2F0ZV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2hpbmdJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gcHJlZGljYXRlO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE1hdGNoaW5nSXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlyc3RNYXRjaGluZ0l0ZW07XG4gICAgfTtcbiAgICBVdGlscy50b1N0cmluZ3MgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGFycmF5LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsIHx8ICFpdGVtLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFV0aWxzLml0ZXJhdGVBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgY2FsbGJhY2spIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy9SZXR1cm5zIHRydWUgaWYgaXQgaXMgYSBET00gbm9kZVxuICAgIC8vdGFrZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODQyODYvamF2YXNjcmlwdC1pc2RvbS1ob3ctZG8teW91LWNoZWNrLWlmLWEtamF2YXNjcmlwdC1vYmplY3QtaXMtYS1kb20tb2JqZWN0XG4gICAgVXRpbHMuaXNOb2RlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgTm9kZSA9PT0gXCJmdW5jdGlvblwiID8gbyBpbnN0YW5jZW9mIE5vZGUgOlxuICAgICAgICAgICAgbyAmJiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygby5ub2RlVHlwZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIik7XG4gICAgfTtcbiAgICAvL1JldHVybnMgdHJ1ZSBpZiBpdCBpcyBhIERPTSBlbGVtZW50XG4gICAgLy90YWtlbiBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4NDI4Ni9qYXZhc2NyaXB0LWlzZG9tLWhvdy1kby15b3UtY2hlY2staWYtYS1qYXZhc2NyaXB0LW9iamVjdC1pcy1hLWRvbS1vYmplY3RcbiAgICBVdGlscy5pc0VsZW1lbnQgPSBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDpcbiAgICAgICAgICAgIG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiKTtcbiAgICB9O1xuICAgIFV0aWxzLmlzTm9kZU9yRWxlbWVudCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTm9kZShvKSB8fCB0aGlzLmlzRWxlbWVudChvKTtcbiAgICB9O1xuICAgIFV0aWxzLmlzRXZlbnRGcm9tUHJpbnRhYmxlQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBwcmVzc2VkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgICAgICBpZiAoZXhwb3J0cy5fLmV4aXN0cyhldmVudC5rZXkpKSB7XG4gICAgICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlciB3aWxsIGltcGxlbWVudCBrZXksIHNvIHdlIHJldHVybiBpZiBrZXkgaXMgbGVuZ3RoIDEsIGVnIGlmIGl0IGlzICdhJyBmb3IgdGhlXG4gICAgICAgICAgICAvLyBhIGtleSwgb3IgJzInIGZvciB0aGUgJzInIGtleS4gbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzIGhhdmUgbmFtZXMsIGVnICdFbnRlcicgb3IgJ0JhY2tzcGFjZScuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQua2V5Lmxlbmd0aCA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgZm9yIG9sZGVyIGJyb3dzZXJzLCB3ZSB0ZXN0IGFnYWluc3QgYSBsaXN0IG9mIGNoYXJhY3RlcnMsIHdoaWNoIGRvZXNuJ3QgaW5jbHVkZVxuICAgICAgICAgICAgLy8gYWNjZW50cyBmb3Igbm9uLUVuZ2xpc2gsIGJ1dCBkb24ndCBjYXJlIG11Y2gsIGFzIG1vc3QgdXNlcnMgYXJlIG9uIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLlBSSU5UQUJMRV9DSEFSQUNURVJTLmluZGV4T2YocHJlc3NlZENoYXIpID49IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vYWRkcyBhbGwgdHlwZSBvZiBjaGFuZ2UgbGlzdGVuZXJzIHRvIGFuIGVsZW1lbnQsIGludGVuZGVkIHRvIGJlIGEgdGV4dCBmaWVsZFxuICAgIFV0aWxzLmFkZENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZWRcIiwgbGlzdGVuZXIpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgLy8gSUUgZG9lc24ndCBmaXJlIGNoYW5nZWQgZm9yIHNwZWNpYWwga2V5cyAoZWcgZGVsZXRlLCBiYWNrc3BhY2UpLCBzbyBuZWVkIHRvXG4gICAgICAgIC8vIGxpc3RlbiBmb3IgdGhpcyBmdXJ0aGVyIG9uZXNcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBsaXN0ZW5lcik7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIC8vaWYgdmFsdWUgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGJsYW5rLCByZXR1cm5zIG51bGwsIG90aGVyd2lzZSByZXR1cm5zIHRoZSB2YWx1ZVxuICAgIFV0aWxzLm1ha2VOdWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMubWlzc2luZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXhpc3RzKHZhbHVlKTtcbiAgICB9O1xuICAgIFV0aWxzLm1pc3NpbmdPckVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pc3NpbmcodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIFV0aWxzLm1pc3NpbmdPckVtcHR5T2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pc3NpbmcodmFsdWUpIHx8IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBVdGlscy5leGlzdHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMuZmlyc3RFeGlzdGluZ1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMuXy5leGlzdHModmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFV0aWxzLmFueUV4aXN0cyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5leGlzdHModmFsdWVzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVXRpbHMuZXhpc3RzQW5kTm90RW1wdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhpc3RzKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgVXRpbHMucmVtb3ZlQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAocGFyZW50LCBjc3NTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnJlbW92ZUZyb21QYXJlbnQocGFyZW50LnF1ZXJ5U2VsZWN0b3IoY3NzU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIFV0aWxzLnJlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMuaXNWaXNpYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIChlbGVtZW50Lm9mZnNldFBhcmVudCAhPT0gbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBsb2FkcyB0aGUgdGVtcGxhdGUgYW5kIHJldHVybnMgaXQgYXMgYW4gZWxlbWVudC4gbWFrZXMgdXAgZm9yIG5vIHNpbXBsZSB3YXkgaW5cbiAgICAgKiB0aGUgZG9tIGFwaSB0byBsb2FkIGh0bWwgZGlyZWN0bHksIGVnIHdlIGNhbm5vdCBkbyB0aGlzOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRlbXBsYXRlKVxuICAgICAqL1xuICAgIFV0aWxzLmxvYWRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG4gICAgICAgIHJldHVybiB0ZW1wRGl2LmZpcnN0Q2hpbGQ7XG4gICAgfTtcbiAgICBVdGlscy5hcHBlbmRIdG1sID0gZnVuY3Rpb24gKGVDb250YWluZXIsIGh0bWxUZW1wbGF0ZSkge1xuICAgICAgICBpZiAoZUNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2luc2VydEFkamFjZW50SFRNTFxuICAgICAgICAgICAgLy8gd2UgcHV0IHRoZSBpdGVtcyBhdCB0aGUgc3RhcnQsIHNvIG5ldyBpdGVtcyBhcHBlYXIgdW5kZXJuZWF0aCBvbGQgaXRlbXMsXG4gICAgICAgICAgICAvLyBzbyB3aGVuIGV4cGFuZGluZy9jb2xsYXBzaW5nIGdyb3VwcywgdGhlIG5ldyByb3dzIGRvbid0IGdvIG9uIHRvcCBvZiB0aGVcbiAgICAgICAgICAgIC8vIHJvd3MgYmVsb3cgdGhhdCBhcmUgbW92aW5nIG91ciBvZiB0aGUgd2F5XG4gICAgICAgICAgICBlQ29udGFpbmVyLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJiZWdpbicsIGh0bWxUZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlQ29udGFpbmVyLmlubmVySFRNTCA9IGh0bWxUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMuYWRkT3JSZW1vdmVDc3NDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUsIGFkZE9yUmVtb3ZlKSB7XG4gICAgICAgIGlmIChhZGRPclJlbW92ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRDc3NDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDc3NDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVdGlscy5jYWxsSWZQcmVzZW50ID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMuYWRkQ3NzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghY2xhc3NOYW1lIHx8IGNsYXNzTmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoJyAnKSA+PSAwKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuYWRkQ3NzQ2xhc3MoZWxlbWVudCwgdmFsdWUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NOYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3NzQ2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNzc0NsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjc3NDbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMuY29udGFpbnNDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAvLyBmb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50LmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgLy8gZm9yIG9sZGVyIGJyb3dzZXJzLCBjaGVjayBhZ2FpbnN0IHRoZSBzdHJpbmcgb2YgY2xhc3MgbmFtZXNcbiAgICAgICAgICAgIC8vIGlmIG9ubHkgb25lIGNsYXNzLCBjYW4gY2hlY2sgZm9yIGV4YWN0IG1hdGNoXG4gICAgICAgICAgICB2YXIgb25seUNsYXNzID0gZWxlbWVudC5jbGFzc05hbWUgPT09IGNsYXNzTmFtZTtcbiAgICAgICAgICAgIC8vIGlmIG1hbnkgY2xhc3NlcywgY2hlY2sgZm9yIGNsYXNzIG5hbWUsIHdlIGhhdmUgdG8gcGFkIHdpdGggJyAnIHRvIHN0b3Agb3RoZXJcbiAgICAgICAgICAgIC8vIGNsYXNzIG5hbWVzIHRoYXQgYXJlIGEgc3Vic3RyaW5nIG9mIHRoaXMgY2xhc3NcbiAgICAgICAgICAgIHZhciBjb250YWlucyA9IGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA+PSAwO1xuICAgICAgICAgICAgLy8gdGhlIHBhZGRpbmcgYWJvdmUgdGhlbiBicmVha3Mgd2hlbiBpdCdzIHRoZSBmaXJzdCBvciBsYXN0IGNsYXNzIG5hbWVzXG4gICAgICAgICAgICB2YXIgc3RhcnRzV2l0aENsYXNzID0gZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUgKyAnICcpID09PSAwO1xuICAgICAgICAgICAgdmFyIGVuZHNXaXRoQ2xhc3MgPSBlbGVtZW50LmNsYXNzTmFtZS5sYXN0SW5kZXhPZignICcgKyBjbGFzc05hbWUpID09PSAoZWxlbWVudC5jbGFzc05hbWUubGVuZ3RoIC0gY2xhc3NOYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG9ubHlDbGFzcyB8fCBjb250YWlucyB8fCBzdGFydHNXaXRoQ2xhc3MgfHwgZW5kc1dpdGhDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGl0ZW0gaXMgbm90IGEgbm9kZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVdGlscy5nZXRFbGVtZW50QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBlbGVtZW50LmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLm9mZnNldEhlaWdodCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZWxlbWVudC5jbGllbnRIZWlnaHQgOiAwO1xuICAgIH07XG4gICAgVXRpbHMub2Zmc2V0V2lkdGggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LmNsaWVudFdpZHRoID8gZWxlbWVudC5jbGllbnRXaWR0aCA6IDA7XG4gICAgfTtcbiAgICBVdGlscy5zb3J0TnVtYmVyQXJyYXkgPSBmdW5jdGlvbiAobnVtYmVyQXJyYXkpIHtcbiAgICAgICAgbnVtYmVyQXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICAgIH07XG4gICAgVXRpbHMucmVtb3ZlQ3NzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc05hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBjc3NDbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3NzQ2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgYWxsIGluc3RhbmNlcyBvZiB0aGUgaXRlbSwgbm90IGp1c3QgdGhlIGZpcnN0LCBpbiBjYXNlIGl0J3MgaW4gbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNzc0NsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc0NsYXNzZXMuc3BsaWNlKGNzc0NsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXMuam9pbignICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMucmVtb3ZlUmVwZWF0c0Zyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IGFycmF5Lmxlbmd0aCAtIDI7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgIHZhciB0aGlzT25lTWF0Y2hlcyA9IGFycmF5W2luZGV4XSA9PT0gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG5leHRPbmVNYXRjaGVzID0gYXJyYXlbaW5kZXggKyAxXSA9PT0gb2JqZWN0O1xuICAgICAgICAgICAgaWYgKHRoaXNPbmVNYXRjaGVzICYmIG5leHRPbmVNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4ICsgMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLnJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChhcnJheS5pbmRleE9mKG9iamVjdCkgPj0gMCkge1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGFycmF5LmluZGV4T2Yob2JqZWN0KSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLnJlbW92ZUFsbEZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgdG9SZW1vdmUpIHtcbiAgICAgICAgdG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGFycmF5LmluZGV4T2YoaXRlbSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnNwbGljZShhcnJheS5pbmRleE9mKGl0ZW0pLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBVdGlscy5pbnNlcnRJbnRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIG9iamVjdCwgdG9JbmRleCkge1xuICAgICAgICBhcnJheS5zcGxpY2UodG9JbmRleCwgMCwgb2JqZWN0KTtcbiAgICB9O1xuICAgIFV0aWxzLmluc2VydEFycmF5SW50b0FycmF5ID0gZnVuY3Rpb24gKGRlc3QsIHNyYywgdG9JbmRleCkge1xuICAgICAgICBpZiAodGhpcy5taXNzaW5nKGRlc3QpIHx8IHRoaXMubWlzc2luZyhzcmMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHV0IGl0ZW1zIGluIGJhY2t3YXJkcywgb3RoZXJ3aXNlIGluc2VydGVkIGl0ZW1zIGVuZCB1cCBpbiByZXZlcnNlIG9yZGVyXG4gICAgICAgIGZvciAodmFyIGkgPSBzcmMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gc3JjW2ldO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRJbnRvQXJyYXkoZGVzdCwgaXRlbSwgdG9JbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLm1vdmVJbkFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBvYmplY3RzVG9Nb3ZlLCB0b0luZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGZpcnN0IHRha2Ugb3V0IGl0IGl0ZW1zIGZyb20gdGhlIGFycmF5XG4gICAgICAgIG9iamVjdHNUb01vdmUuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVGcm9tQXJyYXkoYXJyYXksIG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub3cgYWRkIHRoZSBvYmplY3RzLCBpbiBzYW1lIG9yZGVyIGFzIHByb3ZpZGVkIHRvIHVzLCB0aGF0IG1lYW5zIHdlIHN0YXJ0IGF0IHRoZSBlbmRcbiAgICAgICAgLy8gYXMgdGhlIG9iamVjdHMgd2lsbCBiZSBwdXNoZWQgdG8gdGhlIHJpZ2h0IGFzIHRoZXkgYXJlIGluc2VydGVkXG4gICAgICAgIG9iamVjdHNUb01vdmUuc2xpY2UoKS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBfdGhpcy5pbnNlcnRJbnRvQXJyYXkoYXJyYXksIG9iaiwgdG9JbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVXRpbHMuZGVmYXVsdENvbXBhcmF0b3IgPSBmdW5jdGlvbiAodmFsdWVBLCB2YWx1ZUIsIGFjY2VudGVkQ29tcGFyZSkge1xuICAgICAgICBpZiAoYWNjZW50ZWRDb21wYXJlID09PSB2b2lkIDApIHsgYWNjZW50ZWRDb21wYXJlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHZhbHVlQU1pc3NpbmcgPSB2YWx1ZUEgPT09IG51bGwgfHwgdmFsdWVBID09PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB2YWx1ZUJNaXNzaW5nID0gdmFsdWVCID09PSBudWxsIHx8IHZhbHVlQiA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB0aGlzIGlzIGZvciBhZ2dyZWdhdGlvbnMgc3VtIGFuZCBhdmcsIHdoZXJlIHRoZSByZXN1bHQgY2FuIGJlIGEgbnVtYmVyIHRoYXQgaXMgd3JhcHBlZC5cbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGRvIHRoaXMsIHRoZW4gdGhlIHRvU3RyaW5nKCkgdmFsdWUgd291bGQgYmUgdXNlZCwgd2hpY2ggd291bGQgcmVzdWx0IGluXG4gICAgICAgIC8vIHRoZSBzdHJpbmdzIGdldHRpbmcgdXNlZCBpbnN0ZWFkIG9mIHRoZSBudW1iZXJzLlxuICAgICAgICBpZiAodmFsdWVBICYmIHZhbHVlQS50b051bWJlcikge1xuICAgICAgICAgICAgdmFsdWVBID0gdmFsdWVBLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlQiAmJiB2YWx1ZUIudG9OdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlQiA9IHZhbHVlQi50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZUFNaXNzaW5nICYmIHZhbHVlQk1pc3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZUFNaXNzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlQk1pc3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVBID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoIWFjY2VudGVkQ29tcGFyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb1F1aWNrQ29tcGFyZSh2YWx1ZUEsIHZhbHVlQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBsb2NhbCBjb21wYXJlIGFsc28gYWxsb3dzIGNoaW5lc2UgY29tcGFyaXNvbnNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlQS5sb2NhbGVDb21wYXJlKHZhbHVlQik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHNvbWV0aGluZyB3cm9uZyB3aXRoIGxvY2FsZUNvbXBhcmUsIGVnIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgYnJvd3NlciwgdGhlbiBqdXN0IGNvbnRpbnVlIHdpdGggdGhlIHF1aWNrIG9uZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9RdWlja0NvbXBhcmUodmFsdWVBLCB2YWx1ZUIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVBIDwgdmFsdWVCKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWVBID4gdmFsdWVCKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRvUXVpY2tDb21wYXJlKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYSA+IGIgPyAxIDogKGEgPCBiID8gLTEgOiAwKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLmNvbXBhcmVBcnJheXMgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIpIHtcbiAgICAgICAgaWYgKHRoaXMubWlzc2luZyhhcnJheTEpICYmIHRoaXMubWlzc2luZyhhcnJheTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taXNzaW5nKGFycmF5MSkgfHwgdGhpcy5taXNzaW5nKGFycmF5MikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBVdGlscy5lbnN1cmVEb21PcmRlciA9IGZ1bmN0aW9uIChlQ29udGFpbmVyLCBlQ2hpbGQsIGVDaGlsZEJlZm9yZSkge1xuICAgICAgICAvLyBpZiBhbHJlYWR5IGluIHJpZ2h0IG9yZGVyLCBkbyBub3RoaW5nXG4gICAgICAgIGlmIChlQ2hpbGRCZWZvcmUgJiYgZUNoaWxkQmVmb3JlLm5leHRTaWJsaW5nID09PSBlQ2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZUNoaWxkQmVmb3JlKSB7XG4gICAgICAgICAgICBpZiAoZUNoaWxkQmVmb3JlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGJldHdlZW4gdGhlIGVSb3dCZWZvcmUgYW5kIHRoZSByb3cgYWZ0ZXIgaXRcbiAgICAgICAgICAgICAgICBlQ29udGFpbmVyLmluc2VydEJlZm9yZShlQ2hpbGQsIGVDaGlsZEJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBuZXh0U2libGluZyBpcyBtaXNzaW5nLCBtZWFucyBvdGhlciByb3cgaXMgYXQgZW5kLCBzbyBqdXN0IGFwcGVuZCBuZXcgcm93IGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICBlQ29udGFpbmVyLmFwcGVuZENoaWxkKGVDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgcHV0IGF0IHN0YXJ0XG4gICAgICAgICAgICBpZiAoZUNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGl0IGF0IHRoZSBmaXJzdCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGVDb250YWluZXIuaW5zZXJ0QmVmb3JlKGVDaGlsZCwgZUNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMuaW5zZXJ0V2l0aERvbU9yZGVyID0gZnVuY3Rpb24gKGVDb250YWluZXIsIGVDaGlsZCwgZUNoaWxkQmVmb3JlKSB7XG4gICAgICAgIGlmIChlQ2hpbGRCZWZvcmUpIHtcbiAgICAgICAgICAgIGlmIChlQ2hpbGRCZWZvcmUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYmV0d2VlbiB0aGUgZVJvd0JlZm9yZSBhbmQgdGhlIHJvdyBhZnRlciBpdFxuICAgICAgICAgICAgICAgIGVDb250YWluZXIuaW5zZXJ0QmVmb3JlKGVDaGlsZCwgZUNoaWxkQmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5leHRTaWJsaW5nIGlzIG1pc3NpbmcsIG1lYW5zIG90aGVyIHJvdyBpcyBhdCBlbmQsIHNvIGp1c3QgYXBwZW5kIG5ldyByb3cgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgIGVDb250YWluZXIuYXBwZW5kQ2hpbGQoZUNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgaXQgYXQgdGhlIGZpcnN0IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgZUNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZUNoaWxkLCBlQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGVDb250YWluZXIgaXMgZW1wdHksIHNvIGp1c3QgYXBwZW5kIGl0XG4gICAgICAgICAgICAgICAgZUNvbnRhaW5lci5hcHBlbmRDaGlsZChlQ2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBVdGlscy5pbnNlcnRUZW1wbGF0ZVdpdGhEb21PcmRlciA9IGZ1bmN0aW9uIChlQ29udGFpbmVyLCBodG1sVGVtcGxhdGUsIGVDaGlsZEJlZm9yZSkge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoZUNoaWxkQmVmb3JlKSB7XG4gICAgICAgICAgICAvLyBpZiBwcmV2aW91cyBlbGVtZW50IGV4aXN0cywganVzdCBzbG90IGluIGFmdGVyIHRoZSBwcmV2aW91cyBlbGVtZW50XG4gICAgICAgICAgICBlQ2hpbGRCZWZvcmUuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmVuZCcsIGh0bWxUZW1wbGF0ZSk7XG4gICAgICAgICAgICByZXMgPSBlQ2hpbGRCZWZvcmUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZUNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGl0IGF0IHRoZSBmaXJzdCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGVDb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgaHRtbFRlbXBsYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBlQ29udGFpbmVyIGlzIGVtcHR5LCBzbyBqdXN0IGFwcGVuZCBpdFxuICAgICAgICAgICAgICAgIGVDb250YWluZXIuaW5uZXJIVE1MID0gaHRtbFRlbXBsYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gZUNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBVdGlscy50b1N0cmluZ09yTnVsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5leGlzdHModmFsdWUpICYmIHZhbHVlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVdGlscy5mb3JtYXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLmZvcm1hdE51bWJlclR3b0RlY2ltYWxQbGFjZXNBbmRDb21tYXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyB0b29rIHRoaXMgZnJvbTogaHR0cDovL2Jsb2cudG9tcGF3bGFrLm9yZy9udW1iZXItY3VycmVuY3ktZm9ybWF0dGluZy1qYXZhc2NyaXB0XG4gICAgICAgIHJldHVybiAoTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCkgLyAxMDApLnRvU3RyaW5nKCkucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBcIiQxLFwiKTtcbiAgICB9O1xuICAgIC8vIHRoZSBuYXRpdmUgbWV0aG9kIG51bWJlci50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHttaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDB9KSBwdXRzIGluIGRlY2ltYWwgcGxhY2VzIGluIElFLFxuICAgIC8vIHNvIHdlIHVzZSB0aGlzIG1ldGhvZCBpbnN0ZWFkXG4gICAgVXRpbHMuZm9ybWF0TnVtYmVyQ29tbWFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9vayB0aGlzIGZyb206IGh0dHA6Ly9ibG9nLnRvbXBhd2xhay5vcmcvbnVtYmVyLWN1cnJlbmN5LWZvcm1hdHRpbmctamF2YXNjcmlwdFxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiJDEsXCIpO1xuICAgIH07XG4gICAgVXRpbHMucHJlcGVuZERDID0gZnVuY3Rpb24gKHBhcmVudCwgZG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBpZiAodGhpcy5leGlzdHMocGFyZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50RnJhZ21lbnQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgaWNvbiBwcm92aWRlZCwgdXNlIHRoaXMgKGVpdGhlciBhIHN0cmluZywgb3IgYSBmdW5jdGlvbiBjYWxsYmFjaykuXG4gICAgICogaWYgbm90LCB0aGVuIHVzZSB0aGUgZGVmYXVsdCBpY29uIGZyb20gdGhlIHRoZW1lXG4gICAgICovXG4gICAgVXRpbHMuY3JlYXRlSWNvbiA9IGZ1bmN0aW9uIChpY29uTmFtZSwgZ3JpZE9wdGlvbnNXcmFwcGVyLCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIGljb25Db250ZW50cyA9IHRoaXMuY3JlYXRlSWNvbk5vU3BhbihpY29uTmFtZSwgZ3JpZE9wdGlvbnNXcmFwcGVyLCBjb2x1bW4pO1xuICAgICAgICBpZiAoaWNvbkNvbnRlbnRzLmNsYXNzTmFtZS5pbmRleE9mKCdhZy1pY29uJykgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGljb25Db250ZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlUmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgZVJlc3VsdC5hcHBlbmRDaGlsZChpY29uQ29udGVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLmNyZWF0ZUljb25Ob1NwYW4gPSBmdW5jdGlvbiAoaWNvbk5hbWUsIGdyaWRPcHRpb25zV3JhcHBlciwgY29sdW1uKSB7XG4gICAgICAgIHZhciB1c2VyUHJvdmlkZWRJY29uO1xuICAgICAgICAvLyBjaGVjayBjb2wgZm9yIGljb24gZmlyc3RcbiAgICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4uZ2V0Q29sRGVmKCkuaWNvbnMpIHtcbiAgICAgICAgICAgIHVzZXJQcm92aWRlZEljb24gPSBjb2x1bW4uZ2V0Q29sRGVmKCkuaWNvbnNbaWNvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0IG5vdCBpbiBjb2wsIHRyeSBncmlkIG9wdGlvbnNcbiAgICAgICAgaWYgKCF1c2VyUHJvdmlkZWRJY29uICYmIGdyaWRPcHRpb25zV3JhcHBlci5nZXRJY29ucygpKSB7XG4gICAgICAgICAgICB1c2VyUHJvdmlkZWRJY29uID0gZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEljb25zKClbaWNvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBpZiB1c2VyIHByb3ZpZGVkLCB1c2UgaXRcbiAgICAgICAgaWYgKHVzZXJQcm92aWRlZEljb24pIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlclJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlclByb3ZpZGVkSWNvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyUmVzdWx0ID0gdXNlclByb3ZpZGVkSWNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVzZXJQcm92aWRlZEljb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJSZXN1bHQgPSB1c2VyUHJvdmlkZWRJY29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ljb24gZnJvbSBncmlkIG9wdGlvbnMgbmVlZHMgdG8gYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlbmRlcmVyUmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRUZW1wbGF0ZShyZW5kZXJlclJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzTm9kZU9yRWxlbWVudChyZW5kZXJlclJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXJSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnaWNvblJlbmRlcmVyIHNob3VsZCByZXR1cm4gYmFjayBhIHN0cmluZyBvciBhIGRvbSBvYmplY3QnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICB2YXIgY3NzQ2xhc3MgPSB0aGlzLmljb25OYW1lQ2xhc3NNYXBbaWNvbk5hbWVdO1xuICAgICAgICAgICAgaWYgKCFjc3NDbGFzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpY29uTmFtZSArIFwiIGRpZCBub3QgZmluZCBjbGFzc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhZy1pY29uIGFnLWljb24tXCIgKyBjc3NDbGFzcyk7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMuYWRkU3R5bGVzVG9FbGVtZW50ID0gZnVuY3Rpb24gKGVFbGVtZW50LCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFzdHlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGtleUNhbWVsQ2FzZSA9IF90aGlzLmh5cGhlblRvQ2FtZWxDYXNlKGtleSk7XG4gICAgICAgICAgICBlRWxlbWVudC5zdHlsZVtrZXlDYW1lbENhc2VdID0gc3R5bGVzW2tleV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVXRpbHMuaXNIb3Jpem9udGFsU2Nyb2xsU2hvd2luZyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmNsaWVudFdpZHRoIDwgZWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICB9O1xuICAgIFV0aWxzLmlzVmVydGljYWxTY3JvbGxTaG93aW5nID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xpZW50SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfTtcbiAgICBVdGlscy5nZXRTY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgb3V0ZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIG91dGVyLnN0eWxlLndpZHRoID0gXCIxMDBweFwiO1xuICAgICAgICBvdXRlci5zdHlsZS5tc092ZXJmbG93U3R5bGUgPSBcInNjcm9sbGJhclwiOyAvLyBuZWVkZWQgZm9yIFdpbkpTIGFwcHNcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XG4gICAgICAgIHZhciB3aWR0aE5vU2Nyb2xsID0gb3V0ZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8vIGZvcmNlIHNjcm9sbGJhcnNcbiAgICAgICAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSBcInNjcm9sbFwiO1xuICAgICAgICAvLyBhZGQgaW5uZXJkaXZcbiAgICAgICAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaW5uZXIuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgb3V0ZXIuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgICB2YXIgd2lkdGhXaXRoU2Nyb2xsID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8vIHJlbW92ZSBkaXZzXG4gICAgICAgIG91dGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuICAgICAgICByZXR1cm4gd2lkdGhOb1Njcm9sbCAtIHdpZHRoV2l0aFNjcm9sbDtcbiAgICB9O1xuICAgIFV0aWxzLmlzS2V5UHJlc3NlZCA9IGZ1bmN0aW9uIChldmVudCwga2V5VG9DaGVjaykge1xuICAgICAgICB2YXIgcHJlc3NlZEtleSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIHJldHVybiBwcmVzc2VkS2V5ID09PSBrZXlUb0NoZWNrO1xuICAgIH07XG4gICAgVXRpbHMuc2V0VmlzaWJsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCB2aXNpYmxlKSB7XG4gICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDc3NDbGFzcyhlbGVtZW50LCAnYWctaGlkZGVuJywgIXZpc2libGUpO1xuICAgIH07XG4gICAgVXRpbHMuc2V0SGlkZGVuID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhpZGRlbikge1xuICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3MoZWxlbWVudCwgJ2FnLXZpc2liaWxpdHktaGlkZGVuJywgaGlkZGVuKTtcbiAgICB9O1xuICAgIFV0aWxzLmlzQnJvd3NlcklFID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0lFID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNJRSA9IGZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlOyAvLyBBdCBsZWFzdCBJRTZcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc0lFO1xuICAgIH07XG4gICAgVXRpbHMuaXNCcm93c2VyRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFZGdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNFZGdlID0gIXRoaXMuaXNCcm93c2VySUUoKSAmJiAhIXdpbmRvdy5TdHlsZU1lZGlhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzRWRnZTtcbiAgICB9O1xuICAgIFV0aWxzLmlzQnJvd3NlclNhZmFyaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTYWZhcmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGFueVdpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgICAgIC8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FnLWdyaWQvYWctZ3JpZC9pc3N1ZXMvNTUwXG4gICAgICAgICAgICB0aGlzLmlzU2FmYXJpID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFueVdpbmRvdy5IVE1MRWxlbWVudCkuaW5kZXhPZignQ29uc3RydWN0b3InKSA+IDBcbiAgICAgICAgICAgICAgICB8fCAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IFNhZmFyaVJlbW90ZU5vdGlmaWNhdGlvbl1cIjtcbiAgICAgICAgICAgICAgICB9KSghYW55V2luZG93LnNhZmFyaSB8fCBhbnlXaW5kb3cuc2FmYXJpLnB1c2hOb3RpZmljYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FmYXJpO1xuICAgIH07XG4gICAgVXRpbHMuaXNCcm93c2VyQ2hyb21lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nocm9tZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYW55V2luZG93ID0gd2luZG93O1xuICAgICAgICAgICAgdGhpcy5pc0Nocm9tZSA9ICEhYW55V2luZG93LmNocm9tZSAmJiAhIWFueVdpbmRvdy5jaHJvbWUud2Vic3RvcmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaHJvbWU7XG4gICAgfTtcbiAgICBVdGlscy5pc0Jyb3dzZXJGaXJlZm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZpcmVmb3ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGFueVdpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgICAgIHRoaXMuaXNGaXJlZm94ID0gdHlwZW9mIGFueVdpbmRvdy5JbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGaXJlZm94O1xuICAgIH07XG4gICAgLy8gc3JjRWxlbWVudCBpcyBvbmx5IGF2YWlsYWJsZSBpbiBJRS4gSW4gYWxsIG90aGVyIGJyb3dzZXJzIGl0IGlzIHRhcmdldFxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTMwMTY0My9ob3ctY2FuLWktbWFrZS1ldmVudC1zcmNlbGVtZW50LXdvcmstaW4tZmlyZWZveC1hbmQtd2hhdC1kb2VzLWl0LW1lYW5cbiAgICBVdGlscy5nZXRUYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50Tm9UeXBlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBldmVudE5vVHlwZS50YXJnZXQgfHwgZXZlbnROb1R5cGUuc3JjRWxlbWVudDtcbiAgICB9O1xuICAgIFV0aWxzLmlzRWxlbWVudEluRXZlbnRQYXRoID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQgfHwgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IGV4cG9ydHMuXy5nZXRFdmVudFBhdGgoZXZlbnQpO1xuICAgICAgICByZXR1cm4gcGF0aC5pbmRleE9mKGVsZW1lbnQpID49IDA7XG4gICAgfTtcbiAgICBVdGlscy5jcmVhdGVFdmVudFBhdGggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB2YXIgcG9pbnRlciA9IGV4cG9ydHMuXy5nZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgICB3aGlsZSAocG9pbnRlcikge1xuICAgICAgICAgICAgcmVzLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlci5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvLyBmaXJlZm94IGRvZXNuJ3QgaGF2ZSBldmVudC5wYXRoIHNldCwgb3IgYW55IGFsdGVybmF0aXZlIHRvIGl0LCBzbyB3ZSBoYWNrXG4gICAgLy8gaXQgaW4uIHRoaXMgaXMgbmVlZGVkIGFzIGl0J3MgdG8gbGF0ZSB0byB3b3JrIG91dCB0aGUgcGF0aCB3aGVuIHRoZSBpdGVtIGlzXG4gICAgLy8gcmVtb3ZlZCBmcm9tIHRoZSBkb21cbiAgICBVdGlscy5hZGRBZ0dyaWRFdmVudFBhdGggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuX19hZ0dyaWRFdmVudFBhdGggPSB0aGlzLmdldEV2ZW50UGF0aChldmVudCk7XG4gICAgfTtcbiAgICBVdGlscy5nZXRFdmVudFBhdGggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzkyNDU0ODgvZXZlbnQtcGF0aC11bmRlZmluZWQtd2l0aC1maXJlZm94LWFuZC12dWUtanNcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50XG4gICAgICAgIHZhciBldmVudE5vVHlwZSA9IGV2ZW50O1xuICAgICAgICBpZiAoZXZlbnQuZGVlcFBhdGgpIHtcbiAgICAgICAgICAgIC8vIElFIHN1cHBvcnRzIGRlZXAgcGF0aFxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmRlZXBQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnROb1R5cGUucGF0aCkge1xuICAgICAgICAgICAgLy8gQ2hyb21lIHN1cHBvcnRzIHBhdGhcbiAgICAgICAgICAgIHJldHVybiBldmVudE5vVHlwZS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50Tm9UeXBlLmNvbXBvc2VkUGF0aCkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBzdXBwb3J0cyBjb21wb3NlUGF0aFxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50Tm9UeXBlLmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50Tm9UeXBlLl9fYWdHcmlkRXZlbnRQYXRoKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHN1cHBvcnRzIGNvbXBvc2VQYXRoXG4gICAgICAgICAgICByZXR1cm4gZXZlbnROb1R5cGUuX19hZ0dyaWRFdmVudFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhbmQgZmluYWxseSwgaWYgbm9uZSBvZiB0aGUgYWJvdmUgd29ya2VkLFxuICAgICAgICAgICAgLy8gd2UgY3JlYXRlIHRoZSBwYXRoIG91cnNlbHZlc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXZlbnRQYXRoKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXRpbHMuZm9yRWFjaFNuYXBzaG90Rmlyc3QgPSBmdW5jdGlvbiAobGlzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgIHZhciBhcnJheUNvcHkgPSBsaXN0LnNsaWNlKDApO1xuICAgICAgICAgICAgYXJyYXlDb3B5LmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB0YWtlbiBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMzg3MjcvaG93LXRvLWdldC1icm93c2VyLXdpZHRoLXVzaW5nLWphdmFzY3JpcHQtY29kZVxuICAgIFV0aWxzLmdldEJvZHlXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvLyB0YWtlbiBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMzg3MjcvaG93LXRvLWdldC1icm93c2VyLXdpZHRoLXVzaW5nLWphdmFzY3JpcHQtY29kZVxuICAgIFV0aWxzLmdldEJvZHlIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIFV0aWxzLnNldENoZWNrYm94U3RhdGUgPSBmdW5jdGlvbiAoZUNoZWNrYm94LCBzdGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGVDaGVja2JveC5jaGVja2VkID0gc3RhdGU7XG4gICAgICAgICAgICBlQ2hlY2tib3guaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaXNOb2RlU2VsZWN0ZWQgcmV0dXJucyBiYWNrIHVuZGVmaW5lZCBpZiBpdCdzIGEgZ3JvdXAgYW5kIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgLy8gYXJlIGEgbWl4IG9mIHNlbGVjdGVkIGFuZCB1bnNlbGVjdGVkXG4gICAgICAgICAgICBlQ2hlY2tib3guaW5kZXRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLnRyYXZlcnNlTm9kZXNXaXRoS2V5ID0gZnVuY3Rpb24gKG5vZGVzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIga2V5UGFydHMgPSBbXTtcbiAgICAgICAgcmVjdXJzaXZlU2VhcmNoTm9kZXMobm9kZXMpO1xuICAgICAgICBmdW5jdGlvbiByZWN1cnNpdmVTZWFyY2hOb2Rlcyhub2Rlcykge1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleVBhcnRzLnB1c2gobm9kZS5rZXkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5UGFydHMuam9pbignfCcpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZWN1cnNpdmVTZWFyY2hOb2Rlcyhub2RlLmNoaWxkcmVuQWZ0ZXJHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgIGtleVBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3lvdXNzbWFuLzc0NTU3ODA2MjYwOWU4YWNhYzlmXG4gICAgVXRpbHMuY2FtZWxDYXNlVG9IeXBoZW4gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmIChzdHIgPT09IG51bGwgfHwgc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoZykgeyByZXR1cm4gJy0nICsgZ1swXS50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICB9O1xuICAgIC8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjY2MDk3Ny9jb252ZXJ0LWh5cGhlbnMtdG8tY2FtZWwtY2FzZS1jYW1lbGNhc2VcbiAgICBVdGlscy5oeXBoZW5Ub0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKHN0ciA9PT0gbnVsbCB8fCBzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbiAoZykgeyByZXR1cm4gZ1sxXS50b1VwcGVyQ2FzZSgpOyB9KTtcbiAgICB9O1xuICAgIC8vIHBhcyBpbiBhbiBvYmplY3QgZWc6IHtjb2xvcjogJ2JsYWNrJywgdG9wOiAnMjVweCd9IGFuZCBpdCByZXR1cm5zIFwiY29sb3I6IGJsYWNrOyB0b3A6IDI1cHg7XCIgZm9yIGh0bWxcbiAgICBVdGlscy5jc3NTdHlsZU9iamVjdFRvTWFya3VwID0gZnVuY3Rpb24gKHN0eWxlc1RvVXNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghc3R5bGVzVG9Vc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzUGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVyYXRlT2JqZWN0KHN0eWxlc1RvVXNlLCBmdW5jdGlvbiAoc3R5bGVLZXksIHN0eWxlVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZUtleURhc2hlZCA9IF90aGlzLmNhbWVsQ2FzZVRvSHlwaGVuKHN0eWxlS2V5KTtcbiAgICAgICAgICAgIHJlc1BhcnRzLnB1c2goc3R5bGVLZXlEYXNoZWQgKyBcIjogXCIgKyBzdHlsZVZhbHVlICsgXCI7XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc1BhcnRzLmpvaW4oJyAnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NzE2NDY4L2lzLXRoZXJlLWFueS1mdW5jdGlvbi1saWtlLWlzbnVtZXJpYy1pbi1qYXZhc2NyaXB0LXRvLXZhbGlkYXRlLW51bWJlcnNcbiAgICAgKi9cbiAgICBVdGlscy5pc051bWVyaWMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkgJiYgaXNGaW5pdGUodmFsdWUpO1xuICAgIH07XG4gICAgVXRpbHMuZXNjYXBlID0gZnVuY3Rpb24gKHRvRXNjYXBlKSB7XG4gICAgICAgIGlmICh0b0VzY2FwZSA9PT0gbnVsbCB8fCB0b0VzY2FwZSA9PT0gdW5kZWZpbmVkIHx8ICF0b0VzY2FwZS5yZXBsYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9Fc2NhcGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvRXNjYXBlLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBmdW5jdGlvbiAoY2hyKSB7IHJldHVybiBIVE1MX0VTQ0FQRVNbY2hyXTsgfSk7XG4gICAgfTtcbiAgICAvLyBUYWtlbiBmcm9tIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9maXhlZC1kYXRhLXRhYmxlL2Jsb2IvbWFzdGVyL3NyYy92ZW5kb3JfdXBzdHJlYW0vZG9tL25vcm1hbGl6ZVdoZWVsLmpzXG4gICAgLyoqXG4gICAgICogTW91c2Ugd2hlZWwgKGFuZCAyLWZpbmdlciB0cmFja3BhZCkgc3VwcG9ydCBvbiB0aGUgd2ViIHN1Y2tzLiAgSXQgaXNcbiAgICAgKiBjb21wbGljYXRlZCwgdGh1cyB0aGlzIGRvYyBpcyBsb25nIGFuZCAoaG9wZWZ1bGx5KSBkZXRhaWxlZCBlbm91Z2ggdG8gYW5zd2VyXG4gICAgICogeW91ciBxdWVzdGlvbnMuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgbmVlZCB0byByZWFjdCB0byB0aGUgbW91c2Ugd2hlZWwgaW4gYSBwcmVkaWN0YWJsZSB3YXksIHRoaXMgY29kZSBpc1xuICAgICAqIGxpa2UgeW91ciBiZXN0ZXN0IGZyaWVuZC4gKiBodWdzICpcbiAgICAgKlxuICAgICAqIEFzIG9mIHRvZGF5LCB0aGVyZSBhcmUgNCBET00gZXZlbnQgdHlwZXMgeW91IGNhbiBsaXN0ZW4gdG86XG4gICAgICpcbiAgICAgKiAgICd3aGVlbCcgICAgICAgICAgICAgICAgLS0gQ2hyb21lKDMxKyksIEZGKDE3KyksIElFKDkrKVxuICAgICAqICAgJ21vdXNld2hlZWwnICAgICAgICAgICAtLSBDaHJvbWUsIElFKDYrKSwgT3BlcmEsIFNhZmFyaVxuICAgICAqICAgJ01vek1vdXNlUGl4ZWxTY3JvbGwnICAtLSBGRigzLjUgb25seSEpICgyMDEwLTIwMTMpIC0tIGRvbid0IGJvdGhlciFcbiAgICAgKiAgICdET01Nb3VzZVNjcm9sbCcgICAgICAgLS0gRkYoMC45LjcrKSBzaW5jZSAyMDAzXG4gICAgICpcbiAgICAgKiBTbyB3aGF0IHRvIGRvPyAgVGhlIGlzIHRoZSBiZXN0OlxuICAgICAqXG4gICAgICogICBub3JtYWxpemVXaGVlbC5nZXRFdmVudFR5cGUoKTtcbiAgICAgKlxuICAgICAqIEluIHlvdXIgZXZlbnQgY2FsbGJhY2ssIHVzZSB0aGlzIGNvZGUgdG8gZ2V0IHNhbmUgaW50ZXJwcmV0YXRpb24gb2YgdGhlXG4gICAgICogZGVsdGFzLiAgVGhpcyBjb2RlIHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXM6XG4gICAgICpcbiAgICAgKiAgIHNwaW5YICAgLS0gbm9ybWFsaXplZCBzcGluIHNwZWVkICh1c2UgZm9yIHpvb20pIC0geCBwbGFuZVxuICAgICAqICAgc3BpblkgICAtLSBcIiAtIHkgcGxhbmVcbiAgICAgKiAgIHBpeGVsWCAgLS0gbm9ybWFsaXplZCBkaXN0YW5jZSAodG8gcGl4ZWxzKSAtIHggcGxhbmVcbiAgICAgKiAgIHBpeGVsWSAgLS0gXCIgLSB5IHBsYW5lXG4gICAgICpcbiAgICAgKiBXaGVlbCB2YWx1ZXMgYXJlIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyIGFzc3VtaW5nIHlvdSBhcmUgdXNpbmcgdGhlIHdoZWVsIHRvXG4gICAgICogc2Nyb2xsIGEgd2ViIHBhZ2UgYnkgYSBudW1iZXIgb2YgbGluZXMgb3IgcGl4ZWxzIChvciBwYWdlcykuICBWYWx1ZXMgY2FuIHZhcnlcbiAgICAgKiBzaWduaWZpY2FudGx5IG9uIGRpZmZlcmVudCBwbGF0Zm9ybXMgYW5kIGJyb3dzZXJzLCBmb3JnZXR0aW5nIHRoYXQgeW91IGNhblxuICAgICAqIHNjcm9sbCBhdCBkaWZmZXJlbnQgc3BlZWRzLiAgU29tZSBkZXZpY2VzIChsaWtlIHRyYWNrcGFkcykgZW1pdCBtb3JlIGV2ZW50c1xuICAgICAqIGF0IHNtYWxsZXIgaW5jcmVtZW50cyB3aXRoIGZpbmUgZ3JhbnVsYXJpdHksIGFuZCBzb21lIGVtaXQgbWFzc2l2ZSBqdW1wcyB3aXRoXG4gICAgICogbGluZWFyIHNwZWVkIG9yIGFjY2VsZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBkb2VzIGl0cyBiZXN0IHRvIG5vcm1hbGl6ZSB0aGUgZGVsdGFzIGZvciB5b3U6XG4gICAgICpcbiAgICAgKiAgIC0gc3BpbiBpcyB0cnlpbmcgdG8gbm9ybWFsaXplIGhvdyBmYXIgdGhlIHdoZWVsIHdhcyBzcHVuIChvciB0cmFja3BhZFxuICAgICAqICAgICBkcmFnZ2VkKS4gIFRoaXMgaXMgc3VwZXIgdXNlZnVsIGZvciB6b29tIHN1cHBvcnQgd2hlcmUgeW91IHdhbnQgdG9cbiAgICAgKiAgICAgdGhyb3cgYXdheSB0aGUgY2h1bmt5IHNjcm9sbCBzdGVwcyBvbiB0aGUgUEMgYW5kIG1ha2UgdGhvc2UgZXF1YWwgdG9cbiAgICAgKiAgICAgdGhlIHNsb3cgYW5kIHNtb290aCB0aW55IHN0ZXBzIG9uIHRoZSBNYWMuIEtleSBkYXRhOiBUaGlzIGNvZGUgdHJpZXMgdG9cbiAgICAgKiAgICAgcmVzb2x2ZSBhIHNpbmdsZSBzbG93IHN0ZXAgb24gYSB3aGVlbCB0byAxLlxuICAgICAqXG4gICAgICogICAtIHBpeGVsIGlzIG5vcm1hbGl6aW5nIHRoZSBkZXNpcmVkIHNjcm9sbCBkZWx0YSBpbiBwaXhlbCB1bml0cy4gIFlvdSdsbFxuICAgICAqICAgICBnZXQgdGhlIGNyYXp5IGRpZmZlcmVuY2VzIGJldHdlZW4gYnJvd3NlcnMsIGJ1dCBhdCBsZWFzdCBpdCdsbCBiZSBpblxuICAgICAqICAgICBwaXhlbHMhXG4gICAgICpcbiAgICAgKiAgIC0gcG9zaXRpdmUgdmFsdWUgaW5kaWNhdGVzIHNjcm9sbGluZyBET1dOL1JJR0hULCBuZWdhdGl2ZSBVUC9MRUZULiAgVGhpc1xuICAgICAqICAgICBzaG91bGQgdHJhbnNsYXRlIHRvIHBvc2l0aXZlIHZhbHVlIHpvb21pbmcgSU4sIG5lZ2F0aXZlIHpvb21pbmcgT1VULlxuICAgICAqICAgICBUaGlzIG1hdGNoZXMgdGhlIG5ld2VyICd3aGVlbCcgZXZlbnQuXG4gICAgICpcbiAgICAgKiBXaHkgYXJlIHRoZXJlIHNwaW5YLCBzcGluWSAob3IgcGl4ZWxzKT9cbiAgICAgKlxuICAgICAqICAgLSBzcGluWCBpcyBhIDItZmluZ2VyIHNpZGUgZHJhZyBvbiB0aGUgdHJhY2twYWQsIGFuZCBhIHNoaWZ0ICsgd2hlZWwgdHVyblxuICAgICAqICAgICB3aXRoIGEgbW91c2UuICBJdCByZXN1bHRzIGluIHNpZGUtc2Nyb2xsaW5nIGluIHRoZSBicm93c2VyIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiAgIC0gc3BpblkgaXMgd2hhdCB5b3UgZXhwZWN0IC0tIGl0J3MgdGhlIGNsYXNzaWMgYXhpcyBvZiBhIG1vdXNlIHdoZWVsLlxuICAgICAqXG4gICAgICogICAtIEkgZHJvcHBlZCBzcGluWi9waXhlbFouICBJdCBpcyBzdXBwb3J0ZWQgYnkgdGhlIERPTSAzICd3aGVlbCcgZXZlbnQgYW5kXG4gICAgICogICAgIHByb2JhYmx5IGlzIGJ5IGJyb3dzZXJzIGluIGNvbmp1bmN0aW9uIHdpdGggZmFuY3kgM0QgY29udHJvbGxlcnMgLi4gYnV0XG4gICAgICogICAgIHlvdSBrbm93LlxuICAgICAqXG4gICAgICogSW1wbGVtZW50YXRpb24gaW5mbzpcbiAgICAgKlxuICAgICAqIEV4YW1wbGVzIG9mICd3aGVlbCcgZXZlbnQgaWYgeW91IHNjcm9sbCBzbG93bHkgKGRvd24pIGJ5IG9uZSBzdGVwIHdpdGggYW5cbiAgICAgKiBhdmVyYWdlIG1vdXNlOlxuICAgICAqXG4gICAgICogICBPUyBYICsgQ2hyb21lICAobW91c2UpICAgICAtICAgIDQgICBwaXhlbCBkZWx0YSAgKHdoZWVsRGVsdGEgLTEyMClcbiAgICAgKiAgIE9TIFggKyBTYWZhcmkgIChtb3VzZSkgICAgIC0gIE4vQSAgIHBpeGVsIGRlbHRhICAod2hlZWxEZWx0YSAgLTEyKVxuICAgICAqICAgT1MgWCArIEZpcmVmb3ggKG1vdXNlKSAgICAgLSAgICAwLjEgbGluZSAgZGVsdGEgICh3aGVlbERlbHRhICBOL0EpXG4gICAgICogICBXaW44ICsgQ2hyb21lICAobW91c2UpICAgICAtICAxMDAgICBwaXhlbCBkZWx0YSAgKHdoZWVsRGVsdGEgLTEyMClcbiAgICAgKiAgIFdpbjggKyBGaXJlZm94IChtb3VzZSkgICAgIC0gICAgMyAgIGxpbmUgIGRlbHRhICAod2hlZWxEZWx0YSAtMTIwKVxuICAgICAqXG4gICAgICogT24gdGhlIHRyYWNrcGFkOlxuICAgICAqXG4gICAgICogICBPUyBYICsgQ2hyb21lICAodHJhY2twYWQpICAtICAgIDIgICBwaXhlbCBkZWx0YSAgKHdoZWVsRGVsdGEgICAtNilcbiAgICAgKiAgIE9TIFggKyBGaXJlZm94ICh0cmFja3BhZCkgIC0gICAgMSAgIHBpeGVsIGRlbHRhICAod2hlZWxEZWx0YSAgTi9BKVxuICAgICAqXG4gICAgICogT24gb3RoZXIvb2xkZXIgYnJvd3NlcnMuLiBpdCdzIG1vcmUgY29tcGxpY2F0ZWQgYXMgdGhlcmUgY2FuIGJlIG11bHRpcGxlIGFuZFxuICAgICAqIGFsc28gbWlzc2luZyBkZWx0YSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgJ3doZWVsJyBldmVudCBpcyBtb3JlIHN0YW5kYXJkOlxuICAgICAqXG4gICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtd2hlZWxldmVudHNcbiAgICAgKlxuICAgICAqIFRoZSBiYXNpY3MgaXMgdGhhdCBpdCBpbmNsdWRlcyBhIHVuaXQsIGRlbHRhTW9kZSAocGl4ZWxzLCBsaW5lcywgcGFnZXMpLCBhbmRcbiAgICAgKiBkZWx0YVgsIGRlbHRhWSBhbmQgZGVsdGFaLiAgU29tZSBicm93c2VycyBwcm92aWRlIG90aGVyIHZhbHVlcyB0byBtYWludGFpblxuICAgICAqIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBldmVudHMuICBUaG9zZSBvdGhlciB2YWx1ZXMgaGVscCB1c1xuICAgICAqIGJldHRlciBub3JtYWxpemUgc3BpbiBzcGVlZC4gIEV4YW1wbGUgb2Ygd2hhdCB0aGUgYnJvd3NlcnMgcHJvdmlkZTpcbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8IGV2ZW50LndoZWVsRGVsdGEgfCBldmVudC5kZXRhaWxcbiAgICAgKiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLVxuICAgICAqICAgICAgICAgIFNhZmFyaSB2NS9PUyBYICB8ICAgICAgIC0xMjAgICAgICAgfCAgICAgICAwXG4gICAgICogICAgICAgICAgU2FmYXJpIHY1L1dpbjcgIHwgICAgICAgLTEyMCAgICAgICB8ICAgICAgIDBcbiAgICAgKiAgICAgICAgIENocm9tZSB2MTcvT1MgWCAgfCAgICAgICAtMTIwICAgICAgIHwgICAgICAgMFxuICAgICAqICAgICAgICAgQ2hyb21lIHYxNy9XaW43ICB8ICAgICAgIC0xMjAgICAgICAgfCAgICAgICAwXG4gICAgICogICAgICAgICAgICAgICAgSUU5L1dpbjcgIHwgICAgICAgLTEyMCAgICAgICB8ICAgdW5kZWZpbmVkXG4gICAgICogICAgICAgICBGaXJlZm94IHY0L09TIFggIHwgICAgIHVuZGVmaW5lZCAgICB8ICAgICAgIDFcbiAgICAgKiAgICAgICAgIEZpcmVmb3ggdjQvV2luNyAgfCAgICAgdW5kZWZpbmVkICAgIHwgICAgICAgM1xuICAgICAqXG4gICAgICovXG4gICAgVXRpbHMubm9ybWFsaXplV2hlZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIFBJWEVMX1NURVAgPSAxMDtcbiAgICAgICAgdmFyIExJTkVfSEVJR0hUID0gNDA7XG4gICAgICAgIHZhciBQQUdFX0hFSUdIVCA9IDgwMDtcbiAgICAgICAgLy8gc3BpblgsIHNwaW5ZXG4gICAgICAgIHZhciBzWCA9IDA7XG4gICAgICAgIHZhciBzWSA9IDA7XG4gICAgICAgIC8vIHBpeGVsWCwgcGl4ZWxZXG4gICAgICAgIHZhciBwWCA9IDA7XG4gICAgICAgIHZhciBwWSA9IDA7XG4gICAgICAgIC8vIExlZ2FjeVxuICAgICAgICBpZiAoJ2RldGFpbCcgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIHNZID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnd2hlZWxEZWx0YScgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIHNZID0gLWV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCd3aGVlbERlbHRhWScgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIHNZID0gLWV2ZW50LndoZWVsRGVsdGFZIC8gMTIwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnd2hlZWxEZWx0YVgnIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBzWCA9IC1ldmVudC53aGVlbERlbHRhWCAvIDEyMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaWRlIHNjcm9sbGluZyBvbiBGRiB3aXRoIERPTU1vdXNlU2Nyb2xsXG4gICAgICAgIGlmICgnYXhpcycgaW4gZXZlbnQgJiYgZXZlbnQuYXhpcyA9PT0gZXZlbnQuSE9SSVpPTlRBTF9BWElTKSB7XG4gICAgICAgICAgICBzWCA9IHNZO1xuICAgICAgICAgICAgc1kgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHBYID0gc1ggKiBQSVhFTF9TVEVQO1xuICAgICAgICBwWSA9IHNZICogUElYRUxfU1RFUDtcbiAgICAgICAgaWYgKCdkZWx0YVknIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBwWSA9IGV2ZW50LmRlbHRhWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2RlbHRhWCcgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIHBYID0gZXZlbnQuZGVsdGFYO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocFggfHwgcFkpICYmIGV2ZW50LmRlbHRhTW9kZSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcFggKj0gTElORV9IRUlHSFQ7XG4gICAgICAgICAgICAgICAgcFkgKj0gTElORV9IRUlHSFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwWCAqPSBQQUdFX0hFSUdIVDtcbiAgICAgICAgICAgICAgICBwWSAqPSBQQUdFX0hFSUdIVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsLWJhY2sgaWYgc3BpbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFxuICAgICAgICBpZiAocFggJiYgIXNYKSB7XG4gICAgICAgICAgICBzWCA9IChwWCA8IDEpID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwWSAmJiAhc1kpIHtcbiAgICAgICAgICAgIHNZID0gKHBZIDwgMSkgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwaW5YOiBzWCxcbiAgICAgICAgICAgIHNwaW5ZOiBzWSxcbiAgICAgICAgICAgIHBpeGVsWDogcFgsXG4gICAgICAgICAgICBwaXhlbFk6IHBZXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNDAwNDc5MS9jYW4tc29tZW9uZS1leHBsYWluLXRoZS1kZWJvdW5jZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgICovXG4gICAgVXRpbHMuZGVib3VuY2UgPSBmdW5jdGlvbiAoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUgPT09IHZvaWQgMCkgeyBpbW1lZGlhdGUgPSBmYWxzZTsgfVxuICAgICAgICAvLyAncHJpdmF0ZScgdmFyaWFibGUgZm9yIGluc3RhbmNlXG4gICAgICAgIC8vIFRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGJlIGFibGUgdG8gcmVmZXJlbmNlIHRoaXMgZHVlIHRvIGNsb3N1cmUuXG4gICAgICAgIC8vIEVhY2ggY2FsbCB0byB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gd2lsbCBzaGFyZSB0aGlzIGNvbW1vbiB0aW1lci5cbiAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgIC8vIENhbGxpbmcgZGVib3VuY2UgcmV0dXJucyBhIG5ldyBhbm9ueW1vdXMgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZSB0aGUgY29udGV4dCBhbmQgYXJncyBmb3IgdGhlIHNldFRpbWVvdXQgZnVuY3Rpb25cbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIC8vIFNob3VsZCB0aGUgZnVuY3Rpb24gYmUgY2FsbGVkIG5vdz8gSWYgaW1tZWRpYXRlIGlzIHRydWVcbiAgICAgICAgICAgIC8vICAgYW5kIG5vdCBhbHJlYWR5IGluIGEgdGltZW91dCB0aGVuIHRoZSBhbnN3ZXIgaXM6IFllc1xuICAgICAgICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBiYXNpYyBkZWJvdW5jZSBiZWhhdmlvdXIgd2hlcmUgeW91IGNhbiBjYWxsIHRoaXNcbiAgICAgICAgICAgIC8vICAgZnVuY3Rpb24gc2V2ZXJhbCB0aW1lcywgYnV0IGl0IHdpbGwgb25seSBleGVjdXRlIG9uY2VcbiAgICAgICAgICAgIC8vICAgW2JlZm9yZSBvciBhZnRlciBpbXBvc2luZyBhIGRlbGF5XS5cbiAgICAgICAgICAgIC8vICAgRWFjaCB0aW1lIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB0aW1lciBzdGFydHMgb3Zlci5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmV3IHRpbWVvdXRcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNpZGUgdGhlIHRpbWVvdXQgZnVuY3Rpb24sIGNsZWFyIHRoZSB0aW1lb3V0IHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBsZXQgdGhlIG5leHQgZXhlY3V0aW9uIHJ1biB3aGVuIGluICdpbW1lZGlhdGUnIG1vZGVcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZnVuY3Rpb24gYWxyZWFkeSByYW4gd2l0aCB0aGUgaW1tZWRpYXRlIGZsYWdcbiAgICAgICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIGFwcGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGxldHMgeW91IGRlZmluZSB0aGUgJ3RoaXMnIG9iamVjdCBhcyB3ZWxsIGFzIHRoZSBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgKGJvdGggY2FwdHVyZWQgYmVmb3JlIHNldFRpbWVvdXQpXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgd2FpdCk7XG4gICAgICAgICAgICAvLyBJbW1lZGlhdGUgbW9kZSBhbmQgbm8gd2FpdCB0aW1lcj8gRXhlY3V0ZSB0aGUgZnVuY3Rpb24uLlxuICAgICAgICAgICAgaWYgKGNhbGxOb3cpXG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIDtcbiAgICBVdGlscy5leGVjdXRlSW5BV2hpbGUgPSBmdW5jdGlvbiAoZnVuY3MpIHtcbiAgICAgICAgdGhpcy5leGVjdXRlQWZ0ZXIoZnVuY3MsIDQwMCk7XG4gICAgfTtcbiAgICBVdGlscy5leGVjdXRlTmV4dFZNVHVybiA9IGZ1bmN0aW9uIChmdW5jcykge1xuICAgICAgICB0aGlzLmV4ZWN1dGVBZnRlcihmdW5jcywgMCk7XG4gICAgfTtcbiAgICBVdGlscy5leGVjdXRlQWZ0ZXIgPSBmdW5jdGlvbiAoZnVuY3MsIG1pbGxpcykge1xuICAgICAgICBpZiAoZnVuY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3MuZm9yRWFjaChmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gZnVuYygpOyB9KTtcbiAgICAgICAgICAgIH0sIG1pbGxpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLnJlZmVyZW5jZUNvbXBhcmUgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQgPT0gbnVsbCAmJiByaWdodCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChsZWZ0ID09IG51bGwgJiYgcmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChsZWZ0ICYmIHJpZ2h0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgICB9O1xuICAgIFV0aWxzLmdldCA9IGZ1bmN0aW9uIChzb3VyY2UsIGV4cHJlc3Npb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAoc291cmNlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IGV4cHJlc3Npb24uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciB0aGlzS2V5ID0gZmllbGRzWzBdO1xuICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IHNvdXJjZVt0aGlzS2V5XTtcbiAgICAgICAgICAgIGlmIChuZXh0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5nZXQobmV4dFZhbHVlLCBmaWVsZHMuc2xpY2UoMSwgZmllbGRzLmxlbmd0aCkuam9pbignLicpLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSBzb3VyY2VbZXhwcmVzc2lvbl07XG4gICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlICE9IG51bGwgPyBuZXh0VmFsdWUgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFV0aWxzLmFkZFNhZmVQYXNzaXZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlRWxlbWVudCwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCAoVXRpbHMucGFzc2l2ZUV2ZW50cy5pbmRleE9mKGV2ZW50KSA+IC0xID8geyBwYXNzaXZlOiB0cnVlIH0gOiBudWxsKSk7XG4gICAgfTtcbiAgICBVdGlscy5jYW1lbENhc2VUb0h1bWFuVGV4dCA9IGZ1bmN0aW9uIChjYW1lbENhc2UpIHtcbiAgICAgICAgaWYgKGNhbWVsQ2FzZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIFdobyBuZWVkcyB0byBsZWFybiBob3cgdG8gY29kZSB3aGVuIHlvdSBoYXZlIHN0YWNrIG92ZXJmbG93IVxuICAgICAgICAvLyBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTM2OTU2Ni9wdXR0aW5nLXNwYWNlLWluLWNhbWVsLWNhc2Utc3RyaW5nLXVzaW5nLXJlZ3VsYXItZXhwcmVzc2lvblxuICAgICAgICB2YXIgcmV4ID0gLyhbQS1aXSkoW0EtWl0pKFthLXpdKXwoW2Etel0pKFtBLVpdKS9nO1xuICAgICAgICB2YXIgd29yZHMgPSBjYW1lbENhc2UucmVwbGFjZShyZXgsICckMSQ0ICQyJDMkNScpLnJlcGxhY2UoJy4nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgIHJldHVybiB3b3Jkcy5tYXAoZnVuY3Rpb24gKHdvcmQpIHsgcmV0dXJuIHdvcmQuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyAoKHdvcmQubGVuZ3RoID4gMSkgPyB3b3JkLnN1YnN0cmluZygxLCB3b3JkLmxlbmd0aCkgOiAnJyk7IH0pLmpvaW4oJyAnKTtcbiAgICB9O1xuICAgIFV0aWxzLnNvcnRSb3dOb2Rlc0J5T3JkZXIgPSBmdW5jdGlvbiAocm93Tm9kZXMsIHJvd05vZGVPcmRlcikge1xuICAgICAgICBpZiAoIXJvd05vZGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcm93Tm9kZXMuc29ydChmdW5jdGlvbiAobm9kZUEsIG5vZGVCKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BID0gcm93Tm9kZU9yZGVyW25vZGVBLmlkXTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkIgPSByb3dOb2RlT3JkZXJbbm9kZUIuaWRdO1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uQSAtIHBvc2l0aW9uQjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBVdGlscy5QUklOVEFCTEVfQ0hBUkFDVEVSUyA9ICdxd2VydHl1aW9wYXNkZmdoamtsenhjdmJubVFXRVJUWVVJT1BBU0RGR0hKS0xaWENWQk5NMTIzNDU2Nzg5MCFcIsKjJCVeJiooKV8rLT1bXTtcXCcjLC4vXFx8PD4/OkB+e30nO1xuICAgIC8vIHN0YXRpYyBwcmVwZW5kKHBhcmVudDogSFRNTEVsZW1lbnQsIGNoaWxkOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgIC8vICAgICBpZiAodGhpcy5leGlzdHMocGFyZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgLy8gICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuICAgIFV0aWxzLmljb25OYW1lQ2xhc3NNYXAgPSB7XG4gICAgICAgICdjb2x1bW5Nb3ZlUGluJzogJ3BpbicsXG4gICAgICAgICdjb2x1bW5Nb3ZlQWRkJzogJ3BsdXMnLFxuICAgICAgICAnY29sdW1uTW92ZUhpZGUnOiAnZXllLXNsYXNoJyxcbiAgICAgICAgJ2NvbHVtbk1vdmVNb3ZlJzogJ2Fycm93cycsXG4gICAgICAgICdjb2x1bW5Nb3ZlTGVmdCc6ICdsZWZ0JyxcbiAgICAgICAgJ2NvbHVtbk1vdmVSaWdodCc6ICdyaWdodCcsXG4gICAgICAgICdjb2x1bW5Nb3ZlR3JvdXAnOiAnZ3JvdXAnLFxuICAgICAgICAnY29sdW1uTW92ZVZhbHVlJzogJ2FnZ3JlZ2F0aW9uJyxcbiAgICAgICAgJ2NvbHVtbk1vdmVQaXZvdCc6ICdwaXZvdCcsXG4gICAgICAgICdkcm9wTm90QWxsb3dlZCc6ICdub3QtYWxsb3dlZCcsXG4gICAgICAgICdncm91cENvbnRyYWN0ZWQnOiAnZXhwYW5kZWQnLFxuICAgICAgICAnZ3JvdXBFeHBhbmRlZCc6ICdjb250cmFjdGVkJyxcbiAgICAgICAgJ2NoZWNrYm94Q2hlY2tlZCc6ICdjaGVja2JveC1jaGVja2VkJyxcbiAgICAgICAgJ2NoZWNrYm94VW5jaGVja2VkJzogJ2NoZWNrYm94LXVuY2hlY2tlZCcsXG4gICAgICAgICdjaGVja2JveEluZGV0ZXJtaW5hdGUnOiAnY2hlY2tib3gtaW5kZXRlcm1pbmF0ZScsXG4gICAgICAgICdjaGVja2JveENoZWNrZWRSZWFkT25seSc6ICdjaGVja2JveC1jaGVja2VkLXJlYWRvbmx5JyxcbiAgICAgICAgJ2NoZWNrYm94VW5jaGVja2VkUmVhZE9ubHknOiAnY2hlY2tib3gtdW5jaGVja2VkLXJlYWRvbmx5JyxcbiAgICAgICAgJ2NoZWNrYm94SW5kZXRlcm1pbmF0ZVJlYWRPbmx5JzogJ2NoZWNrYm94LWluZGV0ZXJtaW5hdGUtcmVhZG9ubHknLFxuICAgICAgICAnZ3JvdXBMb2FkaW5nJzogJ2xvYWRpbmcnLFxuICAgICAgICAnbWVudSc6ICdtZW51JyxcbiAgICAgICAgJ2ZpbHRlcic6ICdmaWx0ZXInLFxuICAgICAgICAnY29sdW1ucyc6ICdjb2x1bW5zJyxcbiAgICAgICAgJ21lbnVQaW4nOiAncGluJyxcbiAgICAgICAgJ21lbnVWYWx1ZSc6ICdhZ2dyZWdhdGlvbicsXG4gICAgICAgICdtZW51QWRkUm93R3JvdXAnOiAnZ3JvdXAnLFxuICAgICAgICAnbWVudVJlbW92ZVJvd0dyb3VwJzogJ2dyb3VwJyxcbiAgICAgICAgJ2NsaXBib2FyZENvcHknOiAnY29weScsXG4gICAgICAgICdjbGlwYm9hcmRDdXQnOiAnY3V0JyxcbiAgICAgICAgJ2NsaXBib2FyZFBhc3RlJzogJ3Bhc3RlJyxcbiAgICAgICAgJ3Bpdm90UGFuZWwnOiAncGl2b3QnLFxuICAgICAgICAncm93R3JvdXBQYW5lbCc6ICdncm91cCcsXG4gICAgICAgICd2YWx1ZVBhbmVsJzogJ2FnZ3JlZ2F0aW9uJyxcbiAgICAgICAgJ2NvbHVtbkdyb3VwT3BlbmVkJzogJ2V4cGFuZGVkJyxcbiAgICAgICAgJ2NvbHVtbkdyb3VwQ2xvc2VkJzogJ2NvbnRyYWN0ZWQnLFxuICAgICAgICAnY29sdW1uU2VsZWN0Q2xvc2VkJzogJ3RyZWUtY2xvc2VkJyxcbiAgICAgICAgJ2NvbHVtblNlbGVjdE9wZW4nOiAndHJlZS1vcGVuJyxcbiAgICAgICAgLy8gZnJvbSBkZXByZWNhdGVkIGhlYWRlciwgcmVtb3ZlIGF0IHNvbWUgcG9pbnRcbiAgICAgICAgJ3NvcnRBc2NlbmRpbmcnOiAnYXNjJyxcbiAgICAgICAgJ3NvcnREZXNjZW5kaW5nJzogJ2Rlc2MnLFxuICAgICAgICAnc29ydFVuU29ydCc6ICdub25lJ1xuICAgIH07XG4gICAgVXRpbHMucGFzc2l2ZUV2ZW50cyA9IFsndG91Y2hzdGFydCcsICd0b3VjaGVuZCcsICd0b3VjaG1vdmUnLCAndG91Y2hjYW5jZWwnXTtcbiAgICByZXR1cm4gVXRpbHM7XG59KCkpO1xuZXhwb3J0cy5VdGlscyA9IFV0aWxzO1xudmFyIE51bWJlclNlcXVlbmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOdW1iZXJTZXF1ZW5jZShpbml0VmFsdWUsIHN0ZXApIHtcbiAgICAgICAgaWYgKGluaXRWYWx1ZSA9PT0gdm9pZCAwKSB7IGluaXRWYWx1ZSA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMTsgfVxuICAgICAgICB0aGlzLm5leHRWYWx1ZSA9IGluaXRWYWx1ZTtcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICB9XG4gICAgTnVtYmVyU2VxdWVuY2UucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWxUb1JldHVybiA9IHRoaXMubmV4dFZhbHVlO1xuICAgICAgICB0aGlzLm5leHRWYWx1ZSArPSB0aGlzLnN0ZXA7XG4gICAgICAgIHJldHVybiB2YWxUb1JldHVybjtcbiAgICB9O1xuICAgIE51bWJlclNlcXVlbmNlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VmFsdWU7XG4gICAgfTtcbiAgICBOdW1iZXJTZXF1ZW5jZS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICB0aGlzLm5leHRWYWx1ZSArPSBjb3VudDtcbiAgICB9O1xuICAgIHJldHVybiBOdW1iZXJTZXF1ZW5jZTtcbn0oKSk7XG5leHBvcnRzLk51bWJlclNlcXVlbmNlID0gTnVtYmVyU2VxdWVuY2U7XG5leHBvcnRzLl8gPSBVdGlscztcbnZhciBQcm9taXNlU3RhdHVzO1xuKGZ1bmN0aW9uIChQcm9taXNlU3RhdHVzKSB7XG4gICAgUHJvbWlzZVN0YXR1c1tQcm9taXNlU3RhdHVzW1wiSU5fUFJPR1JFU1NcIl0gPSAwXSA9IFwiSU5fUFJPR1JFU1NcIjtcbiAgICBQcm9taXNlU3RhdHVzW1Byb21pc2VTdGF0dXNbXCJSRVNPTFZFRFwiXSA9IDFdID0gXCJSRVNPTFZFRFwiO1xufSkoUHJvbWlzZVN0YXR1cyA9IGV4cG9ydHMuUHJvbWlzZVN0YXR1cyB8fCAoZXhwb3J0cy5Qcm9taXNlU3RhdHVzID0ge30pKTtcbnZhciBQcm9taXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9taXNlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gUHJvbWlzZVN0YXR1cy5JTl9QUk9HUkVTUztcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5saXN0T2ZXYWl0ZXJzID0gW107XG4gICAgICAgIGNhbGxiYWNrKHRoaXMub25Eb25lLmJpbmQodGhpcyksIHRoaXMub25SZWplY3QuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIFByb21pc2UuYWxsID0gZnVuY3Rpb24gKHRvQ29tYmluZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ1RvUmVzb2x2ZSA9IHRvQ29tYmluZS5sZW5ndGg7XG4gICAgICAgICAgICB0b0NvbWJpbmUuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS50aGVuKGZ1bmN0aW9uIChzb3VyY2VSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdUb1Jlc29sdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWRWYWx1ZXNbaW5kZXhdID0gc291cmNlUmVzb2x2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdUb1Jlc29sdmUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjb21iaW5lZFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21iaW5lZFZhbHVlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7IH0pO1xuICAgIH07XG4gICAgUHJvbWlzZS5leHRlcm5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGNhcHR1cmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICByZXNvbHZlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFByb21pc2VTdGF0dXMuSU5fUFJPR1JFU1MpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdE9mV2FpdGVycy5wdXNoKGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnVuYyh0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoYWRhcHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF90aGlzLnRoZW4oZnVuY3Rpb24gKHVubWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhZGFwdGVyKHVubWFwcGVkKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5yZXNvbHZlTm93ID0gZnVuY3Rpb24gKGlmTm90UmVzb2x2ZWRWYWx1ZSwgaWZSZXNvbHZlZCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gUHJvbWlzZVN0YXR1cy5JTl9QUk9HUkVTUylcbiAgICAgICAgICAgIHJldHVybiBpZk5vdFJlc29sdmVkVmFsdWU7XG4gICAgICAgIHJldHVybiBpZlJlc29sdmVkKHRoaXMucmVzb2x1dGlvbik7XG4gICAgfTtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBQcm9taXNlU3RhdHVzLlJFU09MVkVEO1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5saXN0T2ZXYWl0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHdhaXRlcikgeyByZXR1cm4gd2FpdGVyKHZhbHVlKTsgfSk7XG4gICAgfTtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5vblJlamVjdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUQkknKTtcbiAgICB9O1xuICAgIHJldHVybiBQcm9taXNlO1xufSgpKTtcbmV4cG9ydHMuUHJvbWlzZSA9IFByb21pc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9ldmVudFNlcnZpY2VcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgY29tcG9uZW50VXRpbF8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9jb21wb25lbnRVdGlsXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuL2dyaWRBcGlcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIERFRkFVTFRfUk9XX0hFSUdIVCA9IDI1O1xudmFyIERFRkFVTFRfVklFV1BPUlRfUk9XX01PREVMX1BBR0VfU0laRSA9IDU7XG52YXIgREVGQVVMVF9WSUVXUE9SVF9ST1dfTU9ERUxfQlVGRkVSX1NJWkUgPSA1O1xuZnVuY3Rpb24gaXNUcnVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSAndHJ1ZSc7XG59XG5mdW5jdGlvbiB6ZXJvT3JHcmVhdGVyKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB6ZXJvIGdldHMgcmV0dXJuZWQgaWYgbnVtYmVyIGlzIG1pc3Npbmcgb3IgdGhlIHdyb25nIHR5cGVcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBvbmVPckdyZWF0ZXIodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gemVybyBnZXRzIHJldHVybmVkIGlmIG51bWJlciBpcyBtaXNzaW5nIG9yIHRoZSB3cm9uZyB0eXBlXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxufVxudmFyIEdyaWRPcHRpb25zV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JpZE9wdGlvbnNXcmFwcGVyKCkge1xuICAgICAgICB0aGlzLnByb3BlcnR5RXZlbnRTZXJ2aWNlID0gbmV3IGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSgpO1xuICAgICAgICB0aGlzLmRvbURhdGFLZXkgPSAnX19BR18nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBHcmlkT3B0aW9uc1dyYXBwZXJfMSA9IEdyaWRPcHRpb25zV3JhcHBlcjtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmFnV2lyZSA9IGZ1bmN0aW9uIChncmlkQXBpLCBjb2x1bW5BcGkpIHtcbiAgICAgICAgdGhpcy5ncmlkT3B0aW9ucy5hcGkgPSBncmlkQXBpO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zLmNvbHVtbkFwaSA9IGNvbHVtbkFwaTtcbiAgICAgICAgdGhpcy5jaGVja0ZvckRlcHJlY2F0ZWQoKTtcbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbmVlZCB0byByZW1vdmUgdGhlc2UsIGFzIHdlIGRvbid0IG93biB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBncmlkT3B0aW9ucywgd2UgbmVlZCB0b1xuICAgICAgICAvLyByZW1vdmUgdGhlIHJlZmVyZW5jZXMgaW4gY2FzZSB0aGUgdXNlciBrZWVwcyB0aGUgZ3JpZCBvcHRpb25zLCB3ZSB3YW50IHRoZSByZXN0XG4gICAgICAgIC8vIG9mIHRoZSBncmlkIHRvIGJlIHBpY2tlZCB1cCBieSB0aGUgZ2FyYmFnZSBjb2xsZWN0b3JcbiAgICAgICAgdGhpcy5ncmlkT3B0aW9ucy5hcGkgPSBudWxsO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zLmNvbHVtbkFwaSA9IG51bGw7XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhc3luYyA9IHRoaXMudXNlQXN5bmNFdmVudHMoKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkR2xvYmFsTGlzdGVuZXIodGhpcy5nbG9iYWxFdmVudEhhbmRsZXIuYmluZCh0aGlzKSwgYXN5bmMpO1xuICAgICAgICBpZiAodGhpcy5pc0dyb3VwU2VsZWN0c0NoaWxkcmVuKCkgJiYgdGhpcy5pc1N1cHByZXNzUGFyZW50c0luUm93Tm9kZXMoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBncm91cFNlbGVjdHNDaGlsZHJlbiBkb2VzIG5vdCB3b3JrIHd0aCBzdXBwcmVzc1BhcmVudHNJblJvd05vZGVzLCB0aGlzIHNlbGVjdGlvbiBtZXRob2QgbmVlZHMgdGhlIHBhcnQgaW4gcm93Tm9kZSB0byB3b3JrJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNHcm91cFNlbGVjdHNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSb3dTZWxlY3Rpb25NdWx0aSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYWctR3JpZDogcm93U2VsZWN0aW9uIG11c3QgYmUgJ211bHRpcGxlJyBmb3IgZ3JvdXBTZWxlY3RzQ2hpbGRyZW4gdG8gbWFrZSBzZW5zZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUm93TW9kZWxFbnRlcnByaXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGdyb3VwIHNlbGVjdHMgY2hpbGRyZW4gaXMgTk9UIHN1cHBvcnQgZm9yIEVudGVycHJpc2UgUm93IE1vZGVsLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1RoaXMgaXMgYmVjYXVzZSB0aGUgcm93cyBhcmUgbGF6eSBsb2FkZWQsIHNvIHNlbGVjdGluZyBhIGdyb3VwIGlzIG5vdCBwb3NzaWJsZSBhcycgK1xuICAgICAgICAgICAgICAgICAgICAndGhlIGdyaWQgaGFzIG5vIHdheSBvZiBrbm93aW5nIHdoYXQgdGhlIGNoaWxkcmVuIGFyZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0dyb3VwUmVtb3ZlU2luZ2xlQ2hpbGRyZW4oKSAmJiB0aGlzLmlzR3JvdXBIaWRlT3BlblBhcmVudHMoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBncm91cFJlbW92ZVNpbmdsZUNoaWxkcmVuIGFuZCBncm91cEhpZGVPcGVuUGFyZW50cyBkbyBub3Qgd29yayB3aXRoIGVhY2ggb3RoZXIsIHlvdSBuZWVkIHRvIHBpY2sgb25lLiBBbmQgZG9uXFwndCBhc2sgdXMgaG93IHRvIHVzIHRoZXNlIHRvZ2V0aGVyIG9uIG91ciBzdXBwb3J0IGZvcnVtIGVpdGhlciB5b3Ugd2lsbCBnZXQgdGhlIHNhbWUgYW5zd2VyIScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIHRoZSBkb20gZGF0YSwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0RG9tRGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50LCBrZXkpIHtcbiAgICAgICAgdmFyIGRvbURhdGEgPSBlbGVtZW50W3RoaXMuZG9tRGF0YUtleV07XG4gICAgICAgIGlmIChkb21EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tRGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5zZXREb21EYXRhID0gZnVuY3Rpb24gKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRvbURhdGEgPSBlbGVtZW50W3RoaXMuZG9tRGF0YUtleV07XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcoZG9tRGF0YSkpIHtcbiAgICAgICAgICAgIGRvbURhdGEgPSB7fTtcbiAgICAgICAgICAgIGVsZW1lbnRbdGhpcy5kb21EYXRhS2V5XSA9IGRvbURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZG9tRGF0YVtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzRW50ZXJwcmlzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50ZXJwcmlzZTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzUm93U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5yb3dTZWxlY3Rpb24gPT09IFwic2luZ2xlXCIgfHwgdGhpcy5ncmlkT3B0aW9ucy5yb3dTZWxlY3Rpb24gPT09IFwibXVsdGlwbGVcIjsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzUm93RGVzZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5yb3dEZXNlbGVjdGlvbik7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1Jvd1NlbGVjdGlvbk11bHRpID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5yb3dTZWxlY3Rpb24gPT09ICdtdWx0aXBsZSc7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5jb250ZXh0OyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNQaXZvdE1vZGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5waXZvdE1vZGUpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNQaXZvdFRvdGFscyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnBpdm90VG90YWxzKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzUm93TW9kZWxJbmZpbml0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucm93TW9kZWxUeXBlID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuUk9XX01PREVMX1RZUEVfSU5GSU5JVEU7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1Jvd01vZGVsVmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnJvd01vZGVsVHlwZSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX1ZJRVdQT1JUOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNSb3dNb2RlbEVudGVycHJpc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnJvd01vZGVsVHlwZSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0VOVEVSUFJJU0U7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1Jvd01vZGVsRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMubWlzc2luZyh0aGlzLmdyaWRPcHRpb25zLnJvd01vZGVsVHlwZSkgfHxcbiAgICAgICAgICAgIHRoaXMuZ3JpZE9wdGlvbnMucm93TW9kZWxUeXBlID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuUk9XX01PREVMX1RZUEVfSU5fTUVNT1JZIHx8XG4gICAgICAgICAgICB0aGlzLmdyaWRPcHRpb25zLnJvd01vZGVsVHlwZSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLkRFUFJFQ0FURURfUk9XX01PREVMX1RZUEVfTk9STUFMO1xuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0Z1bGxSb3dFZGl0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5lZGl0VHlwZSA9PT0gJ2Z1bGxSb3cnOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTdXBwcmVzc0ZvY3VzQWZ0ZXJSZWZyZXNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NGb2N1c0FmdGVyUmVmcmVzaCk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1Nob3dUb29sUGFuZWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zaG93VG9vbFBhbmVsKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzVG9vbFBhbmVsU3VwcHJlc3NWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy50b29sUGFuZWxTdXBwcmVzc1ZhbHVlcyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1Rvb2xQYW5lbFN1cHByZXNzUGl2b3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3ZSBkb24ndCBhbGxvdyBwaXZvdHMgd2hlbiBkb2luZyB0cmVlIGRhdGFcbiAgICAgICAgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnRvb2xQYW5lbFN1cHByZXNzUGl2b3RzKSB8fCB0aGlzLmlzVHJlZURhdGEoKTtcbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNUb29sUGFuZWxTdXBwcmVzc1Jvd0dyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgYWxsb3cgcm93IGdyb3VwaW5nIHdoZW4gZG9pbmcgdHJlZSBkYXRhXG4gICAgICAgIHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy50b29sUGFuZWxTdXBwcmVzc1Jvd0dyb3VwcykgfHwgdGhpcy5pc1RyZWVEYXRhKCk7XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzVG9vbFBhbmVsU3VwcHJlc3NQaXZvdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy50b29sUGFuZWxTdXBwcmVzc1Bpdm90TW9kZSkgfHwgdGhpcy5pc1RyZWVEYXRhKCk7XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NUb3VjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzVG91Y2gpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUudXNlQXN5bmNFdmVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NBc3luY0V2ZW50cyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0VuYWJsZUNlbGxDaGFuZ2VGbGFzaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmVuYWJsZUNlbGxDaGFuZ2VGbGFzaCk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0dyb3VwU2VsZWN0c0NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuZ3JvdXBTZWxlY3RzQ2hpbGRyZW4pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHRoaXMuaXNUcmVlRGF0YSgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGdyb3VwU2VsZWN0c0NoaWxkcmVuIGRvZXMgbm90IHdvcmsgd2l0aCB0cmVlIGRhdGEnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNHcm91cFNlbGVjdHNGaWx0ZXJlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmdyb3VwU2VsZWN0c0ZpbHRlcmVkKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzR3JvdXBIaWRlT3BlblBhcmVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5ncm91cEhpZGVPcGVuUGFyZW50cyk7IH07XG4gICAgLy8gaWYgd2UgYXJlIGRvaW5nIGhpZGVPcGVuUGFyZW50cywgdGhlbiB3ZSBhbHdheXMgaGF2ZSBncm91cE11bHRpQXV0b0NvbHVtbiwgb3RoZXJ3aXNlIGhpZGVPcGVuUGFyZW50cyB3b3VsZCBub3Qgd29ya1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNHcm91cE11bHRpQXV0b0NvbHVtbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmdyb3VwTXVsdGlBdXRvQ29sdW1uKSB8fCBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5ncm91cEhpZGVPcGVuUGFyZW50cyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0dyb3VwUmVtb3ZlU2luZ2xlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5ncm91cFJlbW92ZVNpbmdsZUNoaWxkcmVuKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzR3JvdXBSZW1vdmVMb3dlc3RTaW5nbGVDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmdyb3VwUmVtb3ZlTG93ZXN0U2luZ2xlQ2hpbGRyZW4pOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNHcm91cEluY2x1ZGVGb290ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5ncm91cEluY2x1ZGVGb290ZXIpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNHcm91cFN1cHByZXNzQmxhbmtIZWFkZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5ncm91cFN1cHByZXNzQmxhbmtIZWFkZXIpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTdXBwcmVzc1Jvd0NsaWNrU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NSb3dDbGlja1NlbGVjdGlvbik7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzQ2VsbFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzQ2VsbFNlbGVjdGlvbik7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzTXVsdGlTb3J0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NNdWx0aVNvcnQpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNHcm91cFN1cHByZXNzQXV0b0NvbHVtbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmdyb3VwU3VwcHJlc3NBdXRvQ29sdW1uKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NEcmFnTGVhdmVIaWRlc0NvbHVtbnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdXBwcmVzc0RyYWdMZWF2ZUhpZGVzQ29sdW1ucyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzU2Nyb2xsT25OZXdEYXRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NTY3JvbGxPbk5ld0RhdGEpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNGb3JQcmludCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZG9tTGF5b3V0ID09PSAnZm9yUHJpbnQnOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNBdXRvSGVpZ2h0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5kb21MYXlvdXQgPT09ICdhdXRvSGVpZ2h0JzsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NIb3Jpem9udGFsU2Nyb2xsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NIb3Jpem9udGFsU2Nyb2xsKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NMb2FkaW5nT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzTG9hZGluZ092ZXJsYXkpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTdXBwcmVzc05vUm93c092ZXJsYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdXBwcmVzc05vUm93c092ZXJsYXkpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTdXBwcmVzc0ZpZWxkRG90Tm90YXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdXBwcmVzc0ZpZWxkRG90Tm90YXRpb24pOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0UGlubmVkVG9wUm93RGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucGlubmVkVG9wUm93RGF0YTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFBpbm5lZEJvdHRvbVJvd0RhdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnBpbm5lZEJvdHRvbVJvd0RhdGE7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0Z1bmN0aW9uc1Bhc3NpdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5mdW5jdGlvbnNQYXNzaXZlKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NUYWJiaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NUYWJiaW5nKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NDaGFuZ2VEZXRlY3Rpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdXBwcmVzc0NoYW5nZURldGVjdGlvbik7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdXBwcmVzc0FuaW1hdGlvbkZyYW1lKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFF1aWNrRmlsdGVyVGV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucXVpY2tGaWx0ZXJUZXh0OyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNDYWNoZVF1aWNrRmlsdGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuY2FjaGVRdWlja0ZpbHRlcik7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1VuU29ydEljb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy51blNvcnRJY29uKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NNZW51SGlkZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzTWVudUhpZGUpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Um93U3R5bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnJvd1N0eWxlOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Um93Q2xhc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnJvd0NsYXNzOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Um93U3R5bGVGdW5jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5nZXRSb3dTdHlsZTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFJvd0NsYXNzRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZ2V0Um93Q2xhc3M7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5yb3dDbGFzc1J1bGVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5yb3dDbGFzc1J1bGVzOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0UG9zdFByb2Nlc3NQb3B1cEZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnBvc3RQcm9jZXNzUG9wdXA7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXREb2VzRGF0YUZsb3dlckZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmRvZXNEYXRhRmxvd2VyOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0UGFnaW5hdGlvbk51bWJlckZvcm1hdHRlckZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnBhZ2luYXRpb25OdW1iZXJGb3JtYXR0ZXI7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRDaGlsZENvdW50RnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZ2V0Q2hpbGRDb3VudDsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldElzRnVsbFdpZHRoQ2VsbEZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmlzRnVsbFdpZHRoQ2VsbDsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldEZ1bGxXaWR0aENlbGxSZW5kZXJlclBhcmFtcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZnVsbFdpZHRoQ2VsbFJlbmRlcmVyUGFyYW1zOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNFbWJlZEZ1bGxXaWR0aFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIGF1dG9IZWlnaHQsIHdlIGFsd2F5cyBlbWJlZCBmdWxsV2lkdGggcm93cywgb3RoZXJ3aXNlIHdlIGxldCB0aGUgdXNlciBkZWNpZGVcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBdXRvSGVpZ2h0KCkgfHwgaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuZW1iZWRGdWxsV2lkdGhSb3dzKTtcbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0QnVzaW5lc3NLZXlGb3JOb2RlRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZ2V0QnVzaW5lc3NLZXlGb3JOb2RlOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0SGVhZGVyQ2VsbFJlbmRlcmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5oZWFkZXJDZWxsUmVuZGVyZXI7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRBcGkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmFwaTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldENvbHVtbkFwaSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuY29sdW1uQXBpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNEZWx0YVJvd0RhdGFNb2RlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuZGVsdGFSb3dEYXRhTW9kZSk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0Vuc3VyZURvbU9yZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuZW5zdXJlRG9tT3JkZXIpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNFbmFibGVDb2xSZXNpemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5lbmFibGVDb2xSZXNpemUpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTaW5nbGVDbGlja0VkaXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zaW5nbGVDbGlja0VkaXQpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTdXBwcmVzc0NsaWNrRWRpdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzQ2xpY2tFZGl0KTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3RvcEVkaXRpbmdXaGVuR3JpZExvc2VzRm9jdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdG9wRWRpdGluZ1doZW5HcmlkTG9zZXNGb2N1cyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRHcm91cERlZmF1bHRFeHBhbmRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZ3JvdXBEZWZhdWx0RXhwYW5kZWQ7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRNYXhDb25jdXJyZW50RGF0YXNvdXJjZVJlcXVlc3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5tYXhDb25jdXJyZW50RGF0YXNvdXJjZVJlcXVlc3RzOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0TWF4QmxvY2tzSW5DYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMubWF4QmxvY2tzSW5DYWNoZTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldENhY2hlT3ZlcmZsb3dTaXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5jYWNoZU92ZXJmbG93U2l6ZTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFBhZ2luYXRpb25QYWdlU2l6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucGFnaW5hdGlvblBhZ2VTaXplOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Q2FjaGVCbG9ja1NpemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmNhY2hlQmxvY2tTaXplOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0SW5maW5pdGVJbml0aWFsUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmluZmluaXRlSW5pdGlhbFJvd0NvdW50OyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNQdXJnZUNsb3NlZFJvd05vZGVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMucHVyZ2VDbG9zZWRSb3dOb2Rlcyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzUGFnaW5hdGlvblBhbmVsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NQYWdpbmF0aW9uUGFuZWwpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Um93RGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucm93RGF0YTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzR3JvdXBVc2VFbnRpcmVSb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5ncm91cFVzZUVudGlyZVJvdyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0VuYWJsZVJ0bCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmVuYWJsZVJ0bCk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRBdXRvR3JvdXBDb2x1bW5EZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmF1dG9Hcm91cENvbHVtbkRlZjsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzR3JvdXBTdXBwcmVzc1JvdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmdyb3VwU3VwcHJlc3NSb3cpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Um93R3JvdXBQYW5lbFNob3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnJvd0dyb3VwUGFuZWxTaG93OyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0UGl2b3RQYW5lbFNob3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnBpdm90UGFuZWxTaG93OyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNBbmd1bGFyQ29tcGlsZVJvd3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5hbmd1bGFyQ29tcGlsZVJvd3MpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNBbmd1bGFyQ29tcGlsZUZpbHRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5hbmd1bGFyQ29tcGlsZUZpbHRlcnMpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNBbmd1bGFyQ29tcGlsZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5hbmd1bGFyQ29tcGlsZUhlYWRlcnMpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNEZWJ1ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmRlYnVnKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldENvbHVtbkRlZnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmNvbHVtbkRlZnM7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRDb2x1bW5UeXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuY29sdW1uVHlwZXM7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXREYXRhc291cmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5kYXRhc291cmNlOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnREYXRhc291cmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy52aWV3cG9ydERhdGFzb3VyY2U7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRFbnRlcnByaXNlRGF0YXNvdXJjZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZW50ZXJwcmlzZURhdGFzb3VyY2U7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0VuYWJsZVNvcnRpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5lbmFibGVTb3J0aW5nKSB8fCBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5lbmFibGVTZXJ2ZXJTaWRlU29ydGluZyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0FjY2VudGVkU29ydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmFjY2VudGVkU29ydCk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0VuYWJsZUNlbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmVuYWJsZUNlbGxFeHByZXNzaW9ucyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0VuYWJsZUdyb3VwRWRpdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmVuYWJsZUdyb3VwRWRpdCk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzTWlkZGxlQ2xpY2tTY3JvbGxzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NNaWRkbGVDbGlja1Njcm9sbHMpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTdXBwcmVzc1ByZXZlbnREZWZhdWx0T25Nb3VzZVdoZWVsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NQcmV2ZW50RGVmYXVsdE9uTW91c2VXaGVlbCk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzQ29sdW1uVmlydHVhbGlzYXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdXBwcmVzc0NvbHVtblZpcnR1YWxpc2F0aW9uKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NDb250ZXh0TWVudSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzQ29udGV4dE1lbnUpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNBbGxvd0NvbnRleHRNZW51V2l0aENvbnRyb2xLZXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5hbGxvd0NvbnRleHRNZW51V2l0aENvbnRyb2xLZXkpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTdXBwcmVzc0NvcHlSb3dzVG9DbGlwYm9hcmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdXBwcmVzc0NvcHlSb3dzVG9DbGlwYm9hcmQpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNFbmFibGVGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5lbmFibGVGaWx0ZXIpIHx8IGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmVuYWJsZVNlcnZlclNpZGVGaWx0ZXIpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNQYWdpbmF0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMucGFnaW5hdGlvbik7IH07XG4gICAgLy8gdGhlc2UgYXJlIGRlcHJlY2F0ZWQsIHNob3VsZCByZW1vdmUgdGhlbSB3aGVuIHdlIHRha2Ugb3V0IHNlcnZlciBzaWRlIHBhZ2luYXRpb25cbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzRW5hYmxlU2VydmVyU2lkZUZpbHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZW5hYmxlU2VydmVyU2lkZUZpbHRlcjsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzRW5hYmxlU2VydmVyU2lkZVNvcnRpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5lbmFibGVTZXJ2ZXJTaWRlU29ydGluZyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzTW92YWJsZUNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdXBwcmVzc01vdmFibGVDb2x1bW5zKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzQW5pbWF0ZVJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5ldmVyIGFsbG93IGFuaW1hdGluZyBpZiBlbmZvcmNpbmcgdGhlIHJvdyBvcmRlclxuICAgICAgICBpZiAodGhpcy5pc0Vuc3VyZURvbU9yZGVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuYW5pbWF0ZVJvd3MpO1xuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzQ29sdW1uTW92ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzQ29sdW1uTW92ZUFuaW1hdGlvbik7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzQWdnRnVuY0luSGVhZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NBZ2dGdW5jSW5IZWFkZXIpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTdXBwcmVzc0FnZ0F0Um9vdExldmVsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuc3VwcHJlc3NBZ2dBdFJvb3RMZXZlbCk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0VuYWJsZVJhbmdlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuZW5hYmxlUmFuZ2VTZWxlY3Rpb24pOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNQYWdpbmF0aW9uQXV0b1BhZ2VTaXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMucGFnaW5hdGlvbkF1dG9QYWdlU2l6ZSk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1JlbWVtYmVyR3JvdXBTdGF0ZVdoZW5OZXdEYXRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMucmVtZW1iZXJHcm91cFN0YXRlV2hlbk5ld0RhdGEpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0SWNvbnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmljb25zOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0QWdnRnVuY3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmFnZ0Z1bmNzOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0U29ydGluZ09yZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5zb3J0aW5nT3JkZXI7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRBbGlnbmVkR3JpZHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmFsaWduZWRHcmlkczsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldEdyb3VwUm93UmVuZGVyZXJQYXJhbXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmdyb3VwUm93UmVuZGVyZXJQYXJhbXM7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRPdmVybGF5TG9hZGluZ1RlbXBsYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5vdmVybGF5TG9hZGluZ1RlbXBsYXRlOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0T3ZlcmxheU5vUm93c1RlbXBsYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5vdmVybGF5Tm9Sb3dzVGVtcGxhdGU7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc1N1cHByZXNzQXV0b1NpemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5zdXBwcmVzc0F1dG9TaXplKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NQYXJlbnRzSW5Sb3dOb2RlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzUGFyZW50c0luUm93Tm9kZXMpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNFbmFibGVTdGF0dXNCYXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1RydWUodGhpcy5ncmlkT3B0aW9ucy5lbmFibGVTdGF0dXNCYXIpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNBbHdheXNTaG93U3RhdHVzQmFyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuYWx3YXlzU2hvd1N0YXR1c0Jhcik7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0Z1bmN0aW9uc1JlYWRPbmx5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMuZnVuY3Rpb25zUmVhZE9ubHkpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNGbG9hdGluZ0ZpbHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZmxvYXRpbmdGaWx0ZXI7IH07XG4gICAgLy8gcHVibGljIGlzRmxvYXRpbmdGaWx0ZXIoKTogYm9vbGVhbiB7IHJldHVybiB0cnVlOyB9XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXREZWZhdWx0Q29sRGVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5kZWZhdWx0Q29sRGVmOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0RGVmYXVsdENvbEdyb3VwRGVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5kZWZhdWx0Q29sR3JvdXBEZWY7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXREZWZhdWx0RXhwb3J0UGFyYW1zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5kZWZhdWx0RXhwb3J0UGFyYW1zOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNTdXBwcmVzc0NzdkV4cG9ydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzQ3N2RXhwb3J0KTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzU3VwcHJlc3NFeGNlbEV4cG9ydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnN1cHByZXNzRXhjZWxFeHBvcnQpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0SGVhZGVyQ2VsbFRlbXBsYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5oZWFkZXJDZWxsVGVtcGxhdGU7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRIZWFkZXJDZWxsVGVtcGxhdGVGdW5jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5nZXRIZWFkZXJDZWxsVGVtcGxhdGU7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXROb2RlQ2hpbGREZXRhaWxzRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZ2V0Tm9kZUNoaWxkRGV0YWlsczsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldERhdGFQYXRoRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZ2V0RGF0YVBhdGg7IH07XG4gICAgLy8gcHVibGljIGdldElzR3JvdXBGdW5jKCk6ICgoZGF0YUl0ZW06IGFueSkgPT4gYm9vbGVhbikgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5pc0dyb3VwIH1cbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldEdyb3VwUm93QWdnTm9kZXNGdW5jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5ncm91cFJvd0FnZ05vZGVzOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Q29udGV4dE1lbnVJdGVtc0Z1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmdldENvbnRleHRNZW51SXRlbXM7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRNYWluTWVudUl0ZW1zRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuZ2V0TWFpbk1lbnVJdGVtczsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFJvd05vZGVJZEZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmdldFJvd05vZGVJZDsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldE5hdmlnYXRlVG9OZXh0Q2VsbEZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLm5hdmlnYXRlVG9OZXh0Q2VsbDsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFRhYlRvTmV4dENlbGxGdW5jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy50YWJUb05leHRDZWxsOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNUcmVlRGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnRyZWVEYXRhKTsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzVmFsdWVDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLnZhbHVlQ2FjaGUpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNWYWx1ZUNhY2hlTmV2ZXJFeHBpcmVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNUcnVlKHRoaXMuZ3JpZE9wdGlvbnMudmFsdWVDYWNoZU5ldmVyRXhwaXJlcyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5pc0FnZ3JlZ2F0ZU9ubHlDaGFuZ2VkQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJ1ZSh0aGlzLmdyaWRPcHRpb25zLmFnZ3JlZ2F0ZU9ubHlDaGFuZ2VkQ29sdW1ucyk7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRQcm9jZXNzU2Vjb25kYXJ5Q29sRGVmRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucHJvY2Vzc1NlY29uZGFyeUNvbERlZjsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFByb2Nlc3NTZWNvbmRhcnlDb2xHcm91cERlZkZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnByb2Nlc3NTZWNvbmRhcnlDb2xHcm91cERlZjsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFNlbmRUb0NsaXBib2FyZEZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnNlbmRUb0NsaXBib2FyZDsgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFByb2Nlc3NSb3dQb3N0Q3JlYXRlRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucHJvY2Vzc1Jvd1Bvc3RDcmVhdGU7IH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRQcm9jZXNzQ2VsbEZvckNsaXBib2FyZEZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLnByb2Nlc3NDZWxsRm9yQ2xpcGJvYXJkOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0UHJvY2Vzc0NlbGxGcm9tQ2xpcGJvYXJkRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucHJvY2Vzc0NlbGxGcm9tQ2xpcGJvYXJkOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnRSb3dNb2RlbFBhZ2VTaXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb25lT3JHcmVhdGVyKHRoaXMuZ3JpZE9wdGlvbnMudmlld3BvcnRSb3dNb2RlbFBhZ2VTaXplLCBERUZBVUxUX1ZJRVdQT1JUX1JPV19NT0RFTF9QQUdFX1NJWkUpOyB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnRSb3dNb2RlbEJ1ZmZlclNpemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB6ZXJvT3JHcmVhdGVyKHRoaXMuZ3JpZE9wdGlvbnMudmlld3BvcnRSb3dNb2RlbEJ1ZmZlclNpemUsIERFRkFVTFRfVklFV1BPUlRfUk9XX01PREVMX0JVRkZFUl9TSVpFKTsgfTtcbiAgICAvLyBwdWJsaWMgZ2V0Q2VsbFJlbmRlcmVycygpOiB7W2tleTogc3RyaW5nXToge25ldygpOiBJQ2VsbFJlbmRlcmVyfSB8IElDZWxsUmVuZGVyZXJGdW5jfSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmNlbGxSZW5kZXJlcnM7IH1cbiAgICAvLyBwdWJsaWMgZ2V0Q2VsbEVkaXRvcnMoKToge1trZXk6IHN0cmluZ106IHtuZXcoKTogSUNlbGxFZGl0b3J9fSB7IHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmNlbGxFZGl0b3JzOyB9XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRDbGlwYm9hcmREZWxpbWluYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMuZ3JpZE9wdGlvbnMuY2xpcGJvYXJkRGVsaW1pbmF0b3IpID8gdGhpcy5ncmlkT3B0aW9ucy5jbGlwYm9hcmREZWxpbWluYXRvciA6ICdcXHQnO1xuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBncmlkT3B0aW9uc05vVHlwZSA9IHRoaXMuZ3JpZE9wdGlvbnM7XG4gICAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gZ3JpZE9wdGlvbnNOb1R5cGVba2V5XTtcbiAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBncmlkT3B0aW9uc05vVHlwZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBrZXksXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBwcmV2aW91c1ZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoa2V5LCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnByb3BlcnR5RXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoa2V5LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoa2V5LCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnByb3BlcnR5RXZlbnRTZXJ2aWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldEF1dG9TaXplUGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmdyaWRPcHRpb25zLmF1dG9TaXplUGFkZGluZztcbiAgICAgICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJyAmJiBwYWRkaW5nID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGVjaWFsRm9yTmV3TWF0ZXJpYWwoNCwgOCAqIDMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRIZWFkZXJIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ncmlkT3B0aW9ucy5oZWFkZXJIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5oZWFkZXJIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGVjaWFsRm9yTmV3TWF0ZXJpYWwoMjUsIDggKiA3KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRGbG9hdGluZ0ZpbHRlcnNIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ncmlkT3B0aW9ucy5mbG9hdGluZ0ZpbHRlcnNIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5mbG9hdGluZ0ZpbHRlcnNIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGVjaWFsRm9yTmV3TWF0ZXJpYWwoMjUsIDggKiA3KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRHcm91cFBhZGRpbmdTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjaWFsRm9yTmV3TWF0ZXJpYWwoMTAsIDE4ICsgOCAqIDMpO1xuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRGb290ZXJQYWRkaW5nQWRkaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWNpYWxGb3JOZXdNYXRlcmlhbCgxNSwgMzIpO1xuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRMZWFmTm9kZVBhZGRpbmdBZGRpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlY2lhbEZvck5ld01hdGVyaWFsKDEwLCAyNCk7XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldEdyb3VwSGVhZGVySGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ3JpZE9wdGlvbnMuZ3JvdXBIZWFkZXJIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5ncm91cEhlYWRlckhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRlckhlaWdodCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFBpdm90SGVhZGVySGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ3JpZE9wdGlvbnMucGl2b3RIZWFkZXJIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5waXZvdEhlYWRlckhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRlckhlaWdodCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFBpdm90R3JvdXBIZWFkZXJIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ncmlkT3B0aW9ucy5waXZvdEdyb3VwSGVhZGVySGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucGl2b3RHcm91cEhlYWRlckhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEdyb3VwSGVhZGVySGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNFeHRlcm5hbEZpbHRlclByZXNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ncmlkT3B0aW9ucy5pc0V4dGVybmFsRmlsdGVyUHJlc2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMuaXNFeHRlcm5hbEZpbHRlclByZXNlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5kb2VzRXh0ZXJuYWxGaWx0ZXJQYXNzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdyaWRPcHRpb25zLmRvZXNFeHRlcm5hbEZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmRvZXNFeHRlcm5hbEZpbHRlclBhc3Mobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIHVzZXIgaXMgcHJvdmlkaW5nIGRvY3VtZW50LCB3ZSB1c2UgdGhlIHVzZXJzIG9uZSxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHVzZSB0aGUgZG9jdW1lbnQgb24gdGhlIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyh0aGlzLmdyaWRPcHRpb25zLmdldERvY3VtZW50KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5ncmlkT3B0aW9ucy5nZXREb2N1bWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldExheW91dEludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ3JpZE9wdGlvbnMubGF5b3V0SW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5sYXlvdXRJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5Db25zdGFudHMuTEFZT1VUX0lOVEVSVkFMO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldE1pbkNvbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9ucy5taW5Db2xXaWR0aCA+IEdyaWRPcHRpb25zV3JhcHBlcl8xLk1JTl9DT0xfV0lEVEgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWRPcHRpb25zLm1pbkNvbFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEdyaWRPcHRpb25zV3JhcHBlcl8xLk1JTl9DT0xfV0lEVEg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0TWF4Q29sV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zLm1heENvbFdpZHRoID4gR3JpZE9wdGlvbnNXcmFwcGVyXzEuTUlOX0NPTF9XSURUSCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMubWF4Q29sV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRDb2xXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdyaWRPcHRpb25zLmNvbFdpZHRoICE9PSAnbnVtYmVyJyB8fCB0aGlzLmdyaWRPcHRpb25zLmNvbFdpZHRoIDwgR3JpZE9wdGlvbnNXcmFwcGVyXzEuTUlOX0NPTF9XSURUSCkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmNvbFdpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFJvd0J1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdyaWRPcHRpb25zLnJvd0J1ZmZlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zLnJvd0J1ZmZlciA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IHJvd0J1ZmZlciBzaG91bGQgbm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5yb3dCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19CVUZGRVJfU0laRTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gdGhlIHVzZXIgbWlnaHQgYmUgdXNpbmcgc29tZSBub24tc3RhbmRhcmQgc2Nyb2xsYmFyLCBlZyBhIHNjcm9sbGJhciB0aGF0IGhhcyB6ZXJvXG4gICAgLy8gd2lkdGggYW5kIG92ZXJsYXlzIChsaWtlIHRoZSBTYWZhcmkgc2Nyb2xsYmFyLCBidXQgcHJlc2VudGVkIGluIENocm9tZSkuIHNvIHdlXG4gICAgLy8gYWxsb3cgdGhlIHVzZXIgdG8gcHJvdmlkZSB0aGUgc2Nyb2xsIHdpZHRoIGJlZm9yZSB3ZSB3b3JrIGl0IG91dC5cbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldFNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdyaWRPcHRpb25zLnNjcm9sbGJhcldpZHRoO1xuICAgICAgICBpZiAodHlwZW9mIHNjcm9sbGJhcldpZHRoICE9PSAnbnVtYmVyJyB8fCBzY3JvbGxiYXJXaWR0aCA8IDApIHtcbiAgICAgICAgICAgIHNjcm9sbGJhcldpZHRoID0gdXRpbHNfMS5VdGlscy5nZXRTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aDtcbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuY2hlY2tGb3JEZXByZWNhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjYXN0aW5nIHRvIGdlbmVyaWMgb2JqZWN0LCBzbyB0eXBlc2NyaXB0IGNvbXBpbGVzIGV2ZW4gdGhvdWdoXG4gICAgICAgIC8vIHdlIGFyZSBsb29raW5nIGZvciBhdHRyaWJ1dGVzIHRoYXQgZG9uJ3QgZXhpc3RcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdyaWRPcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1VuU29ydCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBhcyBvZiB2MS4xMi40IHN1cHByZXNzVW5Tb3J0IGlzIG5vdCB1c2VkLiBQbGVhc2UgdXNlIHNvcnRpbmdPcmRlciBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzRGVzY1NvcnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogYXMgb2YgdjEuMTIuNCBzdXBwcmVzc0Rlc2NTb3J0IGlzIG5vdCB1c2VkLiBQbGVhc2UgdXNlIHNvcnRpbmdPcmRlciBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmdyb3VwQWdnRmllbGRzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IGFzIG9mIHYzIGdyb3VwQWdnRmllbGRzIGlzIG5vdCB1c2VkLiBQbGVhc2UgYWRkIGFwcHJvcHJpYXRlIGFnZyBmaWVsZHMgdG8geW91ciBjb2x1bW5zLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmdyb3VwSGlkZVBpdm90Q29sdW1ucykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBhcyBvZiB2MyBncm91cEhpZGVQaXZvdENvbHVtbnMgaXMgbm90IHVzZWQgYXMgcGl2b3QgY29sdW1ucyBhcmUgbm93IGNhbGxlZCByb3dHcm91cCBjb2x1bW5zLiBQbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5ncm91cEtleXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogYXMgb2YgdjMgZ3JvdXBLZXlzIGlzIG5vdCB1c2VkLiBZb3UgbmVlZCB0byBzZXQgcm93R3JvdXBJbmRleCBvbiB0aGUgY29sdW1ucyB0byBncm91cC4gUGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmdyb3VwRGVmYXVsdEV4cGFuZGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogZ3JvdXBEZWZhdWx0RXhwYW5kZWQgY2FuIG5vIGxvbmdlciBiZSBib29sZWFuLiBmb3IgZ3JvdXBEZWZhdWx0RXhwYW5kZWQ9dHJ1ZSwgdXNlIGdyb3VwRGVmYXVsdEV4cGFuZGVkPTk5OTkgaW5zdGVhZCwgdG8gZXhwYW5kIGFsbCB0aGUgZ3JvdXBzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub25Sb3dEZXNlbGVjdGVkIHx8IG9wdGlvbnMucm93RGVzZWxlY3RlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBzaW5jZSB2ZXJzaW9uIDMuNCBldmVudCByb3dEZXNlbGVjdGVkIG5vIGxvbmdlciBleGlzdHMsIHBsZWFzZSBjaGVjayB0aGUgZG9jcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJvd3NBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBzaW5jZSB2ZXJzaW9uIDMuNCByb3dzQWxyZWFkeUdyb3VwZWQgbm8gbG9uZ2VyIGV4aXN0cywgcGxlYXNlIHVzZSBnZXROb2RlQ2hpbGREZXRhaWxzKCkgaW5zdGVhZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmdyb3VwQWdnRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogc2luY2UgdmVyc2lvbiA0LjMueCBncm91cEFnZ0Z1bmN0aW9uIGlzIG5vdyBjYWxsZWQgZ3JvdXBSb3dBZ2dOb2RlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrYm94U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IHNpbmNlIHZlcnNpb24gOC4wLnggY2hlY2tib3hTZWxlY3Rpb24gaXMgbm90IHN1cHBvcnRlZCBhcyBhIGdyaWQgb3B0aW9uLiAnICtcbiAgICAgICAgICAgICAgICAnSWYgeW91IHdhbnQgdGhpcyBvbiBhbGwgY29sdW1ucywgdXNlIGRlZmF1bHRDb2xEZWYgaW5zdGVhZCBhbmQgc2V0IGl0IHRoZXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucGFnaW5hdGlvbkluaXRpYWxSb3dDb3VudCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBzaW5jZSB2ZXJzaW9uIDkuMC54IHBhZ2luYXRpb25Jbml0aWFsUm93Q291bnQgaXMgbm93IGNhbGxlZCBpbmZpbml0ZUluaXRpYWxSb3dDb3VudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmluZmluaXRlUGFnZVNpemUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogc2luY2UgdmVyc2lvbiA5LjAueCBpbmZpbml0ZVBhZ2VTaXplIGlzIG5vdyBjYWxsZWQgY2FjaGVCbG9ja1NpemUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbmZpbml0ZUJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBzaW5jZSB2ZXJzaW9uIDEwLjAueCBpbmZpbml0ZUJsb2NrU2l6ZSBpcyBub3cgY2FsbGVkIGNhY2hlQmxvY2tTaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWF4UGFnZXNJbkNhY2hlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IHNpbmNlIHZlcnNpb24gMTAuMC54IG1heFBhZ2VzSW5DYWNoZSBpcyBub3cgY2FsbGVkIG1heEJsb2Nrc0luQ2FjaGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wYWdpbmF0aW9uT3ZlcmZsb3dTaXplKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IHNpbmNlIHZlcnNpb24gMTAuMC54IHBhZ2luYXRpb25PdmVyZmxvd1NpemUgaXMgbm93IGNhbGxlZCBjYWNoZU92ZXJmbG93U2l6ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZvclByaW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IHNpbmNlIHZlcnNpb24gMTAuMS54LCB1c2UgcHJvcGVydHkgZG9tTGF5b3V0PVwiZm9yUHJpbnRcIiBpbnN0ZWFkIG9mIGZvclByaW50PXRydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc01lbnVGaWx0ZXJQYW5lbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYWctZ3JpZDogc2luY2UgdmVyc2lvbiAxMS4wLngsIHVzZSBwcm9wZXJ0eSBjb2xEZWYubWVudVRhYnM9WydnZW5lcmFsTWVudVRhYicsJ2NvbHVtbnNNZW51VGFiJ10gaW5zdGVhZCBvZiBzdXBwcmVzc01lbnVGaWx0ZXJQYW5lbD10cnVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzTWVudU1haW5QYW5lbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYWctZ3JpZDogc2luY2UgdmVyc2lvbiAxMS4wLngsIHVzZSBwcm9wZXJ0eSBjb2xEZWYubWVudVRhYnM9WydmaWx0ZXJNZW51VGFiJywnY29sdW1uc01lbnVUYWInXSBpbnN0ZWFkIG9mIHN1cHByZXNzTWVudU1haW5QYW5lbD10cnVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzTWVudUNvbHVtblBhbmVsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1ncmlkOiBzaW5jZSB2ZXJzaW9uIDExLjAueCwgdXNlIHByb3BlcnR5IGNvbERlZi5tZW51VGFicz1bJ2dlbmVyYWxNZW51VGFiJywnZmlsdGVyTWVudVRhYiddIGluc3RlYWQgb2Ygc3VwcHJlc3NNZW51Q29sdW1uUGFuZWw9dHJ1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1VzZUNvbElkRm9yR3JvdXBzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1ncmlkOiBzaW5jZSB2ZXJzaW9uIDExLjAueCwgdGhpcyBpcyBub3QgaW4gdXNlIGFueW1vcmUuIFlvdSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgaXQgZnJvbSB5b3VyIGRlZmluaXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZ3JvdXBDb2x1bW5EZWYpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLWdyaWQ6IHNpbmNlIHZlcnNpb24gMTEuMC54LCBncm91cENvbHVtbkRlZiBoYXMgYmVlbiByZW5hbWVkLCB0aGlzIHByb3BlcnR5IGlzIG5vdyBjYWxsZWQgYXV0b0dyb3VwQ29sdW1uRGVmLiBQbGVhc2UgY2hhbmdlIHlvdXIgY29uZmlndXJhdGlvbiBhY2NvcmRpbmdseVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zbGF2ZUdyaWRzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1ncmlkOiBzaW5jZSB2ZXJzaW9uIDEyLngsIHNsYXZlR3JpZHMgaGFzIGJlZW4gcmVuYW1lZCwgdGhpcyBwcm9wZXJ0eSBpcyBub3cgY2FsbGVkIGFsaWduZWRHcmlkcy4gUGxlYXNlIGNoYW5nZSB5b3VyIGNvbmZpZ3VyYXRpb24gYWNjb3JkaW5nbHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxvYXRpbmdUb3BSb3dEYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1ncmlkOiBzaW5jZSB2ZXJzaW9uIDEyLngsIGZsb2F0aW5nVG9wUm93RGF0YSBpcyBub3cgY2FsbGVkIHBpbm5lZFRvcFJvd0RhdGFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxvYXRpbmdCb3R0b21Sb3dEYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1ncmlkOiBzaW5jZSB2ZXJzaW9uIDEyLngsIGZsb2F0aW5nQm90dG9tUm93RGF0YSBpcyBub3cgY2FsbGVkIHBpbm5lZEJvdHRvbVJvd0RhdGFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucGFnaW5hdGlvblN0YXJ0UGFnZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYWctZ3JpZDogc2luY2UgdmVyc2lvbiAxMi54LCBwYWdpbmF0aW9uU3RhcnRQYWdlIGlzIGdvbmUsIHBsZWFzZSBjYWxsIGFwaS5wYWdpbmF0aW9uR29Ub1BhZ2UoXCIgKyBvcHRpb25zLnBhZ2luYXRpb25TdGFydFBhZ2UgKyBcIikgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0TG9jYWxlVGV4dEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zLmxvY2FsZVRleHRGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5sb2NhbGVUZXh0RnVuYztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGVUZXh0ID0gdGhhdC5ncmlkT3B0aW9ucy5sb2NhbGVUZXh0O1xuICAgICAgICAgICAgaWYgKGxvY2FsZVRleHQgJiYgbG9jYWxlVGV4dFtrZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZVRleHRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyByZXNwb25zaWJsZSBmb3IgY2FsbGluZyB0aGUgb25YWFggZnVuY3Rpb25zIG9uIGdyaWRPcHRpb25zXG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nbG9iYWxFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICB2YXIgY2FsbGJhY2tNZXRob2ROYW1lID0gY29tcG9uZW50VXRpbF8xLkNvbXBvbmVudFV0aWwuZ2V0Q2FsbGJhY2tGb3JFdmVudChldmVudE5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ3JpZE9wdGlvbnNbY2FsbGJhY2tNZXRob2ROYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1tjYWxsYmFja01ldGhvZE5hbWVdKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gd2UgZG9uJ3QgYWxsb3cgZHluYW1pYyByb3cgaGVpZ2h0IGZvciB2aXJ0dWFsIHBhZ2luZ1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Um93SGVpZ2h0QXNOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dIZWlnaHQgPSB0aGlzLmdyaWRPcHRpb25zLnJvd0hlaWdodDtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyhyb3dIZWlnaHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0Um93SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc051bWVyaWModGhpcy5ncmlkT3B0aW9ucy5yb3dIZWlnaHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9ucy5yb3dIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQgcm93IGhlaWdodCBtdXN0IGJlIGEgbnVtYmVyIGlmIG5vdCB1c2luZyBzdGFuZGFyZCByb3cgbW9kZWwnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRSb3dIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRSb3dIZWlnaHRGb3JOb2RlID0gZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgLy8gY2hlY2sgdGhlIGZ1bmN0aW9uIGZpcnN0LCBpbiBjYXNlIHVzZSBzZXQgYm90aCBmdW5jdGlvbiBhbmRcbiAgICAgICAgLy8gbnVtYmVyLCB3aGVuIHVzaW5nIHZpcnR1YWwgcGFnaW5hdGlvbiB0aGVuIGZ1bmN0aW9uIGNhbiBiZVxuICAgICAgICAvLyB1c2VkIGZvciBwaW5uZWQgcm93cyBhbmQgdGhlIG51bWJlciBmb3IgdGhlIGJvZHkgcm93cy5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdyaWRPcHRpb25zLmdldFJvd0hlaWdodCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiByb3dOb2RlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJvd05vZGUuZGF0YSxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZE9wdGlvbnMuYXBpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuZ3JpZE9wdGlvbnMuY29udGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWRPcHRpb25zLmdldFJvd0hlaWdodChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNOdW1lcmljKHRoaXMuZ3JpZE9wdGlvbnMucm93SGVpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnMucm93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFJvd0hlaWdodCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmlzRHluYW1pY1Jvd0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmdyaWRPcHRpb25zLmdldFJvd0hlaWdodCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0VmlydHVhbEl0ZW1IZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWNpYWxGb3JOZXdNYXRlcmlhbCgyMCwgOCAqIDUpO1xuICAgIH07XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZS5nZXRBZ2dGdW5jUG9wdXBIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWNpYWxGb3JOZXdNYXRlcmlhbCgxMDAsIDggKiA1ICogMy41KTsgLy8gMy41IGN1dHMgdGhlIGxhc3QgaXRlbSBpbiBoYWxmLCBoaW50aW5nIHRoYXQgeW91IGNhbiBzY3JvbGxcbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuZ2V0Q2hlY2tib3hJbmRlbnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlY2lhbEZvck5ld01hdGVyaWFsKDEwLCAxOCArIDgpOyAvLyBpY29uIHNpemUgKyBncmlkIHNpemVcbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuaXNOdW1lcmljID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfTtcbiAgICAvLyBNYXRlcmlhbCBkYXRhIHRhYmxlIGhhcyBzdHJpY3QgZ3VpZGVsaW5lcyBhYm91dCB3aGl0ZXNwYWNlLCBhbmQgdGhlc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgdGhhbiB0aGUgb25lcyBcbiAgICAvLyBhZy1ncmlkIHVzZXMgYnkgZGVmYXVsdC4gV2Ugb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb25lcyBmb3IgdGhlIHNha2Ugb2YgbWFraW5nIGl0IGJldHRlciBvdXQgb2YgdGhlIGJveFxuICAgIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUuc3BlY2lhbEZvck5ld01hdGVyaWFsID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSwgbWF0ZXJpYWxWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5lbnZpcm9ubWVudC5nZXRUaGVtZSgpID09IFwiYWctdGhlbWUtbWF0ZXJpYWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLmdldERlZmF1bHRSb3dIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWNpYWxGb3JOZXdNYXRlcmlhbChERUZBVUxUX1JPV19IRUlHSFQsIDggKiA2KTtcbiAgICB9O1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5NSU5fQ09MX1dJRFRIID0gMTA7XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfSEVBREVSX0hFSUdIVCA9ICdoZWFkZXJIZWlnaHQnO1xuICAgIEdyaWRPcHRpb25zV3JhcHBlci5QUk9QX0dST1VQX1JFTU9WRV9TSU5HTEVfQ0hJTERSRU4gPSAnZ3JvdXBSZW1vdmVTaW5nbGVDaGlsZHJlbic7XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfR1JPVVBfUkVNT1ZFX0xPV0VTVF9TSU5HTEVfQ0hJTERSRU4gPSAnZ3JvdXBSZW1vdmVMb3dlc3RTaW5nbGVDaGlsZHJlbic7XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfUElWT1RfSEVBREVSX0hFSUdIVCA9ICdwaXZvdEhlYWRlckhlaWdodCc7XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfR1JPVVBfSEVBREVSX0hFSUdIVCA9ICdncm91cEhlYWRlckhlaWdodCc7XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfUElWT1RfR1JPVVBfSEVBREVSX0hFSUdIVCA9ICdwaXZvdEdyb3VwSGVhZGVySGVpZ2h0JztcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIuUFJPUF9GTE9BVElOR19GSUxURVJTX0hFSUdIVCA9ICdmbG9hdGluZ0ZpbHRlcnNIZWlnaHQnO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9ucycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIEdyaWRPcHRpb25zV3JhcHBlci5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2VudGVycHJpc2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZSwgXCJlbnRlcnByaXNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZyYW1ld29ya0ZhY3RvcnknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLCBcImZyYW1ld29ya0ZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZEFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZEFwaV8xLkdyaWRBcGkpXG4gICAgXSwgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkFwaSlcbiAgICBdLCBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdlbnZpcm9ubWVudCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZW52aXJvbm1lbnRfMS5FbnZpcm9ubWVudClcbiAgICBdLCBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLCBcImVudmlyb25tZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIF9fcGFyYW0oMCwgY29udGV4dF8xLlF1YWxpZmllcignZ3JpZEFwaScpKSwgX19wYXJhbSgxLCBjb250ZXh0XzEuUXVhbGlmaWVyKCdjb2x1bW5BcGknKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbZ3JpZEFwaV8xLkdyaWRBcGksIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5BcGldKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLCBcImFnV2lyZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlByZURlc3Ryb3ksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgR3JpZE9wdGlvbnNXcmFwcGVyLnByb3RvdHlwZSwgXCJkZXN0cm95XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBHcmlkT3B0aW9uc1dyYXBwZXIucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyID0gR3JpZE9wdGlvbnNXcmFwcGVyXzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2dyaWRPcHRpb25zV3JhcHBlcicpXG4gICAgXSwgR3JpZE9wdGlvbnNXcmFwcGVyKTtcbiAgICByZXR1cm4gR3JpZE9wdGlvbnNXcmFwcGVyO1xuICAgIHZhciBHcmlkT3B0aW9uc1dyYXBwZXJfMTtcbn0oKSk7XG5leHBvcnRzLkdyaWRPcHRpb25zV3JhcHBlciA9IEdyaWRPcHRpb25zV3JhcHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2dyaWRPcHRpb25zV3JhcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBjb2x1bW5Hcm91cF8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2NvbHVtbkdyb3VwXCIpO1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2NvbHVtblwiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgZXhwcmVzc2lvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZVNlcnZpY2UvZXhwcmVzc2lvblNlcnZpY2VcIik7XG52YXIgYmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vYmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlclwiKTtcbnZhciBkaXNwbGF5ZWRHcm91cENyZWF0b3JfMSA9IHJlcXVpcmUoXCIuL2Rpc3BsYXllZEdyb3VwQ3JlYXRvclwiKTtcbnZhciBhdXRvV2lkdGhDYWxjdWxhdG9yXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyaW5nL2F1dG9XaWR0aENhbGN1bGF0b3JcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGNvbHVtblV0aWxzXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5VdGlsc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xudmFyIG9yaWdpbmFsQ29sdW1uR3JvdXBfMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9vcmlnaW5hbENvbHVtbkdyb3VwXCIpO1xudmFyIGdyb3VwSW5zdGFuY2VJZENyZWF0b3JfMSA9IHJlcXVpcmUoXCIuL2dyb3VwSW5zdGFuY2VJZENyZWF0b3JcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBncmlkUGFuZWxfMSA9IHJlcXVpcmUoXCIuLi9ncmlkUGFuZWwvZ3JpZFBhbmVsXCIpO1xudmFyIGNvbHVtbkFuaW1hdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJpbmcvY29sdW1uQW5pbWF0aW9uU2VydmljZVwiKTtcbnZhciBhdXRvR3JvdXBDb2xTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9hdXRvR3JvdXBDb2xTZXJ2aWNlXCIpO1xudmFyIHZhbHVlQ2FjaGVfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZVNlcnZpY2UvdmFsdWVDYWNoZVwiKTtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi4vZ3JpZEFwaVwiKTtcbnZhciBDb2x1bW5BcGkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbHVtbkFwaSgpIHtcbiAgICB9XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5zaXplQ29sdW1uc1RvRml0ID0gZnVuY3Rpb24gKGdyaWRXaWR0aCkgeyB0aGlzLl9jb2x1bW5Db250cm9sbGVyLnNpemVDb2x1bW5zVG9GaXQoZ3JpZFdpZHRoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnNldENvbHVtbkdyb3VwT3BlbmVkID0gZnVuY3Rpb24gKGdyb3VwLCBuZXdWYWx1ZSkgeyB0aGlzLl9jb2x1bW5Db250cm9sbGVyLnNldENvbHVtbkdyb3VwT3BlbmVkKGdyb3VwLCBuZXdWYWx1ZSk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXRDb2x1bW5Hcm91cCA9IGZ1bmN0aW9uIChuYW1lLCBpbnN0YW5jZUlkKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmdldENvbHVtbkdyb3VwKG5hbWUsIGluc3RhbmNlSWQpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0T3JpZ2luYWxDb2x1bW5Hcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmdldE9yaWdpbmFsQ29sdW1uR3JvdXAobmFtZSk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXREaXNwbGF5TmFtZUZvckNvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW4sIGxvY2F0aW9uKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmdldERpc3BsYXlOYW1lRm9yQ29sdW1uKGNvbHVtbiwgbG9jYXRpb24pOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0RGlzcGxheU5hbWVGb3JDb2x1bW5Hcm91cCA9IGZ1bmN0aW9uIChjb2x1bW5Hcm91cCwgbG9jYXRpb24pIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0RGlzcGxheU5hbWVGb3JDb2x1bW5Hcm91cChjb2x1bW5Hcm91cCwgbG9jYXRpb24pOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0Q29sdW1uID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5nZXRQcmltYXJ5Q29sdW1uKGtleSk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5zZXRDb2x1bW5TdGF0ZSA9IGZ1bmN0aW9uIChjb2x1bW5TdGF0ZSkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5TdGF0ZShjb2x1bW5TdGF0ZSk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXRDb2x1bW5TdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0Q29sdW1uU3RhdGUoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnJlc2V0Q29sdW1uU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIucmVzZXRDb2x1bW5TdGF0ZSgpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0Q29sdW1uR3JvdXBTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0Q29sdW1uR3JvdXBTdGF0ZSgpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuc2V0Q29sdW1uR3JvdXBTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZUl0ZW1zKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuc2V0Q29sdW1uR3JvdXBTdGF0ZShzdGF0ZUl0ZW1zKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnJlc2V0Q29sdW1uR3JvdXBTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY29sdW1uQ29udHJvbGxlci5yZXNldENvbHVtbkdyb3VwU3RhdGUoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmlzUGlubmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nTGVmdCgpIHx8IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nUmlnaHQoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmlzUGlubmluZ0xlZnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmlzUGlubmluZ0xlZnQoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmlzUGlubmluZ1JpZ2h0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5pc1Bpbm5pbmdSaWdodCgpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0RGlzcGxheWVkQ29sQWZ0ZXIgPSBmdW5jdGlvbiAoY29sKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmdldERpc3BsYXllZENvbEFmdGVyKGNvbCk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXREaXNwbGF5ZWRDb2xCZWZvcmUgPSBmdW5jdGlvbiAoY29sKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmdldERpc3BsYXllZENvbEJlZm9yZShjb2wpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuc2V0Q29sdW1uVmlzaWJsZSA9IGZ1bmN0aW9uIChrZXksIHZpc2libGUpIHsgdGhpcy5fY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5WaXNpYmxlKGtleSwgdmlzaWJsZSk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5zZXRDb2x1bW5zVmlzaWJsZSA9IGZ1bmN0aW9uIChrZXlzLCB2aXNpYmxlKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuc2V0Q29sdW1uc1Zpc2libGUoa2V5cywgdmlzaWJsZSk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5zZXRDb2x1bW5QaW5uZWQgPSBmdW5jdGlvbiAoa2V5LCBwaW5uZWQpIHsgdGhpcy5fY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5QaW5uZWQoa2V5LCBwaW5uZWQpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuc2V0Q29sdW1uc1Bpbm5lZCA9IGZ1bmN0aW9uIChrZXlzLCBwaW5uZWQpIHsgdGhpcy5fY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5zUGlubmVkKGtleXMsIHBpbm5lZCk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXRBbGxDb2x1bW5zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5nZXRBbGxQcmltYXJ5Q29sdW1ucygpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0QWxsR3JpZENvbHVtbnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmdldEFsbEdyaWRDb2x1bW5zKCk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXREaXNwbGF5ZWRMZWZ0Q29sdW1ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0RGlzcGxheWVkTGVmdENvbHVtbnMoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmdldERpc3BsYXllZENlbnRlckNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmdldERpc3BsYXllZENlbnRlckNvbHVtbnMoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmdldERpc3BsYXllZFJpZ2h0Q29sdW1ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0RGlzcGxheWVkUmlnaHRDb2x1bW5zKCk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKCk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXRBbGxEaXNwbGF5ZWRWaXJ0dWFsQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0QWxsRGlzcGxheWVkVmlydHVhbENvbHVtbnMoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLm1vdmVDb2x1bW4gPSBmdW5jdGlvbiAoa2V5LCB0b0luZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gbW92ZUNvbHVtbiB1c2VkIHRvIHRha2UgaW5kZXhlcywgc28gdGhpcyBpcyBhZHZpc2luZyB1c2VyIHdobyBoYXNuJ3QgbW92ZWQgdG8gbmV3IG1ldGhvZCBuYW1lXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogeW91IGFyZSB1c2luZyBtb3ZlQ29sdW1uKGZyb21JbmRleCwgdG9JbmRleCkgLSBtb3ZlQ29sdW1uIHRha2VzIGEgY29sdW1uIGtleSBhbmQgYSBkZXN0aW5hdGlvbiBpbmRleCwgbm90IHR3byBpbmRleGVzLCB0byBtb3ZlIHdpdGggaW5kZXhlcyB1c2UgbW92ZUNvbHVtbkJ5SW5kZXgoZnJvbSx0bykgaW5zdGVhZCcpO1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uQ29udHJvbGxlci5tb3ZlQ29sdW1uQnlJbmRleChrZXksIHRvSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uQ29udHJvbGxlci5tb3ZlQ29sdW1uKGtleSwgdG9JbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUubW92ZUNvbHVtbkJ5SW5kZXggPSBmdW5jdGlvbiAoZnJvbUluZGV4LCB0b0luZGV4KSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIubW92ZUNvbHVtbkJ5SW5kZXgoZnJvbUluZGV4LCB0b0luZGV4KTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLm1vdmVDb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbnNUb01vdmVLZXlzLCB0b0luZGV4KSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIubW92ZUNvbHVtbnMoY29sdW1uc1RvTW92ZUtleXMsIHRvSW5kZXgpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUubW92ZVJvd0dyb3VwQ29sdW1uID0gZnVuY3Rpb24gKGZyb21JbmRleCwgdG9JbmRleCkgeyB0aGlzLl9jb2x1bW5Db250cm9sbGVyLm1vdmVSb3dHcm91cENvbHVtbihmcm9tSW5kZXgsIHRvSW5kZXgpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuc2V0Q29sdW1uQWdnRnVuYyA9IGZ1bmN0aW9uIChjb2x1bW4sIGFnZ0Z1bmMpIHsgdGhpcy5fY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5BZ2dGdW5jKGNvbHVtbiwgYWdnRnVuYyk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5zZXRDb2x1bW5XaWR0aCA9IGZ1bmN0aW9uIChrZXksIG5ld1dpZHRoLCBmaW5pc2hlZCkge1xuICAgICAgICBpZiAoZmluaXNoZWQgPT09IHZvaWQgMCkgeyBmaW5pc2hlZCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5fY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5XaWR0aChrZXksIG5ld1dpZHRoLCBmaW5pc2hlZCk7XG4gICAgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnNldFBpdm90TW9kZSA9IGZ1bmN0aW9uIChwaXZvdE1vZGUpIHsgdGhpcy5fY29sdW1uQ29udHJvbGxlci5zZXRQaXZvdE1vZGUocGl2b3RNb2RlKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmlzUGl2b3RNb2RlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5pc1Bpdm90TW9kZSgpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0U2Vjb25kYXJ5UGl2b3RDb2x1bW4gPSBmdW5jdGlvbiAocGl2b3RLZXlzLCB2YWx1ZUNvbEtleSkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5nZXRTZWNvbmRhcnlQaXZvdENvbHVtbihwaXZvdEtleXMsIHZhbHVlQ29sS2V5KTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnNldFZhbHVlQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2xLZXlzKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuc2V0VmFsdWVDb2x1bW5zKGNvbEtleXMpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0VmFsdWVDb2x1bW5zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5nZXRWYWx1ZUNvbHVtbnMoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnJlbW92ZVZhbHVlQ29sdW1uID0gZnVuY3Rpb24gKGNvbEtleSkgeyB0aGlzLl9jb2x1bW5Db250cm9sbGVyLnJlbW92ZVZhbHVlQ29sdW1uKGNvbEtleSk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5yZW1vdmVWYWx1ZUNvbHVtbnMgPSBmdW5jdGlvbiAoY29sS2V5cykgeyB0aGlzLl9jb2x1bW5Db250cm9sbGVyLnJlbW92ZVZhbHVlQ29sdW1ucyhjb2xLZXlzKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmFkZFZhbHVlQ29sdW1uID0gZnVuY3Rpb24gKGNvbEtleSkgeyB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmFkZFZhbHVlQ29sdW1uKGNvbEtleSk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5hZGRWYWx1ZUNvbHVtbnMgPSBmdW5jdGlvbiAoY29sS2V5cykgeyB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmFkZFZhbHVlQ29sdW1ucyhjb2xLZXlzKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnNldFJvd0dyb3VwQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2xLZXlzKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuc2V0Um93R3JvdXBDb2x1bW5zKGNvbEtleXMpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUucmVtb3ZlUm93R3JvdXBDb2x1bW4gPSBmdW5jdGlvbiAoY29sS2V5KSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIucmVtb3ZlUm93R3JvdXBDb2x1bW4oY29sS2V5KTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnJlbW92ZVJvd0dyb3VwQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2xLZXlzKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIucmVtb3ZlUm93R3JvdXBDb2x1bW5zKGNvbEtleXMpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuYWRkUm93R3JvdXBDb2x1bW4gPSBmdW5jdGlvbiAoY29sS2V5KSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuYWRkUm93R3JvdXBDb2x1bW4oY29sS2V5KTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmFkZFJvd0dyb3VwQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2xLZXlzKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuYWRkUm93R3JvdXBDb2x1bW5zKGNvbEtleXMpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0Um93R3JvdXBDb2x1bW5zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5nZXRSb3dHcm91cENvbHVtbnMoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnNldFBpdm90Q29sdW1ucyA9IGZ1bmN0aW9uIChjb2xLZXlzKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuc2V0UGl2b3RDb2x1bW5zKGNvbEtleXMpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUucmVtb3ZlUGl2b3RDb2x1bW4gPSBmdW5jdGlvbiAoY29sS2V5KSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIucmVtb3ZlUGl2b3RDb2x1bW4oY29sS2V5KTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnJlbW92ZVBpdm90Q29sdW1ucyA9IGZ1bmN0aW9uIChjb2xLZXlzKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIucmVtb3ZlUGl2b3RDb2x1bW5zKGNvbEtleXMpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuYWRkUGl2b3RDb2x1bW4gPSBmdW5jdGlvbiAoY29sS2V5KSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuYWRkUGl2b3RDb2x1bW4oY29sS2V5KTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmFkZFBpdm90Q29sdW1ucyA9IGZ1bmN0aW9uIChjb2xLZXlzKSB7IHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuYWRkUGl2b3RDb2x1bW5zKGNvbEtleXMpOyB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuZ2V0UGl2b3RDb2x1bW5zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sdW1uQ29udHJvbGxlci5nZXRQaXZvdENvbHVtbnMoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmdldExlZnREaXNwbGF5ZWRDb2x1bW5Hcm91cHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmdldExlZnREaXNwbGF5ZWRDb2x1bW5Hcm91cHMoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmdldENlbnRlckRpc3BsYXllZENvbHVtbkdyb3VwcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0Q2VudGVyRGlzcGxheWVkQ29sdW1uR3JvdXBzKCk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXRSaWdodERpc3BsYXllZENvbHVtbkdyb3VwcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0UmlnaHREaXNwbGF5ZWRDb2x1bW5Hcm91cHMoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmdldEFsbERpc3BsYXllZENvbHVtbkdyb3VwcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0QWxsRGlzcGxheWVkQ29sdW1uR3JvdXBzKCk7IH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5hdXRvU2l6ZUNvbHVtbiA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuYXV0b1NpemVDb2x1bW4oa2V5KTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmF1dG9TaXplQ29sdW1ucyA9IGZ1bmN0aW9uIChrZXlzKSB7IHJldHVybiB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmF1dG9TaXplQ29sdW1ucyhrZXlzKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmF1dG9TaXplQWxsQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY29sdW1uQ29udHJvbGxlci5hdXRvU2l6ZUFsbENvbHVtbnMoKTsgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnNldFNlY29uZGFyeUNvbHVtbnMgPSBmdW5jdGlvbiAoY29sRGVmcykgeyB0aGlzLl9jb2x1bW5Db250cm9sbGVyLnNldFNlY29uZGFyeUNvbHVtbnMoY29sRGVmcyk7IH07XG4gICAgLy8gYmVsb3cgZ29lcyB0aHJvdWdoIGRlcHJlY2F0ZWQgaXRlbXMsIHByaW50cyBtZXNzYWdlIHRvIHVzZXIsIHRoZW4gY2FsbHMgdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBzYW1lIG1ldGhvZFxuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuY29sdW1uR3JvdXBPcGVuZWQgPSBmdW5jdGlvbiAoZ3JvdXAsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FnLUdyaWQ6IGNvbHVtbkdyb3VwT3BlbmVkIG5vIGxvbmdlciBleGlzdHMsIHVzZSBzZXRDb2x1bW5Hcm91cE9wZW5lZCcpO1xuICAgICAgICB0aGlzLnNldENvbHVtbkdyb3VwT3BlbmVkKGdyb3VwLCBuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmhpZGVDb2x1bW5zID0gZnVuY3Rpb24gKGNvbElkcywgaGlkZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBoaWRlQ29sdW1ucyBpcyBkZXByZWNhdGVkLCB1c2Ugc2V0Q29sdW1uc1Zpc2libGUnKTtcbiAgICAgICAgdGhpcy5fY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5zVmlzaWJsZShjb2xJZHMsICFoaWRlKTtcbiAgICB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuaGlkZUNvbHVtbiA9IGZ1bmN0aW9uIChjb2xJZCwgaGlkZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBoaWRlQ29sdW1uIGlzIGRlcHJlY2F0ZWQsIHVzZSBzZXRDb2x1bW5WaXNpYmxlJyk7XG4gICAgICAgIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuc2V0Q29sdW1uVmlzaWJsZShjb2xJZCwgIWhpZGUpO1xuICAgIH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChjb2x1bW5TdGF0ZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBzZXRTdGF0ZSBpcyBkZXByZWNhdGVkLCB1c2Ugc2V0Q29sdW1uU3RhdGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q29sdW1uU3RhdGUoY29sdW1uU3RhdGUpO1xuICAgIH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogZ2V0U3RhdGUgaXMgZGVwcmVjYXRlZCwgdXNlIGdldENvbHVtblN0YXRlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtblN0YXRlKCk7XG4gICAgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnJlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FnLUdyaWQ6IHJlc2V0U3RhdGUgaXMgZGVwcmVjYXRlZCwgdXNlIHJlc2V0Q29sdW1uU3RhdGUnKTtcbiAgICAgICAgdGhpcy5yZXNldENvbHVtblN0YXRlKCk7XG4gICAgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmdldEFnZ3JlZ2F0aW9uQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogZ2V0QWdncmVnYXRpb25Db2x1bW5zIGlzIGRlcHJlY2F0ZWQsIHVzZSBnZXRWYWx1ZUNvbHVtbnMnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuZ2V0VmFsdWVDb2x1bW5zKCk7XG4gICAgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLnJlbW92ZUFnZ3JlZ2F0aW9uQ29sdW1uID0gZnVuY3Rpb24gKGNvbEtleSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiByZW1vdmVBZ2dyZWdhdGlvbkNvbHVtbiBpcyBkZXByZWNhdGVkLCB1c2UgcmVtb3ZlVmFsdWVDb2x1bW4nKTtcbiAgICAgICAgdGhpcy5fY29sdW1uQ29udHJvbGxlci5yZW1vdmVWYWx1ZUNvbHVtbihjb2xLZXkpO1xuICAgIH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5yZW1vdmVBZ2dyZWdhdGlvbkNvbHVtbnMgPSBmdW5jdGlvbiAoY29sS2V5cykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiByZW1vdmVBZ2dyZWdhdGlvbkNvbHVtbnMgaXMgZGVwcmVjYXRlZCwgdXNlIHJlbW92ZVZhbHVlQ29sdW1ucycpO1xuICAgICAgICB0aGlzLl9jb2x1bW5Db250cm9sbGVyLnJlbW92ZVZhbHVlQ29sdW1ucyhjb2xLZXlzKTtcbiAgICB9O1xuICAgIENvbHVtbkFwaS5wcm90b3R5cGUuYWRkQWdncmVnYXRpb25Db2x1bW4gPSBmdW5jdGlvbiAoY29sS2V5KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FnLUdyaWQ6IGFkZEFnZ3JlZ2F0aW9uQ29sdW1uIGlzIGRlcHJlY2F0ZWQsIHVzZSBhZGRWYWx1ZUNvbHVtbicpO1xuICAgICAgICB0aGlzLl9jb2x1bW5Db250cm9sbGVyLmFkZFZhbHVlQ29sdW1uKGNvbEtleSk7XG4gICAgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmFkZEFnZ3JlZ2F0aW9uQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2xLZXlzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FnLUdyaWQ6IGFkZEFnZ3JlZ2F0aW9uQ29sdW1ucyBpcyBkZXByZWNhdGVkLCB1c2UgYWRkVmFsdWVDb2x1bW5zJyk7XG4gICAgICAgIHRoaXMuX2NvbHVtbkNvbnRyb2xsZXIuYWRkVmFsdWVDb2x1bW5zKGNvbEtleXMpO1xuICAgIH07XG4gICAgQ29sdW1uQXBpLnByb3RvdHlwZS5zZXRDb2x1bW5BZ2dGdW5jdGlvbiA9IGZ1bmN0aW9uIChjb2x1bW4sIGFnZ0Z1bmMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogc2V0Q29sdW1uQWdnRnVuY3Rpb24gaXMgZGVwcmVjYXRlZCwgdXNlIHNldENvbHVtbkFnZ0Z1bmMnKTtcbiAgICAgICAgdGhpcy5fY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5BZ2dGdW5jKGNvbHVtbiwgYWdnRnVuYyk7XG4gICAgfTtcbiAgICBDb2x1bW5BcGkucHJvdG90eXBlLmdldERpc3BsYXlOYW1lRm9yQ29sID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBnZXREaXNwbGF5TmFtZUZvckNvbCBpcyBkZXByZWNhdGVkLCB1c2UgZ2V0RGlzcGxheU5hbWVGb3JDb2x1bW4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzcGxheU5hbWVGb3JDb2x1bW4oY29sdW1uLCBudWxsKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5Db250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDb2x1bW5Db250cm9sbGVyKVxuICAgIF0sIENvbHVtbkFwaS5wcm90b3R5cGUsIFwiX2NvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBDb2x1bW5BcGkgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2NvbHVtbkFwaScpXG4gICAgXSwgQ29sdW1uQXBpKTtcbiAgICByZXR1cm4gQ29sdW1uQXBpO1xufSgpKTtcbmV4cG9ydHMuQ29sdW1uQXBpID0gQ29sdW1uQXBpO1xudmFyIENvbHVtbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbHVtbkNvbnRyb2xsZXIoKSB7XG4gICAgICAgIC8vIGhlYWRlciByb3cgY291bnQsIGJhc2VkIG9uIHVzZXIgcHJvdmlkZWQgY29sdW1uc1xuICAgICAgICB0aGlzLnByaW1hcnlIZWFkZXJSb3dDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5SGVhZGVyUm93Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbHVtbnNQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgIC8vIGhlYWRlciByb3cgY291bnQsIGVpdGhlciBhYm92ZSwgb3IgYmFzZWQgb24gcGl2b3RpbmcgaWYgd2UgYXJlIHBpdm90aW5nXG4gICAgICAgIHRoaXMuZ3JpZEhlYWRlclJvd0NvdW50ID0gMDtcbiAgICAgICAgLy8gdGhlc2UgYXJlIHRoZSBsaXN0cyB1c2VkIGJ5IHRoZSByb3dSZW5kZXJlciB0byByZW5kZXIgbm9kZXMuIGFsbW9zdCB0aGUgbGVhZiBub2RlcyBvZiB0aGUgYWJvdmVcbiAgICAgICAgLy8gZGlzcGxheWVkIHRyZWVzLCBob3dldmVyIGl0IGFsc28gdGFrZXMgaW50byBhY2NvdW50IGlmIHRoZSBncm91cHMgYXJlIG9wZW4gb3Igbm90LlxuICAgICAgICB0aGlzLmRpc3BsYXllZExlZnRDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuZGlzcGxheWVkUmlnaHRDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuZGlzcGxheWVkQ2VudGVyQ29sdW1ucyA9IFtdO1xuICAgICAgICAvLyBhbGwgdGhyZWUgbGlzdHMgYWJvdmUgY29tYmluZWRcbiAgICAgICAgdGhpcy5hbGxEaXNwbGF5ZWRDb2x1bW5zID0gW107XG4gICAgICAgIC8vIHNhbWUgYXMgYWJvdmUsIGV4Y2VwdCB0cmltbWVkIGRvd24gdG8gb25seSBjb2x1bW5zIHdpdGhpbiB0aGUgdmlld3BvcnRcbiAgICAgICAgdGhpcy5hbGxEaXNwbGF5ZWRWaXJ0dWFsQ29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLmFsbERpc3BsYXllZENlbnRlclZpcnR1YWxDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMucm93R3JvdXBDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMudmFsdWVDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMucGl2b3RDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRvR3JvdXBzTmVlZEJ1aWxkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGl2b3RNb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYm9keVdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5sZWZ0V2lkdGggPSAwO1xuICAgICAgICB0aGlzLnJpZ2h0V2lkdGggPSAwO1xuICAgICAgICB0aGlzLmJvZHlXaWR0aERpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBpdm90TW9kZSA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzUGl2b3RNb2RlKCk7XG4gICAgICAgIGlmICh0aGlzLmlzUGl2b3RTZXR0aW5nQWxsb3dlZChwaXZvdE1vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLnBpdm90TW9kZSA9IHBpdm90TW9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzaW5nVHJlZURhdGEgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1RyZWVEYXRhKCk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRWaXJ0dWFsVmlld3BvcnRMZWZ0QW5kUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVJ0bCgpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGVmdCA9IHRoaXMuYm9keVdpZHRoIC0gdGhpcy5zY3JvbGxQb3NpdGlvbiAtIHRoaXMuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0UmlnaHQgPSB0aGlzLmJvZHlXaWR0aCAtIHRoaXMuc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGVmdCA9IHRoaXMuc2Nyb2xsUG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0UmlnaHQgPSB0aGlzLnNjcm9sbFdpZHRoICsgdGhpcy5zY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gdXNlZCBieSBjbGlwYm9hcmQgc2VydmljZSwgdG8ga25vdyB3aGF0IGNvbHVtbnMgdG8gcGFzdGUgaW50b1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldERpc3BsYXllZENvbHVtbnNTdGFydGluZ0F0ID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgY3VycmVudENvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodXRpbHNfMS5VdGlscy5leGlzdHMoY3VycmVudENvbHVtbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRDb2x1bW4pO1xuICAgICAgICAgICAgY3VycmVudENvbHVtbiA9IHRoaXMuZ2V0RGlzcGxheWVkQ29sQWZ0ZXIoY3VycmVudENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIGNoZWNrcyB3aGF0IGNvbHVtbnMgYXJlIGN1cnJlbnRseSBkaXNwbGF5ZWQgZHVlIHRvIGNvbHVtbiB2aXJ0dWFsaXNhdGlvbi4gZmlyZXMgYW4gZXZlbnRcbiAgICAvLyBpZiB0aGUgbGlzdCBvZiBjb2x1bW5zIGhhcyBjaGFuZ2VkLlxuICAgIC8vICsgc2V0Q29sdW1uV2lkdGgoKSwgc2V0VmlydHVhbFZpZXdwb3J0UG9zaXRpb24oKSwgc2V0Q29sdW1uRGVmcygpLCBzaXplQ29sdW1uc1RvRml0KClcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5jaGVja0Rpc3BsYXllZFZpcnR1YWxDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjaGVjayBkaXNwbGF5Q2VudGVyQ29sdW1uVHJlZSBleGlzdHMgZmlyc3QsIGFzIGl0IHdvbid0IGV4aXN0IHdoZW4gZ3JpZCBpcyBpbml0aWFsaXNpbmdcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMuZGlzcGxheWVkQ2VudGVyQ29sdW1ucykpIHtcbiAgICAgICAgICAgIHZhciBoYXNoQmVmb3JlID0gdGhpcy5hbGxEaXNwbGF5ZWRWaXJ0dWFsQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gY29sdW1uLmdldElkKCk7IH0pLmpvaW4oJyMnKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlydHVhbFNldHMoKTtcbiAgICAgICAgICAgIHZhciBoYXNoQWZ0ZXIgPSB0aGlzLmFsbERpc3BsYXllZFZpcnR1YWxDb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW4uZ2V0SWQoKTsgfSkuam9pbignIycpO1xuICAgICAgICAgICAgaWYgKGhhc2hCZWZvcmUgIT09IGhhc2hBZnRlcikge1xuICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfVklSVFVBTF9DT0xVTU5TX0NIQU5HRUQsXG4gICAgICAgICAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRWaXJ0dWFsVmlld3BvcnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChzY3JvbGxXaWR0aCwgc2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHNjcm9sbFdpZHRoICE9PSB0aGlzLnNjcm9sbFdpZHRoIHx8IHNjcm9sbFBvc2l0aW9uICE9PSB0aGlzLnNjcm9sbFBvc2l0aW9uIHx8IHRoaXMuYm9keVdpZHRoRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsV2lkdGggPSBzY3JvbGxXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2FsbCBzZXRWaXJ0dWFsVmlld3BvcnRMZWZ0QW5kUmlnaHQoKSBhdCBsZWFzdCBvbmNlIGFmdGVyIHRoZSBib2R5IHdpZHRoIGNoYW5nZXMsXG4gICAgICAgICAgICAvLyBhcyB0aGUgdmlld3BvcnQgY2FuIHN0YXkgdGhlIHNhbWUsIGJ1dCBpbiBSVEwsIGlmIGJvZHkgd2lkdGggY2hhbmdlcywgd2UgbmVlZCB0byB3b3JrIG91dCB0aGVcbiAgICAgICAgICAgIC8vIHZpcnR1YWwgY29sdW1ucyBhZ2FpblxuICAgICAgICAgICAgdGhpcy5ib2R5V2lkdGhEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFZpcnR1YWxWaWV3cG9ydExlZnRBbmRSaWdodCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRGlzcGxheWVkVmlydHVhbENvbHVtbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuaXNQaXZvdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpdm90TW9kZTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmlzUGl2b3RTZXR0aW5nQWxsb3dlZCA9IGZ1bmN0aW9uIChwaXZvdCkge1xuICAgICAgICBpZiAocGl2b3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1RyZWVEYXRhKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1HcmlkOiBQaXZvdCBtb2RlIG5vdCBhdmFpbGFibGUgaW4gY29uanVuY3Rpb24gVHJlZSBEYXRhIGkuZS4gJ2dyaWRPcHRpb25zLnRyZWVEYXRhOiB0cnVlJ1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRQaXZvdE1vZGUgPSBmdW5jdGlvbiAocGl2b3RNb2RlKSB7XG4gICAgICAgIGlmIChwaXZvdE1vZGUgPT09IHRoaXMucGl2b3RNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzUGl2b3RTZXR0aW5nQWxsb3dlZCh0aGlzLnBpdm90TW9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpdm90TW9kZSA9IHBpdm90TW9kZTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUElWT1RfTU9ERV9DSEFOR0VELFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Vjb25kYXJ5UGl2b3RDb2x1bW4gPSBmdW5jdGlvbiAocGl2b3RLZXlzLCB2YWx1ZUNvbEtleSkge1xuICAgICAgICBpZiAoIXRoaXMuc2Vjb25kYXJ5Q29sdW1uc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZUNvbHVtblRvRmluZCA9IHRoaXMuZ2V0UHJpbWFyeUNvbHVtbih2YWx1ZUNvbEtleSk7XG4gICAgICAgIHZhciBmb3VuZENvbHVtbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciB0aGlzUGl2b3RLZXlzID0gY29sdW1uLmdldENvbERlZigpLnBpdm90S2V5cztcbiAgICAgICAgICAgIHZhciBwaXZvdFZhbHVlQ29sdW1uID0gY29sdW1uLmdldENvbERlZigpLnBpdm90VmFsdWVDb2x1bW47XG4gICAgICAgICAgICB2YXIgcGl2b3RLZXlNYXRjaGVzID0gdXRpbHNfMS5VdGlscy5jb21wYXJlQXJyYXlzKHRoaXNQaXZvdEtleXMsIHBpdm90S2V5cyk7XG4gICAgICAgICAgICB2YXIgcGl2b3RWYWx1ZU1hdGNoZXMgPSBwaXZvdFZhbHVlQ29sdW1uID09PSB2YWx1ZUNvbHVtblRvRmluZDtcbiAgICAgICAgICAgIGlmIChwaXZvdEtleU1hdGNoZXMgJiYgcGl2b3RWYWx1ZU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBmb3VuZENvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZENvbHVtbjtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLnNldEJlYW5zID0gZnVuY3Rpb24gKGxvZ2dlckZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXJGYWN0b3J5LmNyZWF0ZSgnQ29sdW1uQ29udHJvbGxlcicpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0Rmlyc3RSaWdodEFuZExhc3RMZWZ0UGlubmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFzdExlZnQ7XG4gICAgICAgIHZhciBmaXJzdFJpZ2h0O1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVSdGwoKSkge1xuICAgICAgICAgICAgbGFzdExlZnQgPSB0aGlzLmRpc3BsYXllZExlZnRDb2x1bW5zID8gdGhpcy5kaXNwbGF5ZWRMZWZ0Q29sdW1uc1swXSA6IG51bGw7XG4gICAgICAgICAgICBmaXJzdFJpZ2h0ID0gdGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtbnMgPyB0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1uc1t0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1ucy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXN0TGVmdCA9IHRoaXMuZGlzcGxheWVkTGVmdENvbHVtbnMgPyB0aGlzLmRpc3BsYXllZExlZnRDb2x1bW5zW3RoaXMuZGlzcGxheWVkTGVmdENvbHVtbnMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgZmlyc3RSaWdodCA9IHRoaXMuZGlzcGxheWVkUmlnaHRDb2x1bW5zID8gdGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtbnNbMF0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICBjb2x1bW4uc2V0TGFzdExlZnRQaW5uZWQoY29sdW1uID09PSBsYXN0TGVmdCk7XG4gICAgICAgICAgICBjb2x1bW4uc2V0Rmlyc3RSaWdodFBpbm5lZChjb2x1bW4gPT09IGZpcnN0UmlnaHQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmF1dG9TaXplQ29sdW1ucyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIC8vIGJlY2F1c2Ugb2YgY29sdW1uIHZpcnR1YWxpc2F0aW9uLCB3ZSBjYW4gb25seSBkbyB0aGlzIGZ1bmN0aW9uIG9uIGNvbHVtbnMgdGhhdCBhcmVcbiAgICAgICAgLy8gYWN0dWFsbHkgcmVuZGVyZWQsIGFzIG5vbi1yZW5kZXJlZCBjb2x1bW5zIChvdXRzaWRlIHRoZSB2aWV3cG9ydCBhbmQgbm90IHJlbmRlcmVkXG4gICAgICAgIC8vIGR1ZSB0byBjb2x1bW4gdmlydHVhbGlzYXRpb24pIGFyZSBub3QgcHJlc2VudC4gdGhpcyBjYW4gcmVzdWx0IGluIGFsbCByZW5kZXJlZCBjb2x1bW5zXG4gICAgICAgIC8vIGdldHRpbmcgbmFycm93ZWQsIHdoaWNoIGluIHR1cm4gaW50cm9kdWNlcyBtb3JlIHJlbmRlcmVkIGNvbHVtbnMgb24gdGhlIFJIUyB3aGljaFxuICAgICAgICAvLyBkaWQgbm90IGdldCBhdXRvc2l6ZWQgaW4gdGhlIG9yaWdpbmFsIHJ1biwgbGVhdmluZyB0aGUgdmlzaWJsZSBncmlkIHdpdGggY29sdW1ucyBvblxuICAgICAgICAvLyB0aGUgTEhTIHNpemVkLCBidXQgUkhTIG5vLiBzbyB3ZSBrZWVwIGxvb3BpbmcgdGhyb3VnaCB0ZWggdmlzaWJsZSBjb2x1bW5zIHVudGlsXG4gICAgICAgIC8vIG5vIG1vcmUgY29scyBhcmUgYXZhaWxhYmxlIChyZW5kZXJlZCkgdG8gYmUgcmVzaXplZFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHdoaWNoIGNvbHMgd2UgaGF2ZSByZXNpemVkIGluIGhlcmVcbiAgICAgICAgdmFyIGNvbHVtbnNBdXRvc2l6ZWQgPSBbXTtcbiAgICAgICAgLy8gaW5pdGlhbGlzZSB3aXRoIGFueXRoaW5nIGV4Y2VwdCAwIHNvIHRoYXQgd2hpbGUgbG9vcCBleGVjdXRzIGF0IGxlYXN0IG9uY2VcbiAgICAgICAgdmFyIGNoYW5nZXNUaGlzVGltZUFyb3VuZCA9IC0xO1xuICAgICAgICB3aGlsZSAoY2hhbmdlc1RoaXNUaW1lQXJvdW5kICE9PSAwKSB7XG4gICAgICAgICAgICBjaGFuZ2VzVGhpc1RpbWVBcm91bmQgPSAwO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25PbkdyaWRDb2x1bW5zKGtleXMsIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGF1dG9zaXplZCwgc2tpcCBpdFxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zQXV0b3NpemVkLmluZGV4T2YoY29sdW1uKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGhvdyB3aWRlIHRoaXMgY29sIHNob3VsZCBiZVxuICAgICAgICAgICAgICAgIHZhciBwcmVmZXJyZWRXaWR0aCA9IF90aGlzLmF1dG9XaWR0aENhbGN1bGF0b3IuZ2V0UHJlZmVycmVkV2lkdGhGb3JDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICAvLyBwcmVmZXJyZWRXaWR0aCA9IC0xIGlmIHRoaXMgY29sIGlzIG5vdCBvbiB0aGUgc2NyZWVuXG4gICAgICAgICAgICAgICAgaWYgKHByZWZlcnJlZFdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBfdGhpcy5ub3JtYWxpc2VDb2x1bW5XaWR0aChjb2x1bW4sIHByZWZlcnJlZFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEFjdHVhbFdpZHRoKG5ld1dpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uc0F1dG9zaXplZC5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXNUaGlzVGltZUFyb3VuZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW5zQXV0b3NpemVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBldmVudF8yID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUkVTSVpFRCxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zQXV0b3NpemVkLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uc0F1dG9zaXplZC5sZW5ndGggPT09IDEgPyBjb2x1bW5zQXV0b3NpemVkWzBdIDogbnVsbCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudF8yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuYXV0b1NpemVDb2x1bW4gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMuYXV0b1NpemVDb2x1bW5zKFtrZXldKTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmF1dG9TaXplQWxsQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsbERpc3BsYXllZENvbHVtbnMgPSB0aGlzLmdldEFsbERpc3BsYXllZENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5hdXRvU2l6ZUNvbHVtbnMoYWxsRGlzcGxheWVkQ29sdW1ucyk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRDb2x1bW5zRnJvbVRyZWUgPSBmdW5jdGlvbiAocm9vdENvbHVtbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICByZWN1cnNpdmVGaW5kQ29sdW1ucyhyb290Q29sdW1ucyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZUZpbmRDb2x1bW5zKGNoaWxkQ29sdW1ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZENvbHVtbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgY29sdW1uXzEuQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBvcmlnaW5hbENvbHVtbkdyb3VwXzEuT3JpZ2luYWxDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICByZWN1cnNpdmVGaW5kQ29sdW1ucyhjaGlsZC5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldEFsbERpc3BsYXllZENvbHVtbkdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheWVkTGVmdENvbHVtblRyZWUgJiYgdGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtblRyZWUgJiYgdGhpcy5kaXNwbGF5ZWRDZW50cmVDb2x1bW5UcmVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5ZWRMZWZ0Q29sdW1uVHJlZVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5kaXNwbGF5ZWRDZW50cmVDb2x1bW5UcmVlKVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtblRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICsgY29sdW1uU2VsZWN0UGFuZWxcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRQcmltYXJ5Q29sdW1uVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeUJhbGFuY2VkVHJlZTtcbiAgICB9O1xuICAgIC8vICsgZ3JpZFBhbmVsIC0+IGZvciByZXNpemluZyB0aGUgYm9keSBhbmQgc2V0dGluZyB0b3AgbWFyZ2luXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0SGVhZGVyUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRIZWFkZXJSb3dDb3VudDtcbiAgICB9O1xuICAgIC8vICsgaGVhZGVyUmVuZGVyZXIgLT4gc2V0dGluZyBwaW5uZWQgYm9keSB3aWR0aFxuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldExlZnREaXNwbGF5ZWRDb2x1bW5Hcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXllZExlZnRDb2x1bW5UcmVlO1xuICAgIH07XG4gICAgLy8gKyBoZWFkZXJSZW5kZXJlciAtPiBzZXR0aW5nIHBpbm5lZCBib2R5IHdpZHRoXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0UmlnaHREaXNwbGF5ZWRDb2x1bW5Hcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1uVHJlZTtcbiAgICB9O1xuICAgIC8vICsgaGVhZGVyUmVuZGVyZXIgLT4gc2V0dGluZyBwaW5uZWQgYm9keSB3aWR0aFxuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldENlbnRlckRpc3BsYXllZENvbHVtbkdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheWVkQ2VudHJlQ29sdW1uVHJlZTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldERpc3BsYXllZENvbHVtbkdyb3VwcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX0xFRlQ6IHJldHVybiB0aGlzLmdldExlZnREaXNwbGF5ZWRDb2x1bW5Hcm91cHMoKTtcbiAgICAgICAgICAgIGNhc2UgY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9SSUdIVDogcmV0dXJuIHRoaXMuZ2V0UmlnaHREaXNwbGF5ZWRDb2x1bW5Hcm91cHMoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB0aGlzLmdldENlbnRlckRpc3BsYXllZENvbHVtbkdyb3VwcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBncmlkUGFuZWwgLT4gZW5zdXJlQ29sdW1uVmlzaWJsZVxuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmlzQ29sdW1uRGlzcGxheWVkID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKCkuaW5kZXhPZihjb2x1bW4pID49IDA7XG4gICAgfTtcbiAgICAvLyArIGNzdkNyZWF0b3JcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxEaXNwbGF5ZWRDb2x1bW5zO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0QWxsRGlzcGxheWVkVmlydHVhbENvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbERpc3BsYXllZFZpcnR1YWxDb2x1bW5zO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0RGlzcGxheWVkTGVmdENvbHVtbnNGb3JSb3cgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29sU3BhbkFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheWVkTGVmdENvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREaXNwbGF5ZWRDb2x1bW5zRm9yUm93KHJvd05vZGUsIHRoaXMuZGlzcGxheWVkTGVmdENvbHVtbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXREaXNwbGF5ZWRSaWdodENvbHVtbnNGb3JSb3cgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29sU3BhbkFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheWVkUmlnaHRDb2x1bW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzcGxheWVkQ29sdW1uc0ZvclJvdyhyb3dOb2RlLCB0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldERpc3BsYXllZENvbHVtbnNGb3JSb3cgPSBmdW5jdGlvbiAocm93Tm9kZSwgZGlzcGxheWVkQ29sdW1ucywgZmlsdGVyQ2FsbGJhY2ssIGdhcEJlZm9yZUNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGxhc3RDb25zaWRlcmVkQ29sID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5ZWRDb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29sID0gZGlzcGxheWVkQ29sdW1uc1tpXTtcbiAgICAgICAgICAgIHZhciBjb2xTcGFuID0gY29sLmdldENvbFNwYW4ocm93Tm9kZSk7XG4gICAgICAgICAgICBpZiAoY29sU3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sc1RvUmVtb3ZlID0gY29sU3BhbiAtIDE7XG4gICAgICAgICAgICAgICAgaSArPSBjb2xzVG9SZW1vdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlsdGVyUGFzc2VzID0gZmlsdGVyQ2FsbGJhY2sgPyBmaWx0ZXJDYWxsYmFjayhjb2wpIDogdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJQYXNzZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2FwQmVmb3JlQ29sdW1uID0gZ2FwQmVmb3JlQ2FsbGJhY2sgPyBnYXBCZWZvcmVDYWxsYmFjayhjb2wpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGFkZEluUHJldmlvdXNDb2x1bW4gPSByZXN1bHQubGVuZ3RoID09PSAwICYmIGdhcEJlZm9yZUNvbHVtbiAmJiBsYXN0Q29uc2lkZXJlZENvbDtcbiAgICAgICAgICAgICAgICBpZiAoYWRkSW5QcmV2aW91c0NvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYXN0Q29uc2lkZXJlZENvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q29uc2lkZXJlZENvbCA9IGNvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLy8gKyByb3dSZW5kZXJlclxuICAgIC8vIGlmIHdlIGFyZSBub3QgY29sdW1uIHNwYW5uaW5nLCB0aGlzIGp1c3QgcmV0dXJucyBiYWNrIHRoZSB2aXJ0dWFsIGNlbnRyZSBjb2x1bW5zLFxuICAgIC8vIGhvd2V2ZXIgaWYgd2UgYXJlIGNvbHVtbiBzcGFubmluZywgdGhlbiBkaWZmZXJlbnQgcm93cyBjYW4gaGF2ZSBkaWZmZXJlbnQgdmlydHVhbFxuICAgIC8vIGNvbHVtbnMsIHNvIHdlIGhhdmUgdG8gd29yayBvdXQgdGhlIGxpc3QgZm9yIGVhY2ggaW5kaXZpZHVhbCByb3cuXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0QWxsRGlzcGxheWVkQ2VudGVyVmlydHVhbENvbHVtbnNGb3JSb3cgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuY29sU3BhbkFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxsRGlzcGxheWVkQ2VudGVyVmlydHVhbENvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdhcEJlZm9yZUNhbGxiYWNrID0gZnVuY3Rpb24gKGNvbCkgeyByZXR1cm4gY29sLmdldExlZnQoKSA+IF90aGlzLnZpZXdwb3J0TGVmdDsgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzcGxheWVkQ29sdW1uc0ZvclJvdyhyb3dOb2RlLCB0aGlzLmRpc3BsYXllZENlbnRlckNvbHVtbnMsIHRoaXMuaXNDb2x1bW5JblZpZXdwb3J0LmJpbmQodGhpcyksIGdhcEJlZm9yZUNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmlzQ29sdW1uSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgdmFyIGNvbHVtbkxlZnQgPSBjb2wuZ2V0TGVmdCgpO1xuICAgICAgICB2YXIgY29sdW1uUmlnaHQgPSBjb2wuZ2V0TGVmdCgpICsgY29sLmdldEFjdHVhbFdpZHRoKCk7XG4gICAgICAgIHZhciBjb2x1bW5Ub011Y2hMZWZ0ID0gY29sdW1uTGVmdCA8IHRoaXMudmlld3BvcnRMZWZ0ICYmIGNvbHVtblJpZ2h0IDwgdGhpcy52aWV3cG9ydExlZnQ7XG4gICAgICAgIHZhciBjb2x1bW5Ub011Y2hSaWdodCA9IGNvbHVtbkxlZnQgPiB0aGlzLnZpZXdwb3J0UmlnaHQgJiYgY29sdW1uUmlnaHQgPiB0aGlzLnZpZXdwb3J0UmlnaHQ7XG4gICAgICAgIHJldHVybiAhY29sdW1uVG9NdWNoTGVmdCAmJiAhY29sdW1uVG9NdWNoUmlnaHQ7XG4gICAgfTtcbiAgICAvLyB1c2VkIGJ5OlxuICAgIC8vICsgYW5ndWxhckdyaWQgLT4gc2V0dGluZyBwaW5uZWQgYm9keSB3aWR0aFxuICAgIC8vIHRvZG86IHRoaXMgbmVlZHMgdG8gYmUgY2FjaGVkXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0UGlubmVkTGVmdENvbnRhaW5lcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXaWR0aE9mQ29sc0luTGlzdCh0aGlzLmRpc3BsYXllZExlZnRDb2x1bW5zKTtcbiAgICB9O1xuICAgIC8vIHRvZG86IHRoaXMgbmVlZHMgdG8gYmUgY2FjaGVkXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0UGlubmVkUmlnaHRDb250YWluZXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2lkdGhPZkNvbHNJbkxpc3QodGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtbnMpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlUHJpbWFyeUNvbHVtbkxpc3QgPSBmdW5jdGlvbiAoa2V5cywgbWFzdGVyTGlzdCwgYWN0aW9uSXNBZGQsIGNvbHVtbkNhbGxiYWNrLCBldmVudFR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZ09yRW1wdHkoa2V5cykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXRMZWFzdE9uZSA9IGZhbHNlO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGNvbHVtblRvQWRkID0gX3RoaXMuZ2V0UHJpbWFyeUNvbHVtbihrZXkpO1xuICAgICAgICAgICAgaWYgKCFjb2x1bW5Ub0FkZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb25Jc0FkZCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXN0ZXJMaXN0LmluZGV4T2YoY29sdW1uVG9BZGQpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXN0ZXJMaXN0LnB1c2goY29sdW1uVG9BZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hc3Rlckxpc3QuaW5kZXhPZihjb2x1bW5Ub0FkZCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVGcm9tQXJyYXkobWFzdGVyTGlzdCwgY29sdW1uVG9BZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sdW1uQ2FsbGJhY2soY29sdW1uVG9BZGQpO1xuICAgICAgICAgICAgYXRMZWFzdE9uZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWF0TGVhc3RPbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXllZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICAgICAgY29sdW1uczogbWFzdGVyTGlzdCxcbiAgICAgICAgICAgIGNvbHVtbjogbWFzdGVyTGlzdC5sZW5ndGggPT09IDEgPyBtYXN0ZXJMaXN0WzBdIDogbnVsbCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLnNldFJvd0dyb3VwQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2xLZXlzKSB7XG4gICAgICAgIHRoaXMuYXV0b0dyb3Vwc05lZWRCdWlsZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0UHJpbWFyeUNvbHVtbkxpc3QoY29sS2V5cywgdGhpcy5yb3dHcm91cENvbHVtbnMsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUk9XX0dST1VQX0NIQU5HRUQsIHRoaXMuc2V0Um93R3JvdXBBY3RpdmUuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRSb3dHcm91cEFjdGl2ZSA9IGZ1bmN0aW9uIChhY3RpdmUsIGNvbHVtbikge1xuICAgICAgICBpZiAoYWN0aXZlID09PSBjb2x1bW4uaXNSb3dHcm91cEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29sdW1uLnNldFJvd0dyb3VwQWN0aXZlKGFjdGl2ZSk7XG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICBjb2x1bW4uc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuYWRkUm93R3JvdXBDb2x1bW4gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMuYWRkUm93R3JvdXBDb2x1bW5zKFtrZXldKTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmFkZFJvd0dyb3VwQ29sdW1ucyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHRoaXMuYXV0b0dyb3Vwc05lZWRCdWlsZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlUHJpbWFyeUNvbHVtbkxpc3Qoa2V5cywgdGhpcy5yb3dHcm91cENvbHVtbnMsIHRydWUsIHRoaXMuc2V0Um93R3JvdXBBY3RpdmUuYmluZCh0aGlzLCB0cnVlKSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9ST1dfR1JPVVBfQ0hBTkdFRCk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVSb3dHcm91cENvbHVtbnMgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICB0aGlzLmF1dG9Hcm91cHNOZWVkQnVpbGRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVByaW1hcnlDb2x1bW5MaXN0KGtleXMsIHRoaXMucm93R3JvdXBDb2x1bW5zLCBmYWxzZSwgdGhpcy5zZXRSb3dHcm91cEFjdGl2ZS5iaW5kKHRoaXMsIGZhbHNlKSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9ST1dfR1JPVVBfQ0hBTkdFRCk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVSb3dHcm91cENvbHVtbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVSb3dHcm91cENvbHVtbnMoW2tleV0pO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuYWRkUGl2b3RDb2x1bW5zID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcmltYXJ5Q29sdW1uTGlzdChrZXlzLCB0aGlzLnBpdm90Q29sdW1ucywgdHJ1ZSwgZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gY29sdW1uLnNldFBpdm90QWN0aXZlKHRydWUpOyB9LCBldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1BJVk9UX0NIQU5HRUQpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0UGl2b3RDb2x1bW5zID0gZnVuY3Rpb24gKGNvbEtleXMpIHtcbiAgICAgICAgdGhpcy5zZXRQcmltYXJ5Q29sdW1uTGlzdChjb2xLZXlzLCB0aGlzLnBpdm90Q29sdW1ucywgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9QSVZPVF9DSEFOR0VELCBmdW5jdGlvbiAoYWRkZWQsIGNvbHVtbikge1xuICAgICAgICAgICAgY29sdW1uLnNldFBpdm90QWN0aXZlKGFkZGVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5hZGRQaXZvdENvbHVtbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5hZGRQaXZvdENvbHVtbnMoW2tleV0pO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlUGl2b3RDb2x1bW5zID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcmltYXJ5Q29sdW1uTGlzdChrZXlzLCB0aGlzLnBpdm90Q29sdW1ucywgZmFsc2UsIGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5zZXRQaXZvdEFjdGl2ZShmYWxzZSk7IH0sIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUElWT1RfQ0hBTkdFRCk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVQaXZvdENvbHVtbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQaXZvdENvbHVtbnMoW2tleV0pO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0UHJpbWFyeUNvbHVtbkxpc3QgPSBmdW5jdGlvbiAoY29sS2V5cywgbWFzdGVyTGlzdCwgZXZlbnROYW1lLCBjb2x1bW5DYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXN0ZXJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhjb2xLZXlzKSkge1xuICAgICAgICAgICAgY29sS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gX3RoaXMuZ2V0UHJpbWFyeUNvbHVtbihrZXkpO1xuICAgICAgICAgICAgICAgIG1hc3Rlckxpc3QucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmltYXJ5Q29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBhZGRlZCA9IG1hc3Rlckxpc3QuaW5kZXhPZihjb2x1bW4pID49IDA7XG4gICAgICAgICAgICBjb2x1bW5DYWxsYmFjayhhZGRlZCwgY29sdW1uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlzcGxheWVkQ29sdW1ucygpO1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudE5hbWUsXG4gICAgICAgICAgICBjb2x1bW5zOiBtYXN0ZXJMaXN0LFxuICAgICAgICAgICAgY29sdW1uOiBtYXN0ZXJMaXN0Lmxlbmd0aCA9PT0gMSA/IG1hc3Rlckxpc3RbMF0gOiBudWxsLFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0VmFsdWVDb2x1bW5zID0gZnVuY3Rpb24gKGNvbEtleXMpIHtcbiAgICAgICAgdGhpcy5zZXRQcmltYXJ5Q29sdW1uTGlzdChjb2xLZXlzLCB0aGlzLnZhbHVlQ29sdW1ucywgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9WQUxVRV9DSEFOR0VELCB0aGlzLnNldFZhbHVlQWN0aXZlLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0VmFsdWVBY3RpdmUgPSBmdW5jdGlvbiAoYWN0aXZlLCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKGFjdGl2ZSA9PT0gY29sdW1uLmlzVmFsdWVBY3RpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbi5zZXRWYWx1ZUFjdGl2ZShhY3RpdmUpO1xuICAgICAgICBpZiAoYWN0aXZlICYmICFjb2x1bW4uZ2V0QWdnRnVuYygpKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEFnZ0Z1bmMgPSB0aGlzLmFnZ0Z1bmNTZXJ2aWNlLmdldERlZmF1bHRBZ2dGdW5jKGNvbHVtbik7XG4gICAgICAgICAgICBjb2x1bW4uc2V0QWdnRnVuYyhkZWZhdWx0QWdnRnVuYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmFkZFZhbHVlQ29sdW1ucyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUHJpbWFyeUNvbHVtbkxpc3Qoa2V5cywgdGhpcy52YWx1ZUNvbHVtbnMsIHRydWUsIHRoaXMuc2V0VmFsdWVBY3RpdmUuYmluZCh0aGlzLCB0cnVlKSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9WQUxVRV9DSEFOR0VEKTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmFkZFZhbHVlQ29sdW1uID0gZnVuY3Rpb24gKGNvbEtleSkge1xuICAgICAgICB0aGlzLmFkZFZhbHVlQ29sdW1ucyhbY29sS2V5XSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVWYWx1ZUNvbHVtbiA9IGZ1bmN0aW9uIChjb2xLZXkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVWYWx1ZUNvbHVtbnMoW2NvbEtleV0pO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlVmFsdWVDb2x1bW5zID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcmltYXJ5Q29sdW1uTGlzdChrZXlzLCB0aGlzLnZhbHVlQ29sdW1ucywgZmFsc2UsIHRoaXMuc2V0VmFsdWVBY3RpdmUuYmluZCh0aGlzLCBmYWxzZSksIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fVkFMVUVfQ0hBTkdFRCk7XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIHRoZSB3aWR0aCB3ZSBjYW4gc2V0IHRvIHRoaXMgY29sLCB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIG1pbiBhbmQgbWF4IHdpZHRoc1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLm5vcm1hbGlzZUNvbHVtbldpZHRoID0gZnVuY3Rpb24gKGNvbHVtbiwgbmV3V2lkdGgpIHtcbiAgICAgICAgaWYgKG5ld1dpZHRoIDwgY29sdW1uLmdldE1pbldpZHRoKCkpIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gY29sdW1uLmdldE1pbldpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbi5pc0dyZWF0ZXJUaGFuTWF4KG5ld1dpZHRoKSkge1xuICAgICAgICAgICAgbmV3V2lkdGggPSBjb2x1bW4uZ2V0TWF4V2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3V2lkdGg7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRQcmltYXJ5T3JHcmlkQ29sdW1uID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRQcmltYXJ5Q29sdW1uKGtleSk7XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkQ29sdW1uKGtleSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLnNldENvbHVtbldpZHRoID0gZnVuY3Rpb24gKGtleSwgbmV3V2lkdGgsIGZpbmlzaGVkKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldFByaW1hcnlPckdyaWRDb2x1bW4oa2V5KTtcbiAgICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdXaWR0aCA9IHRoaXMubm9ybWFsaXNlQ29sdW1uV2lkdGgoY29sdW1uLCBuZXdXaWR0aCk7XG4gICAgICAgIHZhciB3aWR0aENoYW5nZWQgPSBjb2x1bW4uZ2V0QWN0dWFsV2lkdGgoKSAhPT0gbmV3V2lkdGg7XG4gICAgICAgIGlmICh3aWR0aENoYW5nZWQpIHtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRBY3R1YWxXaWR0aChuZXdXaWR0aCk7XG4gICAgICAgICAgICB0aGlzLnNldExlZnRWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUJvZHlXaWR0aHMoKTtcbiAgICAgICAgdGhpcy5jaGVja0Rpc3BsYXllZFZpcnR1YWxDb2x1bW5zKCk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjaGFuZ2UgZmlyc3QsIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGZpcmluZyBvZiBldmVudHNcbiAgICAgICAgLy8gaG93ZXZlciB3ZSBhbHdheXMgZmlyZSAnZmluaXNoZWQnIGV2ZW50cy4gdGhpcyBpcyBpbXBvcnRhbnRcbiAgICAgICAgLy8gd2hlbiBncm91cHMgYXJlIHJlc2l6ZWQsIGFzIGlmIHRoZSBncm91cCBpcyBjaGFuZ2luZyBzbG93bHksXG4gICAgICAgIC8vIGVnIDEgcGl4ZWwgYXQgYSB0aW1lLCB0aGVuIGVhY2ggY2hhbmdlIHdpbGwgZmlyZSBjaGFuZ2UgZXZlbnRzXG4gICAgICAgIC8vIGluIGFsbCB0aGUgY29sdW1ucyBpbiB0aGUgZ3JvdXAsIGJ1dCBvbmx5IG9uZSB3aXRoIGdldCB0aGUgcGl4ZWwuXG4gICAgICAgIGlmIChmaW5pc2hlZCB8fCB3aWR0aENoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8zID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUkVTSVpFRCxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBbY29sdW1uXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZDogZmluaXNoZWQsXG4gICAgICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnRfMyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLnNldENvbHVtbkFnZ0Z1bmMgPSBmdW5jdGlvbiAoY29sdW1uLCBhZ2dGdW5jKSB7XG4gICAgICAgIGNvbHVtbi5zZXRBZ2dGdW5jKGFnZ0Z1bmMpO1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1ZBTFVFX0NIQU5HRUQsXG4gICAgICAgICAgICBjb2x1bW5zOiBbY29sdW1uXSxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUubW92ZVJvd0dyb3VwQ29sdW1uID0gZnVuY3Rpb24gKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5yb3dHcm91cENvbHVtbnNbZnJvbUluZGV4XTtcbiAgICAgICAgdGhpcy5yb3dHcm91cENvbHVtbnMuc3BsaWNlKGZyb21JbmRleCwgMSk7XG4gICAgICAgIHRoaXMucm93R3JvdXBDb2x1bW5zLnNwbGljZSh0b0luZGV4LCAwLCBjb2x1bW4pO1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1JPV19HUk9VUF9DSEFOR0VELFxuICAgICAgICAgICAgY29sdW1uczogdGhpcy5yb3dHcm91cENvbHVtbnMsXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMucm93R3JvdXBDb2x1bW5zLmxlbmd0aCA9PT0gMSA/IHRoaXMucm93R3JvdXBDb2x1bW5zWzBdIDogbnVsbCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLm1vdmVDb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbnNUb01vdmVLZXlzLCB0b0luZGV4KSB7XG4gICAgICAgIHRoaXMuY29sdW1uQW5pbWF0aW9uU2VydmljZS5zdGFydCgpO1xuICAgICAgICBpZiAodG9JbmRleCA+IHRoaXMuZ3JpZENvbHVtbnMubGVuZ3RoIC0gY29sdW1uc1RvTW92ZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IHRyaWVkIHRvIGluc2VydCBjb2x1bW5zIGluIGludmFsaWQgbG9jYXRpb24sIHRvSW5kZXggPSAnICsgdG9JbmRleCk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IHJlbWVtYmVyIHRoYXQgeW91IHNob3VsZCBub3QgY291bnQgdGhlIG1vdmluZyBjb2x1bW5zIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG5ldyBpbmRleCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gcHVsbCBhbGwgdGhlIGNvbHVtbnMgb3V0IGZpcnN0IGFuZCBwdXQgdGhlbSBpbnRvIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgICB2YXIgY29sdW1uc1RvTW92ZSA9IHRoaXMuZ2V0R3JpZENvbHVtbnMoY29sdW1uc1RvTW92ZUtleXMpO1xuICAgICAgICB2YXIgZmFpbGVkUnVsZXMgPSAhdGhpcy5kb2VzTW92ZVBhc3NSdWxlcyhjb2x1bW5zVG9Nb3ZlLCB0b0luZGV4KTtcbiAgICAgICAgaWYgKGZhaWxlZFJ1bGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXRpbHNfMS5VdGlscy5tb3ZlSW5BcnJheSh0aGlzLmdyaWRDb2x1bW5zLCBjb2x1bW5zVG9Nb3ZlLCB0b0luZGV4KTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fTU9WRUQsXG4gICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zVG9Nb3ZlLFxuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5zVG9Nb3ZlLmxlbmd0aCA9PT0gMSA/IGNvbHVtbnNUb01vdmVbMF0gOiBudWxsLFxuICAgICAgICAgICAgdG9JbmRleDogdG9JbmRleCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgdGhpcy5jb2x1bW5BbmltYXRpb25TZXJ2aWNlLmZpbmlzaCgpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZG9lc01vdmVQYXNzUnVsZXMgPSBmdW5jdGlvbiAoY29sdW1uc1RvTW92ZSwgdG9JbmRleCkge1xuICAgICAgICB2YXIgYWxsQ29sdW1uc0NvcHkgPSB0aGlzLmdyaWRDb2x1bW5zLnNsaWNlKCk7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMubW92ZUluQXJyYXkoYWxsQ29sdW1uc0NvcHksIGNvbHVtbnNUb01vdmUsIHRvSW5kZXgpO1xuICAgICAgICB2YXIgcnVsZXNQYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb2x1bW5VdGlscy5kZXB0aEZpcnN0T3JpZ2luYWxUcmVlU2VhcmNoKHRoaXMuZ3JpZEJhbGFuY2VkVHJlZSwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIG9yaWdpbmFsQ29sdW1uR3JvdXBfMS5PcmlnaW5hbENvbHVtbkdyb3VwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2x1bW5Hcm91cCA9IGNoaWxkO1xuICAgICAgICAgICAgdmFyIG1hcnJ5Q2hpbGRyZW4gPSBjb2x1bW5Hcm91cC5nZXRDb2xHcm91cERlZigpICYmIGNvbHVtbkdyb3VwLmdldENvbEdyb3VwRGVmKCkubWFycnlDaGlsZHJlbjtcbiAgICAgICAgICAgIGlmICghbWFycnlDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdJbmRleGVzID0gW107XG4gICAgICAgICAgICBjb2x1bW5Hcm91cC5nZXRMZWFmQ29sdW1ucygpLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdDb2xJbmRleCA9IGFsbENvbHVtbnNDb3B5LmluZGV4T2YoY29sKTtcbiAgICAgICAgICAgICAgICBuZXdJbmRleGVzLnB1c2gobmV3Q29sSW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWF4SW5kZXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBuZXdJbmRleGVzKTtcbiAgICAgICAgICAgIHZhciBtaW5JbmRleCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIG5ld0luZGV4ZXMpO1xuICAgICAgICAgICAgLy8gd2lkdGggaXMgaG93IGZhciB0aGUgZmlyc3QgY29sdW1uIGluIHRoaXMgZ3JvdXAgaXMgYXdheSBmcm9tIHRoZSBsYXN0IGNvbHVtblxuICAgICAgICAgICAgdmFyIHNwcmVhZCA9IG1heEluZGV4IC0gbWluSW5kZXg7XG4gICAgICAgICAgICB2YXIgbWF4U3ByZWFkID0gY29sdW1uR3JvdXAuZ2V0TGVhZkNvbHVtbnMoKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbHVtbnNcbiAgICAgICAgICAgIGlmIChzcHJlYWQgPiBtYXhTcHJlYWQpIHtcbiAgICAgICAgICAgICAgICBydWxlc1Bhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBtYXhJbmRleCA9ICR7bWF4SW5kZXh9LCBtaW5JbmRleCA9ICR7bWluSW5kZXh9LCBzcHJlYWQgPSAke3NwcmVhZH0sIG1heFNwcmVhZCA9ICR7bWF4U3ByZWFkfSwgZmFpbCA9ICR7c3ByZWFkID4gKGNvdW50LTEpfWApXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhhbGxDb2x1bW5zQ29weS5tYXAoIGNvbCA9PiBjb2wuZ2V0Q29sRGVmKCkuZmllbGQpLmpvaW4oJywnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnVsZXNQYXNzO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUubW92ZUNvbHVtbiA9IGZ1bmN0aW9uIChrZXksIHRvSW5kZXgpIHtcbiAgICAgICAgdGhpcy5tb3ZlQ29sdW1ucyhba2V5XSwgdG9JbmRleCk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5tb3ZlQ29sdW1uQnlJbmRleCA9IGZ1bmN0aW9uIChmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ3JpZENvbHVtbnNbZnJvbUluZGV4XTtcbiAgICAgICAgdGhpcy5tb3ZlQ29sdW1uKGNvbHVtbiwgdG9JbmRleCk7XG4gICAgfTtcbiAgICAvLyB1c2VkIGJ5OlxuICAgIC8vICsgYW5ndWxhckdyaWQgLT4gZm9yIHNldHRpbmcgYm9keSB3aWR0aFxuICAgIC8vICsgcm93Q29udHJvbGxlciAtPiBzZXR0aW5nIG1haW4gcm93IHdpZHRocyAod2hlbiBpbnNlcnRpbmcgYW5kIHJlc2l6aW5nKVxuICAgIC8vIG5lZWQgdG8gY2FjaGUgdGhpc1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldEJvZHlDb250YWluZXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keVdpZHRoO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q29udGFpbmVyV2lkdGggPSBmdW5jdGlvbiAocGlubmVkKSB7XG4gICAgICAgIHN3aXRjaCAocGlubmVkKSB7XG4gICAgICAgICAgICBjYXNlIGNvbHVtbl8xLkNvbHVtbi5QSU5ORURfTEVGVDogcmV0dXJuIHRoaXMubGVmdFdpZHRoO1xuICAgICAgICAgICAgY2FzZSBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX1JJR0hUOiByZXR1cm4gdGhpcy5yaWdodFdpZHRoO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHRoaXMuYm9keVdpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBhZnRlciBzZXRDb2x1bW5XaWR0aCBvciB1cGRhdGVHcm91cHNBbmREaXNwbGF5ZWRDb2x1bW5zXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlQm9keVdpZHRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0JvZHlXaWR0aCA9IHRoaXMuZ2V0V2lkdGhPZkNvbHNJbkxpc3QodGhpcy5kaXNwbGF5ZWRDZW50ZXJDb2x1bW5zKTtcbiAgICAgICAgdmFyIG5ld0xlZnRXaWR0aCA9IHRoaXMuZ2V0V2lkdGhPZkNvbHNJbkxpc3QodGhpcy5kaXNwbGF5ZWRMZWZ0Q29sdW1ucyk7XG4gICAgICAgIHZhciBuZXdSaWdodFdpZHRoID0gdGhpcy5nZXRXaWR0aE9mQ29sc0luTGlzdCh0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1ucyk7XG4gICAgICAgIC8vIHRoaXMgaXMgdXNlZCBieSB2aXJ0dWFsIGNvbCBjYWxjdWxhdGlvbiwgZm9yIFJUTCBvbmx5LCBhcyBhIGNoYW5nZSB0byBib2R5IHdpZHRoIGNhbiBpbXBhY3QgZGlzcGxheWVkXG4gICAgICAgIC8vIGNvbHVtbnMsIGR1ZSB0byBSVEwgaW52ZXJ0aW5nIHRoZSB5IGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMuYm9keVdpZHRoRGlydHkgPSB0aGlzLmJvZHlXaWR0aCAhPT0gbmV3Qm9keVdpZHRoO1xuICAgICAgICB2YXIgYXRMZWFzdE9uZUNoYW5nZWQgPSB0aGlzLmJvZHlXaWR0aCAhPT0gbmV3Qm9keVdpZHRoIHx8IHRoaXMubGVmdFdpZHRoICE9PSBuZXdMZWZ0V2lkdGggfHwgdGhpcy5yaWdodFdpZHRoICE9PSBuZXdSaWdodFdpZHRoO1xuICAgICAgICBpZiAoYXRMZWFzdE9uZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keVdpZHRoID0gbmV3Qm9keVdpZHRoO1xuICAgICAgICAgICAgdGhpcy5sZWZ0V2lkdGggPSBuZXdMZWZ0V2lkdGg7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0V2lkdGggPSBuZXdSaWdodFdpZHRoO1xuICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGZpcmVzLCBpdCBpcyBwaWNrZWQgdXAgYnkgdGhlIGdyaWRQYW5lbCwgd2hpY2ggZW5kcyB1cCBpblxuICAgICAgICAgICAgLy8gZ3JpZFBhbmVsIGNhbGxpbmcgc2V0V2lkdGhBbmRTY3JvbGxQb3NpdGlvbigpLCB3aGljaCBpbiB0dXJuIGNhbGxzIHNldFZpcnR1YWxWaWV3cG9ydFBvc2l0aW9uKClcbiAgICAgICAgICAgIHZhciBldmVudF80ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9ESVNQTEFZRURfQ09MVU1OU19XSURUSF9DSEFOR0VELFxuICAgICAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyArIHJvd0NvbnRyb2xsZXJcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRWYWx1ZUNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQ29sdW1ucyA/IHRoaXMudmFsdWVDb2x1bW5zIDogW107XG4gICAgfTtcbiAgICAvLyArIHJvd0NvbnRyb2xsZXJcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRQaXZvdENvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpdm90Q29sdW1ucyA/IHRoaXMucGl2b3RDb2x1bW5zIDogW107XG4gICAgfTtcbiAgICAvLyArIGluTWVtb3J5Um93TW9kZWxcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5pc1Bpdm90QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waXZvdENvbHVtbnMgJiYgdGhpcy5waXZvdENvbHVtbnMubGVuZ3RoID4gMCAmJiB0aGlzLnBpdm90TW9kZTtcbiAgICB9O1xuICAgIC8vICsgdG9vbFBhbmVsXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Um93R3JvdXBDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dHcm91cENvbHVtbnMgPyB0aGlzLnJvd0dyb3VwQ29sdW1ucyA6IFtdO1xuICAgIH07XG4gICAgLy8gKyByb3dDb250cm9sbGVyIC0+IHdoaWxlIGluc2VydGluZyByb3dzXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0RGlzcGxheWVkQ2VudGVyQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheWVkQ2VudGVyQ29sdW1ucztcbiAgICB9O1xuICAgIC8vICsgcm93Q29udHJvbGxlciAtPiB3aGlsZSBpbnNlcnRpbmcgcm93c1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldERpc3BsYXllZExlZnRDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5ZWRMZWZ0Q29sdW1ucztcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldERpc3BsYXllZFJpZ2h0Q29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheWVkUmlnaHRDb2x1bW5zO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0RGlzcGxheWVkQ29sdW1ucyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX0xFRlQ6IHJldHVybiB0aGlzLmdldERpc3BsYXllZExlZnRDb2x1bW5zKCk7XG4gICAgICAgICAgICBjYXNlIGNvbHVtbl8xLkNvbHVtbi5QSU5ORURfUklHSFQ6IHJldHVybiB0aGlzLmdldERpc3BsYXllZFJpZ2h0Q29sdW1ucygpO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHRoaXMuZ2V0RGlzcGxheWVkQ2VudGVyQ29sdW1ucygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB1c2VkIGJ5OlxuICAgIC8vICsgaW5NZW1vcnlSb3dDb250cm9sbGVyIC0+IHNvcnRpbmcsIGJ1aWxkaW5nIHF1aWNrIGZpbHRlciB0ZXh0XG4gICAgLy8gKyBoZWFkZXJSZW5kZXJlciAtPiBzb3J0aW5nIChjbGVhcmluZyBpY29uKVxuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldEFsbFByaW1hcnlDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5Q29sdW1ucztcbiAgICB9O1xuICAgIC8vICsgbW92ZUNvbHVtbkNvbnRyb2xsZXJcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRBbGxHcmlkQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZENvbHVtbnM7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5VdGlscy5taXNzaW5nT3JFbXB0eSh0aGlzLmdyaWRDb2x1bW5zKTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmlzUm93R3JvdXBFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMubWlzc2luZ09yRW1wdHkodGhpcy5yb3dHcm91cENvbHVtbnMpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0Q29sdW1uVmlzaWJsZSA9IGZ1bmN0aW9uIChrZXksIHZpc2libGUpIHtcbiAgICAgICAgdGhpcy5zZXRDb2x1bW5zVmlzaWJsZShba2V5XSwgdmlzaWJsZSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRDb2x1bW5zVmlzaWJsZSA9IGZ1bmN0aW9uIChrZXlzLCB2aXNpYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29sdW1uQW5pbWF0aW9uU2VydmljZS5zdGFydCgpO1xuICAgICAgICB0aGlzLmFjdGlvbk9uR3JpZENvbHVtbnMoa2V5cywgZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgY29sdW1uLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fVklTSUJMRSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBudWxsLFxuICAgICAgICAgICAgICAgIGFwaTogX3RoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgICAgICBjb2x1bW5BcGk6IF90aGlzLmNvbHVtbkFwaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29sdW1uQW5pbWF0aW9uU2VydmljZS5maW5pc2goKTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLnNldENvbHVtblBpbm5lZCA9IGZ1bmN0aW9uIChrZXksIHBpbm5lZCkge1xuICAgICAgICB0aGlzLnNldENvbHVtbnNQaW5uZWQoW2tleV0sIHBpbm5lZCk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRDb2x1bW5zUGlubmVkID0gZnVuY3Rpb24gKGtleXMsIHBpbm5lZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbHVtbkFuaW1hdGlvblNlcnZpY2Uuc3RhcnQoKTtcbiAgICAgICAgdmFyIGFjdHVhbFBpbm5lZDtcbiAgICAgICAgaWYgKHBpbm5lZCA9PT0gdHJ1ZSB8fCBwaW5uZWQgPT09IGNvbHVtbl8xLkNvbHVtbi5QSU5ORURfTEVGVCkge1xuICAgICAgICAgICAgYWN0dWFsUGlubmVkID0gY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9MRUZUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBpbm5lZCA9PT0gY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9SSUdIVCkge1xuICAgICAgICAgICAgYWN0dWFsUGlubmVkID0gY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9SSUdIVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdHVhbFBpbm5lZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25PbkdyaWRDb2x1bW5zKGtleXMsIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRQaW5uZWQoYWN0dWFsUGlubmVkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9QSU5ORUQsXG4gICAgICAgICAgICAgICAgcGlubmVkOiBhY3R1YWxQaW5uZWQsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IG51bGwsXG4gICAgICAgICAgICAgICAgYXBpOiBfdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkFwaTogX3RoaXMuY29sdW1uQXBpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2x1bW5BbmltYXRpb25TZXJ2aWNlLmZpbmlzaCgpO1xuICAgIH07XG4gICAgLy8gZG9lcyBhbiBhY3Rpb24gb24gYSBzZXQgb2YgY29sdW1ucy4gcHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGxvb2tpbmcgdXAgdGhlXG4gICAgLy8gY29sdW1ucyBiYXNlZCBvbiBrZXksIGdldHRpbmcgYSBsaXN0IG9mIGVmZmVjdGVkIGNvbHVtbnMsIGFuZCB0aGVuIHVwZGF0ZWQgdGhlIGV2ZW50XG4gICAgLy8gd2l0aCBlaXRoZXIgb25lIGNvbHVtbiAoaWYgaXQgd2FzIGp1c3Qgb25lIGNvbCkgb3IgYSBsaXN0IG9mIGNvbHVtbnNcbiAgICAvLyB1c2VkIGJ5OiBhdXRvUmVzaXplLCBzZXRWaXNpYmxlLCBzZXRQaW5uZWRcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5hY3Rpb25PbkdyaWRDb2x1bW5zID0gZnVuY3Rpb24gKC8vIHRoZSBjb2x1bW4ga2V5cyB0aGlzIGFjdGlvbiB3aWxsIGJlIG9uXG4gICAgICAgIGtleXMsIFxuICAgICAgICAvLyB0aGUgYWN0aW9uIHRvIGRvIC0gaWYgdGhpcyByZXR1cm5zIGZhbHNlLCB0aGUgY29sdW1uIHdhcyBza2lwcGVkXG4gICAgICAgIC8vIGFuZCB3b24ndCBiZSBpbmNsdWRlZCBpbiB0aGUgZXZlbnRcbiAgICAgICAgYWN0aW9uLCBcbiAgICAgICAgLy8gc2hvdWxkIHJldHVybiBiYWNrIGEgY29sdW1uIGV2ZW50IG9mIHRoZSByaWdodCB0eXBlXG4gICAgICAgIGNyZWF0ZUV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmdPckVtcHR5KGtleXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZWRDb2x1bW5zID0gW107XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gX3RoaXMuZ2V0R3JpZENvbHVtbihrZXkpO1xuICAgICAgICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNoZWNrIGZvciBmYWxzZSB3aXRoIHR5cGUgKGllICE9PSBpbnN0ZWFkIG9mICE9KVxuICAgICAgICAgICAgLy8gYXMgbm90IHJldHVybmluZyBhbnl0aGluZyAodW5kZWZpbmVkKSB3b3VsZCBhbHNvIGJlIGZhbHNlXG4gICAgICAgICAgICB2YXIgcmVzdWx0T2ZBY3Rpb24gPSBhY3Rpb24oY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRPZkFjdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlZENvbHVtbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhjcmVhdGVFdmVudCkpIHtcbiAgICAgICAgICAgIHZhciBldmVudF81ID0gY3JlYXRlRXZlbnQoKTtcbiAgICAgICAgICAgIGV2ZW50XzUuY29sdW1ucyA9IHVwZGF0ZWRDb2x1bW5zO1xuICAgICAgICAgICAgZXZlbnRfNS5jb2x1bW4gPSB1cGRhdGVkQ29sdW1ucy5sZW5ndGggPT09IDEgPyB1cGRhdGVkQ29sdW1uc1swXSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXREaXNwbGF5ZWRDb2xCZWZvcmUgPSBmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgIHZhciBhbGxEaXNwbGF5ZWRDb2x1bW5zID0gdGhpcy5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgICAgIHZhciBvbGRJbmRleCA9IGFsbERpc3BsYXllZENvbHVtbnMuaW5kZXhPZihjb2wpO1xuICAgICAgICBpZiAob2xkSW5kZXggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxsRGlzcGxheWVkQ29sdW1uc1tvbGRJbmRleCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHVzZWQgYnk6XG4gICAgLy8gKyByb3dSZW5kZXJlciAtPiBmb3IgbmF2aWdhdGlvblxuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldERpc3BsYXllZENvbEFmdGVyID0gZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICB2YXIgYWxsRGlzcGxheWVkQ29sdW1ucyA9IHRoaXMuZ2V0QWxsRGlzcGxheWVkQ29sdW1ucygpO1xuICAgICAgICB2YXIgb2xkSW5kZXggPSBhbGxEaXNwbGF5ZWRDb2x1bW5zLmluZGV4T2YoY29sKTtcbiAgICAgICAgaWYgKG9sZEluZGV4IDwgKGFsbERpc3BsYXllZENvbHVtbnMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxEaXNwbGF5ZWRDb2x1bW5zW29sZEluZGV4ICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuaXNQaW5uaW5nTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheWVkTGVmdENvbHVtbnMubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmlzUGlubmluZ1JpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtbnMubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldFByaW1hcnlBbmRTZWNvbmRhcnlBbmRBdXRvQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucHJpbWFyeUNvbHVtbnMgPyB0aGlzLnByaW1hcnlDb2x1bW5zLnNsaWNlKDApIDogW107XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyh0aGlzLmdyb3VwQXV0b0NvbHVtbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwQXV0b0NvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7IHJldHVybiByZXN1bHQucHVzaChjb2wpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlDb2x1bW5zUHJlc2VudCkge1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gcmVzdWx0LnB1c2goY29sdW1uKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmNyZWF0ZVN0YXRlSXRlbUZyb21Db2x1bW4gPSBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHZhciByb3dHcm91cEluZGV4ID0gY29sdW1uLmlzUm93R3JvdXBBY3RpdmUoKSA/IHRoaXMucm93R3JvdXBDb2x1bW5zLmluZGV4T2YoY29sdW1uKSA6IG51bGw7XG4gICAgICAgIHZhciBwaXZvdEluZGV4ID0gY29sdW1uLmlzUGl2b3RBY3RpdmUoKSA/IHRoaXMucGl2b3RDb2x1bW5zLmluZGV4T2YoY29sdW1uKSA6IG51bGw7XG4gICAgICAgIHZhciBhZ2dGdW5jID0gY29sdW1uLmlzVmFsdWVBY3RpdmUoKSA/IGNvbHVtbi5nZXRBZ2dGdW5jKCkgOiBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0SXRlbSA9IHtcbiAgICAgICAgICAgIGNvbElkOiBjb2x1bW4uZ2V0Q29sSWQoKSxcbiAgICAgICAgICAgIGhpZGU6ICFjb2x1bW4uaXNWaXNpYmxlKCksXG4gICAgICAgICAgICBhZ2dGdW5jOiBhZ2dGdW5jLFxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbi5nZXRBY3R1YWxXaWR0aCgpLFxuICAgICAgICAgICAgcGl2b3RJbmRleDogcGl2b3RJbmRleCxcbiAgICAgICAgICAgIHBpbm5lZDogY29sdW1uLmdldFBpbm5lZCgpLFxuICAgICAgICAgICAgcm93R3JvdXBJbmRleDogcm93R3JvdXBJbmRleFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0SXRlbTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldENvbHVtblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMucHJpbWFyeUNvbHVtbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbHVtblN0YXRlTGlzdCA9IHRoaXMucHJpbWFyeUNvbHVtbnMubWFwKHRoaXMuY3JlYXRlU3RhdGVJdGVtRnJvbUNvbHVtbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKCF0aGlzLnBpdm90TW9kZSkge1xuICAgICAgICAgICAgdGhpcy5vcmRlckNvbHVtblN0YXRlTGlzdChjb2x1bW5TdGF0ZUxpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5TdGF0ZUxpc3Q7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5vcmRlckNvbHVtblN0YXRlTGlzdCA9IGZ1bmN0aW9uIChjb2x1bW5TdGF0ZUxpc3QpIHtcbiAgICAgICAgdmFyIGdyaWRDb2x1bW5JZHMgPSB0aGlzLmdyaWRDb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW4uZ2V0Q29sSWQoKTsgfSk7XG4gICAgICAgIGNvbHVtblN0YXRlTGlzdC5zb3J0KGZ1bmN0aW9uIChpdGVtQSwgaXRlbUIpIHtcbiAgICAgICAgICAgIHZhciBwb3NBID0gZ3JpZENvbHVtbklkcy5pbmRleE9mKGl0ZW1BLmNvbElkKTtcbiAgICAgICAgICAgIHZhciBwb3NCID0gZ3JpZENvbHVtbklkcy5pbmRleE9mKGl0ZW1CLmNvbElkKTtcbiAgICAgICAgICAgIHJldHVybiBwb3NBIC0gcG9zQjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5yZXNldENvbHVtblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3ZSBjYW4ndCB1c2UgJ2FsbENvbHVtbnMnIGFzIHRoZSBvcmRlciBtaWdodCBvZiBtZXNzZWQgdXAsIHNvIGdldCB0aGUgcHJpbWFyeSBvcmRlcmVkIGxpc3RcbiAgICAgICAgdmFyIHByaW1hcnlDb2x1bW5zID0gdGhpcy5nZXRDb2x1bW5zRnJvbVRyZWUodGhpcy5wcmltYXJ5QmFsYW5jZWRUcmVlKTtcbiAgICAgICAgdmFyIHN0YXRlID0gW107XG4gICAgICAgIGlmIChwcmltYXJ5Q29sdW1ucykge1xuICAgICAgICAgICAgcHJpbWFyeUNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbElkOiBjb2x1bW4uZ2V0Q29sSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgYWdnRnVuYzogY29sdW1uLmdldENvbERlZigpLmFnZ0Z1bmMsXG4gICAgICAgICAgICAgICAgICAgIGhpZGU6IGNvbHVtbi5nZXRDb2xEZWYoKS5oaWRlLFxuICAgICAgICAgICAgICAgICAgICBwaW5uZWQ6IGNvbHVtbi5nZXRDb2xEZWYoKS5waW5uZWQsXG4gICAgICAgICAgICAgICAgICAgIHJvd0dyb3VwSW5kZXg6IGNvbHVtbi5nZXRDb2xEZWYoKS5yb3dHcm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBwaXZvdEluZGV4OiBjb2x1bW4uZ2V0Q29sRGVmKCkucGl2b3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbHVtbi5nZXRDb2xEZWYoKS53aWR0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDb2x1bW5TdGF0ZShzdGF0ZSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRDb2x1bW5TdGF0ZSA9IGZ1bmN0aW9uIChjb2x1bW5TdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nT3JFbXB0eSh0aGlzLnByaW1hcnlDb2x1bW5zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b0dyb3Vwc05lZWRCdWlsZGluZyA9IHRydWU7XG4gICAgICAgIC8vIGF0IHRoZSBlbmQgYmVsb3csIHRoaXMgbGlzdCB3aWxsIGhhdmUgYWxsIGNvbHVtbnMgd2UgZ290IG5vIHN0YXRlIGZvclxuICAgICAgICB2YXIgY29sdW1uc1dpdGhOb1N0YXRlID0gdGhpcy5wcmltYXJ5Q29sdW1ucy5zbGljZSgpO1xuICAgICAgICB0aGlzLnJvd0dyb3VwQ29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlQ29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLnBpdm90Q29sdW1ucyA9IFtdO1xuICAgICAgICB2YXIgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIHZhciByb3dHcm91cEluZGV4ZXMgPSB7fTtcbiAgICAgICAgdmFyIHBpdm90SW5kZXhlcyA9IHt9O1xuICAgICAgICBpZiAoY29sdW1uU3RhdGUpIHtcbiAgICAgICAgICAgIGNvbHVtblN0YXRlLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBfdGhpcy5nZXRQcmltYXJ5Q29sdW1uKHN0YXRlSXRlbS5jb2xJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBjb2x1bW4gJyArIHN0YXRlSXRlbS5jb2xJZCArICcgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN5bmNDb2x1bW5XaXRoU3RhdGVJdGVtKGNvbHVtbiwgc3RhdGVJdGVtLCByb3dHcm91cEluZGV4ZXMsIHBpdm90SW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbUFycmF5KGNvbHVtbnNXaXRoTm9TdGF0ZSwgY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbnl0aGluZyBsZWZ0IG92ZXIsIHdlIGdvdCBubyBkYXRhIGZvciwgc28gYWRkIGluIHRoZSBjb2x1bW4gYXMgbm9uLXZhbHVlLCBub24tcm93R3JvdXAgYW5kIGhpZGRlblxuICAgICAgICBjb2x1bW5zV2l0aE5vU3RhdGUuZm9yRWFjaCh0aGlzLnN5bmNDb2x1bW5XaXRoTm9TdGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gc29ydCB0aGUgbGlzdHMgYWNjb3JkaW5nIHRvIHRoZSBpbmRleGVzIHRoYXQgd2VyZSBwcm92aWRlZFxuICAgICAgICB0aGlzLnJvd0dyb3VwQ29sdW1ucy5zb3J0KHRoaXMuc29ydENvbHVtbkxpc3RVc2luZ0luZGV4ZXMuYmluZCh0aGlzLCByb3dHcm91cEluZGV4ZXMpKTtcbiAgICAgICAgdGhpcy5waXZvdENvbHVtbnMuc29ydCh0aGlzLnNvcnRDb2x1bW5MaXN0VXNpbmdJbmRleGVzLmJpbmQodGhpcywgcGl2b3RJbmRleGVzKSk7XG4gICAgICAgIHRoaXMuY29weURvd25HcmlkQ29sdW1ucygpO1xuICAgICAgICB2YXIgb3JkZXJPZkNvbElkcyA9IGNvbHVtblN0YXRlLm1hcChmdW5jdGlvbiAoc3RhdGVJdGVtKSB7IHJldHVybiBzdGF0ZUl0ZW0uY29sSWQ7IH0pO1xuICAgICAgICB0aGlzLmdyaWRDb2x1bW5zLnNvcnQoZnVuY3Rpb24gKGNvbEEsIGNvbEIpIHtcbiAgICAgICAgICAgIHZhciBpbmRleEEgPSBvcmRlck9mQ29sSWRzLmluZGV4T2YoY29sQS5nZXRJZCgpKTtcbiAgICAgICAgICAgIHZhciBpbmRleEIgPSBvcmRlck9mQ29sSWRzLmluZGV4T2YoY29sQi5nZXRJZCgpKTtcbiAgICAgICAgICAgIHJldHVybiBpbmRleEEgLSBpbmRleEI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXllZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9FVkVSWVRISU5HX0NIQU5HRUQsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc29ydENvbHVtbkxpc3RVc2luZ0luZGV4ZXMgPSBmdW5jdGlvbiAoaW5kZXhlcywgY29sQSwgY29sQikge1xuICAgICAgICB2YXIgaW5kZXhBID0gaW5kZXhlc1tjb2xBLmdldElkKCldO1xuICAgICAgICB2YXIgaW5kZXhCID0gaW5kZXhlc1tjb2xCLmdldElkKCldO1xuICAgICAgICByZXR1cm4gaW5kZXhBIC0gaW5kZXhCO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc3luY0NvbHVtbldpdGhOb1N0YXRlID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICBjb2x1bW4uc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgIGNvbHVtbi5zZXRBZ2dGdW5jKG51bGwpO1xuICAgICAgICBjb2x1bW4uc2V0UGlubmVkKG51bGwpO1xuICAgICAgICBjb2x1bW4uc2V0Um93R3JvdXBBY3RpdmUoZmFsc2UpO1xuICAgICAgICBjb2x1bW4uc2V0UGl2b3RBY3RpdmUoZmFsc2UpO1xuICAgICAgICBjb2x1bW4uc2V0VmFsdWVBY3RpdmUoZmFsc2UpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc3luY0NvbHVtbldpdGhTdGF0ZUl0ZW0gPSBmdW5jdGlvbiAoY29sdW1uLCBzdGF0ZUl0ZW0sIHJvd0dyb3VwSW5kZXhlcywgcGl2b3RJbmRleGVzKSB7XG4gICAgICAgIC8vIGZvbGxvd2luZyBlbnN1cmVzIHdlIGFyZSBsZWZ0IHdpdGggYm9vbGVhbiB0cnVlIG9yIGZhbHNlLCBlZyBjb252ZXJ0cyAobnVsbCwgdW5kZWZpbmVkLCAwKSBhbGwgdG8gdHJ1ZVxuICAgICAgICBjb2x1bW4uc2V0VmlzaWJsZSghc3RhdGVJdGVtLmhpZGUpO1xuICAgICAgICAvLyBzZXRzIHBpbm5lZCB0byAnbGVmdCcgb3IgJ3JpZ2h0J1xuICAgICAgICBjb2x1bW4uc2V0UGlubmVkKHN0YXRlSXRlbS5waW5uZWQpO1xuICAgICAgICAvLyBpZiB3aWR0aCBwcm92aWRlZCBhbmQgdmFsaWQsIHVzZSBpdCwgb3RoZXJ3aXNlIHN0aWNrIHdpdGggdGhlIG9sZCB3aWR0aFxuICAgICAgICBpZiAoc3RhdGVJdGVtLndpZHRoID49IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldE1pbkNvbFdpZHRoKCkpIHtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRBY3R1YWxXaWR0aChzdGF0ZUl0ZW0ud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVJdGVtLmFnZ0Z1bmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb2x1bW4uc2V0QWdnRnVuYyhzdGF0ZUl0ZW0uYWdnRnVuYyk7XG4gICAgICAgICAgICBjb2x1bW4uc2V0VmFsdWVBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMoc3RhdGVJdGVtLmFnZ0Z1bmMpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBzdGF0ZUl0ZW0uYWdnRnVuYyBtdXN0IGJlIGEgc3RyaW5nLiBpZiB1c2luZyB5b3VyIG93biBhZ2dyZWdhdGlvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9ucywgcmVnaXN0ZXIgdGhlIGZ1bmN0aW9ucyBmaXJzdCBiZWZvcmUgdXNpbmcgdGhlbSBpbiBnZXQvc2V0IHN0YXRlLiBUaGlzIGlzIGJlY2F1c2UgaXQgaXMnICtcbiAgICAgICAgICAgICAgICAgICAgJ2ludGVuZGVkIGZvciB0aGUgY29sdW1uIHN0YXRlIHRvIGJlIHN0b3JlZCBhbmQgcmV0cmlldmVkIGFzIHNpbXBsZSBKU09OLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sdW1uLnNldEFnZ0Z1bmMobnVsbCk7XG4gICAgICAgICAgICBjb2x1bW4uc2V0VmFsdWVBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVJdGVtLnJvd0dyb3VwSW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0dyb3VwQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICBjb2x1bW4uc2V0Um93R3JvdXBBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgICByb3dHcm91cEluZGV4ZXNbY29sdW1uLmdldElkKCldID0gc3RhdGVJdGVtLnJvd0dyb3VwSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4uc2V0Um93R3JvdXBBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVJdGVtLnBpdm90SW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnBpdm90Q29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICBjb2x1bW4uc2V0UGl2b3RBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgICBwaXZvdEluZGV4ZXNbY29sdW1uLmdldElkKCldID0gc3RhdGVJdGVtLnBpdm90SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4uc2V0UGl2b3RBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRHcmlkQ29sdW1ucyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbnMoa2V5cywgdGhpcy5nZXRHcmlkQ29sdW1uLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q29sdW1ucyA9IGZ1bmN0aW9uIChrZXlzLCBjb2x1bW5Mb29rdXBDYWxsYmFjaykge1xuICAgICAgICB2YXIgZm91bmRDb2x1bW5zID0gW107XG4gICAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5Mb29rdXBDYWxsYmFjayhrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmRDb2x1bW5zO1xuICAgIH07XG4gICAgLy8gdXNlZCBieSBncm93R3JvdXBQYW5lbFxuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldENvbHVtbldpdGhWYWxpZGF0aW9uID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRQcmltYXJ5Q29sdW1uKGtleSk7XG4gICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGNvdWxkIG5vdCBmaW5kIGNvbHVtbiAnICsgY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0UHJpbWFyeUNvbHVtbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uKGtleSwgdGhpcy5wcmltYXJ5Q29sdW1ucyk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRHcmlkQ29sdW1uID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oa2V5LCB0aGlzLmdyaWRDb2x1bW5zKTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldENvbHVtbiA9IGZ1bmN0aW9uIChrZXksIGNvbHVtbkxpc3QpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uc01hdGNoKGNvbHVtbkxpc3RbaV0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdXRvQ29sdW1uKGtleSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRBdXRvQ29sdW1uID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMuZ3JvdXBBdXRvQ29sdW1ucykgfHwgdXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMuZ3JvdXBBdXRvQ29sdW1ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsc18xLlV0aWxzLmZpbmQodGhpcy5ncm91cEF1dG9Db2x1bW5zLCBmdW5jdGlvbiAoZ3JvdXBDb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb2x1bW5zTWF0Y2goZ3JvdXBDb2wsIGtleSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuY29sdW1uc01hdGNoID0gZnVuY3Rpb24gKGNvbHVtbiwga2V5KSB7XG4gICAgICAgIHZhciBjb2x1bW5NYXRjaGVzID0gY29sdW1uID09PSBrZXk7XG4gICAgICAgIHZhciBjb2xEZWZNYXRjaGVzID0gY29sdW1uLmdldENvbERlZigpID09PSBrZXk7XG4gICAgICAgIHZhciBpZE1hdGNoZXMgPSBjb2x1bW4uZ2V0Q29sSWQoKSA9PSBrZXk7XG4gICAgICAgIHJldHVybiBjb2x1bW5NYXRjaGVzIHx8IGNvbERlZk1hdGNoZXMgfHwgaWRNYXRjaGVzO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0RGlzcGxheU5hbWVGb3JDb2x1bW4gPSBmdW5jdGlvbiAoY29sdW1uLCBsb2NhdGlvbiwgaW5jbHVkZUFnZ0Z1bmMpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVBZ2dGdW5jID09PSB2b2lkIDApIHsgaW5jbHVkZUFnZ0Z1bmMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaGVhZGVyTmFtZSA9IHRoaXMuZ2V0SGVhZGVyTmFtZShjb2x1bW4uZ2V0Q29sRGVmKCksIGNvbHVtbiwgbnVsbCwgbG9jYXRpb24pO1xuICAgICAgICBpZiAoaW5jbHVkZUFnZ0Z1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBIZWFkZXJOYW1lV2l0aEFnZ0Z1bmMoY29sdW1uLCBoZWFkZXJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJOYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXREaXNwbGF5TmFtZUZvckNvbHVtbkdyb3VwID0gZnVuY3Rpb24gKGNvbHVtbkdyb3VwLCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgY29sR3JvdXBEZWYgPSBjb2x1bW5Hcm91cC5nZXRPcmlnaW5hbENvbHVtbkdyb3VwKCkuZ2V0Q29sR3JvdXBEZWYoKTtcbiAgICAgICAgaWYgKGNvbEdyb3VwRGVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkZXJOYW1lKGNvbEdyb3VwRGVmLCBudWxsLCBjb2x1bW5Hcm91cCwgbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGxvY2F0aW9uIGlzIHdoZXJlIHRoZSBjb2x1bW4gaXMgZ29pbmcgdG8gYXBwZWFyLCBpZSB3aG8gaXMgY2FsbGluZyB1c1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldEhlYWRlck5hbWUgPSBmdW5jdGlvbiAoY29sRGVmLCBjb2x1bW4sIGNvbHVtbkdyb3VwLCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgaGVhZGVyVmFsdWVHZXR0ZXIgPSBjb2xEZWYuaGVhZGVyVmFsdWVHZXR0ZXI7XG4gICAgICAgIGlmIChoZWFkZXJWYWx1ZUdldHRlcikge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb2xEZWY6IGNvbERlZixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBjb2x1bW5Hcm91cDogY29sdW1uR3JvdXAsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCksXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWFkZXJWYWx1ZUdldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlR2V0dGVyIGlzIGEgZnVuY3Rpb24sIHNvIGp1c3QgY2FsbCBpdFxuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJWYWx1ZUdldHRlcihwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGhlYWRlclZhbHVlR2V0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlR2V0dGVyIGlzIGFuIGV4cHJlc3Npb24sIHNvIGV4ZWN1dGUgdGhlIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uU2VydmljZS5ldmFsdWF0ZShoZWFkZXJWYWx1ZUdldHRlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogaGVhZGVyVmFsdWVHZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbERlZi5oZWFkZXJOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xEZWYuaGVhZGVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2xEZWYuZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLlV0aWxzLmNhbWVsQ2FzZVRvSHVtYW5UZXh0KGNvbERlZi5maWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXG4gICAgICAgIHByaXZhdGUgZ2V0SGVhZGVyR3JvdXBOYW1lKGNvbHVtbkdyb3VwOiBDb2x1bW5Hcm91cCk6IHN0cmluZyB7XG4gICAgICAgICAgICBsZXQgY29sR3JvdXBEZWYgPSBjb2x1bW5Hcm91cC5nZXRPcmlnaW5hbENvbHVtbkdyb3VwKCkuZ2V0Q29sR3JvdXBEZWYoKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJWYWx1ZUdldHRlciA9IGNvbEdyb3VwRGVmLmhlYWRlclZhbHVlR2V0dGVyO1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVyVmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5Hcm91cDogY29sdW1uR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIGNvbERlZjogY29sR3JvdXBEZWYsXG4gICAgICAgICAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhlYWRlclZhbHVlR2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlR2V0dGVyIGlzIGEgZnVuY3Rpb24sIHNvIGp1c3QgY2FsbCBpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyVmFsdWVHZXR0ZXIocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJWYWx1ZUdldHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVHZXR0ZXIgaXMgYW4gZXhwcmVzc2lvbiwgc28gZXhlY3V0ZSB0aGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uU2VydmljZS5ldmFsdWF0ZShoZWFkZXJWYWx1ZUdldHRlciwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IGhlYWRlclZhbHVlR2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sR3JvdXBEZWYuaGVhZGVyTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICovXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUud3JhcEhlYWRlck5hbWVXaXRoQWdnRnVuYyA9IGZ1bmN0aW9uIChjb2x1bW4sIGhlYWRlck5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NBZ2dGdW5jSW5IZWFkZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlck5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBjb2x1bW5zIHdpdGggYWdncmVnYXRpb24gYWN0aXZlIGNhbiBoYXZlIGFnZ3JlZ2F0aW9uc1xuICAgICAgICB2YXIgcGl2b3RWYWx1ZUNvbHVtbiA9IGNvbHVtbi5nZXRDb2xEZWYoKS5waXZvdFZhbHVlQ29sdW1uO1xuICAgICAgICB2YXIgcGl2b3RBY3RpdmVPblRoaXNDb2x1bW4gPSB1dGlsc18xLlV0aWxzLmV4aXN0cyhwaXZvdFZhbHVlQ29sdW1uKTtcbiAgICAgICAgdmFyIGFnZ0Z1bmMgPSBudWxsO1xuICAgICAgICB2YXIgYWdnRnVuY0ZvdW5kO1xuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgaGF2ZSBhIG1lYXN1cmUgdGhhdCBpcyBhY3RpdmUsIGFuZCB3ZSBhcmUgZG9pbmcgYWdncmVnYXRpb24gb24gaXRcbiAgICAgICAgaWYgKHBpdm90QWN0aXZlT25UaGlzQ29sdW1uKSB7XG4gICAgICAgICAgICBhZ2dGdW5jID0gcGl2b3RWYWx1ZUNvbHVtbi5nZXRBZ2dGdW5jKCk7XG4gICAgICAgICAgICBhZ2dGdW5jRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1lYXN1cmVBY3RpdmUgPSBjb2x1bW4uaXNWYWx1ZUFjdGl2ZSgpO1xuICAgICAgICAgICAgdmFyIGFnZ3JlZ2F0aW9uUHJlc2VudCA9IHRoaXMucGl2b3RNb2RlIHx8ICF0aGlzLmlzUm93R3JvdXBFbXB0eSgpO1xuICAgICAgICAgICAgaWYgKG1lYXN1cmVBY3RpdmUgJiYgYWdncmVnYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgYWdnRnVuYyA9IGNvbHVtbi5nZXRBZ2dGdW5jKCk7XG4gICAgICAgICAgICAgICAgYWdnRnVuY0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFnZ0Z1bmNGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZ2dGdW5jRm91bmQpIHtcbiAgICAgICAgICAgIHZhciBhZ2dGdW5jU3RyaW5nID0gKHR5cGVvZiBhZ2dGdW5jID09PSAnc3RyaW5nJykgPyBhZ2dGdW5jIDogJ2Z1bmMnO1xuICAgICAgICAgICAgdmFyIGxvY2FsZVRleHRGdW5jID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TG9jYWxlVGV4dEZ1bmMoKTtcbiAgICAgICAgICAgIHZhciBhZ2dGdW5jU3RyaW5nVHJhbnNsYXRlZCA9IGxvY2FsZVRleHRGdW5jKGFnZ0Z1bmNTdHJpbmcsIGFnZ0Z1bmNTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIGFnZ0Z1bmNTdHJpbmdUcmFuc2xhdGVkICsgXCIoXCIgKyBoZWFkZXJOYW1lICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyTmFtZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gcmV0dXJucyB0aGUgZ3JvdXAgd2l0aCBtYXRjaGluZyBjb2xJZCBhbmQgaW5zdGFuY2VJZC4gSWYgaW5zdGFuY2VJZCBpcyBtaXNzaW5nLFxuICAgIC8vIG1hdGNoZXMgb25seSBvbiB0aGUgY29sSWQuXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q29sdW1uR3JvdXAgPSBmdW5jdGlvbiAoY29sSWQsIGluc3RhbmNlSWQpIHtcbiAgICAgICAgaWYgKCFjb2xJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbElkIGluc3RhbmNlb2YgY29sdW1uR3JvdXBfMS5Db2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbElkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxDb2x1bW5Hcm91cHMgPSB0aGlzLmdldEFsbERpc3BsYXllZENvbHVtbkdyb3VwcygpO1xuICAgICAgICB2YXIgY2hlY2tJbnN0YW5jZUlkID0gdHlwZW9mIGluc3RhbmNlSWQgPT09ICdudW1iZXInO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2x1bW5VdGlscy5kZXB0aEZpcnN0QWxsQ29sdW1uVHJlZVNlYXJjaChhbGxDb2x1bW5Hcm91cHMsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgY29sdW1uR3JvdXBfMS5Db2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5Hcm91cCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0luc3RhbmNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGNvbElkID09PSBjb2x1bW5Hcm91cC5nZXRHcm91cElkKCkgJiYgaW5zdGFuY2VJZCA9PT0gY29sdW1uR3JvdXAuZ2V0SW5zdGFuY2VJZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGNvbElkID09PSBjb2x1bW5Hcm91cC5nZXRHcm91cElkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbHVtbkdyb3VwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRDb2x1bW5EZWZzID0gZnVuY3Rpb24gKGNvbHVtbkRlZnMpIHtcbiAgICAgICAgLy8gYWx3YXlzIGludmFsaWRhdGUgY2FjaGUgb24gY2hhbmdpbmcgY29sdW1ucywgYXMgdGhlIGNvbHVtbiBpZCdzIGZvciB0aGUgbmV3IGNvbHVtbnNcbiAgICAgICAgLy8gY291bGQgb3ZlcmxhcCB3aXRoIHRoZSBvbGQgaWQncywgc28gdGhlIGNhY2hlIHdvdWxkIHJldHVybiBvbGQgdmFsdWVzIGZvciBuZXcgY29sdW1ucy5cbiAgICAgICAgdGhpcy52YWx1ZUNhY2hlLmV4cGlyZSgpO1xuICAgICAgICAvLyBOT1RFID09PT09PT09PT09PT09PT09PVxuICAgICAgICAvLyB3ZSBzaG91bGQgYmUgZGVzdHJveWluZyB0aGUgZXhpc3RpbmcgY29sdW1ucyBhbmQgZ3JvdXBzIGlmIHRoZXkgZXhpc3QsIGZvciBleGFtcGxlLCB0aGUgb3JpZ2luYWwgY29sdW1uXG4gICAgICAgIC8vIGdyb3VwIGFkZHMgYSBsaXN0ZW5lciB0byB0aGUgY29sdW1ucywgaXQgc2hvdWxkIGJlIGFsc28gcmVtb3ZpbmcgdGhlIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLmF1dG9Hcm91cHNOZWVkQnVpbGRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgYmFsYW5jZWRUcmVlUmVzdWx0ID0gdGhpcy5iYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyLmNyZWF0ZUJhbGFuY2VkQ29sdW1uR3JvdXBzKGNvbHVtbkRlZnMsIHRydWUpO1xuICAgICAgICB0aGlzLnByaW1hcnlCYWxhbmNlZFRyZWUgPSBiYWxhbmNlZFRyZWVSZXN1bHQuYmFsYW5jZWRUcmVlO1xuICAgICAgICB0aGlzLnByaW1hcnlIZWFkZXJSb3dDb3VudCA9IGJhbGFuY2VkVHJlZVJlc3VsdC50cmVlRGVwdCArIDE7XG4gICAgICAgIHRoaXMucHJpbWFyeUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbnNGcm9tVHJlZSh0aGlzLnByaW1hcnlCYWxhbmNlZFRyZWUpO1xuICAgICAgICB0aGlzLmV4dHJhY3RSb3dHcm91cENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5leHRyYWN0UGl2b3RDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlVmFsdWVDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY29weURvd25HcmlkQ29sdW1ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXllZENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jaGVja0Rpc3BsYXllZFZpcnR1YWxDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICB2YXIgZXZlbnRFdmVyeXRoaW5nQ2hhbmdlZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fRVZFUllUSElOR19DSEFOR0VELFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnRFdmVyeXRoaW5nQ2hhbmdlZCk7XG4gICAgICAgIHZhciBuZXdDb2x1bW5zTG9hZGVkRXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfTkVXX0NPTFVNTlNfTE9BREVELFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQobmV3Q29sdW1uc0xvYWRlZEV2ZW50KTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmlzUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWR5O1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZXh0cmFjdFJvd0dyb3VwQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yb3dHcm91cENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW4uc2V0Um93R3JvdXBBY3RpdmUoZmFsc2UpOyB9KTtcbiAgICAgICAgdGhpcy5yb3dHcm91cENvbHVtbnMgPSBbXTtcbiAgICAgICAgLy8gcHVsbCBvdXQgaXRlbXMgd2l0aCByb3dHcm91cEluZGV4XG4gICAgICAgIHRoaXMucHJpbWFyeUNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbHVtbi5nZXRDb2xEZWYoKS5yb3dHcm91cEluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIF90aGlzLnJvd0dyb3VwQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgY29sdW1uLnNldFJvd0dyb3VwQWN0aXZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhlbiBzb3J0IHRoZW1cbiAgICAgICAgdGhpcy5yb3dHcm91cENvbHVtbnMuc29ydChmdW5jdGlvbiAoY29sQSwgY29sQikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbEEuZ2V0Q29sRGVmKCkucm93R3JvdXBJbmRleCAtIGNvbEIuZ2V0Q29sRGVmKCkucm93R3JvdXBJbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG5vdyBqdXN0IHB1bGwgb3V0IGl0ZW1zIHJvd0dyb3VwLCB0aGV5IHdpbGwgYmUgYWRkZWQgYXQgdGhlIGVuZFxuICAgICAgICAvLyBhZnRlciB0aGUgaW5kZXhlZCBvbmVzLCBidXQgaW4gdGhlIG9yZGVyIHRoZSBjb2x1bW5zIGFwcGVhclxuICAgICAgICB0aGlzLnByaW1hcnlDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgaWYgKGNvbHVtbi5nZXRDb2xEZWYoKS5yb3dHcm91cCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgYWxyZWFkeSBzcGVjaWZpZWQgcm93R3JvdXBJbmRleCB0aGVuIHdlIHNraXAgaXQgYXMgdGhpcyBjb2wgYWxyZWFkeSBpbmNsdWRlZFxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yb3dHcm91cENvbHVtbnMuaW5kZXhPZihjb2x1bW4pID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5yb3dHcm91cENvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRSb3dHcm91cEFjdGl2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5leHRyYWN0UGl2b3RDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBpdm90Q29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5zZXRQaXZvdEFjdGl2ZShmYWxzZSk7IH0pO1xuICAgICAgICB0aGlzLnBpdm90Q29sdW1ucyA9IFtdO1xuICAgICAgICAvLyBwdWxsIG91dCBpdGVtcyB3aXRoIHBpdm90SW5kZXhcbiAgICAgICAgdGhpcy5wcmltYXJ5Q29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sdW1uLmdldENvbERlZigpLnBpdm90SW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGl2b3RDb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4uc2V0UGl2b3RBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGVuIHNvcnQgdGhlbVxuICAgICAgICB0aGlzLnBpdm90Q29sdW1ucy5zb3J0KGZ1bmN0aW9uIChjb2xBLCBjb2xCKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sQS5nZXRDb2xEZWYoKS5waXZvdEluZGV4IC0gY29sQi5nZXRDb2xEZWYoKS5waXZvdEluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbm93IGNoZWNrIHRoZSBib29sZWFuIGVxdWl2YWxlbnRcbiAgICAgICAgdGhpcy5wcmltYXJ5Q29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uZ2V0Q29sRGVmKCkucGl2b3QpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIGFscmVhZHkgc3BlY2lmaWVkIHBpdm90SW5kZXggdGhlbiB3ZSBza2lwIGl0IGFzIHRoaXMgY29sIGFscmVhZHkgaW5jbHVkZWRcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucGl2b3RDb2x1bW5zLmluZGV4T2YoY29sdW1uKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucGl2b3RDb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4uc2V0UGl2b3RBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUucmVzZXRDb2x1bW5Hcm91cFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGVJdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbHVtblV0aWxzLmRlcHRoRmlyc3RPcmlnaW5hbFRyZWVTZWFyY2godGhpcy5wcmltYXJ5QmFsYW5jZWRUcmVlLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIG9yaWdpbmFsQ29sdW1uR3JvdXBfMS5PcmlnaW5hbENvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGNoaWxkLmdldEdyb3VwSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogY2hpbGQuZ2V0Q29sR3JvdXBEZWYoKS5vcGVuQnlEZWZhdWx0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdGF0ZUl0ZW1zLnB1c2goZ3JvdXBTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldENvbHVtbkdyb3VwU3RhdGUoc3RhdGVJdGVtcyk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRDb2x1bW5Hcm91cFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sdW1uR3JvdXBTdGF0ZSA9IFtdO1xuICAgICAgICB0aGlzLmNvbHVtblV0aWxzLmRlcHRoRmlyc3RPcmlnaW5hbFRyZWVTZWFyY2godGhpcy5ncmlkQmFsYW5jZWRUcmVlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBvcmlnaW5hbENvbHVtbkdyb3VwXzEuT3JpZ2luYWxDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbENvbHVtbkdyb3VwID0gbm9kZTtcbiAgICAgICAgICAgICAgICBjb2x1bW5Hcm91cFN0YXRlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBncm91cElkOiBvcmlnaW5hbENvbHVtbkdyb3VwLmdldEdyb3VwSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgb3Blbjogb3JpZ2luYWxDb2x1bW5Hcm91cC5pc0V4cGFuZGVkKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2x1bW5Hcm91cFN0YXRlO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0Q29sdW1uR3JvdXBTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZUl0ZW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29sdW1uQW5pbWF0aW9uU2VydmljZS5zdGFydCgpO1xuICAgICAgICB2YXIgaW1wYWN0ZWRHcm91cHMgPSBbXTtcbiAgICAgICAgc3RhdGVJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZUl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBncm91cEtleSA9IHN0YXRlSXRlbS5ncm91cElkO1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gc3RhdGVJdGVtLm9wZW47XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW5Hcm91cCA9IF90aGlzLmdldE9yaWdpbmFsQ29sdW1uR3JvdXAoZ3JvdXBLZXkpO1xuICAgICAgICAgICAgaWYgKCFvcmlnaW5hbENvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ29sdW1uR3JvdXAuaXNFeHBhbmRlZCgpID09PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coJ2NvbHVtbkdyb3VwT3BlbmVkKCcgKyBvcmlnaW5hbENvbHVtbkdyb3VwLmdldEdyb3VwSWQoKSArICcsJyArIG5ld1ZhbHVlICsgJyknKTtcbiAgICAgICAgICAgIG9yaWdpbmFsQ29sdW1uR3JvdXAuc2V0RXhwYW5kZWQobmV3VmFsdWUpO1xuICAgICAgICAgICAgaW1wYWN0ZWRHcm91cHMucHVzaChvcmlnaW5hbENvbHVtbkdyb3VwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JvdXBzQW5kRGlzcGxheWVkQ29sdW1ucygpO1xuICAgICAgICBpbXBhY3RlZEdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbENvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9HUk9VUF9PUEVORUQsXG4gICAgICAgICAgICAgICAgY29sdW1uR3JvdXA6IG9yaWdpbmFsQ29sdW1uR3JvdXAsXG4gICAgICAgICAgICAgICAgYXBpOiBfdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkFwaTogX3RoaXMuY29sdW1uQXBpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2x1bW5BbmltYXRpb25TZXJ2aWNlLmZpbmlzaCgpO1xuICAgIH07XG4gICAgLy8gY2FsbGVkIGJ5IGhlYWRlclJlbmRlcmVyIC0gd2hlbiBhIGhlYWRlciBpcyBvcGVuZWQgb3IgY2xvc2VkXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0Q29sdW1uR3JvdXBPcGVuZWQgPSBmdW5jdGlvbiAoa2V5LCBuZXdWYWx1ZSkge1xuICAgICAgICB2YXIga2V5QXNTdHJpbmc7XG4gICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBvcmlnaW5hbENvbHVtbkdyb3VwXzEuT3JpZ2luYWxDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAga2V5QXNTdHJpbmcgPSBrZXkuZ2V0SWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleUFzU3RyaW5nID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Q29sdW1uR3JvdXBTdGF0ZShbeyBncm91cElkOiBrZXlBc1N0cmluZywgb3BlbjogbmV3VmFsdWUgfV0pO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0T3JpZ2luYWxDb2x1bW5Hcm91cCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIG9yaWdpbmFsQ29sdW1uR3JvdXBfMS5PcmlnaW5hbENvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogZ3JvdXAga2V5IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UsIHNlYXJjaCBmb3IgdGhlIGNvbHVtbiBncm91cCBieSBpZFxuICAgICAgICB2YXIgcmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2x1bW5VdGlscy5kZXB0aEZpcnN0T3JpZ2luYWxUcmVlU2VhcmNoKHRoaXMuZ3JpZEJhbGFuY2VkVHJlZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygb3JpZ2luYWxDb2x1bW5Hcm91cF8xLk9yaWdpbmFsQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW5Hcm91cCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ29sdW1uR3JvdXAuZ2V0SWQoKSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IG9yaWdpbmFsQ29sdW1uR3JvdXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmNhbGN1bGF0ZUNvbHVtbnNGb3JEaXNwbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sdW1uc0ZvckRpc3BsYXk7XG4gICAgICAgIGlmICh0aGlzLnBpdm90TW9kZSAmJiAhdGhpcy5zZWNvbmRhcnlDb2x1bW5zUHJlc2VudCkge1xuICAgICAgICAgICAgLy8gcGl2b3QgbW9kZSBpcyBvbiwgYnV0IHdlIGFyZSBub3QgcGl2b3RpbmcsIHNvIHdlIG9ubHlcbiAgICAgICAgICAgIC8vIHNob3cgY29sdW1ucyB3ZSBhcmUgYWdncmVnYXRpbmcgb25cbiAgICAgICAgICAgIGNvbHVtbnNGb3JEaXNwbGF5ID0gdGhpcy5jcmVhdGVDb2x1bW5zVG9EaXNwbGF5RnJvbVZhbHVlQ29sdW1ucygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbnRpbnVlIGFzIG5vcm1hbC4gdGhpcyBjYW4gYmUgd29ya2luZyBvbiB0aGUgcHJpbWFyeVxuICAgICAgICAgICAgLy8gb3Igc2Vjb25kYXJ5IGNvbHVtbnMsIHdoYXRldmVyIHRoZSBncmlkQ29sdW1ucyBhcmUgc2V0IHRvXG4gICAgICAgICAgICBjb2x1bW5zRm9yRGlzcGxheSA9IHV0aWxzXzEuVXRpbHMuZmlsdGVyKHRoaXMuZ3JpZENvbHVtbnMsIGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5pc1Zpc2libGUoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGVHcm91cEF1dG9Db2x1bW5zSWZOZWVkZWQoKTtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMuZ3JvdXBBdXRvQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGNvbHVtbnNGb3JEaXNwbGF5ID0gdGhpcy5ncm91cEF1dG9Db2x1bW5zLmNvbmNhdChjb2x1bW5zRm9yRGlzcGxheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbnNGb3JEaXNwbGF5O1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuY2hlY2tDb2xTcGFuQWN0aXZlSW5Db2xzID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKGNvbC5nZXRDb2xEZWYoKS5jb2xTcGFuKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuY2FsY3VsYXRlQ29sdW1uc0Zvckdyb3VwRGlzcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5ncm91cERpc3BsYXlDb2x1bW5zID0gW107XG4gICAgICAgIHZhciBjaGVja0Z1bmMgPSBmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICB2YXIgY29sRGVmID0gY29sLmdldENvbERlZigpO1xuICAgICAgICAgICAgaWYgKGNvbERlZiAmJiB1dGlsc18xLlV0aWxzLmV4aXN0cyhjb2xEZWYuc2hvd1Jvd0dyb3VwKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdyb3VwRGlzcGxheUNvbHVtbnMucHVzaChjb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdyaWRDb2x1bW5zLmZvckVhY2goY2hlY2tGdW5jKTtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBBdXRvQ29sdW1ucykge1xuICAgICAgICAgICAgdGhpcy5ncm91cEF1dG9Db2x1bW5zLmZvckVhY2goY2hlY2tGdW5jKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0R3JvdXBEaXNwbGF5Q29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBEaXNwbGF5Q29sdW1ucztcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmNyZWF0ZUNvbHVtbnNUb0Rpc3BsYXlGcm9tVmFsdWVDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgdmFsdWUgY29sdW1ucywgc28gd2UgaGF2ZSB0byBzaWRlIGVmZmVjdHNcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudmFsdWVDb2x1bW5zLnNsaWNlKCk7XG4gICAgICAgIC8vIG9yZGVyIHRoZSBjb2x1bW5zIGFzIHBlciB0aGUgZ3JpZCBjb2x1bW5zLiBoYXZpbmcgdGhlIG9yZGVyIGlzXG4gICAgICAgIC8vIGltcG9ydGFudCBhcyB3aXRob3V0IGl0LCByZW9yZGVyaW5nIG9mIGNvbHVtbnMgd291bGQgaGF2ZSBubyBpbXBhY3RcbiAgICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24gKGNvbEEsIGNvbEIpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ncmlkQ29sdW1ucy5pbmRleE9mKGNvbEEpIC0gX3RoaXMuZ3JpZENvbHVtbnMuaW5kZXhPZihjb2xCKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ZWRDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sdW1uc0ZvckRpc3BsYXkgPSB0aGlzLmNhbGN1bGF0ZUNvbHVtbnNGb3JEaXNwbGF5KCk7XG4gICAgICAgIHRoaXMuYnVpbGREaXNwbGF5ZWRUcmVlcyhjb2x1bW5zRm9yRGlzcGxheSk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQ29sdW1uc0Zvckdyb3VwRGlzcGxheSgpO1xuICAgICAgICAvLyB0aGlzIGlzIGFsc28gY2FsbGVkIHdoZW4gYSBncm91cCBpcyBvcGVuZWQgb3IgY2xvc2VkXG4gICAgICAgIHRoaXMudXBkYXRlR3JvdXBzQW5kRGlzcGxheWVkQ29sdW1ucygpO1xuICAgICAgICB0aGlzLnNldEZpcnN0UmlnaHRBbmRMYXN0TGVmdFBpbm5lZCgpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuaXNTZWNvbmRhcnlDb2x1bW5zUHJlc2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kYXJ5Q29sdW1uc1ByZXNlbnQ7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRTZWNvbmRhcnlDb2x1bW5zID0gZnVuY3Rpb24gKGNvbERlZnMpIHtcbiAgICAgICAgdmFyIG5ld0NvbHNQcmVzZW50ID0gY29sRGVmcyAmJiBjb2xEZWZzLmxlbmd0aCA+IDA7XG4gICAgICAgIC8vIGlmIG5vdCBjb2xzIHBhc3NlZCwgYW5kIHdlIGhhZCB0byBjb2xzIGFueXdheSwgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICghbmV3Q29sc1ByZXNlbnQgJiYgIXRoaXMuc2Vjb25kYXJ5Q29sdW1uc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q29sc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1NlY29uZGFyeUNvbHVtbkRlZmluaXRpb25zKGNvbERlZnMpO1xuICAgICAgICAgICAgdmFyIGJhbGFuY2VkVHJlZVJlc3VsdCA9IHRoaXMuYmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlci5jcmVhdGVCYWxhbmNlZENvbHVtbkdyb3Vwcyhjb2xEZWZzLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUJhbGFuY2VkVHJlZSA9IGJhbGFuY2VkVHJlZVJlc3VsdC5iYWxhbmNlZFRyZWU7XG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUhlYWRlclJvd0NvdW50ID0gYmFsYW5jZWRUcmVlUmVzdWx0LnRyZWVEZXB0ICsgMTtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uc0Zyb21UcmVlKHRoaXMuc2Vjb25kYXJ5QmFsYW5jZWRUcmVlKTtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29sdW1uc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlCYWxhbmNlZFRyZWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlIZWFkZXJSb3dDb3VudCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb2x1bW5zID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29sdW1uc1ByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvcHlEb3duR3JpZENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5wcm9jZXNzU2Vjb25kYXJ5Q29sdW1uRGVmaW5pdGlvbnMgPSBmdW5jdGlvbiAoY29sRGVmcykge1xuICAgICAgICB2YXIgY29sdW1uQ2FsbGJhY2sgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRQcm9jZXNzU2Vjb25kYXJ5Q29sRGVmRnVuYygpO1xuICAgICAgICB2YXIgZ3JvdXBDYWxsYmFjayA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldFByb2Nlc3NTZWNvbmRhcnlDb2xHcm91cERlZkZ1bmMoKTtcbiAgICAgICAgaWYgKCFjb2x1bW5DYWxsYmFjayAmJiAhZ3JvdXBDYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlYXJjaEZvckNvbERlZnMoY29sRGVmcyk7XG4gICAgICAgIGZ1bmN0aW9uIHNlYXJjaEZvckNvbERlZnMoY29sRGVmczIpIHtcbiAgICAgICAgICAgIGNvbERlZnMyLmZvckVhY2goZnVuY3Rpb24gKGFic3RyYWN0Q29sRGVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzR3JvdXAgPSB1dGlsc18xLlV0aWxzLmV4aXN0cyhhYnN0cmFjdENvbERlZi5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbEdyb3VwRGVmID0gYWJzdHJhY3RDb2xEZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cENhbGxiYWNrKGNvbEdyb3VwRGVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hGb3JDb2xEZWZzKGNvbEdyb3VwRGVmLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xEZWYgPSBhYnN0cmFjdENvbERlZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5DYWxsYmFjayhjb2xEZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGNhbGxlZCBmcm9tOiBzZXRDb2x1bW5TdGF0ZSwgc2V0Q29sdW1uRGVmcywgc2V0QWx0ZXJuYXRpdmVDb2x1bW5EZWZzXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuY29weURvd25HcmlkQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5Q29sdW1ucykge1xuICAgICAgICAgICAgdGhpcy5ncmlkQmFsYW5jZWRUcmVlID0gdGhpcy5zZWNvbmRhcnlCYWxhbmNlZFRyZWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZEhlYWRlclJvd0NvdW50ID0gdGhpcy5zZWNvbmRhcnlIZWFkZXJSb3dDb3VudDtcbiAgICAgICAgICAgIHRoaXMuZ3JpZENvbHVtbnMgPSB0aGlzLnNlY29uZGFyeUNvbHVtbnMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZEJhbGFuY2VkVHJlZSA9IHRoaXMucHJpbWFyeUJhbGFuY2VkVHJlZS5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5ncmlkSGVhZGVyUm93Q291bnQgPSB0aGlzLnByaW1hcnlIZWFkZXJSb3dDb3VudDtcbiAgICAgICAgICAgIHRoaXMuZ3JpZENvbHVtbnMgPSB0aGlzLnByaW1hcnlDb2x1bW5zLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckRpc3BsYXllZENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jb2xTcGFuQWN0aXZlID0gdGhpcy5jaGVja0NvbFNwYW5BY3RpdmVJbkNvbHModGhpcy5ncmlkQ29sdW1ucyk7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9HUklEX0NPTFVNTlNfQ0hBTkdFRCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIC8vIGdldHMgY2FsbGVkIGFmdGVyIHdlIGNvcHkgZG93biBncmlkIGNvbHVtbnMsIHRvIG1ha2Ugc3VyZSBhbnkgcGFydCBvZiB0aGUgZ3VpXG4gICAgLy8gdGhhdCB0cmllcyB0byBkcmF3LCBlZyB0aGUgaGVhZGVyLCBpdCB3aWxsIGdldCBlbXB0eSBsaXN0cyBvZiBjb2x1bW5zIHJhdGhlclxuICAgIC8vIHRoYW4gc3RhbGUgY29sdW1ucy4gZm9yIGV4YW1wbGUsIHRoZSBoZWFkZXIgd2lsbCByZWNlaXZlZCBncmlkQ29sdW1uc0NoYW5nZWRcbiAgICAvLyBldmVudCwgc28gd2lsbCB0cnkgYW5kIGRyYXcsIGJ1dCBpdCB3aWxsIGRyYXcgc3VjY2Vzc2Z1bGx5IHdoZW4gaXQgYWN0cyBvbiB0aGVcbiAgICAvLyB2aXJ0dWFsQ29sdW1uc0NoYW5nZWQgZXZlbnRcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5jbGVhckRpc3BsYXllZENvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTGVmdENvbHVtblRyZWUgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtblRyZWUgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRDZW50cmVDb2x1bW5UcmVlID0gW107XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTGVmdEhlYWRlclJvd3MgPSB7fTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRSaWdodEhlYWRlclJvd3MgPSB7fTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRDZW50cmVIZWFkZXJSb3dzID0ge307XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTGVmdENvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRDZW50ZXJDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuYWxsRGlzcGxheWVkQ29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLmFsbERpc3BsYXllZFZpcnR1YWxDb2x1bW5zID0gW107XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVHcm91cHNBbmREaXNwbGF5ZWRDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUdyb3VwcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXllZENvbHVtbnNGcm9tVHJlZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWaXJ0dWFsU2V0cygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJvZHlXaWR0aHMoKTtcbiAgICAgICAgLy8gdGhpcyBldmVudCBpcyBwaWNrZWQgdXAgYnkgdGhlIGd1aSwgaGVhZGVyUmVuZGVyZXIgYW5kIHJvd1JlbmRlcmVyLCB0byByZWNhbGN1bGF0ZSB3aGF0IGNvbHVtbnMgdG8gZGlzcGxheVxuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfRElTUExBWUVEX0NPTFVNTlNfQ0hBTkdFRCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZURpc3BsYXllZENvbHVtbnNGcm9tVHJlZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkVG9EaXNwbGF5ZWRDb2x1bW5zKHRoaXMuZGlzcGxheWVkTGVmdENvbHVtblRyZWUsIHRoaXMuZGlzcGxheWVkTGVmdENvbHVtbnMpO1xuICAgICAgICB0aGlzLmFkZFRvRGlzcGxheWVkQ29sdW1ucyh0aGlzLmRpc3BsYXllZENlbnRyZUNvbHVtblRyZWUsIHRoaXMuZGlzcGxheWVkQ2VudGVyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuYWRkVG9EaXNwbGF5ZWRDb2x1bW5zKHRoaXMuZGlzcGxheWVkUmlnaHRDb2x1bW5UcmVlLCB0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1ucyk7XG4gICAgICAgIHRoaXMuc2V0dXBBbGxEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuc2V0TGVmdFZhbHVlcygpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0dXBBbGxEaXNwbGF5ZWRDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVSdGwoKSkge1xuICAgICAgICAgICAgdGhpcy5hbGxEaXNwbGF5ZWRDb2x1bW5zID0gdGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtbnNcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuZGlzcGxheWVkQ2VudGVyQ29sdW1ucylcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuZGlzcGxheWVkTGVmdENvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbGxEaXNwbGF5ZWRDb2x1bW5zID0gdGhpcy5kaXNwbGF5ZWRMZWZ0Q29sdW1uc1xuICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5kaXNwbGF5ZWRDZW50ZXJDb2x1bW5zKVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBzZXRzIHRoZSBsZWZ0IHBpeGVsIHBvc2l0aW9uIG9mIGVhY2ggY29sdW1uXG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0TGVmdFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRMZWZ0VmFsdWVzT2ZDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuc2V0TGVmdFZhbHVlc09mR3JvdXBzKCk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRMZWZ0VmFsdWVzT2ZDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBnbyB0aHJvdWdoIGVhY2ggbGlzdCBvZiBkaXNwbGF5ZWQgY29sdW1uc1xuICAgICAgICB2YXIgYWxsQ29sdW1ucyA9IHRoaXMucHJpbWFyeUNvbHVtbnMuc2xpY2UoMCk7XG4gICAgICAgIC8vIGxldCB0b3RhbENvbHVtbldpZHRoID0gdGhpcy5nZXRXaWR0aE9mQ29sc0luTGlzdCgpXG4gICAgICAgIHZhciBkb2luZ1J0bCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCk7XG4gICAgICAgIFt0aGlzLmRpc3BsYXllZExlZnRDb2x1bW5zLCB0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1ucywgdGhpcy5kaXNwbGF5ZWRDZW50ZXJDb2x1bW5zXS5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBpZiAoZG9pbmdSdGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGRvaW5nIFJUTCwgd2Ugc3RhcnQgYXQgdGhlIHRvcCBtb3N0IHBpeGVsIChpZSBSSFMpIGFuZCB3b3JrIGJhY2t3YXJkc1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0XzEgPSBfdGhpcy5nZXRXaWR0aE9mQ29sc0luTGlzdChjb2x1bW5zKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0XzEgLT0gY29sdW1uLmdldEFjdHVhbFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRMZWZ0KGxlZnRfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugbm9ybWFsIExUUiwgd2Ugc3RhcnQgYXQgemVyb1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0XzIgPSAwO1xuICAgICAgICAgICAgICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRMZWZ0KGxlZnRfMik7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRfMiArPSBjb2x1bW4uZ2V0QWN0dWFsV2lkdGgoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlQWxsRnJvbUFycmF5KGFsbENvbHVtbnMsIGNvbHVtbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaXRlbXMgbGVmdCBpbiBhbGxDb2x1bW5zIGFyZSBjb2x1bW5zIG5vdCBkaXNwbGF5ZWQsIHNvIHJlbW92ZSB0aGUgbGVmdCBwb3NpdGlvbi4gdGhpcyBpc1xuICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIHRoZSByb3dzLCBhcyBpZiBhIGNvbCBpcyBtYWRlIHZpc2libGUsIHRoZW4gdGFrZW4gb3V0LCB0aGVuIG1hZGUgdmlzaWJsZSBhZ2FpbixcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgYW5pbWF0aW9uIG9mIHRoZSBjZWxsIGZsb2F0aW5nIGluIGZyb20gdGhlIG9sZCBwb3NpdGlvbiwgd2hhdGV2ZXIgdGhhdCB3YXMuXG4gICAgICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICBjb2x1bW4uc2V0TGVmdChudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRMZWZ0VmFsdWVzT2ZHcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGEgZ3JvdXBzIGxlZnQgdmFsdWUgaXMgdGhlIGxlc3QgbGVmdCB2YWx1ZSBvZiBpdCdzIGNoaWxkcmVuXG4gICAgICAgIFt0aGlzLmRpc3BsYXllZExlZnRDb2x1bW5UcmVlLCB0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1uVHJlZSwgdGhpcy5kaXNwbGF5ZWRDZW50cmVDb2x1bW5UcmVlXS5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gaW5zdGFuY2VvZiBjb2x1bW5Hcm91cF8xLkNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5Hcm91cCA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uR3JvdXAuY2hlY2tMZWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuYWRkVG9EaXNwbGF5ZWRDb2x1bW5zID0gZnVuY3Rpb24gKGRpc3BsYXllZENvbHVtblRyZWUsIGRpc3BsYXllZENvbHVtbnMpIHtcbiAgICAgICAgZGlzcGxheWVkQ29sdW1ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNvbHVtblV0aWxzLmRlcHRoRmlyc3REaXNwbGF5ZWRDb2x1bW5UcmVlU2VhcmNoKGRpc3BsYXllZENvbHVtblRyZWUsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgY29sdW1uXzEuQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheWVkQ29sdW1ucy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ZWRDZW50ZXJWaXJ0dWFsQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNraXBWaXJ0dWFsaXNhdGlvbiA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NDb2x1bW5WaXJ0dWFsaXNhdGlvbigpIHx8IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKTtcbiAgICAgICAgaWYgKHNraXBWaXJ0dWFsaXNhdGlvbikge1xuICAgICAgICAgICAgLy8gbm8gdmlydHVhbGlzYXRpb24sIHNvIGRvbid0IGZpbHRlclxuICAgICAgICAgICAgdGhpcy5hbGxEaXNwbGF5ZWRDZW50ZXJWaXJ0dWFsQ29sdW1ucyA9IHRoaXMuZGlzcGxheWVkQ2VudGVyQ29sdW1ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgd2hhdCBzaG91bGQgYmUgdmlzaWJsZVxuICAgICAgICAgICAgdGhpcy5hbGxEaXNwbGF5ZWRDZW50ZXJWaXJ0dWFsQ29sdW1ucyA9IHRoaXMuZmlsdGVyT3V0Q29sdW1uc1dpdGhpblZpZXdwb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxEaXNwbGF5ZWRWaXJ0dWFsQ29sdW1ucyA9IHRoaXMuYWxsRGlzcGxheWVkQ2VudGVyVmlydHVhbENvbHVtbnNcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5kaXNwbGF5ZWRMZWZ0Q29sdW1ucylcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5kaXNwbGF5ZWRSaWdodENvbHVtbnMpO1xuICAgICAgICAvLyByZXR1cm4gbWFwIG9mIHZpcnR1YWwgY29sIGlkJ3MsIGZvciBlYXN5IGxvb2t1cCB3aGVuIGJ1aWxkaW5nIHRoZSBncm91cHMuXG4gICAgICAgIC8vIHRoZSBtYXAgd2lsbCBiZSBjb2xJZD0+dHJ1ZSwgaWUgY29sIGlkJ3MgbWFwcGluZyB0byAndHJ1ZScuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdGhpcy5hbGxEaXNwbGF5ZWRWaXJ0dWFsQ29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgICAgIHJlc3VsdFtjb2wuZ2V0SWQoKV0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldFZpcnR1YWxIZWFkZXJHcm91cFJvdyA9IGZ1bmN0aW9uICh0eXBlLCBkZXB0KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX0xFRlQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kaXNwbGF5ZWRMZWZ0SGVhZGVyUm93c1tkZXB0XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9SSUdIVDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmRpc3BsYXllZFJpZ2h0SGVhZGVyUm93c1tkZXB0XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kaXNwbGF5ZWRDZW50cmVIZWFkZXJSb3dzW2RlcHRdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcocmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZURpc3BsYXllZFZpcnR1YWxHcm91cHMgPSBmdW5jdGlvbiAodmlydHVhbENvbElkcykge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIGVhY2ggZ3JvdXAsIHNlZSBpZiBhbnkgb2YgaXQncyBjb2xzIGFyZSBkaXNwbGF5ZWQsIGFuZCBpZiB5ZXMsXG4gICAgICAgIC8vIHRoZW4gdGhpcyBncm91cCBpcyBpbmNsdWRlZFxuICAgICAgICB0aGlzLmRpc3BsYXllZExlZnRIZWFkZXJSb3dzID0ge307XG4gICAgICAgIHRoaXMuZGlzcGxheWVkUmlnaHRIZWFkZXJSb3dzID0ge307XG4gICAgICAgIHRoaXMuZGlzcGxheWVkQ2VudHJlSGVhZGVyUm93cyA9IHt9O1xuICAgICAgICB0ZXN0R3JvdXAodGhpcy5kaXNwbGF5ZWRMZWZ0Q29sdW1uVHJlZSwgdGhpcy5kaXNwbGF5ZWRMZWZ0SGVhZGVyUm93cywgMCk7XG4gICAgICAgIHRlc3RHcm91cCh0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1uVHJlZSwgdGhpcy5kaXNwbGF5ZWRSaWdodEhlYWRlclJvd3MsIDApO1xuICAgICAgICB0ZXN0R3JvdXAodGhpcy5kaXNwbGF5ZWRDZW50cmVDb2x1bW5UcmVlLCB0aGlzLmRpc3BsYXllZENlbnRyZUhlYWRlclJvd3MsIDApO1xuICAgICAgICBmdW5jdGlvbiB0ZXN0R3JvdXAoY2hpbGRyZW4sIHJlc3VsdCwgZGVwdCkge1xuICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIHRoaXMgaXRlbSBpcyB3aXRoaW4gdmlld3BvcnRcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB2YXIgYWRkVGhpc0l0ZW0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgY29sdW1uXzEuQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBjb2x1bW4sIHRlc3QgaWYgY29sdW1uIGlzIGluY2x1ZGVkXG4gICAgICAgICAgICAgICAgICAgIGFkZFRoaXNJdGVtID0gdmlydHVhbENvbElkc1tjaGlsZC5nZXRJZCgpXSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGdyb3VwLCBiYXNlIGRlY2lzaW9uIG9uIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5Hcm91cCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhZGRUaGlzSXRlbSA9IHRlc3RHcm91cChjb2x1bW5Hcm91cC5nZXREaXNwbGF5ZWRDaGlsZHJlbigpLCByZXN1bHQsIGRlcHQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkZFRoaXNJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRbZGVwdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtkZXB0XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtkZXB0XS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVZpcnR1YWxTZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmlydHVhbENvbElkcyA9IHRoaXMudXBkYXRlRGlzcGxheWVkQ2VudGVyVmlydHVhbENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5ZWRWaXJ0dWFsR3JvdXBzKHZpcnR1YWxDb2xJZHMpO1xuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZmlsdGVyT3V0Q29sdW1uc1dpdGhpblZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5VdGlscy5maWx0ZXIodGhpcy5kaXNwbGF5ZWRDZW50ZXJDb2x1bW5zLCB0aGlzLmlzQ29sdW1uSW5WaWV3cG9ydC5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIC8vIGNhbGxlZCBmcm9tIGFwaVxuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLnNpemVDb2x1bW5zVG9GaXQgPSBmdW5jdGlvbiAoZ3JpZFdpZHRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGF2b2lkIGRpdmlkZSBieSB6ZXJvXG4gICAgICAgIHZhciBhbGxEaXNwbGF5ZWRDb2x1bW5zID0gdGhpcy5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChncmlkV2lkdGggPD0gMCB8fCBhbGxEaXNwbGF5ZWRDb2x1bW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xzVG9Ob3RTcHJlYWQgPSB1dGlsc18xLlV0aWxzLmZpbHRlcihhbGxEaXNwbGF5ZWRDb2x1bW5zLCBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uLmdldENvbERlZigpLnN1cHByZXNzU2l6ZVRvRml0ID09PSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbHNUb1NwcmVhZCA9IHV0aWxzXzEuVXRpbHMuZmlsdGVyKGFsbERpc3BsYXllZENvbHVtbnMsIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uZ2V0Q29sRGVmKCkuc3VwcHJlc3NTaXplVG9GaXQgIT09IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgY29scyB0aGF0IGFyZSBnb2luZyB0byBiZSByZXNpemVkXG4gICAgICAgIHZhciBjb2xzVG9GaXJlRXZlbnRGb3IgPSBjb2xzVG9TcHJlYWQuc2xpY2UoMCk7XG4gICAgICAgIHZhciBmaW5pc2hlZFJlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghZmluaXNoZWRSZXNpemluZykge1xuICAgICAgICAgICAgZmluaXNoZWRSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlUGl4ZWxzID0gZ3JpZFdpZHRoIC0gdGhpcy5nZXRXaWR0aE9mQ29sc0luTGlzdChjb2xzVG9Ob3RTcHJlYWQpO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVBpeGVscyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gd2lkdGgsIHNldCBldmVyeXRoaW5nIHRvIG1pbmltdW1cbiAgICAgICAgICAgICAgICBjb2xzVG9TcHJlYWQuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRNaW5pbXVtKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBhdmFpbGFibGVQaXhlbHMgLyB0aGlzLmdldFdpZHRoT2ZDb2xzSW5MaXN0KGNvbHNUb1NwcmVhZCk7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2V0IHRoZSBwaXhlbHMgZm9yIHRoZSBsYXN0IGNvbCBiYXNlZCBvbiB3aGF0J3MgbGVmdCwgYXMgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgLy8gd2UgY291bGQgYmUgYSBwaXhlbCBvciB0d28gc2hvcnQgb3IgZXh0cmEgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnMuXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsc0Zvckxhc3RDb2wgPSBhdmFpbGFibGVQaXhlbHM7XG4gICAgICAgICAgICAgICAgLy8gYmFja3dhcmRzIHRocm91Z2ggbG9vcCwgYXMgd2UgYXJlIHJlbW92aW5nIGl0ZW1zIGFzIHdlIGdvXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNvbHNUb1NwcmVhZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gY29sc1RvU3ByZWFkW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBNYXRoLnJvdW5kKGNvbHVtbi5nZXRBY3R1YWxXaWR0aCgpICogc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3V2lkdGggPCBjb2x1bW4uZ2V0TWluV2lkdGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldE1pbmltdW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUb05vdFNwcmVhZChjb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbi5pc0dyZWF0ZXJUaGFuTWF4KG5ld1dpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEFjdHVhbFdpZHRoKGNvbHVtbi5nZXRNYXhXaWR0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUb05vdFNwcmVhZChjb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uTGFzdENvbCA9IGkgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25MYXN0Q29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEFjdHVhbFdpZHRoKHBpeGVsc0Zvckxhc3RDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEFjdHVhbFdpZHRoKG5ld1dpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwaXhlbHNGb3JMYXN0Q29sIC09IG5ld1dpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldExlZnRWYWx1ZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVCb2R5V2lkdGhzKCk7XG4gICAgICAgIGNvbHNUb0ZpcmVFdmVudEZvci5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1JFU0laRUQsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgY29sdW1uczogW2NvbHVtbl0sXG4gICAgICAgICAgICAgICAgZmluaXNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgYXBpOiBfdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkFwaTogX3RoaXMuY29sdW1uQXBpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbW92ZVRvTm90U3ByZWFkKGNvbHVtbikge1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVGcm9tQXJyYXkoY29sc1RvU3ByZWFkLCBjb2x1bW4pO1xuICAgICAgICAgICAgY29sc1RvTm90U3ByZWFkLnB1c2goY29sdW1uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuYnVpbGREaXNwbGF5ZWRUcmVlcyA9IGZ1bmN0aW9uICh2aXNpYmxlQ29sdW1ucykge1xuICAgICAgICB2YXIgbGVmdFZpc2libGVDb2x1bW5zID0gdXRpbHNfMS5VdGlscy5maWx0ZXIodmlzaWJsZUNvbHVtbnMsIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uZ2V0UGlubmVkKCkgPT09ICdsZWZ0JztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByaWdodFZpc2libGVDb2x1bW5zID0gdXRpbHNfMS5VdGlscy5maWx0ZXIodmlzaWJsZUNvbHVtbnMsIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uZ2V0UGlubmVkKCkgPT09ICdyaWdodCc7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2VudGVyVmlzaWJsZUNvbHVtbnMgPSB1dGlsc18xLlV0aWxzLmZpbHRlcih2aXNpYmxlQ29sdW1ucywgZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5nZXRQaW5uZWQoKSAhPT0gJ2xlZnQnICYmIGNvbHVtbi5nZXRQaW5uZWQoKSAhPT0gJ3JpZ2h0JztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBncm91cEluc3RhbmNlSWRDcmVhdG9yID0gbmV3IGdyb3VwSW5zdGFuY2VJZENyZWF0b3JfMS5Hcm91cEluc3RhbmNlSWRDcmVhdG9yKCk7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTGVmdENvbHVtblRyZWUgPSB0aGlzLmRpc3BsYXllZEdyb3VwQ3JlYXRvci5jcmVhdGVEaXNwbGF5ZWRHcm91cHMobGVmdFZpc2libGVDb2x1bW5zLCB0aGlzLmdyaWRCYWxhbmNlZFRyZWUsIGdyb3VwSW5zdGFuY2VJZENyZWF0b3IsIHRoaXMuZGlzcGxheWVkTGVmdENvbHVtblRyZWUpO1xuICAgICAgICB0aGlzLmRpc3BsYXllZFJpZ2h0Q29sdW1uVHJlZSA9IHRoaXMuZGlzcGxheWVkR3JvdXBDcmVhdG9yLmNyZWF0ZURpc3BsYXllZEdyb3VwcyhyaWdodFZpc2libGVDb2x1bW5zLCB0aGlzLmdyaWRCYWxhbmNlZFRyZWUsIGdyb3VwSW5zdGFuY2VJZENyZWF0b3IsIHRoaXMuZGlzcGxheWVkUmlnaHRDb2x1bW5UcmVlKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRDZW50cmVDb2x1bW5UcmVlID0gdGhpcy5kaXNwbGF5ZWRHcm91cENyZWF0b3IuY3JlYXRlRGlzcGxheWVkR3JvdXBzKGNlbnRlclZpc2libGVDb2x1bW5zLCB0aGlzLmdyaWRCYWxhbmNlZFRyZWUsIGdyb3VwSW5zdGFuY2VJZENyZWF0b3IsIHRoaXMuZGlzcGxheWVkQ2VudHJlQ29sdW1uVHJlZSk7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVHcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbGxHcm91cHMgPSB0aGlzLmdldEFsbERpc3BsYXllZENvbHVtbkdyb3VwcygpO1xuICAgICAgICB0aGlzLmNvbHVtblV0aWxzLmRlcHRoRmlyc3RBbGxDb2x1bW5UcmVlU2VhcmNoKGFsbEdyb3VwcywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBjb2x1bW5Hcm91cF8xLkNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgZ3JvdXAuY2FsY3VsYXRlRGlzcGxheWVkQ29sdW1ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldEdyb3VwQXV0b0NvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwQXV0b0NvbHVtbnM7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5jcmVhdGVHcm91cEF1dG9Db2x1bW5zSWZOZWVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5hdXRvR3JvdXBzTmVlZEJ1aWxkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRvR3JvdXBzTmVlZEJ1aWxkaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIHNlZSBpZiB3ZSBuZWVkIHRvIGluc2VydCB0aGUgZGVmYXVsdCBncm91cGluZyBjb2x1bW5cbiAgICAgICAgdmFyIG5lZWRBdXRvQ29sdW1ucyA9ICh0aGlzLnJvd0dyb3VwQ29sdW1ucy5sZW5ndGggPiAwIHx8IHRoaXMudXNpbmdUcmVlRGF0YSlcbiAgICAgICAgICAgICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwU3VwcHJlc3NBdXRvQ29sdW1uKClcbiAgICAgICAgICAgICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwVXNlRW50aXJlUm93KClcbiAgICAgICAgICAgICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwU3VwcHJlc3NSb3coKTtcbiAgICAgICAgaWYgKG5lZWRBdXRvQ29sdW1ucykge1xuICAgICAgICAgICAgdGhpcy5ncm91cEF1dG9Db2x1bW5zID0gdGhpcy5hdXRvR3JvdXBDb2xTZXJ2aWNlLmNyZWF0ZUF1dG9Hcm91cENvbHVtbnModGhpcy5yb3dHcm91cENvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncm91cEF1dG9Db2x1bW5zID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuY3JlYXRlVmFsdWVDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlQ29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5zZXRWYWx1ZUFjdGl2ZShmYWxzZSk7IH0pO1xuICAgICAgICB0aGlzLnZhbHVlQ29sdW1ucyA9IFtdO1xuICAgICAgICAvLyBvdmVycmlkZSB3aXRoIGNvbHVtbnMgdGhhdCBoYXZlIHRoZSBhZ2dGdW5jIHNwZWNpZmllZCBleHBsaWNpdGx5XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcmltYXJ5Q29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMucHJpbWFyeUNvbHVtbnNbaV07XG4gICAgICAgICAgICBpZiAoY29sdW1uLmdldENvbERlZigpLmFnZ0Z1bmMpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4uc2V0QWdnRnVuYyhjb2x1bW4uZ2V0Q29sRGVmKCkuYWdnRnVuYyk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRWYWx1ZUFjdGl2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0V2lkdGhPZkNvbHNJbkxpc3QgPSBmdW5jdGlvbiAoY29sdW1uTGlzdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY29sdW1uTGlzdFtpXS5nZXRBY3R1YWxXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5nZXRHcmlkQmFsYW5jZWRUcmVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkQmFsYW5jZWRUcmVlO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdleHByZXNzaW9uU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXhwcmVzc2lvblNlcnZpY2VfMS5FeHByZXNzaW9uU2VydmljZSlcbiAgICBdLCBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJleHByZXNzaW9uU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyXzEuQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlcilcbiAgICBdLCBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2Rpc3BsYXllZEdyb3VwQ3JlYXRvcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZGlzcGxheWVkR3JvdXBDcmVhdG9yXzEuRGlzcGxheWVkR3JvdXBDcmVhdG9yKVxuICAgIF0sIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcImRpc3BsYXllZEdyb3VwQ3JlYXRvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdhdXRvV2lkdGhDYWxjdWxhdG9yJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBhdXRvV2lkdGhDYWxjdWxhdG9yXzEuQXV0b1dpZHRoQ2FsY3VsYXRvcilcbiAgICBdLCBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJhdXRvV2lkdGhDYWxjdWxhdG9yXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5VdGlscycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uVXRpbHNfMS5Db2x1bW5VdGlscylcbiAgICBdLCBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJjb2x1bW5VdGlsc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkUGFuZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRQYW5lbF8xLkdyaWRQYW5lbClcbiAgICBdLCBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJncmlkUGFuZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29udGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29udGV4dF8xLkNvbnRleHQpXG4gICAgXSwgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5BbmltYXRpb25TZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5BbmltYXRpb25TZXJ2aWNlXzEuQ29sdW1uQW5pbWF0aW9uU2VydmljZSlcbiAgICBdLCBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJjb2x1bW5BbmltYXRpb25TZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2F1dG9Hcm91cENvbFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGF1dG9Hcm91cENvbFNlcnZpY2VfMS5BdXRvR3JvdXBDb2xTZXJ2aWNlKVxuICAgIF0sIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcImF1dG9Hcm91cENvbFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLk9wdGlvbmFsKCdhZ2dGdW5jU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcImFnZ0Z1bmNTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5PcHRpb25hbCgndmFsdWVDYWNoZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdmFsdWVDYWNoZV8xLlZhbHVlQ2FjaGUpXG4gICAgXSwgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUsIFwidmFsdWVDYWNoZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5BcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIENvbHVtbkFwaSlcbiAgICBdLCBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJjb2x1bW5BcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZEFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZEFwaV8xLkdyaWRBcGkpXG4gICAgXSwgQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUsIFwiZ3JpZEFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBfX3BhcmFtKDAsIGNvbnRleHRfMS5RdWFsaWZpZXIoJ2xvZ2dlckZhY3RvcnknKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbbG9nZ2VyXzEuTG9nZ2VyRmFjdG9yeV0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIENvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcInNldEJlYW5zXCIsIG51bGwpO1xuICAgIENvbHVtbkNvbnRyb2xsZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2NvbHVtbkNvbnRyb2xsZXInKVxuICAgIF0sIENvbHVtbkNvbnRyb2xsZXIpO1xuICAgIHJldHVybiBDb2x1bW5Db250cm9sbGVyO1xufSgpKTtcbmV4cG9ydHMuQ29sdW1uQ29udHJvbGxlciA9IENvbHVtbkNvbnRyb2xsZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29udGV4dF8yID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIEV2ZW50U2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRTZXJ2aWNlKCkge1xuICAgICAgICB0aGlzLmFsbFN5bmNMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5hbGxBc3luY0xpc3RlbmVycyA9IHt9O1xuICAgICAgICB0aGlzLmdsb2JhbFN5bmNMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5nbG9iYWxBc3luY0xpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmFzeW5jRnVuY3Rpb25zUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgRXZlbnRTZXJ2aWNlXzEgPSBFdmVudFNlcnZpY2U7XG4gICAgLy8gYmVjYXVzZSB0aGlzIGNsYXNzIGlzIHVzZWQgYm90aCBpbnNpZGUgdGhlIGNvbnRleHQgYW5kIG91dHNpZGUgdGhlIGNvbnRleHQsIHdlIGRvIG5vdFxuICAgIC8vIHVzZSBhdXRvd2lyZWQgYXR0cmlidXRlcywgYXMgdGhhdCB3b3VsZCBiZSBjb25mdXNpbmcsIGFzIHNvbWV0aW1lcyB0aGUgYXR0cmlidXRlc1xuICAgIC8vIHdvdWxkIGJlIHdpcmVkLCBhbmQgc29tZXRpbWVzIG5vdC5cbiAgICAvL1xuICAgIC8vIHRoZSBnbG9iYWwgZXZlbnQgc2VydmVycyB1c2VkIGJ5IGFnLUdyaWQgaXMgYXV0b3dpcmVkIGJ5IHRoZSBjb250ZXh0IG9uY2UsIGFuZCB0aGlzXG4gICAgLy8gc2V0QmVhbnMgbWV0aG9kIGdldHMgY2FsbGVkIG9uY2UuXG4gICAgLy9cbiAgICAvLyB0aGUgdGltZXMgd2hlbiB0aGlzIGNsYXNzIGlzIHVzZWQgb3V0c2lkZSBvZiB0aGUgY29udGV4dCAoZWcgUm93Tm9kZSBoYXMgYW4gaW5zdGFuY2Ugb2YgdGhpc1xuICAgIC8vIGNsYXNzKSB0aGVuIGl0IGlzIG5vdCBhIGJlYW4sIGFuZCB0aGlzIHNldEJlYW5zIG1ldGhvZCBpcyBub3QgY2FsbGVkLlxuICAgIEV2ZW50U2VydmljZS5wcm90b3R5cGUuc2V0QmVhbnMgPSBmdW5jdGlvbiAobG9nZ2VyRmFjdG9yeSwgZ3JpZE9wdGlvbnNXcmFwcGVyLCBnbG9iYWxFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGlmIChnbG9iYWxFdmVudExpc3RlbmVyID09PSB2b2lkIDApIHsgZ2xvYmFsRXZlbnRMaXN0ZW5lciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXJGYWN0b3J5LmNyZWF0ZSgnRXZlbnRTZXJ2aWNlJyk7XG4gICAgICAgIGlmIChnbG9iYWxFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICB2YXIgYXN5bmMgPSBncmlkT3B0aW9uc1dyYXBwZXIudXNlQXN5bmNFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkR2xvYmFsTGlzdGVuZXIoZ2xvYmFsRXZlbnRMaXN0ZW5lciwgYXN5bmMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudFNlcnZpY2UucHJvdG90eXBlLmdldExpc3RlbmVyTGlzdCA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGFzeW5jKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lck1hcCA9IGFzeW5jID8gdGhpcy5hbGxBc3luY0xpc3RlbmVycyA6IHRoaXMuYWxsU3luY0xpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyTGlzdCA9IGxpc3RlbmVyTWFwW2V2ZW50VHlwZV07XG4gICAgICAgIGlmICghbGlzdGVuZXJMaXN0KSB7XG4gICAgICAgICAgICBsaXN0ZW5lckxpc3QgPSBbXTtcbiAgICAgICAgICAgIGxpc3RlbmVyTWFwW2V2ZW50VHlwZV0gPSBsaXN0ZW5lckxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyTGlzdDtcbiAgICB9O1xuICAgIEV2ZW50U2VydmljZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyLCBhc3luYykge1xuICAgICAgICBpZiAoYXN5bmMgPT09IHZvaWQgMCkgeyBhc3luYyA9IGZhbHNlOyB9XG4gICAgICAgIGlmICghdGhpcy5hc3NlcnROb3REZXByZWNhdGVkKGV2ZW50VHlwZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBsaXN0ZW5lckxpc3QgPSB0aGlzLmdldExpc3RlbmVyTGlzdChldmVudFR5cGUsIGFzeW5jKTtcbiAgICAgICAgaWYgKGxpc3RlbmVyTGlzdC5pbmRleE9mKGxpc3RlbmVyKSA8IDApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyTGlzdC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRTZXJ2aWNlLnByb3RvdHlwZS5hc3NlcnROb3REZXByZWNhdGVkID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICBpZiAoZXZlbnRUeXBlID09PSAnZmxvYXRpbmdSb3dEYXRhQ2hhbmdlZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogZmxvYXRpbmdSb3dEYXRhQ2hhbmdlZCBpcyBub3cgY2FsbGVkIHBpbm5lZFJvd0RhdGFDaGFuZ2VkJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZm9yIHNvbWUgZXZlbnRzLCBpdCdzIGltcG9ydGFudCB0aGF0IHRoZSBtb2RlbCBnZXRzIHRvIGhlYXIgYWJvdXQgdGhlbSBiZWZvcmUgdGhlIHZpZXcsXG4gICAgLy8gYXMgdGhlIG1vZGVsIG1heSBuZWVkIHRvIHVwZGF0ZSBiZWZvcmUgdGhlIHZpZXcgd29ya3Mgb24gdGhlIGluZm8uIGlmIHlvdSByZWdpc3RlclxuICAgIC8vIHZpYSB0aGlzIG1ldGhvZCwgeW91IGdldCBub3RpZmllZCBiZWZvcmUgdGhlIHZpZXcgcGFydHNcbiAgICBFdmVudFNlcnZpY2UucHJvdG90eXBlLmFkZE1vZGFsUHJpb3JpdHlFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGFzeW5jKSB7XG4gICAgICAgIGlmIChhc3luYyA9PT0gdm9pZCAwKSB7IGFzeW5jID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKCF0aGlzLmFzc2VydE5vdERlcHJlY2F0ZWQoZXZlbnRUeXBlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSArIEV2ZW50U2VydmljZV8xLlBSSU9SSVRZLCBsaXN0ZW5lciwgYXN5bmMpO1xuICAgIH07XG4gICAgRXZlbnRTZXJ2aWNlLnByb3RvdHlwZS5hZGRHbG9iYWxMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgYXN5bmMpIHtcbiAgICAgICAgaWYgKGFzeW5jID09PSB2b2lkIDApIHsgYXN5bmMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsQXN5bmNMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbFN5bmNMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50U2VydmljZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyLCBhc3luYykge1xuICAgICAgICBpZiAoYXN5bmMgPT09IHZvaWQgMCkgeyBhc3luYyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBsaXN0ZW5lckxpc3QgPSB0aGlzLmdldExpc3RlbmVyTGlzdChldmVudFR5cGUsIGFzeW5jKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVGcm9tQXJyYXkobGlzdGVuZXJMaXN0LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBFdmVudFNlcnZpY2UucHJvdG90eXBlLnJlbW92ZUdsb2JhbExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbUFycmF5KHRoaXMuZ2xvYmFsU3luY0xpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgLy8gd2h5IGRvIHdlIHBhc3MgdGhlIHR5cGUgaGVyZT8gdGhlIHR5cGUgaXMgaW4gQ29sdW1uQ2hhbmdlRXZlbnQsIHNvIHVubGVzcyB0aGVcbiAgICAvLyB0eXBlIGlzIG5vdCBpbiBvdGhlciB0eXBlcyBvZiBldmVudHM/Pz9cbiAgICBFdmVudFNlcnZpY2UucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYGRpc3BhdGNoaW5nICR7ZXZlbnRUeXBlfTogJHtldmVudH1gKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRvTGlzdGVuZXJzKGV2ZW50LCB0cnVlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRvTGlzdGVuZXJzKGV2ZW50LCBmYWxzZSk7XG4gICAgfTtcbiAgICBFdmVudFNlcnZpY2UucHJvdG90eXBlLmRpc3BhdGNoVG9MaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQsIGFzeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBnbG9iYWxMaXN0ZW5lcnMgPSBhc3luYyA/IHRoaXMuZ2xvYmFsQXN5bmNMaXN0ZW5lcnMgOiB0aGlzLmdsb2JhbFN5bmNMaXN0ZW5lcnM7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBldmVudC50eXBlO1xuICAgICAgICAvLyB0aGlzIGFsbG93cyB0aGUgY29sdW1uQ29udHJvbGxlciB0byBnZXQgZXZlbnRzIGJlZm9yZSBhbnlvbmUgZWxzZVxuICAgICAgICB2YXIgcDFMaXN0ZW5lckxpc3QgPSB0aGlzLmdldExpc3RlbmVyTGlzdChldmVudFR5cGUgKyBFdmVudFNlcnZpY2VfMS5QUklPUklUWSwgYXN5bmMpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLmZvckVhY2hTbmFwc2hvdEZpcnN0KHAxTGlzdGVuZXJMaXN0LCBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoQXN5bmMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlzdGVuZXIoZXZlbnQpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsaXN0ZW5lckxpc3QgPSB0aGlzLmdldExpc3RlbmVyTGlzdChldmVudFR5cGUsIGFzeW5jKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5mb3JFYWNoU25hcHNob3RGaXJzdChsaXN0ZW5lckxpc3QsIGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hBc3luYyhmdW5jdGlvbiAoKSB7IHJldHVybiBsaXN0ZW5lcihldmVudCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5mb3JFYWNoU25hcHNob3RGaXJzdChnbG9iYWxMaXN0ZW5lcnMsIGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hBc3luYyhmdW5jdGlvbiAoKSB7IHJldHVybiBsaXN0ZW5lcihldmVudFR5cGUsIGV2ZW50KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihldmVudFR5cGUsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB0aGlzIGdldHMgY2FsbGVkIGluc2lkZSB0aGUgZ3JpZCdzIHRocmVhZCwgZm9yIGVhY2ggZXZlbnQgdGhhdCBpdFxuICAgIC8vIHdhbnRzIHRvIHNldCBhc3luYy4gdGhlIGdyaWQgdGhlbiBiYXRjaGVzIHRoZSBldmVudHMgaW50byBvbmUgc2V0VGltZW91dCgpXG4gICAgLy8gYmVjYXVzZSBzZXRUaW1lb3V0KCkgaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbi4gaWRlYWxseSB3ZSB3b3VsZCBoYXZlXG4gICAgLy8gZWFjaCBldmVudCBpbiBpdCdzIG93biBzZXRUaW1lb3V0KCksIGJ1dCB3ZSBiYXRjaCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgRXZlbnRTZXJ2aWNlLnByb3RvdHlwZS5kaXNwYXRjaEFzeW5jID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgLy8gYWRkIHRvIHRoZSBxdWV1ZSBmb3IgZXhlY3V0aW5nIGxhdGVyIGluIHRoZSBuZXh0IFZNIHR1cm5cbiAgICAgICAgdGhpcy5hc3luY0Z1bmN0aW9uc1F1ZXVlLnB1c2goZnVuYyk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRpbWVvdXQgaXMgYWxyZWFkeSBzY2hlZHVsZWQuIHRoZSBmaXJzdCB0aW1lIHRoZSBncmlkIGNhbGxzXG4gICAgICAgIC8vIHRoaXMgd2l0aGluIGl0J3MgdGhyZWFkIHR1cm4sIHRoaXMgc2hvdWxkIGJlIGZhbHNlLCBzbyBpdCB3aWxsIHNjaGVkdWxlXG4gICAgICAgIC8vIHRoZSAnZmx1c2ggcXVldWUnIG1ldGhvZCB0aGUgZmlyc3QgdGltZSBpdCBjb21lcyBoZXJlLiB0aGVuIHRoZSBmbGFnIGlzXG4gICAgICAgIC8vIHNldCB0byAndHJ1ZScgc28gaXQgd2lsbCBrbm93IGl0J3MgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICAgIGlmICghdGhpcy5zY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBzY2hlZHVsZWQsIHNjaGVkdWxlIG9uZVxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLmZsdXNoQXN5bmNRdWV1ZS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgICAgIC8vIG1hcmsgdGhhdCBpdCBpcyBzY2hlZHVsZWRcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gdGhpcyBoYXBwZW5zIGluIHRoZSBuZXh0IFZNIHR1cm4gb25seSwgYW5kIGVtcHRpZXMgdGhlIHF1ZXVlIG9mIGV2ZW50c1xuICAgIEV2ZW50U2VydmljZS5wcm90b3R5cGUuZmx1c2hBc3luY1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAvLyB3ZSB0YWtlIGEgY29weSwgYmVjYXVzZSB0aGUgZXZlbnQgbGlzdGVuZXIgY291bGQgYmUgdXNpbmdcbiAgICAgICAgLy8gdGhlIGdyaWQsIHdoaWNoIHdvdWxkIGNhdXNlIG1vcmUgZXZlbnRzLCB3aGljaCB3b3VsZCBiZSBwb3RlbnRpYWxseVxuICAgICAgICAvLyBhZGRlZCB0byB0aGUgcXVldWUsIHNvIHNhZmUgdG8gdGFrZSBhIGNvcHksIHRoZSBuZXcgZXZlbnRzIHdpbGxcbiAgICAgICAgLy8gZ2V0IGV4ZWN1dGVkIGluIGEgbGF0ZXIgVk0gdHVybiByYXRoZXIgdGhhbiByaXNrIHVwZGF0aW5nIHRoZVxuICAgICAgICAvLyBxdWV1ZSBhcyB3ZSBhcmUgZmx1c2hpbmcgaXQuXG4gICAgICAgIHZhciBxdWV1ZUNvcHkgPSB0aGlzLmFzeW5jRnVuY3Rpb25zUXVldWUuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5hc3luY0Z1bmN0aW9uc1F1ZXVlID0gW107XG4gICAgICAgIC8vIGV4ZWN1dGUgdGhlIHF1ZXVlXG4gICAgICAgIHF1ZXVlQ29weS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7IHJldHVybiBmdW5jKCk7IH0pO1xuICAgIH07XG4gICAgLy8gdGhpcyBpcyBhbiBvbGQgaWRlYSBuaWFsbCBoYWQsIHNob3VsZCByZWFsbHkgdGFrZSBpdCBvdXQsIHdhcyB0byBkbyB3aXRoIG9yZGVyaW5nIHdobyBnZXRzIHRvIHByb2Nlc3NcbiAgICAvLyBldmVudHMgZmlyc3QsIHRvIGdpdmUgbW9kZWwgYW5kIHNlcnZpY2Ugb2JqZWN0cyBwcmVmZXJlbmNlIG92ZXIgdGhlIHZpZXdcbiAgICBFdmVudFNlcnZpY2UuUFJJT1JJVFkgPSAnLVAxJztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgX19wYXJhbSgwLCBjb250ZXh0XzIuUXVhbGlmaWVyKCdsb2dnZXJGYWN0b3J5JykpLFxuICAgICAgICBfX3BhcmFtKDEsIGNvbnRleHRfMi5RdWFsaWZpZXIoJ2dyaWRPcHRpb25zV3JhcHBlcicpKSxcbiAgICAgICAgX19wYXJhbSgyLCBjb250ZXh0XzIuUXVhbGlmaWVyKCdnbG9iYWxFdmVudExpc3RlbmVyJykpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2xvZ2dlcl8xLkxvZ2dlckZhY3RvcnksXG4gICAgICAgICAgICBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIsXG4gICAgICAgICAgICBGdW5jdGlvbl0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEV2ZW50U2VydmljZS5wcm90b3R5cGUsIFwic2V0QmVhbnNcIiwgbnVsbCk7XG4gICAgRXZlbnRTZXJ2aWNlID0gRXZlbnRTZXJ2aWNlXzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2V2ZW50U2VydmljZScpXG4gICAgXSwgRXZlbnRTZXJ2aWNlKTtcbiAgICByZXR1cm4gRXZlbnRTZXJ2aWNlO1xuICAgIHZhciBFdmVudFNlcnZpY2VfMTtcbn0oKSk7XG5leHBvcnRzLkV2ZW50U2VydmljZSA9IEV2ZW50U2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2V2ZW50U2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRLZXlzXzEgPSByZXF1aXJlKFwiLi9ldmVudEtleXNcIik7XG5leHBvcnRzLkV2ZW50cyA9IGV2ZW50S2V5c18xLkV2ZW50cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNzdkNyZWF0b3JfMSA9IHJlcXVpcmUoXCIuL2NzdkNyZWF0b3JcIik7XG52YXIgcm93UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmluZy9yb3dSZW5kZXJlclwiKTtcbnZhciBoZWFkZXJSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vaGVhZGVyUmVuZGVyaW5nL2hlYWRlclJlbmRlcmVyXCIpO1xudmFyIGZpbHRlck1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlci9maWx0ZXJNYW5hZ2VyXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBzZWxlY3Rpb25Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9zZWxlY3Rpb25Db250cm9sbGVyXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGdyaWRQYW5lbF8xID0gcmVxdWlyZShcIi4vZ3JpZFBhbmVsL2dyaWRQYW5lbFwiKTtcbnZhciB2YWx1ZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3ZhbHVlU2VydmljZS92YWx1ZVNlcnZpY2VcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9ldmVudFNlcnZpY2VcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRDb3JlXzEgPSByZXF1aXJlKFwiLi9ncmlkQ29yZVwiKTtcbnZhciBzb3J0Q29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4vc29ydENvbnRyb2xsZXJcIik7XG52YXIgZm9jdXNlZENlbGxDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9mb2N1c2VkQ2VsbENvbnRyb2xsZXJcIik7XG52YXIgZ3JpZENlbGxfMSA9IHJlcXVpcmUoXCIuL2VudGl0aWVzL2dyaWRDZWxsXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBjZWxsUmVuZGVyZXJGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9yZW5kZXJpbmcvY2VsbFJlbmRlcmVyRmFjdG9yeVwiKTtcbnZhciBjZWxsRWRpdG9yRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vcmVuZGVyaW5nL2NlbGxFZGl0b3JGYWN0b3J5XCIpO1xudmFyIHBhZ2luYXRpb25Qcm94eV8xID0gcmVxdWlyZShcIi4vcm93TW9kZWxzL3BhZ2luYXRpb25Qcm94eVwiKTtcbnZhciBpbW11dGFibGVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9yb3dNb2RlbHMvaW5NZW1vcnkvaW1tdXRhYmxlU2VydmljZVwiKTtcbnZhciB2YWx1ZUNhY2hlXzEgPSByZXF1aXJlKFwiLi92YWx1ZVNlcnZpY2UvdmFsdWVDYWNoZVwiKTtcbnZhciBhbGlnbmVkR3JpZHNTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9hbGlnbmVkR3JpZHNTZXJ2aWNlXCIpO1xudmFyIHBpbm5lZFJvd01vZGVsXzEgPSByZXF1aXJlKFwiLi9yb3dNb2RlbHMvcGlubmVkUm93TW9kZWxcIik7XG52YXIgR3JpZEFwaSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JpZEFwaSgpIHtcbiAgICB9XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJvd01vZGVsLmdldFR5cGUoKSkge1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuUk9XX01PREVMX1RZUEVfSU5fTUVNT1JZOlxuICAgICAgICAgICAgICAgIHRoaXMuaW5NZW1vcnlSb3dNb2RlbCA9IHRoaXMucm93TW9kZWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5ST1dfTU9ERUxfVFlQRV9JTkZJTklURTpcbiAgICAgICAgICAgICAgICB0aGlzLmluZmluaXRlUGFnZVJvd01vZGVsID0gdGhpcy5yb3dNb2RlbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0VOVEVSUFJJU0U6XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcnByaXNlUm93TW9kZWwgPSB0aGlzLnJvd01vZGVsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVXNlZCBpbnRlcm5hbGx5IGJ5IGdyaWQuIE5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIGJ5IHRoZSBjbGllbnQuIEludGVyZmFjZSBtYXkgY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuICovXG4gICAgR3JpZEFwaS5wcm90b3R5cGUuX19nZXRBbGlnbmVkR3JpZFNlcnZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsaWduZWRHcmlkc1NlcnZpY2U7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXREYXRhQXNDc3YgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzdkNyZWF0b3IuZ2V0RGF0YUFzQ3N2KHBhcmFtcyk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5leHBvcnREYXRhQXNDc3YgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY3N2Q3JlYXRvci5leHBvcnREYXRhQXNDc3YocGFyYW1zKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldERhdGFBc0V4Y2VsID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMuZXhjZWxDcmVhdG9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IEV4Y2VsIGV4cG9ydCBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhZy1HcmlkIEVudGVycHJpc2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGNlbENyZWF0b3IuZ2V0RGF0YUFzRXhjZWxYbWwocGFyYW1zKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmV4cG9ydERhdGFBc0V4Y2VsID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMuZXhjZWxDcmVhdG9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IEV4Y2VsIGV4cG9ydCBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhZy1HcmlkIEVudGVycHJpc2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4Y2VsQ3JlYXRvci5leHBvcnREYXRhQXNFeGNlbChwYXJhbXMpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2V0RW50ZXJwcmlzZURhdGFzb3VyY2UgPSBmdW5jdGlvbiAoZGF0YXNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNSb3dNb2RlbEVudGVycHJpc2UoKSkge1xuICAgICAgICAgICAgLy8gc2hvdWxkIHJlYWxseSBoYXZlIGFuIElFbnRlcnByaXNlUm93TW9kZWwgaW50ZXJmYWNlLCBzbyB3ZSBhcmUgbm90IGNhc3RpbmcgdG8gYW55XG4gICAgICAgICAgICB0aGlzLnJvd01vZGVsLnNldERhdGFzb3VyY2UoZGF0YXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1HcmlkOiB5b3UgY2FuIG9ubHkgdXNlIGFuIGVudGVycHJpc2UgZGF0YXNvdXJjZSB3aGVuIGdyaWRPcHRpb25zLnJvd01vZGVsVHlwZSBpcyAnXCIgKyBjb25zdGFudHNfMS5Db25zdGFudHMuUk9XX01PREVMX1RZUEVfRU5URVJQUklTRSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2V0RGF0YXNvdXJjZSA9IGZ1bmN0aW9uIChkYXRhc291cmNlKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1Jvd01vZGVsSW5maW5pdGUoKSkge1xuICAgICAgICAgICAgdGhpcy5yb3dNb2RlbC5zZXREYXRhc291cmNlKGRhdGFzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYWctR3JpZDogeW91IGNhbiBvbmx5IHVzZSBhIGRhdGFzb3VyY2Ugd2hlbiBncmlkT3B0aW9ucy5yb3dNb2RlbFR5cGUgaXMgJ1wiICsgY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0lORklOSVRFICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zZXRWaWV3cG9ydERhdGFzb3VyY2UgPSBmdW5jdGlvbiAodmlld3BvcnREYXRhc291cmNlKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1Jvd01vZGVsVmlld3BvcnQoKSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBiYWQgY29kaW5nLCBiZWNhdXNlIGl0J3MgdXNpbmcgYW4gaW50ZXJmYWNlIHRoYXQncyBleHBvc2VkIGluIHRoZSBlbnRlcnByaXNlLlxuICAgICAgICAgICAgLy8gcmVhbGx5IHdlIHNob3VsZCBjcmVhdGUgYW4gaW50ZXJmYWNlIGluIHRoZSBjb3JlIGZvciB2aWV3cG9ydERhdGFzb3VyY2UgYW5kIGxldFxuICAgICAgICAgICAgLy8gdGhlIGVudGVycHJpc2UgaW1wbGVtZW50IGl0LCByYXRoZXIgdGhhbiBjYXN0aW5nIHRvICdhbnknIGhlcmVcbiAgICAgICAgICAgIHRoaXMucm93TW9kZWwuc2V0Vmlld3BvcnREYXRhc291cmNlKHZpZXdwb3J0RGF0YXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1HcmlkOiB5b3UgY2FuIG9ubHkgdXNlIGEgdmlld3BvcnQgZGF0YXNvdXJjZSB3aGVuIGdyaWRPcHRpb25zLnJvd01vZGVsVHlwZSBpcyAnXCIgKyBjb25zdGFudHNfMS5Db25zdGFudHMuUk9XX01PREVMX1RZUEVfVklFV1BPUlQgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNldFJvd0RhdGEgPSBmdW5jdGlvbiAocm93RGF0YSkge1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNSb3dNb2RlbERlZmF1bHQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRGVsdGFSb3dEYXRhTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5pbW11dGFibGVTZXJ2aWNlLmNyZWF0ZVRyYW5zYWN0aW9uRm9yUm93RGF0YShyb3dEYXRhKSwgdHJhbnNhY3Rpb24gPSBfYVswXSwgb3JkZXJJZE1hcCA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5NZW1vcnlSb3dNb2RlbC51cGRhdGVSb3dEYXRhKHRyYW5zYWN0aW9uLCBvcmRlcklkTWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5NZW1vcnlSb3dNb2RlbC5zZXRSb3dEYXRhKHJvd0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Nhbm5vdCBjYWxsIHNldFJvd0RhdGEgdW5sZXNzIHVzaW5nIG5vcm1hbCByb3cgbW9kZWwnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gREVQUkVDQVRFRFxuICAgIEdyaWRBcGkucHJvdG90eXBlLnNldEZsb2F0aW5nVG9wUm93RGF0YSA9IGZ1bmN0aW9uIChyb3dzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogc2luY2UgdjEyLCBhcGkuc2V0RmxvYXRpbmdUb3BSb3dEYXRhKCkgaXMgbm93IGFwaS5zZXRQaW5uZWRUb3BSb3dEYXRhKCknKTtcbiAgICAgICAgdGhpcy5zZXRQaW5uZWRUb3BSb3dEYXRhKHJvd3MpO1xuICAgIH07XG4gICAgLy8gREVQUkVDQVRFRFxuICAgIEdyaWRBcGkucHJvdG90eXBlLnNldEZsb2F0aW5nQm90dG9tUm93RGF0YSA9IGZ1bmN0aW9uIChyb3dzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogc2luY2UgdjEyLCBhcGkuc2V0RmxvYXRpbmdCb3R0b21Sb3dEYXRhKCkgaXMgbm93IGFwaS5zZXRQaW5uZWRCb3R0b21Sb3dEYXRhKCknKTtcbiAgICAgICAgdGhpcy5zZXRQaW5uZWRCb3R0b21Sb3dEYXRhKHJvd3MpO1xuICAgIH07XG4gICAgLy8gREVQUkVDQVRFRFxuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldEZsb2F0aW5nVG9wUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogc2luY2UgdjEyLCBhcGkuZ2V0RmxvYXRpbmdUb3BSb3dDb3VudCgpIGlzIG5vdyBhcGkuZ2V0UGlubmVkVG9wUm93Q291bnQoKScpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQaW5uZWRUb3BSb3dDb3VudCgpO1xuICAgIH07XG4gICAgLy8gREVQUkVDQVRFRFxuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldEZsb2F0aW5nQm90dG9tUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogc2luY2UgdjEyLCBhcGkuZ2V0RmxvYXRpbmdCb3R0b21Sb3dDb3VudCgpIGlzIG5vdyBhcGkuZ2V0UGlubmVkQm90dG9tUm93Q291bnQoKScpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQaW5uZWRCb3R0b21Sb3dDb3VudCgpO1xuICAgIH07XG4gICAgLy8gREVQUkVDQVRFRFxuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldEZsb2F0aW5nVG9wUm93ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogc2luY2UgdjEyLCBhcGkuZ2V0RmxvYXRpbmdUb3BSb3coKSBpcyBub3cgYXBpLmdldFBpbm5lZFRvcFJvdygpJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBpbm5lZFRvcFJvdyhpbmRleCk7XG4gICAgfTtcbiAgICAvLyBERVBSRUNBVEVEXG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0RmxvYXRpbmdCb3R0b21Sb3cgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBzaW5jZSB2MTIsIGFwaS5nZXRGbG9hdGluZ0JvdHRvbVJvdygpIGlzIG5vdyBhcGkuZ2V0UGlubmVkQm90dG9tUm93KCknKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGlubmVkQm90dG9tUm93KGluZGV4KTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNldFBpbm5lZFRvcFJvd0RhdGEgPSBmdW5jdGlvbiAocm93cykge1xuICAgICAgICB0aGlzLnBpbm5lZFJvd01vZGVsLnNldFBpbm5lZFRvcFJvd0RhdGEocm93cyk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zZXRQaW5uZWRCb3R0b21Sb3dEYXRhID0gZnVuY3Rpb24gKHJvd3MpIHtcbiAgICAgICAgdGhpcy5waW5uZWRSb3dNb2RlbC5zZXRQaW5uZWRCb3R0b21Sb3dEYXRhKHJvd3MpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0UGlubmVkVG9wUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbm5lZFJvd01vZGVsLmdldFBpbm5lZFRvcFJvd0NvdW50KCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRQaW5uZWRCb3R0b21Sb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlubmVkUm93TW9kZWwuZ2V0UGlubmVkQm90dG9tUm93Q291bnQoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldFBpbm5lZFRvcFJvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waW5uZWRSb3dNb2RlbC5nZXRQaW5uZWRUb3BSb3coaW5kZXgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0UGlubmVkQm90dG9tUm93ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbm5lZFJvd01vZGVsLmdldFBpbm5lZEJvdHRvbVJvdyhpbmRleCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zZXRDb2x1bW5EZWZzID0gZnVuY3Rpb24gKGNvbERlZnMpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5Db250cm9sbGVyLnNldENvbHVtbkRlZnMoY29sRGVmcyk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5leHBpcmVWYWx1ZUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlQ2FjaGUuZXhwaXJlKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRWZXJ0aWNhbFBpeGVsUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRQYW5lbC5nZXRWZXJ0aWNhbFBpeGVsUmFuZ2UoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnJlZnJlc2hUb29sUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRvb2xQYW5lbCkge1xuICAgICAgICAgICAgdGhpcy50b29sUGFuZWwucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5yZWZyZXNoQ2VsbHMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7fTsgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gb2YgcmVmcmVzaENlbGxzKCkgdG9vayBhbiBhcnJheSBvZiByb3dOb2RlcyBmb3IgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NpbmNlIGFnLUdyaWQgdjExLjEsIHJlZnJlc2hDZWxscygpIG5vdyB0YWtlcyBwYXJhbWV0ZXJzLCBwbGVhc2Ugc2VlIHRoZSBkb2N1bWVudGF0aW9uLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93UmVuZGVyZXIucmVmcmVzaENlbGxzKHBhcmFtcyk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5yZWRyYXdSb3dzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cbiAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucm93Tm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMucm93UmVuZGVyZXIucmVkcmF3Um93cyhwYXJhbXMucm93Tm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3dSZW5kZXJlci5yZWRyYXdBZnRlck1vZGVsVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnRpbWVGdWxsUmVkcmF3ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIGlmIChjb3VudCA9PT0gdm9pZCAwKSB7IGNvdW50ID0gMTsgfVxuICAgICAgICB2YXIgaXRlcmF0aW9uQ291bnQgPSAwO1xuICAgICAgICB2YXIgdG90YWxQcm9jZXNzaW5nID0gMDtcbiAgICAgICAgdmFyIHRvdGFsUmVmbG93ID0gMDtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBkb09uZUl0ZXJhdGlvbigpO1xuICAgICAgICBmdW5jdGlvbiBkb09uZUl0ZXJhdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGF0LnJvd1JlbmRlcmVyLnJlZHJhd0FmdGVyTW9kZWxVcGRhdGUoKTtcbiAgICAgICAgICAgIHZhciBlbmRQcm9jZXNzaW5nID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmRSZWZsb3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvblByb2Nlc3NpbmcgPSBlbmRQcm9jZXNzaW5nIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uUmVmbG93ID0gZW5kUmVmbG93IC0gZW5kUHJvY2Vzc2luZztcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZHVyYXRpb246ICBwcm9jZXNzaW5nID0gJyArIGR1cmF0aW9uUHJvY2Vzc2luZyArICdtcywgcmVmbG93ID0gJyArIGR1cmF0aW9uUmVmbG93ICsgJ21zJyk7XG4gICAgICAgICAgICAgICAgaXRlcmF0aW9uQ291bnQrKztcbiAgICAgICAgICAgICAgICB0b3RhbFByb2Nlc3NpbmcgKz0gZHVyYXRpb25Qcm9jZXNzaW5nO1xuICAgICAgICAgICAgICAgIHRvdGFsUmVmbG93ICs9IGR1cmF0aW9uUmVmbG93O1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb25Db3VudCA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIDFzIGJldHdlZW4gdGVzdHNcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChkb09uZUl0ZXJhdGlvbiwgMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygndGVzdHMgY29tcGxldGUuIGl0ZXJhdGlvbiBjb3VudCA9ICcgKyBpdGVyYXRpb25Db3VudCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYXZlcmFnZSBwcm9jZXNzaW5nID0gJyArICh0b3RhbFByb2Nlc3NpbmcgLyBpdGVyYXRpb25Db3VudCkgKyAnbXMnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhdmVyYWdlIHJlZmxvdyA9ICcgKyAodG90YWxSZWZsb3cgLyBpdGVyYXRpb25Db3VudCkgKyAnbXMnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gKioqIGRlcHJlY2F0ZWRcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5yZWZyZXNoVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBzaW5jZSB2MTEuMSwgcmVmcmVzaFZpZXcoKSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgY2FsbCByZWRyYXdSb3dzKCkgaW5zdGVhZCcpO1xuICAgICAgICB0aGlzLnJlZHJhd1Jvd3MoKTtcbiAgICB9O1xuICAgIC8vICoqKiBkZXByZWNhdGVkXG4gICAgR3JpZEFwaS5wcm90b3R5cGUucmVmcmVzaFJvd3MgPSBmdW5jdGlvbiAocm93Tm9kZXMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdzaW5jZSBhZy1HcmlkIHYxMS4xLCByZWZyZXNoUm93cygpIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgcmVmcmVzaENlbGxzKHtyb3dOb2Rlczogcm93c30pIG9yIHJlZHJhd1Jvd3Moe3Jvd05vZGVzOiByb3dzfSkgaW5zdGVhZCcpO1xuICAgICAgICB0aGlzLnJlZnJlc2hDZWxscyh7IHJvd05vZGVzOiByb3dOb2RlcyB9KTtcbiAgICB9O1xuICAgIC8vICoqKiBkZXByZWNhdGVkXG4gICAgR3JpZEFwaS5wcm90b3R5cGUucm93RGF0YUNoYW5nZWQgPSBmdW5jdGlvbiAocm93cykge1xuICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogcm93RGF0YUNoYW5nZWQgaXMgZGVwcmVjYXRlZCwgZWl0aGVyIGNhbGwgcmVmcmVzaFZpZXcoKSB0byByZWZyZXNoIGV2ZXJ5dGhpbmcsIG9yIGNhbGwgcm93Tm9kZS5zZXRSb3dEYXRhKG5ld0RhdGEpIHRvIHNldCB2YWx1ZSBvbiBhIHBhcnRpY3VsYXIgbm9kZScpO1xuICAgICAgICB0aGlzLnJlZHJhd1Jvd3MoKTtcbiAgICB9O1xuICAgIC8vICoqKiBkZXByZWNhdGVkXG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc29mdFJlZnJlc2hWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IHNpbmNlIHYxMS4xLCBzb2Z0UmVmcmVzaFZpZXcoKSBpcyBkZXByZWNhdGVkLCBjYWxsIHJlZnJlc2hDZWxscyhwYXJhbXMpIGluc3RlYWQuJyk7XG4gICAgICAgIHRoaXMucmVmcmVzaENlbGxzKHsgdm9sYXRpbGU6IHRydWUgfSk7XG4gICAgfTtcbiAgICAvLyAqKiogZGVwcmVjYXRlZFxuICAgIEdyaWRBcGkucHJvdG90eXBlLnJlZnJlc2hHcm91cFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogc2luY2UgdjExLjEsIHJlZnJlc2hHcm91cFJvd3MoKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCBjYWxsIHJlZnJlc2hDZWxscygpIGluc3RlYWQuICcgK1xuICAgICAgICAgICAgJ0JlY2F1c2UgcmVmcmVzaENlbGxzKCkgbm93IGRvZXMgZGlydHkgY2hlY2tpbmcsIGl0IHdpbGwgb25seSByZWZyZXNoIGNlbGxzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBzbyBpdCBzaG91bGQgJyArXG4gICAgICAgICAgICAnbm90IGJlIG5lY2Vzc2FyeSB0byBvbmx5IHJlZnJlc2ggdGhlIGdyb3VwIHJvd3MuJyk7XG4gICAgICAgIHRoaXMucmVmcmVzaENlbGxzKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zZXRGdW5jdGlvbnNSZWFkT25seSA9IGZ1bmN0aW9uIChyZWFkT25seSkge1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5zZXRQcm9wZXJ0eSgnZnVuY3Rpb25zUmVhZE9ubHknLCByZWFkT25seSk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5yZWZyZXNoSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhlYWRlclJlbmRlcmVyLnJlZnJlc2hIZWFkZXIoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmlzQW55RmlsdGVyUHJlc2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyTWFuYWdlci5pc0FueUZpbHRlclByZXNlbnQoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmlzQWR2YW5jZWRGaWx0ZXJQcmVzZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJNYW5hZ2VyLmlzQWR2YW5jZWRGaWx0ZXJQcmVzZW50KCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5pc1F1aWNrRmlsdGVyUHJlc2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyTWFuYWdlci5pc1F1aWNrRmlsdGVyUHJlc2VudCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd01vZGVsO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUub25Hcm91cEV4cGFuZGVkT3JDb2xsYXBzZWQgPSBmdW5jdGlvbiAoZGVwcmVjYXRlZF9yZWZyZXNoRnJvbUluZGV4KSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5pbk1lbW9yeVJvd01vZGVsKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FnLUdyaWQ6IGNhbm5vdCBjYWxsIG9uR3JvdXBFeHBhbmRlZE9yQ29sbGFwc2VkIHVubGVzcyB1c2luZyBub3JtYWwgcm93IG1vZGVsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKGRlcHJlY2F0ZWRfcmVmcmVzaEZyb21JbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZy1HcmlkOiBhcGkub25Hcm91cEV4cGFuZGVkT3JDb2xsYXBzZWQgLSByZWZyZXNoRnJvbUluZGV4IHBhcmFtZXRlciBpcyBub3QgbG9uZ2VyIHVzZWQsIHRoZSBncmlkIHdpbGwgcmVmcmVzaCBhbGwgcm93cycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSB3YW50IHRoZSB1c2VyIGNhbGxpbmcgdGhpcyBpZiBvbmUgb25lIHJvd05vZGUgd2FzIGV4cGFuZGVkLCBpbnN0ZWFkIHRoZXkgc2hvdWxkIGJlXG4gICAgICAgIC8vIGNhbGxpbmcgcm93Tm9kZS5zZXRFeHBhbmRlZChib29sZWFuKSAtIHRoaXMgd2F5IHdlIGRvIGEgJ2tlZXBSZW5kZXJlZFJvd3M9ZmFsc2UnIHNvIHRoYXQgdGhlIHdob2xlXG4gICAgICAgIC8vIGdyaWQgZ2V0cyByZWZyZXNoZWQgYWdhaW4gLSBvdGhlcndpc2UgdGhlIHJvdyB3aXRoIHRoZSByb3dOb2RlcyB0aGF0IHdlcmUgY2hhbmdlZCB3b24ndCBnZXQgdXBkYXRlZCxcbiAgICAgICAgLy8gYW5kIHRodXMgdGhlIGV4cGFuZCBpY29uIGluIHRoZSBncm91cCBjZWxsIHdvbid0IGdldCAnb3BlbmVkJyBvciAnY2xvc2VkJy5cbiAgICAgICAgdGhpcy5pbk1lbW9yeVJvd01vZGVsLnJlZnJlc2hNb2RlbCh7IHN0ZXA6IGNvbnN0YW50c18xLkNvbnN0YW50cy5TVEVQX01BUCB9KTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnJlZnJlc2hJbk1lbW9yeVJvd01vZGVsID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyh0aGlzLmluTWVtb3J5Um93TW9kZWwpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY2Fubm90IGNhbGwgcmVmcmVzaEluTWVtb3J5Um93TW9kZWwgdW5sZXNzIHVzaW5nIG5vcm1hbCByb3cgbW9kZWwnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1zU3RlcCA9IGNvbnN0YW50c18xLkNvbnN0YW50cy5TVEVQX0VWRVJZVEhJTkc7XG4gICAgICAgIHZhciBzdGVwc01hcHBlZCA9IHtcbiAgICAgICAgICAgIGdyb3VwOiBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9FVkVSWVRISU5HLFxuICAgICAgICAgICAgZmlsdGVyOiBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9GSUxURVIsXG4gICAgICAgICAgICBtYXA6IGNvbnN0YW50c18xLkNvbnN0YW50cy5TVEVQX01BUCxcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZTogY29uc3RhbnRzXzEuQ29uc3RhbnRzLlNURVBfQUdHUkVHQVRFLFxuICAgICAgICAgICAgc29ydDogY29uc3RhbnRzXzEuQ29uc3RhbnRzLlNURVBfU09SVCxcbiAgICAgICAgICAgIHBpdm90OiBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9QSVZPVFxuICAgICAgICB9O1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMoc3RlcCkpIHtcbiAgICAgICAgICAgIHBhcmFtc1N0ZXAgPSBzdGVwc01hcHBlZFtzdGVwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHBhcmFtc1N0ZXApKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYWctR3JpZDogaW52YWxpZCBzdGVwIFwiICsgc3RlcCArIFwiLCBhdmFpbGFibGUgc3RlcHMgYXJlIFwiICsgT2JqZWN0LmtleXMoc3RlcHNNYXBwZWQpLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RlbFBhcmFtcyA9IHtcbiAgICAgICAgICAgIHN0ZXA6IHBhcmFtc1N0ZXAsXG4gICAgICAgICAgICBrZWVwUmVuZGVyZWRSb3dzOiB0cnVlLFxuICAgICAgICAgICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGtlZXBFZGl0aW5nUm93czogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluTWVtb3J5Um93TW9kZWwucmVmcmVzaE1vZGVsKG1vZGVsUGFyYW1zKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldFJvd05vZGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyh0aGlzLmluTWVtb3J5Um93TW9kZWwpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGNhbm5vdCBjYWxsIGdldFJvd05vZGUgdW5sZXNzIHVzaW5nIG5vcm1hbCByb3cgbW9kZWwnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbk1lbW9yeVJvd01vZGVsLmdldFJvd05vZGUoaWQpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZXhwYW5kQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMuaW5NZW1vcnlSb3dNb2RlbCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogY2Fubm90IGNhbGwgZXhwYW5kQWxsIHVubGVzcyB1c2luZyBub3JtYWwgcm93IG1vZGVsJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbk1lbW9yeVJvd01vZGVsLmV4cGFuZE9yQ29sbGFwc2VBbGwodHJ1ZSk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5jb2xsYXBzZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyh0aGlzLmluTWVtb3J5Um93TW9kZWwpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGNhbm5vdCBjYWxsIGNvbGxhcHNlQWxsIHVubGVzcyB1c2luZyBub3JtYWwgcm93IG1vZGVsJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbk1lbW9yeVJvd01vZGVsLmV4cGFuZE9yQ29sbGFwc2VBbGwoZmFsc2UpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuYWRkVmlydHVhbFJvd0xpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcm93SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FnLUdyaWQ6IGFkZFZpcnR1YWxSb3dMaXN0ZW5lciBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFkZFJlbmRlcmVkUm93TGlzdGVuZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRSZW5kZXJlZFJvd0xpc3RlbmVyKGV2ZW50TmFtZSwgcm93SW5kZXgsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmFkZFJlbmRlcmVkUm93TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCByb3dJbmRleCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3ZpcnR1YWxSb3dTZWxlY3RlZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZy1HcmlkOiBldmVudCB2aXJ0dWFsUm93U2VsZWN0ZWQgaXMgZGVwcmVjYXRlZCwgdG8gcmVnaXN0ZXIgZm9yIGluZGl2aWR1YWwgcm93ICcgK1xuICAgICAgICAgICAgICAgICdzZWxlY3Rpb24gZXZlbnRzLCBhZGQgYSBsaXN0ZW5lciBkaXJlY3RseSB0byB0aGUgcm93IG5vZGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dSZW5kZXJlci5hZGRSZW5kZXJlZFJvd0xpc3RlbmVyKGV2ZW50TmFtZSwgcm93SW5kZXgsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNldFF1aWNrRmlsdGVyID0gZnVuY3Rpb24gKG5ld0ZpbHRlcikge1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIuc2V0UXVpY2tGaWx0ZXIobmV3RmlsdGVyKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNlbGVjdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCB0cnlNdWx0aSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2FnLUdyaWQ6IGRvIG5vdCB1c2UgYXBpIGZvciBzZWxlY3Rpb24sIGNhbGwgbm9kZS5zZXRTZWxlY3RlZCh2YWx1ZSkgaW5zdGVhZCcpO1xuICAgICAgICBpZiAoc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZy1HcmlkOiBzdXBwcmVzc0V2ZW50cyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCBzdG9wIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IGlmIHlvdSBubyBsb25nZXIgd2FudCBpdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5zZWxlY3RJbmRleChpbmRleCwgdHJ5TXVsdGkpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZGVzZWxlY3RJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgaWYgKHN1cHByZXNzRXZlbnRzID09PSB2b2lkIDApIHsgc3VwcHJlc3NFdmVudHMgPSBmYWxzZTsgfVxuICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogZG8gbm90IHVzZSBhcGkgZm9yIHNlbGVjdGlvbiwgY2FsbCBub2RlLnNldFNlbGVjdGVkKHZhbHVlKSBpbnN0ZWFkJyk7XG4gICAgICAgIGlmIChzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FnLUdyaWQ6IHN1cHByZXNzRXZlbnRzIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHN0b3AgbGlzdGVuaW5nIGZvciB0aGUgZXZlbnQgaWYgeW91IG5vIGxvbmdlciB3YW50IGl0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLmRlc2VsZWN0SW5kZXgoaW5kZXgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2VsZWN0Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCB0cnlNdWx0aSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgaWYgKHRyeU11bHRpID09PSB2b2lkIDApIHsgdHJ5TXVsdGkgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoc3VwcHJlc3NFdmVudHMgPT09IHZvaWQgMCkgeyBzdXBwcmVzc0V2ZW50cyA9IGZhbHNlOyB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdhZy1HcmlkOiBBUEkgZm9yIHNlbGVjdGlvbiBpcyBkZXByZWNhdGVkLCBjYWxsIG5vZGUuc2V0U2VsZWN0ZWQodmFsdWUpIGluc3RlYWQnKTtcbiAgICAgICAgaWYgKHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogc3VwcHJlc3NFdmVudHMgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgc3RvcCBsaXN0ZW5pbmcgZm9yIHRoZSBldmVudCBpZiB5b3Ugbm8gbG9uZ2VyIHdhbnQgaXQnKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNlbGVjdGVkUGFyYW1zKHsgbmV3VmFsdWU6IHRydWUsIGNsZWFyU2VsZWN0aW9uOiAhdHJ5TXVsdGkgfSk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5kZXNlbGVjdE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgaWYgKHN1cHByZXNzRXZlbnRzID09PSB2b2lkIDApIHsgc3VwcHJlc3NFdmVudHMgPSBmYWxzZTsgfVxuICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogQVBJIGZvciBzZWxlY3Rpb24gaXMgZGVwcmVjYXRlZCwgY2FsbCBub2RlLnNldFNlbGVjdGVkKHZhbHVlKSBpbnN0ZWFkJyk7XG4gICAgICAgIGlmIChzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FnLUdyaWQ6IHN1cHByZXNzRXZlbnRzIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHN0b3AgbGlzdGVuaW5nIGZvciB0aGUgZXZlbnQgaWYgeW91IG5vIGxvbmdlciB3YW50IGl0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTZWxlY3RlZFBhcmFtcyh7IG5ld1ZhbHVlOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLnNlbGVjdEFsbFJvd05vZGVzKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5kZXNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLmRlc2VsZWN0QWxsUm93Tm9kZXMoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNlbGVjdEFsbEZpbHRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIuc2VsZWN0QWxsUm93Tm9kZXModHJ1ZSk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5kZXNlbGVjdEFsbEZpbHRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIuZGVzZWxlY3RBbGxSb3dOb2Rlcyh0cnVlKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnJlY29tcHV0ZUFnZ3JlZ2F0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5pbk1lbW9yeVJvd01vZGVsKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Nhbm5vdCBjYWxsIHJlY29tcHV0ZUFnZ3JlZ2F0ZXMgdW5sZXNzIHVzaW5nIG5vcm1hbCByb3cgbW9kZWwnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluTWVtb3J5Um93TW9kZWwucmVmcmVzaE1vZGVsKHsgc3RlcDogY29uc3RhbnRzXzEuQ29uc3RhbnRzLlNURVBfQUdHUkVHQVRFIH0pO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2l6ZUNvbHVtbnNUb0ZpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBzaXplQ29sdW1uc1RvRml0IGRvZXMgbm90IHdvcmsgd2hlbiBmb3JQcmludD10cnVlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkUGFuZWwuc2l6ZUNvbHVtbnNUb0ZpdCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2hvd0xvYWRpbmdPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdyaWRQYW5lbC5zaG93TG9hZGluZ092ZXJsYXkoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNob3dOb1Jvd3NPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdyaWRQYW5lbC5zaG93Tm9Sb3dzT3ZlcmxheSgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuaGlkZU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ3JpZFBhbmVsLmhpZGVPdmVybGF5KCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5pc05vZGVTZWxlY3RlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhZy1HcmlkOiBubyBuZWVkIHRvIGNhbGwgYXBpLmlzTm9kZVNlbGVjdGVkKCksIGp1c3QgY2FsbCBub2RlLmlzU2VsZWN0ZWQoKSBpbnN0ZWFkJyk7XG4gICAgICAgIHJldHVybiBub2RlLmlzU2VsZWN0ZWQoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldFNlbGVjdGVkTm9kZXNCeUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBzaW5jZSB2ZXJzaW9uIDMuNCwgZ2V0U2VsZWN0ZWROb2Rlc0J5SWQgbm8gbG9uZ2VyIGV4aXN0cywgdXNlIGdldFNlbGVjdGVkTm9kZXMoKSBpbnN0ZWFkJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0U2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5nZXRTZWxlY3RlZE5vZGVzKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRTZWxlY3RlZFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRCZXN0Q29zdE5vZGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIuZ2V0QmVzdENvc3ROb2RlU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRSZW5kZXJlZE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dSZW5kZXJlci5nZXRSZW5kZXJlZE5vZGVzKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5lbnN1cmVDb2xJbmRleFZpc2libGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBlbnN1cmVDb2xJbmRleFZpc2libGUoaW5kZXgpIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHVzZSBlbnN1cmVDb2x1bW5WaXNpYmxlKGNvbEtleSkgaW5zdGVhZC4nKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmVuc3VyZUNvbHVtblZpc2libGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMuZ3JpZFBhbmVsLmVuc3VyZUNvbHVtblZpc2libGUoa2V5KTtcbiAgICB9O1xuICAgIC8vIFZhbGlkIHZhbHVlcyBmb3IgcG9zaXRpb24gYXJlIGJvdHRvbSwgbWlkZGxlIGFuZCB0b3BcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5lbnN1cmVJbmRleFZpc2libGUgPSBmdW5jdGlvbiAoaW5kZXgsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7IHBvc2l0aW9uID0gJ3RvcCc7IH1cbiAgICAgICAgdGhpcy5ncmlkUGFuZWwuZW5zdXJlSW5kZXhWaXNpYmxlKGluZGV4LCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICAvLyBWYWxpZCB2YWx1ZXMgZm9yIHBvc2l0aW9uIGFyZSBib3R0b20sIG1pZGRsZSBhbmQgdG9wXG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZW5zdXJlTm9kZVZpc2libGUgPSBmdW5jdGlvbiAoY29tcGFyYXRvciwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSB2b2lkIDApIHsgcG9zaXRpb24gPSAndG9wJzsgfVxuICAgICAgICB0aGlzLmdyaWRDb3JlLmVuc3VyZU5vZGVWaXNpYmxlKGNvbXBhcmF0b3IsIHBvc2l0aW9uKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmZvckVhY2hMZWFmTm9kZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMuaW5NZW1vcnlSb3dNb2RlbCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjYW5ub3QgY2FsbCBmb3JFYWNoTm9kZSB1bmxlc3MgdXNpbmcgbm9ybWFsIHJvdyBtb2RlbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5NZW1vcnlSb3dNb2RlbC5mb3JFYWNoTGVhZk5vZGUoY2FsbGJhY2spO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZm9yRWFjaE5vZGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yb3dNb2RlbC5mb3JFYWNoTm9kZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5mb3JFYWNoTm9kZUFmdGVyRmlsdGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5pbk1lbW9yeVJvd01vZGVsKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Nhbm5vdCBjYWxsIGZvckVhY2hOb2RlQWZ0ZXJGaWx0ZXIgdW5sZXNzIHVzaW5nIG5vcm1hbCByb3cgbW9kZWwnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluTWVtb3J5Um93TW9kZWwuZm9yRWFjaE5vZGVBZnRlckZpbHRlcihjYWxsYmFjayk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5mb3JFYWNoTm9kZUFmdGVyRmlsdGVyQW5kU29ydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMuaW5NZW1vcnlSb3dNb2RlbCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjYW5ub3QgY2FsbCBmb3JFYWNoTm9kZUFmdGVyRmlsdGVyQW5kU29ydCB1bmxlc3MgdXNpbmcgbm9ybWFsIHJvdyBtb2RlbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5NZW1vcnlSb3dNb2RlbC5mb3JFYWNoTm9kZUFmdGVyRmlsdGVyQW5kU29ydChjYWxsYmFjayk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRGaWx0ZXJBcGlGb3JDb2xEZWYgPSBmdW5jdGlvbiAoY29sRGVmKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZCBBUEkgbWV0aG9kIGdldEZpbHRlckFwaUZvckNvbERlZiBkZXByZWNhdGVkLCB1c2UgZ2V0RmlsdGVyQXBpIGluc3RlYWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsdGVySW5zdGFuY2UoY29sRGVmKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldEZpbHRlckluc3RhbmNlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldFByaW1hcnlDb2x1bW4oa2V5KTtcbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJDb21wb25lbnQoY29sdW1uKS5yZXNvbHZlTm93KG51bGwsIGZ1bmN0aW9uIChmaWx0ZXJDb21wKSB7IHJldHVybiBmaWx0ZXJDb21wOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0RmlsdGVyQXBpID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGdldEZpbHRlckFwaSBpcyBkZXByZWNhdGVkLCB1c2UgZ2V0RmlsdGVySW5zdGFuY2UgaW5zdGVhZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWx0ZXJJbnN0YW5jZShrZXkpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZGVzdHJveUZpbHRlciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRQcmltYXJ5Q29sdW1uKGtleSk7XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlck1hbmFnZXIuZGVzdHJveUZpbHRlcihjb2x1bW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRDb2x1bW5EZWYgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0UHJpbWFyeUNvbHVtbihrZXkpO1xuICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uLmdldENvbERlZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLm9uRmlsdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJNYW5hZ2VyLm9uRmlsdGVyQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUub25Tb3J0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zb3J0Q29udHJvbGxlci5vblNvcnRDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zZXRTb3J0TW9kZWwgPSBmdW5jdGlvbiAoc29ydE1vZGVsKSB7XG4gICAgICAgIHRoaXMuc29ydENvbnRyb2xsZXIuc2V0U29ydE1vZGVsKHNvcnRNb2RlbCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRTb3J0TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRDb250cm9sbGVyLmdldFNvcnRNb2RlbCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2V0RmlsdGVyTW9kZWwgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJNYW5hZ2VyLnNldEZpbHRlck1vZGVsKG1vZGVsKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldEZpbHRlck1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJNYW5hZ2VyLmdldEZpbHRlck1vZGVsKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRGb2N1c2VkQ2VsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZENlbGxDb250cm9sbGVyLmdldEZvY3VzZWRDZWxsKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5jbGVhckZvY3VzZWRDZWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c2VkQ2VsbENvbnRyb2xsZXIuY2xlYXJGb2N1c2VkQ2VsbCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2V0Rm9jdXNlZENlbGwgPSBmdW5jdGlvbiAocm93SW5kZXgsIGNvbEtleSwgZmxvYXRpbmcpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbENvbnRyb2xsZXIuc2V0Rm9jdXNlZENlbGwocm93SW5kZXgsIGNvbEtleSwgZmxvYXRpbmcsIHRydWUpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2V0SGVhZGVySGVpZ2h0ID0gZnVuY3Rpb24gKGhlYWRlckhlaWdodCkge1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5zZXRQcm9wZXJ0eShncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIuUFJPUF9IRUFERVJfSEVJR0hULCBoZWFkZXJIZWlnaHQpO1xuICAgICAgICB0aGlzLmRvTGF5b3V0KCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zZXRHcm91cEhlYWRlckhlaWdodCA9IGZ1bmN0aW9uIChoZWFkZXJIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuc2V0UHJvcGVydHkoZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfR1JPVVBfSEVBREVSX0hFSUdIVCwgaGVhZGVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kb0xheW91dCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2V0RmxvYXRpbmdGaWx0ZXJzSGVpZ2h0ID0gZnVuY3Rpb24gKGhlYWRlckhlaWdodCkge1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5zZXRQcm9wZXJ0eShncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIuUFJPUF9GTE9BVElOR19GSUxURVJTX0hFSUdIVCwgaGVhZGVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kb0xheW91dCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2V0UGl2b3RHcm91cEhlYWRlckhlaWdodCA9IGZ1bmN0aW9uIChoZWFkZXJIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuc2V0UHJvcGVydHkoZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfUElWT1RfR1JPVVBfSEVBREVSX0hFSUdIVCwgaGVhZGVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kb0xheW91dCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2V0UGl2b3RIZWFkZXJIZWlnaHQgPSBmdW5jdGlvbiAoaGVhZGVySGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLnNldFByb3BlcnR5KGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlci5QUk9QX1BJVk9UX0hFQURFUl9IRUlHSFQsIGhlYWRlckhlaWdodCk7XG4gICAgICAgIHRoaXMuZG9MYXlvdXQoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNob3dUb29sUGFuZWwgPSBmdW5jdGlvbiAoc2hvdykge1xuICAgICAgICB0aGlzLmdyaWRDb3JlLnNob3dUb29sUGFuZWwoc2hvdyk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5pc1Rvb2xQYW5lbFNob3dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRDb3JlLmlzVG9vbFBhbmVsU2hvd2luZygpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZG9MYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ3JpZENvcmUuZG9MYXlvdXQoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnJlc2V0Um93SGVpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMuaW5NZW1vcnlSb3dNb2RlbCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5NZW1vcnlSb3dNb2RlbC5yZXNldFJvd0hlaWdodHMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuc2V0R3JvdXBSZW1vdmVTaW5nbGVDaGlsZHJlbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5zZXRQcm9wZXJ0eShncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIuUFJPUF9HUk9VUF9SRU1PVkVfU0lOR0xFX0NISUxEUkVOLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zZXRHcm91cFJlbW92ZUxvd2VzdFNpbmdsZUNoaWxkcmVuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLnNldFByb3BlcnR5KGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlci5QUk9QX0dST1VQX1JFTU9WRV9MT1dFU1RfU0lOR0xFX0NISUxEUkVOLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5vblJvd0hlaWdodENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyh0aGlzLmluTWVtb3J5Um93TW9kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmluTWVtb3J5Um93TW9kZWwub25Sb3dIZWlnaHRDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGNvbEtleSwgcm93Tm9kZSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldFByaW1hcnlDb2x1bW4oY29sS2V5KTtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyhjb2x1bW4pKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0R3JpZENvbHVtbihjb2xLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcoY29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVNlcnZpY2UuZ2V0VmFsdWUoY29sdW1uLCByb3dOb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBhc3luYyA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLnVzZUFzeW5jRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgYXN5bmMpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuYWRkR2xvYmFsTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGFzeW5jID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIudXNlQXN5bmNFdmVudHMoKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkR2xvYmFsTGlzdGVuZXIobGlzdGVuZXIsIGFzeW5jKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUucmVtb3ZlR2xvYmFsTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UucmVtb3ZlR2xvYmFsTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZXN0cm95KCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5yZXNldFF1aWNrRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJvd01vZGVsLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnF1aWNrRmlsdGVyQWdncmVnYXRlVGV4dCA9IG51bGw7IH0pO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0UmFuZ2VTZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlQ29udHJvbGxlci5nZXRDZWxsUmFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGNlbGwgcmFuZ2Ugc2VsZWN0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIGluIGFnLUdyaWQgRW50ZXJwcmlzZScpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmNhbWVsQ2FzZVRvSHVtYW5SZWFkYWJsZSA9IGZ1bmN0aW9uIChjYW1lbENhc2UpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMuY2FtZWxDYXNlVG9IdW1hblRleHQoY2FtZWxDYXNlKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmFkZFJhbmdlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHJhbmdlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5yYW5nZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogY2VsbCByYW5nZSBzZWxlY3Rpb24gaXMgb25seSBhdmFpbGFibGUgaW4gYWctR3JpZCBFbnRlcnByaXNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYW5nZUNvbnRyb2xsZXIuYWRkUmFuZ2UocmFuZ2VTZWxlY3Rpb24pO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuY2xlYXJSYW5nZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlQ29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBjZWxsIHJhbmdlIHNlbGVjdGlvbiBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhZy1HcmlkIEVudGVycHJpc2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhbmdlQ29udHJvbGxlci5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuY29weVNlbGVjdGVkUm93c1RvQ2xpcGJvYXJkID0gZnVuY3Rpb24gKGluY2x1ZGVIZWFkZXIsIGNvbHVtbktleXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaXBib2FyZFNlcnZpY2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogY2xpcGJvYXJkIGlzIG9ubHkgYXZhaWxhYmxlIGluIGFnLUdyaWQgRW50ZXJwcmlzZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkU2VydmljZS5jb3B5U2VsZWN0ZWRSb3dzVG9DbGlwYm9hcmQoaW5jbHVkZUhlYWRlciwgY29sdW1uS2V5cyk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5jb3B5U2VsZWN0ZWRSYW5nZVRvQ2xpcGJvYXJkID0gZnVuY3Rpb24gKGluY2x1ZGVIZWFkZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaXBib2FyZFNlcnZpY2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogY2xpcGJvYXJkIGlzIG9ubHkgYXZhaWxhYmxlIGluIGFnLUdyaWQgRW50ZXJwcmlzZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkU2VydmljZS5jb3B5U2VsZWN0ZWRSYW5nZVRvQ2xpcGJvYXJkKGluY2x1ZGVIZWFkZXIpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuY29weVNlbGVjdGVkUmFuZ2VEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xpcGJvYXJkU2VydmljZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBjbGlwYm9hcmQgaXMgb25seSBhdmFpbGFibGUgaW4gYWctR3JpZCBFbnRlcnByaXNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGlwYm9hcmRTZXJ2aWNlLmNvcHlSYW5nZURvd24oKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNob3dDb2x1bW5NZW51QWZ0ZXJCdXR0b25DbGljayA9IGZ1bmN0aW9uIChjb2xLZXksIGJ1dHRvbkVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRQcmltYXJ5Q29sdW1uKGNvbEtleSk7XG4gICAgICAgIHRoaXMubWVudUZhY3Rvcnkuc2hvd01lbnVBZnRlckJ1dHRvbkNsaWNrKGNvbHVtbiwgYnV0dG9uRWxlbWVudCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zaG93Q29sdW1uTWVudUFmdGVyTW91c2VDbGljayA9IGZ1bmN0aW9uIChjb2xLZXksIG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRQcmltYXJ5Q29sdW1uKGNvbEtleSk7XG4gICAgICAgIHRoaXMubWVudUZhY3Rvcnkuc2hvd01lbnVBZnRlck1vdXNlRXZlbnQoY29sdW1uLCBtb3VzZUV2ZW50KTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnRhYlRvTmV4dENlbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1JlbmRlcmVyLnRhYlRvTmV4dENlbGwoZmFsc2UpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUudGFiVG9QcmV2aW91c0NlbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1JlbmRlcmVyLnRhYlRvTmV4dENlbGwodHJ1ZSk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zdG9wRWRpdGluZyA9IGZ1bmN0aW9uIChjYW5jZWwpIHtcbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gdm9pZCAwKSB7IGNhbmNlbCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMucm93UmVuZGVyZXIuc3RvcEVkaXRpbmcoY2FuY2VsKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnN0YXJ0RWRpdGluZ0NlbGwgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0R3JpZENvbHVtbihwYXJhbXMuY29sS2V5KTtcbiAgICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLUdyaWQ6IG5vIGNvbHVtbiBmb3VuZCBmb3IgXCIgKyBwYXJhbXMuY29sS2V5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JpZENlbGxEZWYgPSB7IHJvd0luZGV4OiBwYXJhbXMucm93SW5kZXgsIGZsb2F0aW5nOiBudWxsLCBjb2x1bW46IGNvbHVtbiB9O1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBuZXcgZ3JpZENlbGxfMS5HcmlkQ2VsbChncmlkQ2VsbERlZik7XG4gICAgICAgIHRoaXMuZ3JpZFBhbmVsLmVuc3VyZUluZGV4VmlzaWJsZShwYXJhbXMucm93SW5kZXgpO1xuICAgICAgICB0aGlzLnJvd1JlbmRlcmVyLnN0YXJ0RWRpdGluZ0NlbGwoZ3JpZENlbGwsIHBhcmFtcy5rZXlQcmVzcywgcGFyYW1zLmNoYXJQcmVzcyk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5hZGRBZ2dGdW5jID0gZnVuY3Rpb24gKGtleSwgYWdnRnVuYykge1xuICAgICAgICBpZiAodGhpcy5hZ2dGdW5jU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5hZ2dGdW5jU2VydmljZS5hZGRBZ2dGdW5jKGtleSwgYWdnRnVuYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmFkZEFnZ0Z1bmNzID0gZnVuY3Rpb24gKGFnZ0Z1bmNzKSB7XG4gICAgICAgIGlmICh0aGlzLmFnZ0Z1bmNTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLmFnZ0Z1bmNTZXJ2aWNlLmFkZEFnZ0Z1bmNzKGFnZ0Z1bmNzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuY2xlYXJBZ2dGdW5jcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWdnRnVuY1NlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWdnRnVuY1NlcnZpY2UuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUudXBkYXRlUm93RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdmFyIHJlcyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmluTWVtb3J5Um93TW9kZWwpIHtcbiAgICAgICAgICAgIHJlcyA9IHRoaXMuaW5NZW1vcnlSb3dNb2RlbC51cGRhdGVSb3dEYXRhKHJvd0RhdGFUcmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmZpbml0ZVBhZ2VSb3dNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5pbmZpbml0ZVBhZ2VSb3dNb2RlbC51cGRhdGVSb3dEYXRhKHJvd0RhdGFUcmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiB1cGRhdGVSb3dEYXRhKCkgb25seSB3b3JrcyB3aXRoIEluTWVtb3J5Um93TW9kZWwgYW5kIEluZmluaXRlUm93TW9kZWwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gY2hhbmdlIGRldGVjdGlvbiBmb3IgYWxsIHByZXNlbnQgY2VsbHNcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzQ2hhbmdlRGV0ZWN0aW9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMucm93UmVuZGVyZXIucmVmcmVzaENlbGxzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmluc2VydEl0ZW1zQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbXMsIHNraXBSZWZyZXNoKSB7XG4gICAgICAgIGlmIChza2lwUmVmcmVzaCA9PT0gdm9pZCAwKSB7IHNraXBSZWZyZXNoID0gZmFsc2U7IH1cbiAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBpbnNlcnRJdGVtc0F0SW5kZXgoKSBpcyBkZXByZWNhdGVkLCB1c2UgdXBkYXRlUm93RGF0YSh0cmFuc2FjdGlvbikgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy51cGRhdGVSb3dEYXRhKHsgYWRkOiBpdGVtcywgYWRkSW5kZXg6IGluZGV4LCB1cGRhdGU6IG51bGwsIHJlbW92ZTogbnVsbCB9KTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnJlbW92ZUl0ZW1zID0gZnVuY3Rpb24gKHJvd05vZGVzLCBza2lwUmVmcmVzaCkge1xuICAgICAgICBpZiAoc2tpcFJlZnJlc2ggPT09IHZvaWQgMCkgeyBza2lwUmVmcmVzaCA9IGZhbHNlOyB9XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogcmVtb3ZlSXRlbXMoKSBpcyBkZXByZWNhdGVkLCB1c2UgdXBkYXRlUm93RGF0YSh0cmFuc2FjdGlvbikgaW5zdGVhZC4nKTtcbiAgICAgICAgdmFyIGRhdGFUb1JlbW92ZSA9IHJvd05vZGVzLm1hcChmdW5jdGlvbiAocm93Tm9kZSkgeyByZXR1cm4gcm93Tm9kZS5kYXRhOyB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVSb3dEYXRhKHsgYWRkOiBudWxsLCBhZGRJbmRleDogbnVsbCwgdXBkYXRlOiBudWxsLCByZW1vdmU6IGRhdGFUb1JlbW92ZSB9KTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmFkZEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zLCBza2lwUmVmcmVzaCkge1xuICAgICAgICBpZiAoc2tpcFJlZnJlc2ggPT09IHZvaWQgMCkgeyBza2lwUmVmcmVzaCA9IGZhbHNlOyB9XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogYWRkSXRlbXMoKSBpcyBkZXByZWNhdGVkLCB1c2UgdXBkYXRlUm93RGF0YSh0cmFuc2FjdGlvbikgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy51cGRhdGVSb3dEYXRhKHsgYWRkOiBpdGVtcywgYWRkSW5kZXg6IG51bGwsIHVwZGF0ZTogbnVsbCwgcmVtb3ZlOiBudWxsIH0pO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUucmVmcmVzaFZpcnR1YWxQYWdlQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogcmVmcmVzaFZpcnR1YWxQYWdlQ2FjaGUoKSBpcyBub3cgY2FsbGVkIHJlZnJlc2hJbmZpbml0ZUNhY2hlKCksIHBsZWFzZSBjYWxsIHJlZnJlc2hJbmZpbml0ZUNhY2hlKCkgaW5zdGVhZCcpO1xuICAgICAgICB0aGlzLnJlZnJlc2hJbmZpbml0ZUNhY2hlKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5yZWZyZXNoSW5maW5pdGVQYWdlQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogcmVmcmVzaEluZmluaXRlUGFnZUNhY2hlKCkgaXMgbm93IGNhbGxlZCByZWZyZXNoSW5maW5pdGVDYWNoZSgpLCBwbGVhc2UgY2FsbCByZWZyZXNoSW5maW5pdGVDYWNoZSgpIGluc3RlYWQnKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoSW5maW5pdGVDYWNoZSgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUucmVmcmVzaEluZmluaXRlQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZmluaXRlUGFnZVJvd01vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLmluZmluaXRlUGFnZVJvd01vZGVsLnJlZnJlc2hDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYWctR3JpZDogYXBpLnJlZnJlc2hJbmZpbml0ZUNhY2hlIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gcm93TW9kZWxUeXBlPSdpbmZpbml0ZScuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5wdXJnZVZpcnR1YWxQYWdlQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogcHVyZ2VWaXJ0dWFsUGFnZUNhY2hlKCkgaXMgbm93IGNhbGxlZCBwdXJnZUluZmluaXRlQ2FjaGUoKSwgcGxlYXNlIGNhbGwgcHVyZ2VJbmZpbml0ZUNhY2hlKCkgaW5zdGVhZCcpO1xuICAgICAgICB0aGlzLnB1cmdlSW5maW5pdGVQYWdlQ2FjaGUoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnB1cmdlSW5maW5pdGVQYWdlQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogcHVyZ2VJbmZpbml0ZVBhZ2VDYWNoZSgpIGlzIG5vdyBjYWxsZWQgcHVyZ2VJbmZpbml0ZUNhY2hlKCksIHBsZWFzZSBjYWxsIHB1cmdlSW5maW5pdGVDYWNoZSgpIGluc3RlYWQnKTtcbiAgICAgICAgdGhpcy5wdXJnZUluZmluaXRlQ2FjaGUoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnB1cmdlSW5maW5pdGVDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5maW5pdGVQYWdlUm93TW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5maW5pdGVQYWdlUm93TW9kZWwucHVyZ2VDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYWctR3JpZDogYXBpLnB1cmdlSW5maW5pdGVDYWNoZSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHJvd01vZGVsVHlwZT0naW5maW5pdGUnLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUucHVyZ2VFbnRlcnByaXNlQ2FjaGUgPSBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZW50ZXJwcmlzZVJvd01vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLmVudGVycHJpc2VSb3dNb2RlbC5wdXJnZUNhY2hlKHJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLUdyaWQ6IGFwaS5wdXJnZUVudGVycHJpc2VDYWNoZSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHJvd01vZGVsVHlwZT0nZW50ZXJwcmlzZScuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRWaXJ0dWFsUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogZ2V0VmlydHVhbFJvd0NvdW50KCkgaXMgbm93IGNhbGxlZCBnZXRJbmZpbml0ZVJvd0NvdW50KCksIHBsZWFzZSBjYWxsIGdldEluZmluaXRlUm93Q291bnQoKSBpbnN0ZWFkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEluZmluaXRlUm93Q291bnQoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldEluZmluaXRlUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZmluaXRlUGFnZVJvd01vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZpbml0ZVBhZ2VSb3dNb2RlbC5nZXRWaXJ0dWFsUm93Q291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLUdyaWQ6IGFwaS5nZXRWaXJ0dWFsUm93Q291bnQgaXMgb25seSBhdmFpbGFibGUgd2hlbiByb3dNb2RlbFR5cGU9J3ZpcnR1YWwnLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuaXNNYXhSb3dGb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5maW5pdGVQYWdlUm93TW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZmluaXRlUGFnZVJvd01vZGVsLmlzTWF4Um93Rm91bmQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLUdyaWQ6IGFwaS5pc01heFJvd0ZvdW5kIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gcm93TW9kZWxUeXBlPSd2aXJ0dWFsJy5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnNldFZpcnR1YWxSb3dDb3VudCA9IGZ1bmN0aW9uIChyb3dDb3VudCwgbWF4Um93Rm91bmQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBzZXRWaXJ0dWFsUm93Q291bnQoKSBpcyBub3cgY2FsbGVkIHNldEluZmluaXRlUm93Q291bnQoKSwgcGxlYXNlIGNhbGwgc2V0SW5maW5pdGVSb3dDb3VudCgpIGluc3RlYWQnKTtcbiAgICAgICAgdGhpcy5zZXRJbmZpbml0ZVJvd0NvdW50KHJvd0NvdW50LCBtYXhSb3dGb3VuZCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5zZXRJbmZpbml0ZVJvd0NvdW50ID0gZnVuY3Rpb24gKHJvd0NvdW50LCBtYXhSb3dGb3VuZCkge1xuICAgICAgICBpZiAodGhpcy5pbmZpbml0ZVBhZ2VSb3dNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5pbmZpbml0ZVBhZ2VSb3dNb2RlbC5zZXRWaXJ0dWFsUm93Q291bnQocm93Q291bnQsIG1heFJvd0ZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLUdyaWQ6IGFwaS5zZXRWaXJ0dWFsUm93Q291bnQgaXMgb25seSBhdmFpbGFibGUgd2hlbiByb3dNb2RlbFR5cGU9J3ZpcnR1YWwnLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0VmlydHVhbFBhZ2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBnZXRWaXJ0dWFsUGFnZVN0YXRlKCkgaXMgbm93IGNhbGxlZCBnZXRDYWNoZUJsb2NrU3RhdGUoKSwgcGxlYXNlIGNhbGwgZ2V0Q2FjaGVCbG9ja1N0YXRlKCkgaW5zdGVhZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZUJsb2NrU3RhdGUoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldEluZmluaXRlUGFnZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGdldEluZmluaXRlUGFnZVN0YXRlKCkgaXMgbm93IGNhbGxlZCBnZXRDYWNoZUJsb2NrU3RhdGUoKSwgcGxlYXNlIGNhbGwgZ2V0Q2FjaGVCbG9ja1N0YXRlKCkgaW5zdGVhZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZUJsb2NrU3RhdGUoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldENhY2hlQmxvY2tTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5maW5pdGVQYWdlUm93TW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZmluaXRlUGFnZVJvd01vZGVsLmdldEJsb2NrU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmVudGVycHJpc2VSb3dNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50ZXJwcmlzZVJvd01vZGVsLmdldEJsb2NrU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLUdyaWQ6IGFwaS5nZXRDYWNoZUJsb2NrU3RhdGUoKSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHJvd01vZGVsVHlwZT0naW5maW5pdGUnIG9yIHJvd01vZGVsVHlwZT0nZW50ZXJwcmlzZScuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5jaGVja0dyaWRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdyaWRQYW5lbC5zZXRCb2R5QW5kSGVhZGVySGVpZ2h0cygpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0Rmlyc3RSZW5kZXJlZFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2luIGFnLUdyaWQgdjEyLCBnZXRGaXJzdFJlbmRlcmVkUm93KCkgd2FzIHJlbmFtZWQgdG8gZ2V0Rmlyc3REaXNwbGF5ZWRSb3coKScpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXJzdERpc3BsYXllZFJvdygpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUuZ2V0Rmlyc3REaXNwbGF5ZWRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1JlbmRlcmVyLmdldEZpcnN0VmlydHVhbFJlbmRlcmVkUm93KCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5nZXRMYXN0UmVuZGVyZWRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdpbiBhZy1HcmlkIHYxMiwgZ2V0TGFzdFJlbmRlcmVkUm93KCkgd2FzIHJlbmFtZWQgdG8gZ2V0TGFzdERpc3BsYXllZFJvdygpJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExhc3REaXNwbGF5ZWRSb3coKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldExhc3REaXNwbGF5ZWRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1JlbmRlcmVyLmdldExhc3RWaXJ0dWFsUmVuZGVyZWRSb3coKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldERpc3BsYXllZFJvd0F0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93TW9kZWwuZ2V0Um93KGluZGV4KTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLmdldERpc3BsYXllZFJvd0NvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dNb2RlbC5nZXRSb3dDb3VudCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUucGFnaW5hdGlvbklzTGFzdFBhZ2VGb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnaW5hdGlvblByb3h5LmlzTGFzdFBhZ2VGb3VuZCgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUucGFnaW5hdGlvbkdldFBhZ2VTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0UGFnZVNpemUoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnBhZ2luYXRpb25TZXRQYWdlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLnNldFByb3BlcnR5KCdwYWdpbmF0aW9uUGFnZVNpemUnLCBzaXplKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnBhZ2luYXRpb25HZXRDdXJyZW50UGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnaW5hdGlvblByb3h5LmdldEN1cnJlbnRQYWdlKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5wYWdpbmF0aW9uR2V0VG90YWxQYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnaW5hdGlvblByb3h5LmdldFRvdGFsUGFnZXMoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnBhZ2luYXRpb25HZXRSb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnaW5hdGlvblByb3h5LmdldFRvdGFsUm93Q291bnQoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnBhZ2luYXRpb25Hb1RvTmV4dFBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFnaW5hdGlvblByb3h5LmdvVG9OZXh0UGFnZSgpO1xuICAgIH07XG4gICAgR3JpZEFwaS5wcm90b3R5cGUucGFnaW5hdGlvbkdvVG9QcmV2aW91c1BhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFnaW5hdGlvblByb3h5LmdvVG9QcmV2aW91c1BhZ2UoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnBhZ2luYXRpb25Hb1RvRmlyc3RQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhZ2luYXRpb25Qcm94eS5nb1RvRmlyc3RQYWdlKCk7XG4gICAgfTtcbiAgICBHcmlkQXBpLnByb3RvdHlwZS5wYWdpbmF0aW9uR29Ub0xhc3RQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhZ2luYXRpb25Qcm94eS5nb1RvTGFzdFBhZ2UoKTtcbiAgICB9O1xuICAgIEdyaWRBcGkucHJvdG90eXBlLnBhZ2luYXRpb25Hb1RvUGFnZSA9IGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgIHRoaXMucGFnaW5hdGlvblByb3h5LmdvVG9QYWdlKHBhZ2UpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ltbXV0YWJsZVNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGltbXV0YWJsZVNlcnZpY2VfMS5JbW11dGFibGVTZXJ2aWNlKVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcImltbXV0YWJsZVNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY3N2Q3JlYXRvcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY3N2Q3JlYXRvcl8xLkNzdkNyZWF0b3IpXG4gICAgXSwgR3JpZEFwaS5wcm90b3R5cGUsIFwiY3N2Q3JlYXRvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuT3B0aW9uYWwoJ2V4Y2VsQ3JlYXRvcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcImV4Y2VsQ3JlYXRvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQ29yZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZENvcmVfMS5HcmlkQ29yZSlcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJncmlkQ29yZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdyb3dSZW5kZXJlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgcm93UmVuZGVyZXJfMS5Sb3dSZW5kZXJlcilcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJyb3dSZW5kZXJlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdoZWFkZXJSZW5kZXJlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgaGVhZGVyUmVuZGVyZXJfMS5IZWFkZXJSZW5kZXJlcilcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJoZWFkZXJSZW5kZXJlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdmaWx0ZXJNYW5hZ2VyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBmaWx0ZXJNYW5hZ2VyXzEuRmlsdGVyTWFuYWdlcilcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJmaWx0ZXJNYW5hZ2VyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnc2VsZWN0aW9uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgc2VsZWN0aW9uQ29udHJvbGxlcl8xLlNlbGVjdGlvbkNvbnRyb2xsZXIpXG4gICAgXSwgR3JpZEFwaS5wcm90b3R5cGUsIFwic2VsZWN0aW9uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZFBhbmVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkUGFuZWxfMS5HcmlkUGFuZWwpXG4gICAgXSwgR3JpZEFwaS5wcm90b3R5cGUsIFwiZ3JpZFBhbmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3ZhbHVlU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdmFsdWVTZXJ2aWNlXzEuVmFsdWVTZXJ2aWNlKVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcInZhbHVlU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdhbGlnbmVkR3JpZHNTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBhbGlnbmVkR3JpZHNTZXJ2aWNlXzEuQWxpZ25lZEdyaWRzU2VydmljZSlcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJhbGlnbmVkR3JpZHNTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdwaW5uZWRSb3dNb2RlbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgcGlubmVkUm93TW9kZWxfMS5QaW5uZWRSb3dNb2RlbClcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJwaW5uZWRSb3dNb2RlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3Jvd01vZGVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR3JpZEFwaS5wcm90b3R5cGUsIFwicm93TW9kZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnc29ydENvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNvcnRDb250cm9sbGVyXzEuU29ydENvbnRyb2xsZXIpXG4gICAgXSwgR3JpZEFwaS5wcm90b3R5cGUsIFwic29ydENvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncGFnaW5hdGlvblByb3h5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBwYWdpbmF0aW9uUHJveHlfMS5QYWdpbmF0aW9uUHJveHkpXG4gICAgXSwgR3JpZEFwaS5wcm90b3R5cGUsIFwicGFnaW5hdGlvblByb3h5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZvY3VzZWRDZWxsQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZm9jdXNlZENlbGxDb250cm9sbGVyXzEuRm9jdXNlZENlbGxDb250cm9sbGVyKVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcImZvY3VzZWRDZWxsQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuT3B0aW9uYWwoJ3JhbmdlQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcInJhbmdlQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuT3B0aW9uYWwoJ2NsaXBib2FyZFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJjbGlwYm9hcmRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5PcHRpb25hbCgnYWdnRnVuY1NlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJhZ2dGdW5jU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdtZW51RmFjdG9yeScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcIm1lbnVGYWN0b3J5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NlbGxSZW5kZXJlckZhY3RvcnknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNlbGxSZW5kZXJlckZhY3RvcnlfMS5DZWxsUmVuZGVyZXJGYWN0b3J5KVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcImNlbGxSZW5kZXJlckZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY2VsbEVkaXRvckZhY3RvcnknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNlbGxFZGl0b3JGYWN0b3J5XzEuQ2VsbEVkaXRvckZhY3RvcnkpXG4gICAgXSwgR3JpZEFwaS5wcm90b3R5cGUsIFwiY2VsbEVkaXRvckZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgndmFsdWVDYWNoZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdmFsdWVDYWNoZV8xLlZhbHVlQ2FjaGUpXG4gICAgXSwgR3JpZEFwaS5wcm90b3R5cGUsIFwidmFsdWVDYWNoZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuT3B0aW9uYWwoJ3Rvb2xQYW5lbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRBcGkucHJvdG90eXBlLCBcInRvb2xQYW5lbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBHcmlkQXBpLnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIEdyaWRBcGkgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2dyaWRBcGknKVxuICAgIF0sIEdyaWRBcGkpO1xuICAgIHJldHVybiBHcmlkQXBpO1xufSgpKTtcbmV4cG9ydHMuR3JpZEFwaSA9IEdyaWRBcGk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9ncmlkQXBpLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb25zdGFudHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnN0YW50cygpIHtcbiAgICB9XG4gICAgQ29uc3RhbnRzLlNURVBfRVZFUllUSElORyA9IDA7XG4gICAgQ29uc3RhbnRzLlNURVBfRklMVEVSID0gMTtcbiAgICBDb25zdGFudHMuU1RFUF9TT1JUID0gMjtcbiAgICBDb25zdGFudHMuU1RFUF9NQVAgPSAzO1xuICAgIENvbnN0YW50cy5TVEVQX0FHR1JFR0FURSA9IDQ7XG4gICAgQ29uc3RhbnRzLlNURVBfUElWT1QgPSA1O1xuICAgIENvbnN0YW50cy5ST1dfQlVGRkVSX1NJWkUgPSAxMDtcbiAgICBDb25zdGFudHMuTEFZT1VUX0lOVEVSVkFMID0gNTAwO1xuICAgIENvbnN0YW50cy5FWFBPUlRfVFlQRV9EUkFHX0NPUFkgPSAnZHJhZ0NvcHknO1xuICAgIENvbnN0YW50cy5FWFBPUlRfVFlQRV9DTElQQk9BUkQgPSAnY2xpcGJvYXJkJztcbiAgICBDb25zdGFudHMuRVhQT1JUX1RZUEVfRVhDRUwgPSAnZXhjZWwnO1xuICAgIENvbnN0YW50cy5FWFBPUlRfVFlQRV9DU1YgPSAnY3N2JztcbiAgICBDb25zdGFudHMuS0VZX0JBQ0tTUEFDRSA9IDg7XG4gICAgQ29uc3RhbnRzLktFWV9UQUIgPSA5O1xuICAgIENvbnN0YW50cy5LRVlfRU5URVIgPSAxMztcbiAgICBDb25zdGFudHMuS0VZX1NISUZUID0gMTY7XG4gICAgQ29uc3RhbnRzLktFWV9FU0NBUEUgPSAyNztcbiAgICBDb25zdGFudHMuS0VZX1NQQUNFID0gMzI7XG4gICAgQ29uc3RhbnRzLktFWV9MRUZUID0gMzc7XG4gICAgQ29uc3RhbnRzLktFWV9VUCA9IDM4O1xuICAgIENvbnN0YW50cy5LRVlfUklHSFQgPSAzOTtcbiAgICBDb25zdGFudHMuS0VZX0RPV04gPSA0MDtcbiAgICBDb25zdGFudHMuS0VZX0RFTEVURSA9IDQ2O1xuICAgIENvbnN0YW50cy5LRVlfQSA9IDY1O1xuICAgIENvbnN0YW50cy5LRVlfQyA9IDY3O1xuICAgIENvbnN0YW50cy5LRVlfViA9IDg2O1xuICAgIENvbnN0YW50cy5LRVlfRCA9IDY4O1xuICAgIENvbnN0YW50cy5LRVlfRjIgPSAxMTM7XG4gICAgQ29uc3RhbnRzLktFWV9QQUdFX1VQID0gMzM7XG4gICAgQ29uc3RhbnRzLktFWV9QQUdFX0RPV04gPSAzNDtcbiAgICBDb25zdGFudHMuS0VZX1BBR0VfSE9NRSA9IDM2O1xuICAgIENvbnN0YW50cy5LRVlfUEFHRV9FTkQgPSAzNTtcbiAgICBDb25zdGFudHMuUk9XX01PREVMX1RZUEVfSU5GSU5JVEUgPSAnaW5maW5pdGUnO1xuICAgIENvbnN0YW50cy5ST1dfTU9ERUxfVFlQRV9WSUVXUE9SVCA9ICd2aWV3cG9ydCc7XG4gICAgQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0lOX01FTU9SWSA9ICdpbk1lbW9yeSc7XG4gICAgQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0VOVEVSUFJJU0UgPSAnZW50ZXJwcmlzZSc7XG4gICAgQ29uc3RhbnRzLkRFUFJFQ0FURURfUk9XX01PREVMX1RZUEVfTk9STUFMID0gJ25vcm1hbCc7XG4gICAgQ29uc3RhbnRzLkFMV0FZUyA9ICdhbHdheXMnO1xuICAgIENvbnN0YW50cy5PTkxZX1dIRU5fR1JPVVBJTkcgPSAnb25seVdoZW5Hcm91cGluZyc7XG4gICAgQ29uc3RhbnRzLlBJTk5FRF9UT1AgPSAndG9wJztcbiAgICBDb25zdGFudHMuUElOTkVEX0JPVFRPTSA9ICdib3R0b20nO1xuICAgIHJldHVybiBDb25zdGFudHM7XG59KCkpO1xuZXhwb3J0cy5Db25zdGFudHMgPSBDb25zdGFudHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBiZWFuU3R1Yl8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvYmVhblN0dWJcIik7XG52YXIgY29tcElkU2VxdWVuY2UgPSBuZXcgdXRpbHNfMS5OdW1iZXJTZXF1ZW5jZSgpO1xudmFyIENvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21wb25lbnQodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2hpbGRDb21wb25lbnRzID0gW107XG4gICAgICAgIF90aGlzLmFubm90YXRlZEV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgICAgIF90aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAvLyB1bmlxdWUgaWQgZm9yIHRoaXMgcm93IGNvbXBvbmVudC4gdGhpcyBpcyB1c2VkIGZvciBnZXR0aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBIVE1MIGRvbS5cbiAgICAgICAgLy8gd2UgY2Fubm90IHVzZSB0aGUgUm93Tm9kZSBpZCBhcyB0aGlzIGlzIG5vdCB1bmlxdWUgKGR1ZSB0byBhbmltYXRpb24sIG9sZCByb3dzIGNhbiBiZSBseWluZ1xuICAgICAgICAvLyBhcm91bmQgYXMgd2UgY3JlYXRlIGEgbmV3IHJvd0NvbXAgaW5zdGFuY2UgZm9yIHRoZSBzYW1lIHJvdyBub2RlKS5cbiAgICAgICAgX3RoaXMuY29tcElkID0gY29tcElkU2VxdWVuY2UubmV4dCgpO1xuICAgICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q29tcElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wSWQ7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmluc3RhbnRpYXRlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0ZVJlY3Vyc2UodGhpcy5nZXRHdWkoKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmluc3RhbnRpYXRlUmVjdXJzZSA9IGZ1bmN0aW9uIChwYXJlbnROb2RlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjaGlsZENvdW50ID0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzID8gcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA6IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgdmFyIG5ld0NvbXBvbmVudCA9IGNvbnRleHQuY3JlYXRlQ29tcG9uZW50KGNoaWxkTm9kZSk7XG4gICAgICAgICAgICBpZiAobmV3Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2FwQ29tcG9uZW50Rm9yTm9kZShuZXdDb21wb25lbnQsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW50aWF0ZVJlY3Vyc2UoY2hpbGROb2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc3dhcENvbXBvbmVudEZvck5vZGUgPSBmdW5jdGlvbiAobmV3Q29tcG9uZW50LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q29tcG9uZW50LmdldEd1aSgpLCBjaGlsZE5vZGUpO1xuICAgICAgICB0aGlzLmNoaWxkQ29tcG9uZW50cy5wdXNoKG5ld0NvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuc3dhcEluQ29tcG9uZW50Rm9yUXVlcnlTZWxlY3RvcnMobmV3Q29tcG9uZW50LCBjaGlsZE5vZGUpO1xuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5zd2FwSW5Db21wb25lbnRGb3JRdWVyeVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChuZXdDb21wb25lbnQsIGNoaWxkTm9kZSkge1xuICAgICAgICB2YXIgdGhpc1Byb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgICB2YXIgdGhpc05vVHlwZSA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh0aGlzUHJvdG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1ldGFEYXRhID0gdGhpc1Byb3RvLl9fYWdDb21wb25lbnRNZXRhRGF0YTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvdG9OYW1lID0gKHRoaXNQcm90by5jb25zdHJ1Y3RvcikubmFtZTtcbiAgICAgICAgICAgIGlmIChtZXRhRGF0YSAmJiBtZXRhRGF0YVtjdXJyZW50UHJvdG9OYW1lXSAmJiBtZXRhRGF0YVtjdXJyZW50UHJvdG9OYW1lXS5xdWVyeVNlbGVjdG9ycykge1xuICAgICAgICAgICAgICAgIG1ldGFEYXRhW2N1cnJlbnRQcm90b05hbWVdLnF1ZXJ5U2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNOb1R5cGVbcXVlcnlTZWxlY3Rvci5hdHRyaWJ1dGVOYW1lXSA9PT0gY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzTm9UeXBlW3F1ZXJ5U2VsZWN0b3IuYXR0cmlidXRlTmFtZV0gPSBuZXdDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzUHJvdG8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBlR3VpID0gdXRpbHNfMS5VdGlscy5sb2FkVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICB0aGlzLnNldFRlbXBsYXRlRnJvbUVsZW1lbnQoZUd1aSk7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFRlbXBsYXRlRnJvbUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVHdWkgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmVHdWkuX19hZ0NvbXBvbmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRkQW5ub3RhdGVkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy53aXJlUXVlcnlTZWxlY3RvcnMoKTtcbiAgICB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuYXR0cmlidXRlc1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUud2lyZVF1ZXJ5U2VsZWN0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuZUd1aSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1ldGFEYXRhID0gdGhpc1Byb3RvLl9fYWdDb21wb25lbnRNZXRhRGF0YTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvdG9OYW1lID0gKHRoaXNQcm90by5jb25zdHJ1Y3RvcikubmFtZTtcbiAgICAgICAgICAgIGlmIChtZXRhRGF0YSAmJiBtZXRhRGF0YVtjdXJyZW50UHJvdG9OYW1lXSAmJiBtZXRhRGF0YVtjdXJyZW50UHJvdG9OYW1lXS5xdWVyeVNlbGVjdG9ycykge1xuICAgICAgICAgICAgICAgIHZhciB0aGlzTm9UeXBlXzEgPSB0aGlzXzE7XG4gICAgICAgICAgICAgICAgbWV0YURhdGFbY3VycmVudFByb3RvTmFtZV0ucXVlcnlTZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0T2ZRdWVyeSA9IF90aGlzLmVHdWkucXVlcnlTZWxlY3RvcihxdWVyeVNlbGVjdG9yLnF1ZXJ5U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0T2ZRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhY2tpbmdDb21wb25lbnQgPSByZXN1bHRPZlF1ZXJ5Ll9fYWdDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFja2luZ0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNOb1R5cGVfMVtxdWVyeVNlbGVjdG9yLmF0dHJpYnV0ZU5hbWVdID0gYmFja2luZ0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNOb1R5cGVfMVtxdWVyeVNlbGVjdG9yLmF0dHJpYnV0ZU5hbWVdID0gcmVzdWx0T2ZRdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1dCBkZWJ1ZyBtc2cgaW4gaGVyZSBpZiBxdWVyeSBzZWxlY3RvciBmYWlscz8/P1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpc1Byb3RvKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh0aGlzUHJvdG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmFkZEFubm90YXRlZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlbW92ZUFubm90YXRlZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIGlmICghdGhpcy5lR3VpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgd2hpbGUgKHRoaXNQcm90byAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbWV0YURhdGEgPSB0aGlzUHJvdG8uX19hZ0NvbXBvbmVudE1ldGFEYXRhO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm90b05hbWUgPSAodGhpc1Byb3RvLmNvbnN0cnVjdG9yKS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1ldGFEYXRhICYmIG1ldGFEYXRhW2N1cnJlbnRQcm90b05hbWVdICYmIG1ldGFEYXRhW2N1cnJlbnRQcm90b05hbWVdLmxpc3RlbmVyTWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbm5vdGF0ZWRFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRlZEV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldGFEYXRhW2N1cnJlbnRQcm90b05hbWVdLmxpc3RlbmVyTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF90aGlzW2V2ZW50TGlzdGVuZXIubWV0aG9kTmFtZV0uYmluZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVHdWkuYWRkRXZlbnRMaXN0ZW5lcihldmVudExpc3RlbmVyLmV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbm5vdGF0ZWRFdmVudExpc3RlbmVycy5wdXNoKHsgZXZlbnROYW1lOiBldmVudExpc3RlbmVyLmV2ZW50TmFtZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1Byb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXNQcm90byk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQW5ub3RhdGVkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5hbm5vdGF0ZWRFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5lR3VpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbm5vdGF0ZWRFdmVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5lR3VpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRMaXN0ZW5lci5ldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIubGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hbm5vdGF0ZWRFdmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmdldEd1aSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZUd1aTtcbiAgICB9O1xuICAgIC8vIHRoaXMgbWV0aG9kIGlzIGZvciBvbGRlciBjb2RlLCB0aGF0IHdhbnRzIHRvIHByb3ZpZGUgdGhlIGd1aSBlbGVtZW50LFxuICAgIC8vIGl0IGlzIG5vdCBpbnRlbmRlZCBmb3IgdGhpcyB0byBiZSBpbiBhZy1TdGFja1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0R3VpID0gZnVuY3Rpb24gKGVHdWkpIHtcbiAgICAgICAgdGhpcy5lR3VpID0gZUd1aTtcbiAgICB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUucXVlcnlGb3JIdG1sRWxlbWVudCA9IGZ1bmN0aW9uIChjc3NTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lR3VpLnF1ZXJ5U2VsZWN0b3IoY3NzU2VsZWN0b3IpO1xuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5xdWVyeUZvckh0bWxJbnB1dEVsZW1lbnQgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZUd1aS5xdWVyeVNlbGVjdG9yKGNzc1NlbGVjdG9yKTtcbiAgICB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAobmV3Q2hpbGQpIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuaXNOb2RlT3JFbGVtZW50KG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgdGhpcy5lR3VpLmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGlsZENvbXBvbmVudCA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgdGhpcy5lR3VpLmFwcGVuZENoaWxkKGNoaWxkQ29tcG9uZW50LmdldEd1aSgpKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRDb21wb25lbnRzLnB1c2goY2hpbGRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbiAoY29udGV4dCwgZmVhdHVyZSkge1xuICAgICAgICBjb250ZXh0LndpcmVCZWFuKGZlYXR1cmUpO1xuICAgICAgICBpZiAoZmVhdHVyZS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLmFkZERlc3Ryb3lGdW5jKGZlYXR1cmUuZGVzdHJveS5iaW5kKGZlYXR1cmUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGU7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAodmlzaWJsZSkge1xuICAgICAgICBpZiAodmlzaWJsZSAhPT0gdGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZUd1aSwgJ2FnLWhpZGRlbicsICF2aXNpYmxlKTtcbiAgICAgICAgICAgIHZhciBldmVudF8xID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudC5FVkVOVF9WSVNJQkxFX0NIQU5HRUQsXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmFkZE9yUmVtb3ZlQ3NzQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBhZGRPclJlbW92ZSkge1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5lR3VpLCBjbGFzc05hbWUsIGFkZE9yUmVtb3ZlKTtcbiAgICB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2hpbGRDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkQ29tcG9uZW50KSB7IHJldHVybiBjaGlsZENvbXBvbmVudC5kZXN0cm95KCk7IH0pO1xuICAgICAgICB0aGlzLmNoaWxkQ29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnJlbW92ZUFubm90YXRlZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmFkZEd1aUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZ2V0R3VpKCkuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lGdW5jKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdldEd1aSgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTsgfSk7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmFkZENzc0NsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFkZENzc0NsYXNzKHRoaXMuZ2V0R3VpKCksIGNsYXNzTmFtZSk7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNzc0NsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUNzc0NsYXNzKHRoaXMuZ2V0R3VpKCksIGNsYXNzTmFtZSk7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGVHdWkgPSB0aGlzLmdldEd1aSgpO1xuICAgICAgICBpZiAoZUd1aSkge1xuICAgICAgICAgICAgcmV0dXJuIGVHdWkuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRSZWZFbGVtZW50ID0gZnVuY3Rpb24gKHJlZk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlGb3JIdG1sRWxlbWVudCgnW3JlZj1cIicgKyByZWZOYW1lICsgJ1wiXScpO1xuICAgIH07XG4gICAgQ29tcG9uZW50LkVWRU5UX1ZJU0lCTEVfQ0hBTkdFRCA9ICd2aXNpYmxlQ2hhbmdlZCc7XG4gICAgcmV0dXJuIENvbXBvbmVudDtcbn0oYmVhblN0dWJfMS5CZWFuU3R1YikpO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi93aWRnZXRzL2NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2V2ZW50U2VydmljZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGNvbHVtblV0aWxzXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5VdGlsc1wiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi9ncmlkQXBpXCIpO1xuLy8gV3JhcHBlciBhcm91bmQgYSB1c2VyIHByb3ZpZGUgY29sdW1uIGRlZmluaXRpb24uIFRoZSBncmlkIHRyZWF0cyB0aGUgY29sdW1uIGRlZmluaXRpb24gYXMgcmVhZHkgb25seS5cbi8vIFRoaXMgY2xhc3MgY29udGFpbnMgYWxsIHRoZSBydW50aW1lIGluZm9ybWF0aW9uIGFib3V0IGEgY29sdW1uLCBwbHVzIHNvbWUgbG9naWMgKHRoZSBkZWZpbml0aW9uIGhhcyBubyBsb2dpYykuXG4vLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgYm90aCBpbnRlcmZhY2VzIENvbHVtbkdyb3VwQ2hpbGQgYW5kIE9yaWdpbmFsQ29sdW1uR3JvdXBDaGlsZCBhcyB0aGUgY2xhc3MgY2FuXG4vLyBhcHBlYXIgYXMgYSBjaGlsZCBvZiBlaXRoZXIgdGhlIG9yaWdpbmFsIHRyZWUgb3IgdGhlIGRpc3BsYXllZCB0cmVlLiBIb3dldmVyIHRoZSByZWxldmFudCBncm91cCBjbGFzc2VzXG4vLyBmb3IgZWFjaCB0eXBlIG9ubHkgaW1wbGVtZW50cyBvbmUsIGFzIGVhY2ggZ3JvdXAgY2FuIG9ubHkgYXBwZWFyIGluIGl0J3MgYXNzb2NpYXRlZCB0cmVlIChlZyBPcmlnaW5hbENvbHVtbkdyb3VwXG4vLyBjYW4gb25seSBhcHBlYXIgaW4gT3JpZ2luYWxDb2x1bW4gdHJlZSkuXG52YXIgQ29sdW1uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2x1bW4oY29sRGVmLCBjb2xJZCwgcHJpbWFyeSkge1xuICAgICAgICB0aGlzLm1vdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1lbnVWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmlsdGVyQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlID0gbmV3IGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSgpO1xuICAgICAgICB0aGlzLnJvd0dyb3VwQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGl2b3RBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGlvbkFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbERlZiA9IGNvbERlZjtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gIWNvbERlZi5oaWRlO1xuICAgICAgICB0aGlzLnNvcnQgPSBjb2xEZWYuc29ydDtcbiAgICAgICAgdGhpcy5zb3J0ZWRBdCA9IGNvbERlZi5zb3J0ZWRBdDtcbiAgICAgICAgdGhpcy5jb2xJZCA9IGNvbElkO1xuICAgICAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5O1xuICAgIH1cbiAgICBDb2x1bW4ucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH07XG4gICAgLy8gdGhpcyBpcyBkb25lIGFmdGVyIGNvbnN0cnVjdG9yIGFzIGl0IHVzZXMgZ3JpZE9wdGlvbnNXcmFwcGVyXG4gICAgQ29sdW1uLnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFBpbm5lZCh0aGlzLmNvbERlZi5waW5uZWQpO1xuICAgICAgICB2YXIgbWluQ29sV2lkdGggPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRNaW5Db2xXaWR0aCgpO1xuICAgICAgICB2YXIgbWF4Q29sV2lkdGggPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRNYXhDb2xXaWR0aCgpO1xuICAgICAgICBpZiAodGhpcy5jb2xEZWYubWluV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSB0aGlzLmNvbERlZi5taW5XaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSBtaW5Db2xXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2xEZWYubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMubWF4V2lkdGggPSB0aGlzLmNvbERlZi5tYXhXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWF4V2lkdGggPSBtYXhDb2xXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdHVhbFdpZHRoID0gdGhpcy5jb2x1bW5VdGlscy5jYWxjdWxhdGVDb2xJbml0aWFsV2lkdGgodGhpcy5jb2xEZWYpO1xuICAgICAgICB2YXIgc3VwcHJlc3NEb3ROb3RhdGlvbiA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NGaWVsZERvdE5vdGF0aW9uKCk7XG4gICAgICAgIHRoaXMuZmllbGRDb250YWluc0RvdHMgPSB1dGlsc18xLlV0aWxzLmV4aXN0cyh0aGlzLmNvbERlZi5maWVsZCkgJiYgdGhpcy5jb2xEZWYuZmllbGQuaW5kZXhPZignLicpID49IDAgJiYgIXN1cHByZXNzRG90Tm90YXRpb247XG4gICAgICAgIHRoaXMudG9vbHRpcEZpZWxkQ29udGFpbnNEb3RzID0gdXRpbHNfMS5VdGlscy5leGlzdHModGhpcy5jb2xEZWYudG9vbHRpcEZpZWxkKSAmJiB0aGlzLmNvbERlZi50b29sdGlwRmllbGQuaW5kZXhPZignLicpID49IDAgJiYgIXN1cHByZXNzRG90Tm90YXRpb247XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNFbXB0eUdyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmlzUm93R3JvdXBEaXNwbGF5ZWQgPSBmdW5jdGlvbiAoY29sSWQpIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyh0aGlzLmNvbERlZikgfHwgdXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMuY29sRGVmLnNob3dSb3dHcm91cCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvd2luZ0FsbEdyb3VwcyA9IHRoaXMuY29sRGVmLnNob3dSb3dHcm91cCA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIHNob3dpbmdUaGlzR3JvdXAgPSB0aGlzLmNvbERlZi5zaG93Um93R3JvdXAgPT09IGNvbElkO1xuICAgICAgICByZXR1cm4gc2hvd2luZ0FsbEdyb3VwcyB8fCBzaG93aW5nVGhpc0dyb3VwO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5nZXRVbmlxdWVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWQoKTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNQcmltYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5O1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5pc0ZpbHRlckFsbG93ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaW1hcnkgJiYgIXRoaXMuY29sRGVmLnN1cHByZXNzRmlsdGVyO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5pc0ZpZWxkQ29udGFpbnNEb3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZENvbnRhaW5zRG90cztcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNUb29sdGlwRmllbGRDb250YWluc0RvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvb2x0aXBGaWVsZENvbnRhaW5zRG90cztcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2xEZWZBbnkgPSB0aGlzLmNvbERlZjtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VudGVycHJpc2UoKSkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zTm90QWxsb3dlZFdpdGhvdXRFbnRlcnByaXNlID0gWydlbmFibGVSb3dHcm91cCcsICdyb3dHcm91cCcsICdyb3dHcm91cEluZGV4JywgJ2VuYWJsZVBpdm90JywgJ3Bpdm90JywgJ3Bpdm90SW5kZXgnLCAnYWdnRnVuYyddO1xuICAgICAgICAgICAgaXRlbXNOb3RBbGxvd2VkV2l0aG91dEVudGVycHJpc2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhjb2xEZWZBbnlbaXRlbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLUdyaWQ6IFwiICsgaXRlbSArIFwiIGlzIG9ubHkgdmFsaWQgaW4gYWctR3JpZC1FbnRlcnByaXNlLCB5b3VyIGNvbHVtbiBkZWZpbml0aW9uIHNob3VsZCBub3QgaGF2ZSBcIiArIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1RyZWVEYXRhKCkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtc05vdEFsbG93ZWRXaXRoVHJlZURhdGEgPSBbJ2VuYWJsZVJvd0dyb3VwJywgJ3Jvd0dyb3VwJywgJ3Jvd0dyb3VwSW5kZXgnLCAnZW5hYmxlUGl2b3QnLCAncGl2b3QnLCAncGl2b3RJbmRleCddO1xuICAgICAgICAgICAgaXRlbXNOb3RBbGxvd2VkV2l0aFRyZWVEYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMoY29sRGVmQW55W2l0ZW1dKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1HcmlkOiBcIiArIGl0ZW0gKyBcIiBpcyBub3QgcG9zc2libGUgd2hlbiBkb2luZyB0cmVlIGRhdGEsIHlvdXIgY29sdW1uIGRlZmluaXRpb24gc2hvdWxkIG5vdCBoYXZlIFwiICsgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMuY29sRGVmLndpZHRoKSAmJiB0eXBlb2YgdGhpcy5jb2xEZWYud2lkdGggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGNvbERlZi53aWR0aCBzaG91bGQgYmUgYSBudW1iZXIsIG5vdCAnICsgdHlwZW9mIHRoaXMuY29sRGVmLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5nZXQodGhpcywgJ2NvbERlZi5jZWxsUmVuZGVyZXJQYXJhbXMucmVzdHJpY3RUb09uZUdyb3VwJywgbnVsbCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogU2luY2UgYWctZ3JpZCAxMS4wLjAgY2VsbFJlbmRlcmVyUGFyYW1zLnJlc3RyaWN0VG9PbmVHcm91cCBpcyBkZXByZWNhdGVkLiBZb3Ugc2hvdWxkIHVzZSBzaG93Um93R3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5nZXQodGhpcywgJ2NvbERlZi5jZWxsUmVuZGVyZXJQYXJhbXMua2V5TWFwJywgbnVsbCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogU2luY2UgYWctZ3JpZCAxMS4wLjAgY2VsbFJlbmRlcmVyUGFyYW1zLmtleU1hcCBpcyBkZXByZWNhdGVkLiBZb3Ugc2hvdWxkIHVzZSBjb2xEZWYua2V5Q3JlYXRvcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmdldCh0aGlzLCAnY29sRGVmLmNlbGxSZW5kZXJlclBhcmFtcy5rZXlNYXAnLCBudWxsKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBTaW5jZSBhZy1ncmlkIDExLjAuMCBjZWxsUmVuZGVyZXJQYXJhbXMua2V5TWFwIGlzIGRlcHJlY2F0ZWQuIFlvdSBzaG91bGQgdXNlIGNvbERlZi5rZXlDcmVhdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbERlZkFueS5mbG9hdGluZ0NlbGxSZW5kZXJlcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBzaW5jZSB2MTEsIGZsb2F0aW5nQ2VsbFJlbmRlcmVyIGlzIG5vdyBwaW5uZWRSb3dDZWxsUmVuZGVyZXInKTtcbiAgICAgICAgICAgIHRoaXMuY29sRGVmLnBpbm5lZFJvd0NlbGxSZW5kZXJlciA9IGNvbERlZkFueS5mbG9hdGluZ0NlbGxSZW5kZXJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sRGVmQW55LmZsb2F0aW5nUmVuZGVyZXJGcmFtZXdvcmspIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogc2luY2UgdjExLCBmbG9hdGluZ1JlbmRlcmVyRnJhbWV3b3JrIGlzIG5vdyBwaW5uZWRSb3dDZWxsUmVuZGVyZXJGcmFtZXdvcmsnKTtcbiAgICAgICAgICAgIHRoaXMuY29sRGVmLnBpbm5lZFJvd0NlbGxSZW5kZXJlckZyYW1ld29yayA9IGNvbERlZkFueS5mbG9hdGluZ1JlbmRlcmVyRnJhbWV3b3JrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xEZWZBbnkuZmxvYXRpbmdSZW5kZXJlclBhcmFtcykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBzaW5jZSB2MTEsIGZsb2F0aW5nUmVuZGVyZXJQYXJhbXMgaXMgbm93IHBpbm5lZFJvd0NlbGxSZW5kZXJlclBhcmFtcycpO1xuICAgICAgICAgICAgdGhpcy5jb2xEZWYucGlubmVkUm93Q2VsbFJlbmRlcmVyUGFyYW1zID0gY29sRGVmQW55LmZsb2F0aW5nUmVuZGVyZXJQYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbERlZkFueS5mbG9hdGluZ1ZhbHVlRm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IHNpbmNlIHYxMSwgZmxvYXRpbmdWYWx1ZUZvcm1hdHRlciBpcyBub3cgcGlubmVkUm93VmFsdWVGb3JtYXR0ZXInKTtcbiAgICAgICAgICAgIHRoaXMuY29sRGVmLnBpbm5lZFJvd1ZhbHVlRm9ybWF0dGVyID0gY29sRGVmQW55LmZsb2F0aW5nVmFsdWVGb3JtYXR0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbERlZkFueS5jZWxsRm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IHNpbmNlIHYxMiwgY2VsbEZvcm1hdHRlciBpcyBub3cgdmFsdWVGb3JtYXR0ZXInKTtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5jb2xEZWYudmFsdWVGb3JtYXR0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xEZWYudmFsdWVGb3JtYXR0ZXIgPSBjb2xEZWZBbnkuY2VsbEZvcm1hdHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmNyZWF0ZUlzQ29sdW1uRnVuY1BhcmFtcyA9IGZ1bmN0aW9uIChyb3dOb2RlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiByb3dOb2RlLFxuICAgICAgICAgICAgY29sdW1uOiB0aGlzLFxuICAgICAgICAgICAgY29sRGVmOiB0aGlzLmNvbERlZixcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbHVtbkFwaSgpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmlzU3VwcHJlc3NOYXZpZ2FibGUgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICAvLyBpZiBib29sZWFuIHNldCwgdGhlbiBqdXN0IHVzZSBpdFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29sRGVmLnN1cHByZXNzTmF2aWdhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbERlZi5zdXBwcmVzc05hdmlnYWJsZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSBmdW5jdGlvbiB0byBmaW5kIG91dFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29sRGVmLnN1cHByZXNzTmF2aWdhYmxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5jcmVhdGVJc0NvbHVtbkZ1bmNQYXJhbXMocm93Tm9kZSk7XG4gICAgICAgICAgICB2YXIgdXNlckZ1bmMgPSB0aGlzLmNvbERlZi5zdXBwcmVzc05hdmlnYWJsZTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyRnVuYyhwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNDZWxsRWRpdGFibGUgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICAvLyBvbmx5IGFsbG93IGVkaXRpbmcgb2YgZ3JvdXBzIGlmIHRoZSB1c2VyIGhhcyB0aGlzIG9wdGlvbiBlbmFibGVkXG4gICAgICAgIGlmIChyb3dOb2RlLmdyb3VwICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZUdyb3VwRWRpdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDb2x1bW5GdW5jKHJvd05vZGUsIHRoaXMuY29sRGVmLmVkaXRhYmxlKTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNTdXBwcmVzc1Bhc3RlID0gZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDb2x1bW5GdW5jKHJvd05vZGUsIHRoaXMuY29sRGVmID8gdGhpcy5jb2xEZWYuc3VwcHJlc3NQYXN0ZSA6IG51bGwpO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5pc1Jlc2l6YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVuYWJsZUNvbFJlc2l6ZSA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlQ29sUmVzaXplKCk7XG4gICAgICAgIHZhciBzdXBwcmVzc1Jlc2l6ZSA9IHRoaXMuY29sRGVmICYmIHRoaXMuY29sRGVmLnN1cHByZXNzUmVzaXplO1xuICAgICAgICByZXR1cm4gZW5hYmxlQ29sUmVzaXplICYmICFzdXBwcmVzc1Jlc2l6ZTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNDb2x1bW5GdW5jID0gZnVuY3Rpb24gKHJvd05vZGUsIHZhbHVlKSB7XG4gICAgICAgIC8vIGlmIGJvb2xlYW4gc2V0LCB0aGVuIGp1c3QgdXNlIGl0XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIGZ1bmN0aW9uIHRvIGZpbmQgb3V0XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmNyZWF0ZUlzQ29sdW1uRnVuY1BhcmFtcyhyb3dOb2RlKTtcbiAgICAgICAgICAgIHZhciBlZGl0YWJsZUZ1bmMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBlZGl0YWJsZUZ1bmMocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLnNldE1vdmluZyA9IGZ1bmN0aW9uIChtb3ZpbmcpIHtcbiAgICAgICAgdGhpcy5tb3ZpbmcgPSBtb3Zpbmc7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVDb2x1bW5FdmVudChDb2x1bW4uRVZFTlRfTU9WSU5HX0NIQU5HRUQpKTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuY3JlYXRlQ29sdW1uRXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbnM6IFt0aGlzXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5pc01vdmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW92aW5nO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5nZXRTb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0O1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5zZXRTb3J0ID0gZnVuY3Rpb24gKHNvcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ydCAhPT0gc29ydCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0ID0gc29ydDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVDb2x1bW5FdmVudChDb2x1bW4uRVZFTlRfU09SVF9DSEFOR0VEKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuc2V0TWVudVZpc2libGUgPSBmdW5jdGlvbiAodmlzaWJsZSkge1xuICAgICAgICBpZiAodGhpcy5tZW51VmlzaWJsZSAhPT0gdmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5tZW51VmlzaWJsZSA9IHZpc2libGU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlQ29sdW1uRXZlbnQoQ29sdW1uLkVWRU5UX01FTlVfVklTSUJMRV9DSEFOR0VEKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNNZW51VmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVudVZpc2libGU7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmlzU29ydEFzY2VuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydCA9PT0gQ29sdW1uLlNPUlRfQVNDO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5pc1NvcnREZXNjZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ID09PSBDb2x1bW4uU09SVF9ERVNDO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5pc1NvcnROb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMuc29ydCk7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmlzU29ydGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMuc29ydCk7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmdldFNvcnRlZEF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRBdDtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuc2V0U29ydGVkQXQgPSBmdW5jdGlvbiAoc29ydGVkQXQpIHtcbiAgICAgICAgdGhpcy5zb3J0ZWRBdCA9IHNvcnRlZEF0O1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5zZXRBZ2dGdW5jID0gZnVuY3Rpb24gKGFnZ0Z1bmMpIHtcbiAgICAgICAgdGhpcy5hZ2dGdW5jID0gYWdnRnVuYztcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuZ2V0QWdnRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWdnRnVuYztcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdDtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuZ2V0T2xkTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2xkTGVmdDtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQgKyB0aGlzLmFjdHVhbFdpZHRoO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5zZXRMZWZ0ID0gZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgdGhpcy5vbGRMZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBsZWZ0KSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUNvbHVtbkV2ZW50KENvbHVtbi5FVkVOVF9MRUZUX0NIQU5HRUQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5pc0ZpbHRlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQWN0aXZlO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5zZXRGaWx0ZXJBY3RpdmUgPSBmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlckFjdGl2ZSAhPT0gYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVDb2x1bW5FdmVudChDb2x1bW4uRVZFTlRfRklMVEVSX0FDVElWRV9DSEFOR0VEKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUNvbHVtbkV2ZW50KENvbHVtbi5FVkVOVF9GSUxURVJfQ0hBTkdFRCkpO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5zZXRQaW5uZWQgPSBmdW5jdGlvbiAocGlubmVkKSB7XG4gICAgICAgIC8vIHBpbm5pbmcgaXMgbm90IGFsbG93ZWQgd2hlbiBkb2luZyAnZm9yUHJpbnQnXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0ZvclByaW50KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGlubmVkID09PSB0cnVlIHx8IHBpbm5lZCA9PT0gQ29sdW1uLlBJTk5FRF9MRUZUKSB7XG4gICAgICAgICAgICB0aGlzLnBpbm5lZCA9IENvbHVtbi5QSU5ORURfTEVGVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwaW5uZWQgPT09IENvbHVtbi5QSU5ORURfUklHSFQpIHtcbiAgICAgICAgICAgIHRoaXMucGlubmVkID0gQ29sdW1uLlBJTk5FRF9SSUdIVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGlubmVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgc2V0Q29sdW1uc1Bpbm5lZCAke3RoaXMuZ2V0Q29sSWQoKX0gJHt0aGlzLnBpbm5lZH1gKTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuc2V0Rmlyc3RSaWdodFBpbm5lZCA9IGZ1bmN0aW9uIChmaXJzdFJpZ2h0UGlubmVkKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0UmlnaHRQaW5uZWQgIT09IGZpcnN0UmlnaHRQaW5uZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RSaWdodFBpbm5lZCA9IGZpcnN0UmlnaHRQaW5uZWQ7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlQ29sdW1uRXZlbnQoQ29sdW1uLkVWRU5UX0ZJUlNUX1JJR0hUX1BJTk5FRF9DSEFOR0VEKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuc2V0TGFzdExlZnRQaW5uZWQgPSBmdW5jdGlvbiAobGFzdExlZnRQaW5uZWQpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdExlZnRQaW5uZWQgIT09IGxhc3RMZWZ0UGlubmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RMZWZ0UGlubmVkID0gbGFzdExlZnRQaW5uZWQ7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlQ29sdW1uRXZlbnQoQ29sdW1uLkVWRU5UX0xBU1RfTEVGVF9QSU5ORURfQ0hBTkdFRCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmlzRmlyc3RSaWdodFBpbm5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RSaWdodFBpbm5lZDtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNMYXN0TGVmdFBpbm5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdExlZnRQaW5uZWQ7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmlzUGlubmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waW5uZWQgPT09IENvbHVtbi5QSU5ORURfTEVGVCB8fCB0aGlzLnBpbm5lZCA9PT0gQ29sdW1uLlBJTk5FRF9SSUdIVDtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNQaW5uZWRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waW5uZWQgPT09IENvbHVtbi5QSU5ORURfTEVGVDtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNQaW5uZWRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlubmVkID09PSBDb2x1bW4uUElOTkVEX1JJR0hUO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5nZXRQaW5uZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbm5lZDtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuc2V0VmlzaWJsZSA9IGZ1bmN0aW9uICh2aXNpYmxlKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHZpc2libGUgPT09IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVDb2x1bW5FdmVudChDb2x1bW4uRVZFTlRfVklTSUJMRV9DSEFOR0VEKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5nZXRDb2xEZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbERlZjtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuZ2V0Q29sdW1uR3JvdXBTaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xEZWYuY29sdW1uR3JvdXBTaG93O1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5nZXRDb2xJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sSWQ7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2xJZCgpO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5nZXREZWZpbml0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xEZWY7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmdldEFjdHVhbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaWR0aDtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuZ2V0Q29sU3BhbiA9IGZ1bmN0aW9uIChyb3dOb2RlKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5jb2xEZWYuY29sU3BhbikpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiByb3dOb2RlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJvd05vZGUuZGF0YSxcbiAgICAgICAgICAgICAgICBjb2xEZWY6IHRoaXMuY29sRGVmLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcyxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29sdW1uQXBpKCksXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNvbFNwYW4gPSB0aGlzLmNvbERlZi5jb2xTcGFuKHBhcmFtcyk7XG4gICAgICAgICAgICAvLyBjb2xTcGFuIG11c3QgYmUgbnVtYmVyIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAxXG4gICAgICAgICAgICBpZiAoY29sU3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sU3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLnNldEFjdHVhbFdpZHRoID0gZnVuY3Rpb24gKGFjdHVhbFdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdHVhbFdpZHRoICE9PSBhY3R1YWxXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5hY3R1YWxXaWR0aCA9IGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUNvbHVtbkV2ZW50KENvbHVtbi5FVkVOVF9XSURUSF9DSEFOR0VEKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNHcmVhdGVyVGhhbk1heCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICBpZiAodGhpcy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5nZXRNaW5XaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluV2lkdGg7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmdldE1heFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhXaWR0aDtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuc2V0TWluaW11bSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRBY3R1YWxXaWR0aCh0aGlzLm1pbldpZHRoKTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuc2V0Um93R3JvdXBBY3RpdmUgPSBmdW5jdGlvbiAocm93R3JvdXApIHtcbiAgICAgICAgaWYgKHRoaXMucm93R3JvdXBBY3RpdmUgIT09IHJvd0dyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0dyb3VwQWN0aXZlID0gcm93R3JvdXA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlQ29sdW1uRXZlbnQoQ29sdW1uLkVWRU5UX1JPV19HUk9VUF9DSEFOR0VEKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNSb3dHcm91cEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93R3JvdXBBY3RpdmU7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLnNldFBpdm90QWN0aXZlID0gZnVuY3Rpb24gKHBpdm90KSB7XG4gICAgICAgIGlmICh0aGlzLnBpdm90QWN0aXZlICE9PSBwaXZvdCkge1xuICAgICAgICAgICAgdGhpcy5waXZvdEFjdGl2ZSA9IHBpdm90O1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUNvbHVtbkV2ZW50KENvbHVtbi5FVkVOVF9QSVZPVF9DSEFOR0VEKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNQaXZvdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGl2b3RBY3RpdmU7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmlzQW55RnVuY3Rpb25BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzUGl2b3RBY3RpdmUoKSB8fCB0aGlzLmlzUm93R3JvdXBBY3RpdmUoKSB8fCB0aGlzLmlzVmFsdWVBY3RpdmUoKTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNBbnlGdW5jdGlvbkFsbG93ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQWxsb3dQaXZvdCgpIHx8IHRoaXMuaXNBbGxvd1Jvd0dyb3VwKCkgfHwgdGhpcy5pc0FsbG93VmFsdWUoKTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuc2V0VmFsdWVBY3RpdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWdncmVnYXRpb25BY3RpdmUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFnZ3JlZ2F0aW9uQWN0aXZlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlQ29sdW1uRXZlbnQoQ29sdW1uLkVWRU5UX1ZBTFVFX0NIQU5HRUQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5pc1ZhbHVlQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZ2dyZWdhdGlvbkFjdGl2ZTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuaXNBbGxvd1Bpdm90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xEZWYuZW5hYmxlUGl2b3QgPT09IHRydWU7XG4gICAgfTtcbiAgICBDb2x1bW4ucHJvdG90eXBlLmlzQWxsb3dWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sRGVmLmVuYWJsZVZhbHVlID09PSB0cnVlO1xuICAgIH07XG4gICAgQ29sdW1uLnByb3RvdHlwZS5pc0FsbG93Um93R3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbERlZi5lbmFibGVSb3dHcm91cCA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIENvbHVtbi5wcm90b3R5cGUuZ2V0TWVudVRhYnMgPSBmdW5jdGlvbiAoZGVmYXVsdFZhbHVlcykge1xuICAgICAgICB2YXIgbWVudVRhYnMgPSB0aGlzLmdldENvbERlZigpLm1lbnVUYWJzO1xuICAgICAgICBpZiAobWVudVRhYnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVudVRhYnMgPSBkZWZhdWx0VmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW51VGFicztcbiAgICB9O1xuICAgIC8vICsgcmVuZGVyZWRIZWFkZXJDZWxsIC0gZm9yIG1ha2luZyBoZWFkZXIgY2VsbCB0cmFuc3BhcmVudCB3aGVuIG1vdmluZ1xuICAgIENvbHVtbi5FVkVOVF9NT1ZJTkdfQ0hBTkdFRCA9ICdtb3ZpbmdDaGFuZ2VkJztcbiAgICAvLyArIHJlbmRlcmVkQ2VsbCAtIGNoYW5naW5nIGxlZnQgcG9zaXRpb25cbiAgICBDb2x1bW4uRVZFTlRfTEVGVF9DSEFOR0VEID0gJ2xlZnRDaGFuZ2VkJztcbiAgICAvLyArIHJlbmRlcmVkQ2VsbCAtIGNoYW5naW5nIHdpZHRoXG4gICAgQ29sdW1uLkVWRU5UX1dJRFRIX0NIQU5HRUQgPSAnd2lkdGhDaGFuZ2VkJztcbiAgICAvLyArIHJlbmRlcmVkQ2VsbCAtIGZvciBjaGFuZ2luZyBwaW5uZWQgY2xhc3Nlc1xuICAgIENvbHVtbi5FVkVOVF9MQVNUX0xFRlRfUElOTkVEX0NIQU5HRUQgPSAnbGFzdExlZnRQaW5uZWRDaGFuZ2VkJztcbiAgICBDb2x1bW4uRVZFTlRfRklSU1RfUklHSFRfUElOTkVEX0NIQU5HRUQgPSAnZmlyc3RSaWdodFBpbm5lZENoYW5nZWQnO1xuICAgIC8vICsgcmVuZGVyZWRDb2x1bW4gLSBmb3IgY2hhbmdpbmcgdmlzaWJpbGl0eSBpY29uXG4gICAgQ29sdW1uLkVWRU5UX1ZJU0lCTEVfQ0hBTkdFRCA9ICd2aXNpYmxlQ2hhbmdlZCc7XG4gICAgLy8gKyBldmVyeSB0aW1lIHRoZSBmaWx0ZXIgY2hhbmdlcywgdXNlZCBpbiB0aGUgZmxvYXRpbmcgZmlsdGVyc1xuICAgIENvbHVtbi5FVkVOVF9GSUxURVJfQ0hBTkdFRCA9ICdmaWx0ZXJDaGFuZ2VkJztcbiAgICAvLyArIHJlbmRlcmVkSGVhZGVyQ2VsbCAtIG1hcmtzIHRoZSBoZWFkZXIgd2l0aCBmaWx0ZXIgaWNvblxuICAgIENvbHVtbi5FVkVOVF9GSUxURVJfQUNUSVZFX0NIQU5HRUQgPSAnZmlsdGVyQWN0aXZlQ2hhbmdlZCc7XG4gICAgLy8gKyByZW5kZXJlZEhlYWRlckNlbGwgLSBtYXJrcyB0aGUgaGVhZGVyIHdpdGggc29ydCBpY29uXG4gICAgQ29sdW1uLkVWRU5UX1NPUlRfQ0hBTkdFRCA9ICdzb3J0Q2hhbmdlZCc7XG4gICAgQ29sdW1uLkVWRU5UX01FTlVfVklTSUJMRV9DSEFOR0VEID0gJ21lbnVWaXNpYmxlQ2hhbmdlZCc7XG4gICAgLy8gKyB0b29scGFuZWwsIGZvciBndWkgdXBkYXRlc1xuICAgIENvbHVtbi5FVkVOVF9ST1dfR1JPVVBfQ0hBTkdFRCA9ICdjb2x1bW5Sb3dHcm91cENoYW5nZWQnO1xuICAgIC8vICsgdG9vbHBhbmVsLCBmb3IgZ3VpIHVwZGF0ZXNcbiAgICBDb2x1bW4uRVZFTlRfUElWT1RfQ0hBTkdFRCA9ICdjb2x1bW5QaXZvdENoYW5nZWQnO1xuICAgIC8vICsgdG9vbHBhbmVsLCBmb3IgZ3VpIHVwZGF0ZXNcbiAgICBDb2x1bW4uRVZFTlRfVkFMVUVfQ0hBTkdFRCA9ICdjb2x1bW5WYWx1ZUNoYW5nZWQnO1xuICAgIENvbHVtbi5QSU5ORURfUklHSFQgPSAncmlnaHQnO1xuICAgIENvbHVtbi5QSU5ORURfTEVGVCA9ICdsZWZ0JztcbiAgICBDb2x1bW4uU09SVF9BU0MgPSAnYXNjJztcbiAgICBDb2x1bW4uU09SVF9ERVNDID0gJ2Rlc2MnO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBDb2x1bW4ucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5VdGlscycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uVXRpbHNfMS5Db2x1bW5VdGlscylcbiAgICBdLCBDb2x1bW4ucHJvdG90eXBlLCBcImNvbHVtblV0aWxzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZyYW1ld29ya0ZhY3RvcnknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDb2x1bW4ucHJvdG90eXBlLCBcImZyYW1ld29ya0ZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIENvbHVtbi5wcm90b3R5cGUsIFwiY29sdW1uQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRBcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRBcGlfMS5HcmlkQXBpKVxuICAgIF0sIENvbHVtbi5wcm90b3R5cGUsIFwiZ3JpZEFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBDb2x1bW4ucHJvdG90eXBlLCBcImluaXRpYWxpc2VcIiwgbnVsbCk7XG4gICAgcmV0dXJuIENvbHVtbjtcbn0oKSk7XG5leHBvcnRzLkNvbHVtbiA9IENvbHVtbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2VudGl0aWVzL2NvbHVtbi5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIHJvd1JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyaW5nL3Jvd1JlbmRlcmVyXCIpO1xudmFyIGJvcmRlckxheW91dF8xID0gcmVxdWlyZShcIi4uL2xheW91dC9ib3JkZXJMYXlvdXRcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4uL2V2ZW50c1wiKTtcbnZhciBkcmFnU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2RyYWdBbmREcm9wL2RyYWdTZXJ2aWNlXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBzZWxlY3Rpb25Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vc2VsZWN0aW9uQ29udHJvbGxlclwiKTtcbnZhciBjc3ZDcmVhdG9yXzEgPSByZXF1aXJlKFwiLi4vY3N2Q3JlYXRvclwiKTtcbnZhciBtb3VzZUV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4vbW91c2VFdmVudFNlcnZpY2VcIik7XG52YXIgZm9jdXNlZENlbGxDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vZm9jdXNlZENlbGxDb250cm9sbGVyXCIpO1xudmFyIHNjcm9sbFZpc2libGVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zY3JvbGxWaXNpYmxlU2VydmljZVwiKTtcbnZhciBiZWFuU3R1Yl8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvYmVhblN0dWJcIik7XG52YXIgcm93Q29udGFpbmVyQ29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyaW5nL3Jvd0NvbnRhaW5lckNvbXBvbmVudFwiKTtcbnZhciBwYWdpbmF0aW9uUHJveHlfMSA9IHJlcXVpcmUoXCIuLi9yb3dNb2RlbHMvcGFnaW5hdGlvblByb3h5XCIpO1xudmFyIHBvcHVwRWRpdG9yV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL3JlbmRlcmluZy9jZWxsRWRpdG9ycy9wb3B1cEVkaXRvcldyYXBwZXJcIik7XG52YXIgYWxpZ25lZEdyaWRzU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2FsaWduZWRHcmlkc1NlcnZpY2VcIik7XG52YXIgcGlubmVkUm93TW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9yb3dNb2RlbHMvcGlubmVkUm93TW9kZWxcIik7XG52YXIgZ3JpZEFwaV8xID0gcmVxdWlyZShcIi4uL2dyaWRBcGlcIik7XG52YXIgYW5pbWF0aW9uRnJhbWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbWlzYy9hbmltYXRpb25GcmFtZVNlcnZpY2VcIik7XG52YXIgcm93Q29tcF8xID0gcmVxdWlyZShcIi4uL3JlbmRlcmluZy9yb3dDb21wXCIpO1xudmFyIG5hdmlnYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9uYXZpZ2F0aW9uU2VydmljZVwiKTtcbi8vIGluIHRoZSBodG1sIGJlbG93LCBpdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGVyZSBhcmUgbm8gd2hpdGUgc3BhY2UgYmV0d2VlbiBzb21lIG9mIHRoZSBkaXZzLCBhcyBpZiB0aGVyZSBpcyB3aGl0ZSBzcGFjZSxcbi8vIGl0IHdvbid0IHJlbmRlciBjb3JyZWN0bHkgaW4gc2FmYXJpLCBhcyBzYWZhcmkgcmVuZGVycyB3aGl0ZSBzcGFjZSBhcyBhIGdhcFxudmFyIEhFQURFUl9TTklQUEVUID0gJzxkaXYgY2xhc3M9XCJhZy1oZWFkZXJcIiByb2xlPVwicm93XCI+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJhZy1waW5uZWQtbGVmdC1oZWFkZXJcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+PC9kaXY+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJhZy1waW5uZWQtcmlnaHQtaGVhZGVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjwvZGl2PicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctaGVhZGVyLXZpZXdwb3J0XCIgcm9sZT1cInByZXNlbnRhdGlvblwiPicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctaGVhZGVyLWNvbnRhaW5lclwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L2Rpdj4nICtcbiAgICAnPC9kaXY+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJhZy1oZWFkZXItb3ZlcmxheVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L2Rpdj4nICtcbiAgICAnPC9kaXY+JztcbnZhciBGTE9BVElOR19UT1BfU05JUFBFVCA9ICc8ZGl2IGNsYXNzPVwiYWctZmxvYXRpbmctdG9wXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctcGlubmVkLWxlZnQtZmxvYXRpbmctdG9wXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjwvZGl2PicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctcGlubmVkLXJpZ2h0LWZsb2F0aW5nLXRvcFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L2Rpdj4nICtcbiAgICAnPGRpdiBjbGFzcz1cImFnLWZsb2F0aW5nLXRvcC12aWV3cG9ydFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj4nICtcbiAgICAnPGRpdiBjbGFzcz1cImFnLWZsb2F0aW5nLXRvcC1jb250YWluZXJcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+PC9kaXY+JyArXG4gICAgJzwvZGl2PicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctZmxvYXRpbmctdG9wLWZ1bGwtd2lkdGgtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjwvZGl2PicgK1xuICAgICc8L2Rpdj4nO1xudmFyIEZMT0FUSU5HX0JPVFRPTV9TTklQUEVUID0gJzxkaXYgY2xhc3M9XCJhZy1mbG9hdGluZy1ib3R0b21cIiByb2xlPVwicHJlc2VudGF0aW9uXCI+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJhZy1waW5uZWQtbGVmdC1mbG9hdGluZy1ib3R0b21cIiByb2xlPVwicHJlc2VudGF0aW9uXCI+PC9kaXY+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJhZy1waW5uZWQtcmlnaHQtZmxvYXRpbmctYm90dG9tXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjwvZGl2PicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctZmxvYXRpbmctYm90dG9tLXZpZXdwb3J0XCIgcm9sZT1cInByZXNlbnRhdGlvblwiPicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctZmxvYXRpbmctYm90dG9tLWNvbnRhaW5lclwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L2Rpdj4nICtcbiAgICAnPC9kaXY+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJhZy1mbG9hdGluZy1ib3R0b20tZnVsbC13aWR0aC1jb250YWluZXJcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+PC9kaXY+JyArXG4gICAgJzwvZGl2Pic7XG52YXIgQk9EWV9TTklQUEVUID0gJzxkaXYgY2xhc3M9XCJhZy1ib2R5XCIgcm9sZT1cInByZXNlbnRhdGlvblwiPicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctcGlubmVkLWxlZnQtY29scy12aWV3cG9ydFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj4nICtcbiAgICAnPGRpdiBjbGFzcz1cImFnLXBpbm5lZC1sZWZ0LWNvbHMtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjwvZGl2PicgK1xuICAgICc8L2Rpdj4nICtcbiAgICAnPGRpdiBjbGFzcz1cImFnLXBpbm5lZC1yaWdodC1jb2xzLXZpZXdwb3J0XCIgcm9sZT1cInByZXNlbnRhdGlvblwiPicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctcGlubmVkLXJpZ2h0LWNvbHMtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjwvZGl2PicgK1xuICAgICc8L2Rpdj4nICtcbiAgICAnPGRpdiBjbGFzcz1cImFnLWJvZHktdmlld3BvcnQtd3JhcHBlclwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj4nICtcbiAgICAnPGRpdiBjbGFzcz1cImFnLWJvZHktdmlld3BvcnRcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJhZy1ib2R5LWNvbnRhaW5lclwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L2Rpdj4nICtcbiAgICAnPC9kaXY+JyArXG4gICAgJzwvZGl2PicgK1xuICAgICc8ZGl2IGNsYXNzPVwiYWctZnVsbC13aWR0aC12aWV3cG9ydFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj4nICtcbiAgICAnPGRpdiBjbGFzcz1cImFnLWZ1bGwtd2lkdGgtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjwvZGl2PicgK1xuICAgICc8L2Rpdj4nICtcbiAgICAnPC9kaXY+Jztcbi8vIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlICdub3JtYWwnIGFuZCAnZnVsbCBoZWlnaHQnIHRlbXBsYXRlIGlzIHRoZSBvcmRlciBvZiB0aGUgZmxvYXRpbmcgYW5kIGJvZHksXG4vLyBmb3Igbm9ybWFsLCB0aGUgZmxvYXRpbmcgdG9wIGFuZCBib3R0b20gZ28gaW4gZmlyc3QgYXMgdGhleSBhcmUgZml4ZWQgcG9zaXRpb24sXG4vLyBmb3IgYXV0by1oZWlnaHQsIHRoZSBib2R5IGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRvcCBhbmQgYm90dG9tIGFzIHRoZXkgYXJlIGp1c3Qgbm9ybWFsbHkgbGFpZCBvdXRcbnZhciBHUklEX1BBTkVMX05PUk1BTF9URU1QTEFURSA9ICc8ZGl2IGNsYXNzPVwiYWctcm9vdCBhZy1mb250LXN0eWxlXCIgcm9sZT1cImdyaWRcIj4nICtcbiAgICBIRUFERVJfU05JUFBFVCArIEZMT0FUSU5HX1RPUF9TTklQUEVUICsgRkxPQVRJTkdfQk9UVE9NX1NOSVBQRVQgKyBCT0RZX1NOSVBQRVQgK1xuICAgICc8L2Rpdj4nO1xudmFyIEdSSURfUEFORUxfQVVUT19IRUlHSFRfVEVNUExBVEUgPSAnPGRpdiBjbGFzcz1cImFnLXJvb3QgYWctZm9udC1zdHlsZVwiIHJvbGU9XCJncmlkXCI+JyArXG4gICAgSEVBREVSX1NOSVBQRVQgKyBGTE9BVElOR19UT1BfU05JUFBFVCArIEJPRFlfU05JUFBFVCArIEZMT0FUSU5HX0JPVFRPTV9TTklQUEVUICtcbiAgICAnPC9kaXY+Jztcbi8vIHRoZSB0ZW1wbGF0ZSBmb3IgZm9yLXByaW50IGlzIG11Y2ggZWFzaWVyIHRoYW4gdGhhdCBvdGhlcnMsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgcGlubmVkIGFyZWFzXG4vLyBvciBzY3JvbGxhYmxlIGFyZWFzIChzbyBubyB2aWV3cG9ydHMpLlxudmFyIEdSSURfUEFORUxfRk9SX1BSSU5UX1RFTVBMQVRFID0gJzxkaXYgY2xhc3M9XCJhZy1yb290IGFnLWZvbnQtc3R5bGVcIj4nICtcbiAgICAvLyBoZWFkZXJcbiAgICAnPGRpdiBjbGFzcz1cImFnLWhlYWRlci1jb250YWluZXJcIj48L2Rpdj4nICtcbiAgICAvLyBmbG9hdGluZ1xuICAgICc8ZGl2IGNsYXNzPVwiYWctZmxvYXRpbmctdG9wLWNvbnRhaW5lclwiPjwvZGl2PicgK1xuICAgIC8vIGJvZHlcbiAgICAnPGRpdiBjbGFzcz1cImFnLWJvZHktY29udGFpbmVyXCI+PC9kaXY+JyArXG4gICAgLy8gZmxvYXRpbmcgYm90dG9tXG4gICAgJzxkaXYgY2xhc3M9XCJhZy1mbG9hdGluZy1ib3R0b20tY29udGFpbmVyXCI+PC9kaXY+JyArXG4gICAgJzwvZGl2Pic7XG4vLyB3cmFwcGluZyBpbiBvdXRlciBkaXYsIGFuZCB3cmFwcGVyLCBpcyBuZWVkZWQgdG8gY2VudGVyIHRoZSBsb2FkaW5nIGljb25cbi8vIFRoZSBpZGVhIGZvciBjZW50ZXJpbmcgY2FtZSBmcm9tIGhlcmU6IGh0dHA6Ly93d3cudmFuc2VvZGVzaWduLmNvbS9jc3MvdmVydGljYWwtY2VudGVyaW5nL1xudmFyIE9WRVJMQVlfVEVNUExBVEUgPSAnPGRpdiBjbGFzcz1cImFnLW92ZXJsYXktcGFuZWxcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJhZy1vdmVybGF5LXdyYXBwZXIgYWctb3ZlcmxheS1bT1ZFUkxBWV9OQU1FXS13cmFwcGVyXCI+W09WRVJMQVlfVEVNUExBVEVdPC9kaXY+JyArXG4gICAgJzwvZGl2Pic7XG52YXIgTE9BRElOR19PVkVSTEFZX1RFTVBMQVRFID0gJzxzcGFuIGNsYXNzPVwiYWctb3ZlcmxheS1sb2FkaW5nLWNlbnRlclwiPltMT0FESU5HLi4uXTwvc3Bhbj4nO1xudmFyIE5PX1JPV1NfVE9fU0hPV19PVkVSTEFZX1RFTVBMQVRFID0gJzxzcGFuIGNsYXNzPVwiYWctb3ZlcmxheS1uby1yb3dzLWNlbnRlclwiPltOT19ST1dTX1RPX1NIT1ddPC9zcGFuPic7XG52YXIgR3JpZFBhbmVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JpZFBhbmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyaWRQYW5lbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNjcm9sbExlZnQgPSAtMTtcbiAgICAgICAgX3RoaXMubmV4dFNjcm9sbExlZnQgPSAtMTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsVG9wID0gLTE7XG4gICAgICAgIF90aGlzLm5leHRTY3JvbGxUb3AgPSAtMTtcbiAgICAgICAgX3RoaXMudmVydGljYWxSZWRyYXdOZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmFnV2lyZSA9IGZ1bmN0aW9uIChsb2dnZXJGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyRmFjdG9yeS5jcmVhdGUoJ0dyaWRQYW5lbCcpO1xuICAgICAgICAvLyBtYWtlcyBjb2RlIGJlbG93IG1vcmUgcmVhZGFibGUgaWYgd2UgcHVsbCAnZm9yUHJpbnQnIG91dFxuICAgICAgICB0aGlzLmZvclByaW50ID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNGb3JQcmludCgpO1xuICAgICAgICB0aGlzLmF1dG9IZWlnaHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0F1dG9IZWlnaHQoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxXaWR0aCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldFNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIHRoaXMuZW5hYmxlUnRsID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVSdGwoKTtcbiAgICAgICAgdGhpcy5sb2FkVGVtcGxhdGUoKTtcbiAgICAgICAgdGhpcy5maW5kRWxlbWVudHMoKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuZ2V0VmVydGljYWxQaXhlbFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRQcmltYXJ5U2Nyb2xsVmlld3BvcnQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHRvcDogY29udGFpbmVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIGJvdHRvbTogY29udGFpbmVyLnNjcm9sbFRvcCArIGNvbnRhaW5lci5vZmZzZXRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIHdlIG92ZXJyaWRlIHRoaXMsIGFzIHRoZSBiYXNlIGNsYXNzIGlzIG1pc3NpbmcgdGhlIGFubm90YXRpb25cbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5vblJvd0RhdGFDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNob3dPckhpZGVPdmVybGF5KCk7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLnNob3dPckhpZGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYWdpbmF0aW9uUHJveHkuaXNFbXB0eSgpICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzTm9Sb3dzT3ZlcmxheSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dOb1Jvd3NPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQ7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXNlQW5pbWF0aW9uRnJhbWUgPSAhdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc0FuaW1hdGlvbkZyYW1lKCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5hZGREcmFnTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gbmV3IGJvcmRlckxheW91dF8xLkJvcmRlckxheW91dCh7XG4gICAgICAgICAgICBvdmVybGF5czoge1xuICAgICAgICAgICAgICAgIGxvYWRpbmc6IHV0aWxzXzEuVXRpbHMubG9hZFRlbXBsYXRlKHRoaXMuY3JlYXRlTG9hZGluZ092ZXJsYXlUZW1wbGF0ZSgpKSxcbiAgICAgICAgICAgICAgICBub1Jvd3M6IHV0aWxzXzEuVXRpbHMubG9hZFRlbXBsYXRlKHRoaXMuY3JlYXRlTm9Sb3dzT3ZlcmxheVRlbXBsYXRlKCkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2VudGVyOiB0aGlzLmVSb290LFxuICAgICAgICAgICAgZG9udEZpbGw6IHRoaXMuZm9yUHJpbnQsXG4gICAgICAgICAgICBmaWxsSG9yaXpvbnRhbE9ubHk6IHRoaXMuYXV0b0hlaWdodCxcbiAgICAgICAgICAgIG5hbWU6ICdlR3JpZFBhbmVsJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXlvdXQuYWRkU2l6ZUNoYW5nZUxpc3RlbmVyKHRoaXMuc2V0Qm9keUFuZEhlYWRlckhlaWdodHMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubGF5b3V0LmFkZFNpemVDaGFuZ2VMaXN0ZW5lcih0aGlzLnNldExlZnRBbmRSaWdodEJvdW5kcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGRTY3JvbGxMaXN0ZW5lcigpO1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc0hvcml6b250YWxTY3JvbGwoKSkge1xuICAgICAgICAgICAgdGhpcy5lQm9keVZpZXdwb3J0LnN0eWxlLm92ZXJmbG93WCA9ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1Jvd01vZGVsRGVmYXVsdCgpICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRSb3dEYXRhKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0xvYWRpbmdPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRQaW5uZWRDb250YWluZXJzVmlzaWJsZSgpO1xuICAgICAgICB0aGlzLnNldEJvZHlBbmRIZWFkZXJIZWlnaHRzKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUJyb3dzZXJEcmFnZ2luZygpO1xuICAgICAgICB0aGlzLmFkZFNob3J0Y3V0S2V5TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuYWRkTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5hZGRLZXlib2FyZEV2ZW50cygpO1xuICAgICAgICB0aGlzLmFkZEJvZHlWaWV3cG9ydExpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuYWRkU3RvcEVkaXRpbmdXaGVuR3JpZExvc2VzRm9jdXMoKTtcbiAgICAgICAgaWYgKHRoaXMuJHNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEFuZ3VsYXJBcHBseUNoZWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkRpc3BsYXllZENvbHVtbnNXaWR0aENoYW5nZWQoKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuYWRkU3RvcEVkaXRpbmdXaGVuR3JpZExvc2VzRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N0b3BFZGl0aW5nV2hlbkdyaWRMb3Nlc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZUJvZHksICdmb2N1c291dCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGVsZW1lbnQgdGhlIGZvY3VzIGlzIG1vdmluZyB0b1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50V2l0aEZvY3VzID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgICAgICAvLyBzZWUgaWYgdGhlIGVsZW1lbnQgdGhlIGZvY3VzIGlzIGdvaW5nIHRvIGlzIHBhcnQgb2YgdGhlIGdyaWRcbiAgICAgICAgICAgICAgICB2YXIgY2xpY2tJbnNpZGVHcmlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSBlbGVtZW50V2l0aEZvY3VzO1xuICAgICAgICAgICAgICAgIHdoaWxlICh1dGlsc18xLlV0aWxzLmV4aXN0cyhwb2ludGVyKSAmJiAhY2xpY2tJbnNpZGVHcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1BvcHVwID0gISFfdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RG9tRGF0YShwb2ludGVyLCBwb3B1cEVkaXRvcldyYXBwZXJfMS5Qb3B1cEVkaXRvcldyYXBwZXIuRE9NX0tFWV9QT1BVUF9FRElUT1JfV1JBUFBFUik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0JvZHkgPSBfdGhpcy5lQm9keSA9PSBwb2ludGVyO1xuICAgICAgICAgICAgICAgICAgICBjbGlja0luc2lkZUdyaWQgPSBpc1BvcHVwIHx8IGlzQm9keTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjbGlja0luc2lkZUdyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucm93UmVuZGVyZXIuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5hZGRBbmd1bGFyQXBwbHlDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gdGhpcyBtYWtlcyBzdXJlIGlmIHdlIHF1ZXVlIHVwIHJlcXVlc3RzLCB3ZSBvbmx5IGV4ZWN1dGUgb2VcbiAgICAgICAgdmFyIGFwcGx5VHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgbmVlZCB0byBkbyBvbmUgYXBwbHkgYXQgYSB0aW1lXG4gICAgICAgICAgICBpZiAoYXBwbHlUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcHBseVRyaWdnZXJlZCA9IHRydWU7IC8vIG1hcmsgJ25lZWQgYXBwbHknIHRvIHRydWVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGFwcGx5VHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRoZXNlIGFyZSB0aGUgZXZlbnRzIHdlIG5lZWQgdG8gZG8gYW4gYXBwbHkgYWZ0ZXIgLSB0aGVzZSBhcmUgdGhlIG9uZXMgdGhhdCBjYW4gZW5kIHVwXG4gICAgICAgIC8vIHdpdGggY29sdW1ucyBhZGRlZCBvciByZW1vdmVkXG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfRElTUExBWUVEX0NPTFVNTlNfQ0hBTkdFRCwgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1ZJUlRVQUxfQ09MVU1OU19DSEFOR0VELCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICAvLyBpZiB3ZSBkbyBub3QgZG8gdGhpcywgdGhlbiB0aGUgdXNlciBjYW4gc2VsZWN0IGEgcGljIGluIHRoZSBncmlkIChlZyBhbiBpbWFnZSBpbiBhIGN1c3RvbSBjZWxsIHJlbmRlcmVyKVxuICAgIC8vIGFuZCB0aGVuIHRoYXQgd2lsbCBzdGFydCB0aGUgYnJvd3NlciBuYXRpdmUgZHJhZyBuJyBkcm9wLCB3aGljaCBtZXNzZXMgdXAgd2l0aCBvdXIgb3duIGRyYWcgYW5kIGRyb3AuXG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5kaXNhYmxlQnJvd3NlckRyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVSb290LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0RJU1BMQVlFRF9DT0xVTU5TX0NIQU5HRUQsIHRoaXMub25EaXNwbGF5ZWRDb2x1bW5zQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9ESVNQTEFZRURfQ09MVU1OU19XSURUSF9DSEFOR0VELCB0aGlzLm9uRGlzcGxheWVkQ29sdW1uc1dpZHRoQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9TQ1JPTExfVklTSUJJTElUWV9DSEFOR0VELCB0aGlzLm9uU2Nyb2xsVmlzaWJpbGl0eUNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfUElOTkVEX1JPV19EQVRBX0NIQU5HRUQsIHRoaXMuc2V0Qm9keUFuZEhlYWRlckhlaWdodHMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfUk9XX0RBVEFfQ0hBTkdFRCwgdGhpcy5vblJvd0RhdGFDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1JPV19EQVRBX1VQREFURUQsIHRoaXMub25Sb3dEYXRhQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlci5QUk9QX0hFQURFUl9IRUlHSFQsIHRoaXMuc2V0Qm9keUFuZEhlYWRlckhlaWdodHMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIuUFJPUF9QSVZPVF9IRUFERVJfSEVJR0hULCB0aGlzLnNldEJvZHlBbmRIZWFkZXJIZWlnaHRzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfR1JPVVBfSEVBREVSX0hFSUdIVCwgdGhpcy5zZXRCb2R5QW5kSGVhZGVySGVpZ2h0cy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlci5QUk9QX1BJVk9UX0dST1VQX0hFQURFUl9IRUlHSFQsIHRoaXMuc2V0Qm9keUFuZEhlYWRlckhlaWdodHMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIuUFJPUF9GTE9BVElOR19GSUxURVJTX0hFSUdIVCwgdGhpcy5zZXRCb2R5QW5kSGVhZGVySGVpZ2h0cy5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuYWRkRHJhZ0xpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZm9yUHJpbnQgLy8gbm8gcmFuZ2Ugc2VsZWN0IHdoZW4gZG9pbmcgJ2ZvciBwcmludCdcbiAgICAgICAgICAgIHx8ICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVJhbmdlU2VsZWN0aW9uKCkgLy8gbm8gcmFuZ2Ugc2VsZWN0aW9uIGlmIG5vIHByb3BlcnR5XG4gICAgICAgICAgICB8fCB1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5yYW5nZUNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRhaW5lcnMgPSBbdGhpcy5lUGlubmVkTGVmdENvbHNDb250YWluZXIsIHRoaXMuZVBpbm5lZFJpZ2h0Q29sc0NvbnRhaW5lciwgdGhpcy5lQm9keUNvbnRhaW5lcixcbiAgICAgICAgICAgIHRoaXMuZUZsb2F0aW5nVG9wLCB0aGlzLmVGbG9hdGluZ0JvdHRvbV07XG4gICAgICAgIGNvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRyYWdTdGFydFBpeGVsczogMCxcbiAgICAgICAgICAgICAgICBlRWxlbWVudDogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0OiBfdGhpcy5yYW5nZUNvbnRyb2xsZXIub25EcmFnU3RhcnQuYmluZChfdGhpcy5yYW5nZUNvbnRyb2xsZXIpLFxuICAgICAgICAgICAgICAgIG9uRHJhZ1N0b3A6IF90aGlzLnJhbmdlQ29udHJvbGxlci5vbkRyYWdTdG9wLmJpbmQoX3RoaXMucmFuZ2VDb250cm9sbGVyKSxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nOiBfdGhpcy5yYW5nZUNvbnRyb2xsZXIub25EcmFnZ2luZy5iaW5kKF90aGlzLnJhbmdlQ29udHJvbGxlcilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5kcmFnU2VydmljZS5hZGREcmFnU291cmNlKHBhcmFtcyk7XG4gICAgICAgICAgICBfdGhpcy5hZGREZXN0cm95RnVuYyhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kcmFnU2VydmljZS5yZW1vdmVEcmFnU291cmNlKHBhcmFtcyk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuYWRkTW91c2VMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudE5hbWVzID0gWydjbGljaycsICdtb3VzZWRvd24nLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0J107XG4gICAgICAgIGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBfdGhpcy5wcm9jZXNzTW91c2VFdmVudC5iaW5kKF90aGlzLCBldmVudE5hbWUpO1xuICAgICAgICAgICAgX3RoaXMuZUFsbENlbGxDb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoY29udGFpbmVyLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuYWRkS2V5Ym9hcmRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudE5hbWVzID0gWydrZXlkb3duJywgJ2tleXByZXNzJ107XG4gICAgICAgIGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBfdGhpcy5wcm9jZXNzS2V5Ym9hcmRFdmVudC5iaW5kKF90aGlzLCBldmVudE5hbWUpO1xuICAgICAgICAgICAgX3RoaXMuZUFsbENlbGxDb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcihjb250YWluZXIsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5hZGRCb2R5Vmlld3BvcnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gd2UgbmV2ZXIgYWRkIHRoaXMgd2hlbiBkb2luZyAnZm9yUHJpbnQnXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0ZvclByaW50KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSB3YW50IHRvIGxpc3RlbiBmb3IgY2xpY2tzIGRpcmVjdGx5IG9uIHRoZSBlQm9keVZpZXdwb3J0LCBzbyB0aGUgdXNlciBoYXMgYSB3YXkgb2Ygc2hvd2luZ1xuICAgICAgICAvLyB0aGUgY29udGV4dCBtZW51IGlmIG5vIHJvd3MgYXJlIGRpc3BsYXllZCwgb3IgdXNlciBzaW1wbHkgY2xpY2tzIG91dHNpZGUgb2YgYSBjZWxsXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdXRpbHNfMS5VdGlscy5nZXRUYXJnZXQobW91c2VFdmVudCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBfdGhpcy5lQm9keVZpZXdwb3J0IHx8IHRhcmdldCA9PT0gX3RoaXMuZVBpbm5lZExlZnRDb2xzVmlld3BvcnQgfHwgdGFyZ2V0ID09PSBfdGhpcy5lUGlubmVkUmlnaHRDb2xzVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBzaG93IGl0XG4gICAgICAgICAgICAgICAgX3RoaXMub25Db250ZXh0TWVudShtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ29udGV4dE1lbnUobW91c2VFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vRm9yIHNvbWUgcmVhc29uIGxpc3RlbmluZyBvbmx5IHRvIHRoaXMuZUJvZHkgZG9lc250IHdvcmsuLi4gTWF5YmUgYmVjYXVzZSB0aGUgZXZlbnQgaXMgY29uc3VtZWQgc29tZXdoZXJlIGVsc2U/XG4gICAgICAgIC8vSW4gYW55IGNhc2UsIG5vdCBleHBlbmRpbmcgbXVjaCB0aW1lIG9uIHRoaXMsIGlmIGFueW9tZSBjb21lcyBhY2Nyb3NzIHRoaXMgYW5kIGtub3dzIGhvdyB0byBtYWtlIHRoaXMgd29yayB3aXRoXG4gICAgICAgIC8vb25lIGxpc3RlbmVyIHBsZWFzZSBnbyBhaGVhZCBhbmQgY2hhbmdlIGl0Li4uXG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZUJvZHlWaWV3cG9ydCwgJ2NvbnRleHRtZW51JywgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVQaW5uZWRSaWdodENvbHNWaWV3cG9ydCwgJ2NvbnRleHRtZW51JywgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVQaW5uZWRMZWZ0Q29sc1ZpZXdwb3J0LCAnY29udGV4dG1lbnUnLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmdldFJvd0ZvckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBzb3VyY2VFbGVtZW50ID0gdXRpbHNfMS5VdGlscy5nZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgICB3aGlsZSAoc291cmNlRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkUm93ID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RG9tRGF0YShzb3VyY2VFbGVtZW50LCByb3dDb21wXzEuUm93Q29tcC5ET01fREFUQV9LRVlfUkVOREVSRURfUk9XKTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZFJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJlZFJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBzb3VyY2VFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLnByb2Nlc3NLZXlib2FyZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwga2V5Ym9hcmRFdmVudCkge1xuICAgICAgICB2YXIgcmVuZGVyZWRDZWxsID0gdGhpcy5tb3VzZUV2ZW50U2VydmljZS5nZXRSZW5kZXJlZENlbGxGb3JFdmVudChrZXlib2FyZEV2ZW50KTtcbiAgICAgICAgaWYgKCFyZW5kZXJlZENlbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgICAgICAgICAgLy8gZmlyc3Qgc2VlIGlmIGl0J3MgYSBzY3JvbGwga2V5LCBwYWdlIHVwIC8gZG93biwgaG9tZSAvIGVuZCBldGNcbiAgICAgICAgICAgICAgICB2YXIgd2FzU2Nyb2xsS2V5ID0gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5oYW5kbGVQYWdlU2Nyb2xsaW5nS2V5KGtleWJvYXJkRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBhIHNjcm9sbCBrZXksIHRoZW4gd2UgcGFzcyBvbnRvIGNlbGxcbiAgICAgICAgICAgICAgICBpZiAoIXdhc1Njcm9sbEtleSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZENlbGwub25LZXlEb3duKGtleWJvYXJkRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tleXByZXNzJzpcbiAgICAgICAgICAgICAgICByZW5kZXJlZENlbGwub25LZXlQcmVzcyhrZXlib2FyZEV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZ2V0cyBjYWxsZWQgYnkgcm93UmVuZGVyZXIgd2hlbiBuZXcgZGF0YSBsb2FkZWQsIGFzIGl0IHdpbGwgd2FudCB0byBzY3JvbGxcbiAgICAvLyB0byB0aGUgdG9wXG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5zY3JvbGxUb1RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZvclByaW50KSB7XG4gICAgICAgICAgICB0aGlzLmdldFByaW1hcnlTY3JvbGxWaWV3cG9ydCgpLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUucHJvY2Vzc01vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsQ29tcCA9IHRoaXMubW91c2VFdmVudFNlcnZpY2UuZ2V0UmVuZGVyZWRDZWxsRm9yRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgIGlmIChjZWxsQ29tcCkge1xuICAgICAgICAgICAgY2VsbENvbXAub25Nb3VzZUV2ZW50KGV2ZW50TmFtZSwgbW91c2VFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvd0NvbXAgPSB0aGlzLmdldFJvd0ZvckV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICBpZiAocm93Q29tcCkge1xuICAgICAgICAgICAgcm93Q29tcC5vbk1vdXNlRXZlbnQoZXZlbnROYW1lLCBtb3VzZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0T25Db250ZXh0TWVudShtb3VzZUV2ZW50KTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIChtb3VzZUV2ZW50KSB7XG4gICAgICAgIC8vIHRvIGFsbG93IHVzIHRvIGRlYnVnIGluIGNocm9tZSwgd2UgaWdub3JlIHRoZSBldmVudCBpZiBjdHJsIGlzIHByZXNzZWQuXG4gICAgICAgIC8vIG5vdCBldmVyeW9uZSB3YW50cyB0aGlzLCBzbyBmaXJzdCAnaWYnIGJlbG93IGFsbG93cyB0byB0dXJuIHRoaXMgaGFjayBvZmYuXG4gICAgICAgIGlmICghdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNBbGxvd0NvbnRleHRNZW51V2l0aENvbnRyb2xLZXkoKSkge1xuICAgICAgICAgICAgLy8gdGhlbiBkbyB0aGUgY2hlY2tcbiAgICAgICAgICAgIGlmIChtb3VzZUV2ZW50LmN0cmxLZXkgfHwgbW91c2VFdmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51RmFjdG9yeSAmJiAhdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc0NvbnRleHRNZW51KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnVGYWN0b3J5LnNob3dNZW51KG51bGwsIG51bGwsIG51bGwsIG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLnByZXZlbnREZWZhdWx0T25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIChtb3VzZUV2ZW50KSB7XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGRvIHRoaXMsIHRoZW4gbWlkZGxlIGNsaWNrIHdpbGwgbmV2ZXIgcmVzdWx0IGluIGEgJ2NsaWNrJyBldmVudCwgYXMgJ21vdXNlZG93bidcbiAgICAgICAgLy8gd2lsbCBiZSBjb25zdW1lZCBieSB0aGUgYnJvd3NlciB0byBtZWFuICdzY3JvbGwnIChhcyB5b3UgY2FuIHNjcm9sbCB3aXRoIHRoZSBtaWRkbGUgbW91c2VcbiAgICAgICAgLy8gYnV0dG9uIGluIHRoZSBicm93c2VyKS4gc28gdGhpcyBwcm9wZXJ0eSBhbGxvd3MgdGhlIHVzZXIgdG8gcmVjZWl2ZSBtaWRkbGUgYnV0dG9uIGNsaWNrcyBpZlxuICAgICAgICAvLyB0aGV5IHdhbnQuXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzTWlkZGxlQ2xpY2tTY3JvbGxzKCkgJiYgbW91c2VFdmVudC53aGljaCA9PT0gMikge1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmFkZFNob3J0Y3V0S2V5TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVBbGxDZWxsQ29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNlbGwgdGhlIGV2ZW50IGNhbWUgZnJvbSBpcyBlZGl0aW5nLCB0aGVuIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gZG8gdGhlIGRlZmF1bHQgc2hvcnRjdXQga2V5cywgb3RoZXJ3aXNlIHRoZSBlZGl0b3JcbiAgICAgICAgICAgICAgICAvLyAoZWcgYSB0ZXh0IGZpZWxkKSB3b3VsZCBub3QgYmUgYWJsZSB0byBkbyB0aGUgbm9ybWFsIGN1dC9jb3B5L3Bhc3RlXG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlcmVkQ2VsbCA9IF90aGlzLm1vdXNlRXZlbnRTZXJ2aWNlLmdldFJlbmRlcmVkQ2VsbEZvckV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZWRDZWxsICYmIHJlbmRlcmVkQ2VsbC5pc0VkaXRpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZvciBjb3B5IC8gcGFzdGUsIHdlIGRvbid0IHdhbnQgdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdhcyBmcm9tIGEgY2hpbGQgZ3JpZCAoaGFwcGVucyBpbiBtYXN0ZXIgZGV0YWlsKVxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMubW91c2VFdmVudFNlcnZpY2UuaXNFdmVudEZyb21UaGlzR3JpZChldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9BOiByZXR1cm4gX3RoaXMub25DdHJsQW5kQShldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfQzogcmV0dXJuIF90aGlzLm9uQ3RybEFuZEMoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX1Y6IHJldHVybiBfdGhpcy5vbkN0cmxBbmRWKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9EOiByZXR1cm4gX3RoaXMub25DdHJsQW5kRChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLm9uQ3RybEFuZEEgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VDb250cm9sbGVyICYmIHRoaXMucGFnaW5hdGlvblByb3h5LmlzUm93c1RvUmVuZGVyKCkpIHtcbiAgICAgICAgICAgIHZhciByb3dFbmQgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgZmxvYXRpbmdTdGFydCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBmbG9hdGluZ0VuZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpbm5lZFJvd01vZGVsLmlzRW1wdHkoY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9UT1ApKSB7XG4gICAgICAgICAgICAgICAgZmxvYXRpbmdTdGFydCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbG9hdGluZ1N0YXJ0ID0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9UT1A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5waW5uZWRSb3dNb2RlbC5pc0VtcHR5KGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfQk9UVE9NKSkge1xuICAgICAgICAgICAgICAgIGZsb2F0aW5nRW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICByb3dFbmQgPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRUb3RhbFJvd0NvdW50KCkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxvYXRpbmdFbmQgPSBjb25zdGFudHNfMS5Db25zdGFudHMuUElOTkVEX0JPVFRPTTtcbiAgICAgICAgICAgICAgICByb3dFbmQgPSB0aGlzLnBpbm5lZFJvd01vZGVsLmdldFBpbm5lZEJvdHRvbVJvd0RhdGEoKS5sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFsbERpc3BsYXllZENvbHVtbnMgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0QWxsRGlzcGxheWVkQ29sdW1ucygpO1xuICAgICAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZ09yRW1wdHkoYWxsRGlzcGxheWVkQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlQ29udHJvbGxlci5zZXRSYW5nZSh7XG4gICAgICAgICAgICAgICAgcm93U3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdTdGFydDogZmxvYXRpbmdTdGFydCxcbiAgICAgICAgICAgICAgICByb3dFbmQ6IHJvd0VuZCxcbiAgICAgICAgICAgICAgICBmbG9hdGluZ0VuZDogZmxvYXRpbmdFbmQsXG4gICAgICAgICAgICAgICAgY29sdW1uU3RhcnQ6IGFsbERpc3BsYXllZENvbHVtbnNbMF0sXG4gICAgICAgICAgICAgICAgY29sdW1uRW5kOiBhbGxEaXNwbGF5ZWRDb2x1bW5zW2FsbERpc3BsYXllZENvbHVtbnMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUub25DdHJsQW5kQyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xpcGJvYXJkU2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb2N1c2VkQ2VsbCA9IHRoaXMuZm9jdXNlZENlbGxDb250cm9sbGVyLmdldEZvY3VzZWRDZWxsKCk7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkU2VydmljZS5jb3B5VG9DbGlwYm9hcmQoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gdGhlIGNvcHkgb3BlcmF0aW9uIHJlc3VsdHMgaW4gbG9vc2luZyBmb2N1cyBvbiB0aGUgY2VsbCxcbiAgICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgdHJpY2tlcnkgdGhlIGNvcHkgbG9naWMgdXNlcyB3aXRoIGEgdGVtcG9yYXJ5XG4gICAgICAgIC8vIHdpZGdldC4gc28gd2Ugc2V0IGl0IGJhY2sgYWdhaW4uXG4gICAgICAgIGlmIChmb2N1c2VkQ2VsbCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbENvbnRyb2xsZXIuc2V0Rm9jdXNlZENlbGwoZm9jdXNlZENlbGwucm93SW5kZXgsIGZvY3VzZWRDZWxsLmNvbHVtbiwgZm9jdXNlZENlbGwuZmxvYXRpbmcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUub25DdHJsQW5kViA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMucmFuZ2VDb250cm9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGlwYm9hcmRTZXJ2aWNlLnBhc3RlRnJvbUNsaXBib2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLm9uQ3RybEFuZEQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaXBib2FyZFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaXBib2FyZFNlcnZpY2UuY29weVJhbmdlRG93bigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmNyZWF0ZU92ZXJsYXlUZW1wbGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBkZWZhdWx0VGVtcGxhdGUsIHVzZXJQcm92aWRlZFRlbXBsYXRlKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IE9WRVJMQVlfVEVNUExBVEVcbiAgICAgICAgICAgIC5yZXBsYWNlKCdbT1ZFUkxBWV9OQU1FXScsIG5hbWUpO1xuICAgICAgICBpZiAodXNlclByb3ZpZGVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgnW09WRVJMQVlfVEVNUExBVEVdJywgdXNlclByb3ZpZGVkVGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKCdbT1ZFUkxBWV9URU1QTEFURV0nLCBkZWZhdWx0VGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuY3JlYXRlTG9hZGluZ092ZXJsYXlUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVzZXJQcm92aWRlZFRlbXBsYXRlID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0T3ZlcmxheUxvYWRpbmdUZW1wbGF0ZSgpO1xuICAgICAgICB2YXIgdGVtcGxhdGVOb3RMb2NhbGlzZWQgPSB0aGlzLmNyZWF0ZU92ZXJsYXlUZW1wbGF0ZSgnbG9hZGluZycsIExPQURJTkdfT1ZFUkxBWV9URU1QTEFURSwgdXNlclByb3ZpZGVkVGVtcGxhdGUpO1xuICAgICAgICB2YXIgbG9jYWxlVGV4dEZ1bmMgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRMb2NhbGVUZXh0RnVuYygpO1xuICAgICAgICB2YXIgdGVtcGxhdGVMb2NhbGlzZWQgPSB0ZW1wbGF0ZU5vdExvY2FsaXNlZC5yZXBsYWNlKCdbTE9BRElORy4uLl0nLCBsb2NhbGVUZXh0RnVuYygnbG9hZGluZ09vbycsICdMb2FkaW5nLi4uJykpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVMb2NhbGlzZWQ7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmNyZWF0ZU5vUm93c092ZXJsYXlUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVzZXJQcm92aWRlZFRlbXBsYXRlID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0T3ZlcmxheU5vUm93c1RlbXBsYXRlKCk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZU5vdExvY2FsaXNlZCA9IHRoaXMuY3JlYXRlT3ZlcmxheVRlbXBsYXRlKCduby1yb3dzJywgTk9fUk9XU19UT19TSE9XX09WRVJMQVlfVEVNUExBVEUsIHVzZXJQcm92aWRlZFRlbXBsYXRlKTtcbiAgICAgICAgdmFyIGxvY2FsZVRleHRGdW5jID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TG9jYWxlVGV4dEZ1bmMoKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlTG9jYWxpc2VkID0gdGVtcGxhdGVOb3RMb2NhbGlzZWQucmVwbGFjZSgnW05PX1JPV1NfVE9fU0hPV10nLCBsb2NhbGVUZXh0RnVuYygnbm9Sb3dzVG9TaG93JywgJ05vIFJvd3MgVG8gU2hvdycpKTtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlTG9jYWxpc2VkO1xuICAgIH07XG4gICAgLy8gVmFsaWQgdmFsdWVzIGZvciBwb3NpdGlvbiBhcmUgYm90dG9tLCBtaWRkbGUgYW5kIHRvcFxuICAgIC8vIHBvc2l0aW9uIHNob3VsZCBiZSB7J3RvcCcsJ21pZGRsZScsJ2JvdHRvbScsIG9yIHVuZGVmaW5lZC9udWxsfS5cbiAgICAvLyBpZiB1bmRlZmluZWQvbnVsbCwgdGhlbiB0aGUgZ3JpZCB3aWxsIHRvIHRoZSBtaW5pbWFsIGFtb3VudCBvZiBzY3JvbGxpbmcsXG4gICAgLy8gZWcgaWYgZ3JpZCBuZWVkcyB0byBzY3JvbGwgdXAsIGl0IHNjcm9sbHMgdW50aWwgcm93IGlzIG9uIHRvcCxcbiAgICAvLyAgICBpZiBncmlkIG5lZWRzIHRvIHNjcm9sbCBkb3duLCBpdCBzY3JvbGxzIHVudGlsIHJvdyBpcyBvbiBib3R0b20sXG4gICAgLy8gICAgaWYgcm93IGlzIGFscmVhZHkgaW4gdmlldywgZ3JpZCBkb2VzIG5vdCBzY3JvbGxcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmVuc3VyZUluZGV4VmlzaWJsZSA9IGZ1bmN0aW9uIChpbmRleCwgcG9zaXRpb24pIHtcbiAgICAgICAgLy8gaWYgZm9yIHByaW50LCBldmVyeXRoaW5nIGlzIGFsd2F5cyB2aXNpYmxlXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0ZvclByaW50KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ2Vuc3VyZUluZGV4VmlzaWJsZTogJyArIGluZGV4KTtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0VG90YWxSb3dDb3VudCgpO1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gcm93Q291bnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaW52YWxpZCByb3cgaW5kZXggZm9yIGVuc3VyZUluZGV4VmlzaWJsZTogJyArIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhZ2luYXRpb25Qcm94eS5nb1RvUGFnZVdpdGhJbmRleChpbmRleCk7XG4gICAgICAgIHZhciBub2RlQXRJbmRleCA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFJvdyhpbmRleCk7XG4gICAgICAgIHZhciBwaXhlbE9mZnNldCA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFBpeGVsT2Zmc2V0KCk7XG4gICAgICAgIHZhciByb3dUb3BQaXhlbCA9IG5vZGVBdEluZGV4LnJvd1RvcCAtIHBpeGVsT2Zmc2V0O1xuICAgICAgICB2YXIgcm93Qm90dG9tUGl4ZWwgPSByb3dUb3BQaXhlbCArIG5vZGVBdEluZGV4LnJvd0hlaWdodDtcbiAgICAgICAgdmFyIHZSYW5nZSA9IHRoaXMuZ2V0VmVydGljYWxQaXhlbFJhbmdlKCk7XG4gICAgICAgIHZhciB2UmFuZ2VUb3AgPSB2UmFuZ2UudG9wO1xuICAgICAgICB2YXIgdlJhbmdlQm90dG9tID0gdlJhbmdlLmJvdHRvbTtcbiAgICAgICAgdmFyIHNjcm9sbFNob3dpbmcgPSB0aGlzLmlzSG9yaXpvbnRhbFNjcm9sbFNob3dpbmcoKTtcbiAgICAgICAgaWYgKHNjcm9sbFNob3dpbmcpIHtcbiAgICAgICAgICAgIHZSYW5nZUJvdHRvbSAtPSB0aGlzLnNjcm9sbFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3dUb0hpZ2hsaWdodEhlaWdodCA9IHJvd0JvdHRvbVBpeGVsIC0gcm93VG9wUGl4ZWw7XG4gICAgICAgIHZhciB2aWV3cG9ydEhlaWdodCA9IHZSYW5nZUJvdHRvbSAtIHZSYW5nZVRvcDtcbiAgICAgICAgdmFyIGhhbGZTY3JlZW5IZWlnaHQgPSAodmlld3BvcnRIZWlnaHQgLyAyKSArIChyb3dUb0hpZ2hsaWdodEhlaWdodCAvIDIpO1xuICAgICAgICB2YXIgZVZpZXdwb3J0VG9TY3JvbGwgPSB0aGlzLmdldFByaW1hcnlTY3JvbGxWaWV3cG9ydCgpO1xuICAgICAgICB2YXIgbmV3U2Nyb2xsUG9zaXRpb247XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgbmV3U2Nyb2xsUG9zaXRpb24gPSByb3dUb3BQaXhlbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgbmV3U2Nyb2xsUG9zaXRpb24gPSByb3dCb3R0b21QaXhlbCAtIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICBuZXdTY3JvbGxQb3NpdGlvbiA9IGhhbGZTY3JlZW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGlmL2Vsc2UgbG9naWMgaGVyZSBwcm90ZWN0cyB1cyBmcm9tIG92ZXIgc2Nyb2xsaW5nXG4gICAgICAgICAgICAgICAgLy8gaWU6IFRyeWluZyB0byBzY3JvbGwgcGFzdCB0aGUgcm93IChpZSBlbnN1cmVOb2RlVmlzaWJsZSAoMCwgJ21pZGRsZScpKVxuICAgICAgICAgICAgICAgIG5ld1Njcm9sbFBvc2l0aW9uID0gbmV3U2Nyb2xsUG9zaXRpb24gPiByb3dUb3BQaXhlbCA/IHJvd1RvcFBpeGVsIDogbmV3U2Nyb2xsUG9zaXRpb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG5ld1Njcm9sbFBvc2l0aW9uID0gcm93VG9wUGl4ZWw7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0U2Nyb2xsZWRQYXN0Um93ID0gdlJhbmdlVG9wID4gcm93VG9wUGl4ZWw7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0U2Nyb2xsZWRCZWZvcmVSb3cgPSB2UmFuZ2VCb3R0b20gPCByb3dCb3R0b21QaXhlbDtcbiAgICAgICAgICAgICAgICBpZiAodmlld3BvcnRTY3JvbGxlZFBhc3RSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgcm93IGlzIGJlZm9yZSwgc2Nyb2xsIHVwIHdpdGggcm93IGF0IHRvcFxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JvbGxQb3NpdGlvbiA9IHJvd1RvcFBpeGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2aWV3cG9ydFNjcm9sbGVkQmVmb3JlUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHJvdyBpcyBiZWxvdywgc2Nyb2xsIGRvd24gd2l0aCByb3cgYXQgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydEhlaWdodF8xID0gdlJhbmdlQm90dG9tIC0gdlJhbmdlVG9wO1xuICAgICAgICAgICAgICAgICAgICBuZXdTY3JvbGxQb3NpdGlvbiA9IHJvd0JvdHRvbVBpeGVsIC0gdmlld3BvcnRIZWlnaHRfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJvdyBhbHJlYWR5IGluIHZpZXcsIGFuZCB0b3AvbWlkZGxlL2JvdHRvbSBub3Qgc3BlY2lmaWVkLCBzbyBkbyBub3RoaW5nLlxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhlIHJvdyBpcyBhbHJlYWR5IGluIHZpZXcsIGFuZCB3ZSBkb24ndCBuZWVkIHRvIHNjcm9sbFxuICAgICAgICBpZiAobmV3U2Nyb2xsUG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlVmlld3BvcnRUb1Njcm9sbC5zY3JvbGxUb3AgPSBuZXdTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5yb3dSZW5kZXJlci5yZWRyYXdBZnRlclNjcm9sbCgpO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5nZXRQcmltYXJ5U2Nyb2xsVmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVJ0bCAmJiB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nTGVmdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lUGlubmVkTGVmdENvbHNWaWV3cG9ydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5lbmFibGVSdGwgJiYgdGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGlubmluZ1JpZ2h0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVQaW5uZWRSaWdodENvbHNWaWV3cG9ydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVCb2R5Vmlld3BvcnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICsgbW92ZUNvbHVtbkNvbnRyb2xsZXJcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmdldENlbnRlcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lQm9keVZpZXdwb3J0LmNsaWVudFdpZHRoO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5pc0hvcml6b250YWxTY3JvbGxTaG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdXRpbHNfMS5VdGlscy5pc0hvcml6b250YWxTY3JvbGxTaG93aW5nKHRoaXMuZUJvZHlWaWV3cG9ydCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmlzVmVydGljYWxTY3JvbGxTaG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGlubmluZ1JpZ2h0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLlV0aWxzLmlzVmVydGljYWxTY3JvbGxTaG93aW5nKHRoaXMuZVBpbm5lZFJpZ2h0Q29sc1ZpZXdwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLlV0aWxzLmlzVmVydGljYWxTY3JvbGxTaG93aW5nKHRoaXMuZUJvZHlWaWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuaXNCb2R5VmVydGljYWxTY3JvbGxTaG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpZiB0aGUgc2Nyb2xsIGlzIG9uIHRoZSBwaW5uZWQgcGFuZWwsIHRoZW4gaXQgaXMgbmV2ZXIgaW4gdGhlIGNlbnRlciBwYW5lbC5cbiAgICAgICAgLy8gaWYgTFJULCB0aGVuIHBpbm5pbmcgcmlnaHQgbWVhbnMgc2Nyb2xsIE5PVCBvbiBjZW50ZXJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVJ0bCAmJiB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nUmlnaHQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIFJUTCwgdGhlbiBwaW5uaW5nIGxlZnQgbWVhbnMgc2Nyb2xsIE5PVCBvbiBjZW50ZXJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUnRsICYmIHRoaXMuY29sdW1uQ29udHJvbGxlci5pc1Bpbm5pbmdMZWZ0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHNfMS5VdGlscy5pc1ZlcnRpY2FsU2Nyb2xsU2hvd2luZyh0aGlzLmVCb2R5Vmlld3BvcnQpO1xuICAgIH07XG4gICAgLy8gZ2V0cyBjYWxsZWQgZXZlcnkgNTAwIG1zLiB3ZSB1c2UgdGhpcyB0byBzZXQgcGFkZGluZyBvbiByaWdodCBwaW5uZWQgY29sdW1uXG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5wZXJpb2RpY2FsbHlDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEJvdHRvbVBhZGRpbmdPblBpbm5lZFJpZ2h0KCk7XG4gICAgICAgIHRoaXMuc2V0TWFyZ2luT25GdWxsV2lkdGhDZWxsQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsU2hvd2luZygpO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5zZXRTY3JvbGxTaG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgdkJvZHk6IGZhbHNlLFxuICAgICAgICAgICAgaEJvZHk6IGZhbHNlLFxuICAgICAgICAgICAgdlBpbm5lZExlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgdlBpbm5lZFJpZ2h0OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5lbmFibGVSdGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nTGVmdCgpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnZQaW5uZWRMZWZ0ID0gdGhpcy5mb3JQcmludCA/IGZhbHNlIDogdXRpbHNfMS5VdGlscy5pc1ZlcnRpY2FsU2Nyb2xsU2hvd2luZyh0aGlzLmVQaW5uZWRMZWZ0Q29sc1ZpZXdwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy52Qm9keSA9IHV0aWxzXzEuVXRpbHMuaXNWZXJ0aWNhbFNjcm9sbFNob3dpbmcodGhpcy5lQm9keVZpZXdwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nUmlnaHQoKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy52UGlubmVkUmlnaHQgPSB0aGlzLmZvclByaW50ID8gZmFsc2UgOiB1dGlsc18xLlV0aWxzLmlzVmVydGljYWxTY3JvbGxTaG93aW5nKHRoaXMuZVBpbm5lZFJpZ2h0Q29sc1ZpZXdwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy52Qm9keSA9IHV0aWxzXzEuVXRpbHMuaXNWZXJ0aWNhbFNjcm9sbFNob3dpbmcodGhpcy5lQm9keVZpZXdwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaEJvZHkgPSB1dGlsc18xLlV0aWxzLmlzSG9yaXpvbnRhbFNjcm9sbFNob3dpbmcodGhpcy5lQm9keVZpZXdwb3J0KTtcbiAgICAgICAgdGhpcy5zY3JvbGxWaXNpYmxlU2VydmljZS5zZXRTY3JvbGxzVmlzaWJsZShwYXJhbXMpO1xuICAgIH07XG4gICAgLy8gdGhlIHBpbm5lZCBjb250YWluZXIgbmVlZHMgZXh0cmEgc3BhY2UgYXQgdGhlIGJvdHRvbSwgc29tZSBibGFuayBzcGFjZSwgb3RoZXJ3aXNlIHdoZW5cbiAgICAvLyB2ZXJ0aWNhbGx5IHNjcm9sbGVkIGFsbCB0aGUgd2F5IGRvd24sIHRoZSBsYXN0IHJvdyB3aWxsIGJlIGhpZGRlbiBiZWhpbmQgdGhlIHNjcm9sbHMuXG4gICAgLy8gdGhpcyBleHRyYSBwYWRkaW5nIGFsbG93cyB0aGUgbGFzdCByb3cgdG8gYmUgbGlmdGVkIGFib3ZlIHRoZSBib3R0b20gc2Nyb2xsYmFyLlxuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuc2V0Qm90dG9tUGFkZGluZ09uUGlubmVkUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvclByaW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uQ29udHJvbGxlci5pc1Bpbm5pbmdSaWdodCgpKSB7XG4gICAgICAgICAgICB2YXIgYm9keUhvcml6b250YWxTY3JvbGxTaG93aW5nID0gdGhpcy5lQm9keVZpZXdwb3J0LmNsaWVudFdpZHRoIDwgdGhpcy5lQm9keVZpZXdwb3J0LnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgaWYgKGJvZHlIb3Jpem9udGFsU2Nyb2xsU2hvd2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZVBpbm5lZFJpZ2h0Q29sc0NvbnRhaW5lci5zdHlsZS5tYXJnaW5Cb3R0b20gPSB0aGlzLnNjcm9sbFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZVBpbm5lZFJpZ2h0Q29sc0NvbnRhaW5lci5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5zZXRNYXJnaW5PbkZ1bGxXaWR0aENlbGxDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvclByaW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgZWl0aGVyIHJpZ2h0IG9yIGJvdHRvbSBzY3JvbGxiYXJzIGFyZSBzaG93aW5nLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgLy8gZnVsbFdpZHRoQ2VsbCBwYW5lbCBpc24ndCBjb3ZlcmluZyB0aGUgc2Nyb2xsYmFycy4gb3JpZ2luYWxseSBpIHRyaWVkIHRvIGRvIHRoaXMgdXNpbmdcbiAgICAgICAgLy8gbWFyZ2luLCBidXQgdGhlIG92ZXJmbG93IHdhcyBub3QgZ2V0dGluZyBjbGlwcGVkIGFuZCBnb2luZyBpbnRvIHRoZSBtYXJnaW4sXG4gICAgICAgIC8vIHNvIHVzZWQgYm9yZGVyIGluc3RlYWQuIGR1bm5vIHdoeSBpdCB3b3JrcywgdHJpYWwgYW5kIGVycm9yIGZvdW5kIHRoZSBzb2x1dGlvbi5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUnRsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsU2Nyb2xsU2hvd2luZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lRnVsbFdpZHRoQ2VsbFZpZXdwb3J0LnN0eWxlLmJvcmRlckxlZnQgPSB0aGlzLnNjcm9sbFdpZHRoICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZUZ1bGxXaWR0aENlbGxWaWV3cG9ydC5zdHlsZS5ib3JkZXJMZWZ0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsU2Nyb2xsU2hvd2luZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lRnVsbFdpZHRoQ2VsbFZpZXdwb3J0LnN0eWxlLmJvcmRlclJpZ2h0ID0gdGhpcy5zY3JvbGxXaWR0aCArICdweCBzb2xpZCB0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVGdWxsV2lkdGhDZWxsVmlld3BvcnQuc3R5bGUuYm9yZGVyUmlnaHQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWxTY3JvbGxTaG93aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZUZ1bGxXaWR0aENlbGxWaWV3cG9ydC5zdHlsZS5ib3JkZXJCb3R0b20gPSB0aGlzLnNjcm9sbFdpZHRoICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZUZ1bGxXaWR0aENlbGxWaWV3cG9ydC5zdHlsZS5ib3JkZXJCb3R0b20gPSAnJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5lbnN1cmVDb2x1bW5WaXNpYmxlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvLyBpZiBmb3IgcHJpbnQsIGV2ZXJ5dGhpbmcgaXMgYWx3YXlzIHZpc2libGVcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0R3JpZENvbHVtbihrZXkpO1xuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4uaXNQaW5uZWQoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdjYWxsaW5nIGVuc3VyZUluZGV4VmlzaWJsZSBvbiBhICcgKyBjb2x1bW4uZ2V0UGlubmVkKCkgKyAnIHBpbm5lZCBjb2x1bW4gZG9lc25cXCd0IG1ha2Ugc2Vuc2UgZm9yIGNvbHVtbiAnICsgY29sdW1uLmdldENvbElkKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW5Db250cm9sbGVyLmlzQ29sdW1uRGlzcGxheWVkKGNvbHVtbikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignY29sdW1uIGlzIG5vdCBjdXJyZW50bHkgdmlzaWJsZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xMZWZ0UGl4ZWwgPSBjb2x1bW4uZ2V0TGVmdCgpO1xuICAgICAgICB2YXIgY29sUmlnaHRQaXhlbCA9IGNvbExlZnRQaXhlbCArIGNvbHVtbi5nZXRBY3R1YWxXaWR0aCgpO1xuICAgICAgICB2YXIgdmlld3BvcnRXaWR0aCA9IHRoaXMuZUJvZHlWaWV3cG9ydC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIHNjcm9sbFBvc2l0aW9uID0gdGhpcy5nZXRCb2R5Vmlld3BvcnRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHZhciBib2R5V2lkdGggPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0Qm9keUNvbnRhaW5lcldpZHRoKCk7XG4gICAgICAgIHZhciB2aWV3cG9ydExlZnRQaXhlbDtcbiAgICAgICAgdmFyIHZpZXdwb3J0UmlnaHRQaXhlbDtcbiAgICAgICAgLy8gdGhlIGxvZ2ljIG9mIHdvcmtpbmcgb3V0IGxlZnQgYW5kIHJpZ2h0IHZpZXdwb3J0IHB4IGlzIGJvdGggaGVyZSBhbmQgaW4gdGhlIENvbHVtbkNvbnRyb2xsZXIsXG4gICAgICAgIC8vIG5lZWQgdG8gcmVmYWN0b3IgaXQgb3V0IHRvIG9uZSBwbGFjZVxuICAgICAgICBpZiAodGhpcy5lbmFibGVSdGwpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdFBpeGVsID0gYm9keVdpZHRoIC0gc2Nyb2xsUG9zaXRpb24gLSB2aWV3cG9ydFdpZHRoO1xuICAgICAgICAgICAgdmlld3BvcnRSaWdodFBpeGVsID0gYm9keVdpZHRoIC0gc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3cG9ydExlZnRQaXhlbCA9IHNjcm9sbFBvc2l0aW9uO1xuICAgICAgICAgICAgdmlld3BvcnRSaWdodFBpeGVsID0gdmlld3BvcnRXaWR0aCArIHNjcm9sbFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3cG9ydFNjcm9sbGVkUGFzdENvbCA9IHZpZXdwb3J0TGVmdFBpeGVsID4gY29sTGVmdFBpeGVsO1xuICAgICAgICB2YXIgdmlld3BvcnRTY3JvbGxlZEJlZm9yZUNvbCA9IHZpZXdwb3J0UmlnaHRQaXhlbCA8IGNvbFJpZ2h0UGl4ZWw7XG4gICAgICAgIHZhciBjb2xUb1NtYWxsRm9yVmlld3BvcnQgPSB2aWV3cG9ydFdpZHRoIDwgY29sdW1uLmdldEFjdHVhbFdpZHRoKCk7XG4gICAgICAgIHZhciBhbGlnbkNvbFRvTGVmdCA9IHZpZXdwb3J0U2Nyb2xsZWRQYXN0Q29sIHx8IGNvbFRvU21hbGxGb3JWaWV3cG9ydDtcbiAgICAgICAgdmFyIGFsaWduQ29sVG9SaWdodCA9IHZpZXdwb3J0U2Nyb2xsZWRCZWZvcmVDb2w7XG4gICAgICAgIGlmIChhbGlnbkNvbFRvTGVmdCkge1xuICAgICAgICAgICAgLy8gaWYgdmlld3BvcnQncyBsZWZ0IHNpZGUgaXMgYWZ0ZXIgY29sJ3MgbGVmdCBzaWRlLCBzY3JvbGwgbGVmdCB0byBwdWxsIGNvbCBpbnRvIHZpZXdwb3J0IGF0IGxlZnRcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVJ0bCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTY3JvbGxQb3NpdGlvbiA9IGJvZHlXaWR0aCAtIHZpZXdwb3J0V2lkdGggLSBjb2xMZWZ0UGl4ZWw7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRCb2R5Vmlld3BvcnRTY3JvbGxMZWZ0KG5ld1Njcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Qm9keVZpZXdwb3J0U2Nyb2xsTGVmdChjb2xMZWZ0UGl4ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsaWduQ29sVG9SaWdodCkge1xuICAgICAgICAgICAgLy8gaWYgdmlld3BvcnQncyByaWdodCBzaWRlIGlzIGJlZm9yZSBjb2wncyByaWdodCBzaWRlLCBzY3JvbGwgcmlnaHQgdG8gcHVsbCBjb2wgaW50byB2aWV3cG9ydCBhdCByaWdodFxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlUnRsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1Njcm9sbFBvc2l0aW9uID0gYm9keVdpZHRoIC0gY29sUmlnaHRQaXhlbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEJvZHlWaWV3cG9ydFNjcm9sbExlZnQobmV3U2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1Njcm9sbFBvc2l0aW9uID0gY29sUmlnaHRQaXhlbCAtIHZpZXdwb3J0V2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRCb2R5Vmlld3BvcnRTY3JvbGxMZWZ0KG5ld1Njcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgY29sIGlzIGFscmVhZHkgaW4gdmlldywgc28gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgd2lsbCBoYXBwZW4gYW55d2F5LCBhcyB0aGUgbW92ZSB3aWxsIGNhdXNlIGEgJ3Njcm9sbCcgZXZlbnQgb24gdGhlIGJvZHksIGhvd2V2ZXJcbiAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCB0aGUgZW5zdXJlQ29sdW1uVmlzaWJsZSBtZXRob2QgaXMgY2FsbGVkIGZyb20gd2l0aGluIGFnLUdyaWQgYW5kXG4gICAgICAgIC8vIHRoZSBjYWxsZXIgd2lsbCBuZWVkIHRvIGhhdmUgdGhlIGNvbHVtbnMgcmVuZGVyZWQgdG8gY29udGludWUsIHdoaWNoIHdpbGwgYmUgYmVmb3JlXG4gICAgICAgIC8vIHRoZSBldmVudCBoYXMgYmVlbiB3b3JrZWQgb24gKHdoaWNoIGlzIHRoZSBjYXNlIGZvciBjZWxsIG5hdmlnYXRpb24pLlxuICAgICAgICB0aGlzLnNldExlZnRBbmRSaWdodEJvdW5kcygpO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5zaG93TG9hZGluZ092ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc0xvYWRpbmdPdmVybGF5KCkpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0LnNob3dPdmVybGF5KCdsb2FkaW5nJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuc2hvd05vUm93c092ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc05vUm93c092ZXJsYXkoKSkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQuc2hvd092ZXJsYXkoJ25vUm93cycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmhpZGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWRlT3ZlcmxheSgpO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5nZXRXaWR0aEZvclNpemVDb2xzVG9GaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHRoaXMuZUJvZHkuY2xpZW50V2lkdGg7XG4gICAgICAgIC8vIGlmIHBpbm5pbmcgcmlnaHQsIHRoZW4gdGhlIHNjcm9sbCBiYXIgY2FuIHNob3csIGhvd2V2ZXIgZm9yIHNvbWUgcmVhc29uXG4gICAgICAgIC8vIGl0IG92ZXJsYXlzIHRoZSBncmlkIGFuZCBkb2Vzbid0IHRha2Ugc3BhY2UuIHNvIHdlIGFyZSBvbmx5IGludGVyZXN0ZWRcbiAgICAgICAgLy8gaW4gdGhlIGJvZHkgc2Nyb2xsIHNob3dpbmcuXG4gICAgICAgIHZhciByZW1vdmVWZXJ0aWNhbFNjcm9sbFdpZHRoID0gdGhpcy5pc1ZlcnRpY2FsU2Nyb2xsU2hvd2luZygpO1xuICAgICAgICBpZiAocmVtb3ZlVmVydGljYWxTY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGggLT0gdGhpcy5zY3JvbGxXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXZhaWxhYmxlV2lkdGg7XG4gICAgfTtcbiAgICAvLyBtZXRob2Qgd2lsbCBjYWxsIGl0c2VsZiBpZiBubyBhdmFpbGFibGUgd2lkdGguIHRoaXMgY292ZXJzIGlmIHRoZSBncmlkXG4gICAgLy8gaXNuJ3QgdmlzaWJsZSwgYnV0IGlzIGp1c3QgYWJvdXQgdG8gYmUgdmlzaWJsZS5cbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLnNpemVDb2x1bW5zVG9GaXQgPSBmdW5jdGlvbiAobmV4dFRpbWVvdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gdGhpcy5nZXRXaWR0aEZvclNpemVDb2xzVG9GaXQoKTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5Db250cm9sbGVyLnNpemVDb2x1bW5zVG9GaXQoYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5leHRUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2l6ZUNvbHVtbnNUb0ZpdCgxMDApO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV4dFRpbWVvdXQgPT09IDEwMCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaXplQ29sdW1uc1RvRml0KDUwMCk7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHRUaW1lb3V0ID09PSA1MDApIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2l6ZUNvbHVtbnNUb0ZpdCgtMSk7XG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZy1HcmlkOiB0cmllZCB0byBjYWxsIHNpemVDb2x1bW5zVG9GaXQoKSBidXQgdGhlIGdyaWQgaXMgY29taW5nIGJhY2sgd2l0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3plcm8gd2lkdGgsIG1heWJlIHRoZSBncmlkIGlzIG5vdCB2aXNpYmxlIHlldCBvbiB0aGUgc2NyZWVuPycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmdldEJvZHlDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVCb2R5Q29udGFpbmVyO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5nZXREcm9wVGFyZ2V0Qm9keUNvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvclByaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZUJvZHlDb250YWluZXIsIHRoaXMuZUZsb2F0aW5nVG9wQ29udGFpbmVyLCB0aGlzLmVGbG9hdGluZ0JvdHRvbUNvbnRhaW5lcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZUJvZHlWaWV3cG9ydCwgdGhpcy5lRmxvYXRpbmdUb3BWaWV3cG9ydCwgdGhpcy5lRmxvYXRpbmdCb3R0b21WaWV3cG9ydF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuZ2V0Qm9keVZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lQm9keVZpZXdwb3J0O1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5nZXREcm9wVGFyZ2V0TGVmdENvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvclByaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZVBpbm5lZExlZnRDb2xzVmlld3BvcnQsIHRoaXMuZVBpbm5lZExlZnRGbG9hdGluZ0JvdHRvbSwgdGhpcy5lUGlubmVkTGVmdEZsb2F0aW5nVG9wXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5nZXREcm9wVGFyZ2V0UGlubmVkUmlnaHRDb250YWluZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5mb3JQcmludCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmVQaW5uZWRSaWdodENvbHNWaWV3cG9ydCwgdGhpcy5lUGlubmVkUmlnaHRGbG9hdGluZ0JvdHRvbSwgdGhpcy5lUGlubmVkUmlnaHRGbG9hdGluZ1RvcF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuZ2V0SGVhZGVyQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lSGVhZGVyQ29udGFpbmVyO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5nZXRIZWFkZXJPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lSGVhZGVyT3ZlcmxheTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZVJvb3Q7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmdldFBpbm5lZExlZnRIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVQaW5uZWRMZWZ0SGVhZGVyO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5nZXRQaW5uZWRSaWdodEhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZVBpbm5lZFJpZ2h0SGVhZGVyO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5xdWVyeUh0bWxFbGVtZW50ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVSb290LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5sb2FkVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRoZSB0ZW1wbGF0ZSB3ZSB1c2UgaXMgZGlmZmVyZW50IHdoZW4gZG9pbmcgJ2ZvciBwcmludCdcbiAgICAgICAgdmFyIHRlbXBsYXRlO1xuICAgICAgICBpZiAodGhpcy5mb3JQcmludCkge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSBHUklEX1BBTkVMX0ZPUl9QUklOVF9URU1QTEFURTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gR1JJRF9QQU5FTF9BVVRPX0hFSUdIVF9URU1QTEFURTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gR1JJRF9QQU5FTF9OT1JNQUxfVEVNUExBVEU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lUm9vdCA9IHV0aWxzXzEuVXRpbHMubG9hZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuZmluZEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5mb3JQcmludCkge1xuICAgICAgICAgICAgdGhpcy5lSGVhZGVyQ29udGFpbmVyID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctaGVhZGVyLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgdGhpcy5lQm9keUNvbnRhaW5lciA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWJvZHktY29udGFpbmVyJyk7XG4gICAgICAgICAgICB0aGlzLmVGbG9hdGluZ1RvcENvbnRhaW5lciA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWZsb2F0aW5nLXRvcC1jb250YWluZXInKTtcbiAgICAgICAgICAgIHRoaXMuZUZsb2F0aW5nQm90dG9tQ29udGFpbmVyID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctZmxvYXRpbmctYm90dG9tLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgdGhpcy5lQWxsQ2VsbENvbnRhaW5lcnMgPSBbdGhpcy5lQm9keUNvbnRhaW5lciwgdGhpcy5lRmxvYXRpbmdUb3BDb250YWluZXIsIHRoaXMuZUZsb2F0aW5nQm90dG9tQ29udGFpbmVyXTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJzID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IG5ldyByb3dDb250YWluZXJDb21wb25lbnRfMS5Sb3dDb250YWluZXJDb21wb25lbnQoeyBlQ29udGFpbmVyOiB0aGlzLmVCb2R5Q29udGFpbmVyIH0pLFxuICAgICAgICAgICAgICAgIGZ1bGxXaWR0aDogbnVsbCxcbiAgICAgICAgICAgICAgICBwaW5uZWRMZWZ0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBpbm5lZFJpZ2h0OiBudWxsLFxuICAgICAgICAgICAgICAgIGZsb2F0aW5nVG9wOiBuZXcgcm93Q29udGFpbmVyQ29tcG9uZW50XzEuUm93Q29udGFpbmVyQ29tcG9uZW50KHsgZUNvbnRhaW5lcjogdGhpcy5lRmxvYXRpbmdUb3BDb250YWluZXIgfSksXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdUb3BQaW5uZWRMZWZ0OiBudWxsLFxuICAgICAgICAgICAgICAgIGZsb2F0aW5nVG9wUGlubmVkUmlnaHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdUb3BGdWxsV2lkdGg6IG51bGwsXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdCb3R0b206IG5ldyByb3dDb250YWluZXJDb21wb25lbnRfMS5Sb3dDb250YWluZXJDb21wb25lbnQoeyBlQ29udGFpbmVyOiB0aGlzLmVGbG9hdGluZ0JvdHRvbUNvbnRhaW5lciB9KSxcbiAgICAgICAgICAgICAgICBmbG9hdGluZ0JvdHRvbVBpbm5lZExlZnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdCb3R0b21QaW5uZWRSaWdodDogbnVsbCxcbiAgICAgICAgICAgICAgICBmbG9hdGluZ0JvdHRvbUZ1bGxXaXRoOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yb3dDb250YWluZXJDb21wb25lbnRzID0gY29udGFpbmVycztcbiAgICAgICAgICAgIC8vIHdoZW4gZG9pbmcgZm9yUHJpbnQsIHdlIGRvbid0IGhhdmUgYW55IGZ1bGxXaWR0aCBjb250YWluZXJzLCBpbnN0ZWFkIHdlIGFkZCBkaXJlY3RseSB0byB0aGUgbWFpblxuICAgICAgICAgICAgLy8gY29udGFpbmVycy4gdGhpcyB3b3JrcyBpbiBmb3JQcmludCBvbmx5IGFzIHRoZXJlIGFyZSBubyBwaW5uZWQgY29sdW1ucyAobm8gbmVlZCBmb3IgZnVsbFdpZHRoIHRvXG4gICAgICAgICAgICAvLyBzcGFuIHBpbm5lZCBjb2x1bW5zKSBhbmQgdGhlIHJvd3MgYXJlIGFscmVhZHkgdGhlIGZ1bGwgd2lkdGggb2YgdGhlIGdyaWQgKHRoZSByZWFzb24gZm9yIGZ1bGxXaWR0aClcbiAgICAgICAgICAgIGNvbnRhaW5lcnMuZnVsbFdpZHRoID0gY29udGFpbmVycy5ib2R5O1xuICAgICAgICAgICAgY29udGFpbmVycy5mbG9hdGluZ0JvdHRvbUZ1bGxXaXRoID0gY29udGFpbmVycy5mbG9hdGluZ0JvdHRvbTtcbiAgICAgICAgICAgIGNvbnRhaW5lcnMuZmxvYXRpbmdUb3BGdWxsV2lkdGggPSBjb250YWluZXJzLmZsb2F0aW5nVG9wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lQm9keSA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWJvZHknKTtcbiAgICAgICAgICAgIHRoaXMuZUJvZHlDb250YWluZXIgPSB0aGlzLnF1ZXJ5SHRtbEVsZW1lbnQoJy5hZy1ib2R5LWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgdGhpcy5lQm9keVZpZXdwb3J0ID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctYm9keS12aWV3cG9ydCcpO1xuICAgICAgICAgICAgdGhpcy5lQm9keVZpZXdwb3J0V3JhcHBlciA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWJvZHktdmlld3BvcnQtd3JhcHBlcicpO1xuICAgICAgICAgICAgdGhpcy5lRnVsbFdpZHRoQ2VsbENvbnRhaW5lciA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWZ1bGwtd2lkdGgtY29udGFpbmVyJyk7XG4gICAgICAgICAgICB0aGlzLmVGdWxsV2lkdGhDZWxsVmlld3BvcnQgPSB0aGlzLnF1ZXJ5SHRtbEVsZW1lbnQoJy5hZy1mdWxsLXdpZHRoLXZpZXdwb3J0Jyk7XG4gICAgICAgICAgICB0aGlzLmVQaW5uZWRMZWZ0Q29sc0NvbnRhaW5lciA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLXBpbm5lZC1sZWZ0LWNvbHMtY29udGFpbmVyJyk7XG4gICAgICAgICAgICB0aGlzLmVQaW5uZWRSaWdodENvbHNDb250YWluZXIgPSB0aGlzLnF1ZXJ5SHRtbEVsZW1lbnQoJy5hZy1waW5uZWQtcmlnaHQtY29scy1jb250YWluZXInKTtcbiAgICAgICAgICAgIHRoaXMuZVBpbm5lZExlZnRDb2xzVmlld3BvcnQgPSB0aGlzLnF1ZXJ5SHRtbEVsZW1lbnQoJy5hZy1waW5uZWQtbGVmdC1jb2xzLXZpZXdwb3J0Jyk7XG4gICAgICAgICAgICB0aGlzLmVQaW5uZWRSaWdodENvbHNWaWV3cG9ydCA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLXBpbm5lZC1yaWdodC1jb2xzLXZpZXdwb3J0Jyk7XG4gICAgICAgICAgICB0aGlzLmVQaW5uZWRMZWZ0SGVhZGVyID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctcGlubmVkLWxlZnQtaGVhZGVyJyk7XG4gICAgICAgICAgICB0aGlzLmVQaW5uZWRSaWdodEhlYWRlciA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLXBpbm5lZC1yaWdodC1oZWFkZXInKTtcbiAgICAgICAgICAgIHRoaXMuZUhlYWRlciA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWhlYWRlcicpO1xuICAgICAgICAgICAgdGhpcy5lSGVhZGVyQ29udGFpbmVyID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctaGVhZGVyLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgdGhpcy5lSGVhZGVyT3ZlcmxheSA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWhlYWRlci1vdmVybGF5Jyk7XG4gICAgICAgICAgICB0aGlzLmVIZWFkZXJWaWV3cG9ydCA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWhlYWRlci12aWV3cG9ydCcpO1xuICAgICAgICAgICAgdGhpcy5lRmxvYXRpbmdUb3AgPSB0aGlzLnF1ZXJ5SHRtbEVsZW1lbnQoJy5hZy1mbG9hdGluZy10b3AnKTtcbiAgICAgICAgICAgIHRoaXMuZVBpbm5lZExlZnRGbG9hdGluZ1RvcCA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLXBpbm5lZC1sZWZ0LWZsb2F0aW5nLXRvcCcpO1xuICAgICAgICAgICAgdGhpcy5lUGlubmVkUmlnaHRGbG9hdGluZ1RvcCA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLXBpbm5lZC1yaWdodC1mbG9hdGluZy10b3AnKTtcbiAgICAgICAgICAgIHRoaXMuZUZsb2F0aW5nVG9wQ29udGFpbmVyID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctZmxvYXRpbmctdG9wLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgdGhpcy5lRmxvYXRpbmdUb3BWaWV3cG9ydCA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWZsb2F0aW5nLXRvcC12aWV3cG9ydCcpO1xuICAgICAgICAgICAgdGhpcy5lRmxvYXRpbmdUb3BGdWxsV2lkdGhDZWxsQ29udGFpbmVyID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctZmxvYXRpbmctdG9wLWZ1bGwtd2lkdGgtY29udGFpbmVyJyk7XG4gICAgICAgICAgICB0aGlzLmVGbG9hdGluZ0JvdHRvbSA9IHRoaXMucXVlcnlIdG1sRWxlbWVudCgnLmFnLWZsb2F0aW5nLWJvdHRvbScpO1xuICAgICAgICAgICAgdGhpcy5lUGlubmVkTGVmdEZsb2F0aW5nQm90dG9tID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctcGlubmVkLWxlZnQtZmxvYXRpbmctYm90dG9tJyk7XG4gICAgICAgICAgICB0aGlzLmVQaW5uZWRSaWdodEZsb2F0aW5nQm90dG9tID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctcGlubmVkLXJpZ2h0LWZsb2F0aW5nLWJvdHRvbScpO1xuICAgICAgICAgICAgdGhpcy5lRmxvYXRpbmdCb3R0b21Db250YWluZXIgPSB0aGlzLnF1ZXJ5SHRtbEVsZW1lbnQoJy5hZy1mbG9hdGluZy1ib3R0b20tY29udGFpbmVyJyk7XG4gICAgICAgICAgICB0aGlzLmVGbG9hdGluZ0JvdHRvbVZpZXdwb3J0ID0gdGhpcy5xdWVyeUh0bWxFbGVtZW50KCcuYWctZmxvYXRpbmctYm90dG9tLXZpZXdwb3J0Jyk7XG4gICAgICAgICAgICB0aGlzLmVGbG9hdGluZ0JvdHRvbUZ1bGxXaWR0aENlbGxDb250YWluZXIgPSB0aGlzLnF1ZXJ5SHRtbEVsZW1lbnQoJy5hZy1mbG9hdGluZy1ib3R0b20tZnVsbC13aWR0aC1jb250YWluZXInKTtcbiAgICAgICAgICAgIHRoaXMuZUFsbENlbGxDb250YWluZXJzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuZVBpbm5lZExlZnRDb2xzQ29udGFpbmVyLCB0aGlzLmVQaW5uZWRSaWdodENvbHNDb250YWluZXIsIHRoaXMuZUJvZHlDb250YWluZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5lRmxvYXRpbmdUb3AsIHRoaXMuZUZsb2F0aW5nQm90dG9tLCB0aGlzLmVGdWxsV2lkdGhDZWxsQ29udGFpbmVyXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5yb3dDb250YWluZXJDb21wb25lbnRzID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IG5ldyByb3dDb250YWluZXJDb21wb25lbnRfMS5Sb3dDb250YWluZXJDb21wb25lbnQoeyBlQ29udGFpbmVyOiB0aGlzLmVCb2R5Q29udGFpbmVyLCBlVmlld3BvcnQ6IHRoaXMuZUJvZHlWaWV3cG9ydCB9KSxcbiAgICAgICAgICAgICAgICBmdWxsV2lkdGg6IG5ldyByb3dDb250YWluZXJDb21wb25lbnRfMS5Sb3dDb250YWluZXJDb21wb25lbnQoeyBlQ29udGFpbmVyOiB0aGlzLmVGdWxsV2lkdGhDZWxsQ29udGFpbmVyLCBoaWRlV2hlbk5vQ2hpbGRyZW46IHRydWUsIGVWaWV3cG9ydDogdGhpcy5lRnVsbFdpZHRoQ2VsbFZpZXdwb3J0IH0pLFxuICAgICAgICAgICAgICAgIHBpbm5lZExlZnQ6IG5ldyByb3dDb250YWluZXJDb21wb25lbnRfMS5Sb3dDb250YWluZXJDb21wb25lbnQoeyBlQ29udGFpbmVyOiB0aGlzLmVQaW5uZWRMZWZ0Q29sc0NvbnRhaW5lciwgZVZpZXdwb3J0OiB0aGlzLmVQaW5uZWRMZWZ0Q29sc1ZpZXdwb3J0IH0pLFxuICAgICAgICAgICAgICAgIHBpbm5lZFJpZ2h0OiBuZXcgcm93Q29udGFpbmVyQ29tcG9uZW50XzEuUm93Q29udGFpbmVyQ29tcG9uZW50KHsgZUNvbnRhaW5lcjogdGhpcy5lUGlubmVkUmlnaHRDb2xzQ29udGFpbmVyLCBlVmlld3BvcnQ6IHRoaXMuZVBpbm5lZFJpZ2h0Q29sc1ZpZXdwb3J0IH0pLFxuICAgICAgICAgICAgICAgIGZsb2F0aW5nVG9wOiBuZXcgcm93Q29udGFpbmVyQ29tcG9uZW50XzEuUm93Q29udGFpbmVyQ29tcG9uZW50KHsgZUNvbnRhaW5lcjogdGhpcy5lRmxvYXRpbmdUb3BDb250YWluZXIgfSksXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdUb3BQaW5uZWRMZWZ0OiBuZXcgcm93Q29udGFpbmVyQ29tcG9uZW50XzEuUm93Q29udGFpbmVyQ29tcG9uZW50KHsgZUNvbnRhaW5lcjogdGhpcy5lUGlubmVkTGVmdEZsb2F0aW5nVG9wIH0pLFxuICAgICAgICAgICAgICAgIGZsb2F0aW5nVG9wUGlubmVkUmlnaHQ6IG5ldyByb3dDb250YWluZXJDb21wb25lbnRfMS5Sb3dDb250YWluZXJDb21wb25lbnQoeyBlQ29udGFpbmVyOiB0aGlzLmVQaW5uZWRSaWdodEZsb2F0aW5nVG9wIH0pLFxuICAgICAgICAgICAgICAgIGZsb2F0aW5nVG9wRnVsbFdpZHRoOiBuZXcgcm93Q29udGFpbmVyQ29tcG9uZW50XzEuUm93Q29udGFpbmVyQ29tcG9uZW50KHsgZUNvbnRhaW5lcjogdGhpcy5lRmxvYXRpbmdUb3BGdWxsV2lkdGhDZWxsQ29udGFpbmVyLCBoaWRlV2hlbk5vQ2hpbGRyZW46IHRydWUgfSksXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdCb3R0b206IG5ldyByb3dDb250YWluZXJDb21wb25lbnRfMS5Sb3dDb250YWluZXJDb21wb25lbnQoeyBlQ29udGFpbmVyOiB0aGlzLmVGbG9hdGluZ0JvdHRvbUNvbnRhaW5lciB9KSxcbiAgICAgICAgICAgICAgICBmbG9hdGluZ0JvdHRvbVBpbm5lZExlZnQ6IG5ldyByb3dDb250YWluZXJDb21wb25lbnRfMS5Sb3dDb250YWluZXJDb21wb25lbnQoeyBlQ29udGFpbmVyOiB0aGlzLmVQaW5uZWRMZWZ0RmxvYXRpbmdCb3R0b20gfSksXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdCb3R0b21QaW5uZWRSaWdodDogbmV3IHJvd0NvbnRhaW5lckNvbXBvbmVudF8xLlJvd0NvbnRhaW5lckNvbXBvbmVudCh7IGVDb250YWluZXI6IHRoaXMuZVBpbm5lZFJpZ2h0RmxvYXRpbmdCb3R0b20gfSksXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdCb3R0b21GdWxsV2l0aDogbmV3IHJvd0NvbnRhaW5lckNvbXBvbmVudF8xLlJvd0NvbnRhaW5lckNvbXBvbmVudCh7IGVDb250YWluZXI6IHRoaXMuZUZsb2F0aW5nQm90dG9tRnVsbFdpZHRoQ2VsbENvbnRhaW5lciwgaGlkZVdoZW5Ob0NoaWxkcmVuOiB0cnVlIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYWRkTW91c2VXaGVlbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMucm93Q29udGFpbmVyQ29tcG9uZW50cywgZnVuY3Rpb24gKGtleSwgY29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC53aXJlQmVhbihjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuZ2V0Um93Q29udGFpbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93Q29udGFpbmVyQ29tcG9uZW50cztcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuYWRkTW91c2VXaGVlbEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJRTksIENocm9tZSwgU2FmYXJpLCBPcGVyYSB1c2UgJ21vdXNld2hlZWwnLCBGaXJlZm94IHVzZXMgJ0RPTU1vdXNlU2Nyb2xsJ1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVCb2R5Vmlld3BvcnQsICdtb3VzZXdoZWVsJywgdGhpcy5jZW50ZXJNb3VzZVdoZWVsTGlzdGVuZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZUJvZHlWaWV3cG9ydCwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5jZW50ZXJNb3VzZVdoZWVsTGlzdGVuZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVJ0bCkge1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lUGlubmVkUmlnaHRDb2xzVmlld3BvcnQsICdtb3VzZXdoZWVsJywgdGhpcy5nZW5lcmljTW91c2VXaGVlbExpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lUGlubmVkUmlnaHRDb2xzVmlld3BvcnQsICdET01Nb3VzZVNjcm9sbCcsIHRoaXMuZ2VuZXJpY01vdXNlV2hlZWxMaXN0ZW5lci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZVBpbm5lZExlZnRDb2xzVmlld3BvcnQsICdtb3VzZXdoZWVsJywgdGhpcy5nZW5lcmljTW91c2VXaGVlbExpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lUGlubmVkTGVmdENvbHNWaWV3cG9ydCwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5nZW5lcmljTW91c2VXaGVlbExpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmdldEhlYWRlclZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lSGVhZGVyVmlld3BvcnQ7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmNlbnRlck1vdXNlV2hlZWxMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyB3ZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIG1pbWlja2luZyB0aGUgbW91c2Ugd2hlZWwgaWYgd2UgYXJlIG5vdCBzY3JvbGxpbmcgb24gdGhlIG1pZGRsZSxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBib2R5IGhhcyBzY3JvbGxzIGFuZCB0aGUgbW91c2Ugd2hlZWwgd29ya3MgZm9yIGZyZWVcbiAgICAgICAgdmFyIGJvZHlWU2Nyb2xsU2hvd2luZyA9IHRoaXMuaXNCb2R5VmVydGljYWxTY3JvbGxBY3RpdmUoKTtcbiAgICAgICAgaWYgKCFib2R5VlNjcm9sbFNob3dpbmcpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRQYW5lbCA9IHRoaXMuZW5hYmxlUnRsID8gdGhpcy5lUGlubmVkTGVmdENvbHNWaWV3cG9ydCA6IHRoaXMuZVBpbm5lZFJpZ2h0Q29sc1ZpZXdwb3J0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhbE1vdXNlV2hlZWxMaXN0ZW5lcihldmVudCwgdGFyZ2V0UGFuZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB1c2VkIGZvciBsaXN0ZW5pbmcgdG8gbW91c2Ugd2hlZWwgZXZlbnRzIG9uIDEpIGxlZnQgcGlubmVkIGFuZCBhbHNvIHRoZSAyKSBmdWxsV2lkdGhDZWxsIGNvbXBvbmVudHMuXG4gICAgLy8gdGhlIGZ1bGxXaWR0aENlbGwgbGlzdGVuZXIgaXMgYWRkZWQgaW4gcmVuZGVyZWRSb3csIGhlbmNlIHB1YmxpYy5cbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmdlbmVyaWNNb3VzZVdoZWVsTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldFBhbmVsO1xuICAgICAgICB2YXIgYm9keVZTY3JvbGxBY3RpdmUgPSB0aGlzLmlzQm9keVZlcnRpY2FsU2Nyb2xsQWN0aXZlKCk7XG4gICAgICAgIGlmIChib2R5VlNjcm9sbEFjdGl2ZSkge1xuICAgICAgICAgICAgdGFyZ2V0UGFuZWwgPSB0aGlzLmVCb2R5Vmlld3BvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRQYW5lbCA9IHRoaXMuZW5hYmxlUnRsID8gdGhpcy5lUGlubmVkTGVmdENvbHNWaWV3cG9ydCA6IHRoaXMuZVBpbm5lZFJpZ2h0Q29sc1ZpZXdwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYWxNb3VzZVdoZWVsTGlzdGVuZXIoZXZlbnQsIHRhcmdldFBhbmVsKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuZ2VuZXJhbE1vdXNlV2hlZWxMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0UGFuZWwpIHtcbiAgICAgICAgdmFyIHdoZWVsRXZlbnQgPSB1dGlsc18xLlV0aWxzLm5vcm1hbGl6ZVdoZWVsKGV2ZW50KTtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBkZXRlY3QgaW4gd2hpY2ggZGlyZWN0aW9uIHNjcm9sbCBpcyBoYXBwZW5pbmcgdG8gYWxsb3cgdHJhY2twYWRzIHNjcm9sbCBob3Jpem9udGFsbHlcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBzY3JvbGxcbiAgICAgICAgaWYgKE1hdGguYWJzKHdoZWVsRXZlbnQucGl4ZWxYKSA+IE1hdGguYWJzKHdoZWVsRXZlbnQucGl4ZWxZKSkge1xuICAgICAgICAgICAgdmFyIG5ld0xlZnRQb3NpdGlvbiA9IHRoaXMuZUJvZHlWaWV3cG9ydC5zY3JvbGxMZWZ0ICsgd2hlZWxFdmVudC5waXhlbFg7XG4gICAgICAgICAgICB0aGlzLmVCb2R5Vmlld3BvcnQuc2Nyb2xsTGVmdCA9IG5ld0xlZnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdUb3BQb3NpdGlvbiA9IHRhcmdldFBhbmVsLnNjcm9sbFRvcCArIHdoZWVsRXZlbnQucGl4ZWxZO1xuICAgICAgICAgICAgdGFyZ2V0UGFuZWwuc2Nyb2xsVG9wID0gbmV3VG9wUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgdGhlIG9wdGlvbiB0byBwYXNzIG1vdXNlIHdoZWVsIGV2ZW50cyB0byB0aGUgYnJvd3NlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYWctZ3JpZC9hZy1ncmlkL2lzc3Vlcy84MDBcbiAgICAgICAgLy8gaW4gdGhlIGZ1dHVyZSwgdGhpcyBzaG91bGQgYmUgdGllZCBpbiB3aXRoICdmb3JQcmludCcgb3B0aW9uLCBvciBoYXZlIGFuIG9wdGlvbiAnbm8gdmVydGljYWwgc2Nyb2xscydcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzUHJldmVudERlZmF1bHRPbk1vdXNlV2hlZWwoKSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgcHJldmVudCBkZWZhdWx0LCB0aGVuIHRoZSB3aG9sZSBicm93c2VyIHdpbGwgc2Nyb2xsIGFsc28gYXMgd2VsbCBhcyB0aGUgZ3JpZFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLm9uRGlzcGxheWVkQ29sdW1uc0NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0UGlubmVkQ29udGFpbmVyc1Zpc2libGUoKTtcbiAgICAgICAgdGhpcy5zZXRCb2R5QW5kSGVhZGVySGVpZ2h0cygpO1xuICAgICAgICB0aGlzLnNldExlZnRBbmRSaWdodEJvdW5kcygpO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5vbkRpc3BsYXllZENvbHVtbnNXaWR0aENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0V2lkdGhzT2ZDb250YWluZXJzKCk7XG4gICAgICAgIHRoaXMuc2V0TGVmdEFuZFJpZ2h0Qm91bmRzKCk7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVJ0bCkge1xuICAgICAgICAgICAgLy8gYmVjYXVzZSBSVEwgaXMgYWxsIGJhY2t3YXJkcywgYSBjaGFuZ2UgaW4gdGhlIHdpZHRoIG9mIHRoZSByb3dcbiAgICAgICAgICAgIC8vIGNhbiBjYXVzZSBhIGNoYW5nZSBpbiB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aXRob3V0IGEgc2Nyb2xsIGV2ZW50LFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIFJUTCBpcyBhIGZ1bmN0aW9uIHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gdGhlIHdpZHRoLiB0byBiZSBjb252aW5jZWQgb2YgdGhpcywgdGFrZSBvdXQgdGhpcyBsaW5lLCBlbmFibGUgUlRMLFxuICAgICAgICAgICAgLy8gc2Nyb2xsIGFsbCB0aGUgd2F5IHRvIHRoZSBsZWZ0IGFuZCB0aGVuIHJlc2l6ZSBhIGNvbHVtblxuICAgICAgICAgICAgdGhpcy5ob3Jpem9udGFsbHlTY3JvbGxIZWFkZXJDZW50ZXJBbmRGbG9hdGluZ0NlbnRlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLm9uU2Nyb2xsVmlzaWJpbGl0eUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0V2lkdGhzT2ZDb250YWluZXJzKCk7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLnNldFdpZHRoc09mQ29udGFpbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1haW5Sb3dXaWR0aCA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRCb2R5Q29udGFpbmVyV2lkdGgoKSArICdweCc7XG4gICAgICAgIHRoaXMuZUJvZHlDb250YWluZXIuc3R5bGUud2lkdGggPSBtYWluUm93V2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmZvclByaW50KSB7XG4gICAgICAgICAgICAvLyBwaW5uZWQgY29sIGRvZXNuJ3QgZXhpc3Qgd2hlbiBkb2luZyBmb3JQcmludFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZUZsb2F0aW5nQm90dG9tQ29udGFpbmVyLnN0eWxlLndpZHRoID0gbWFpblJvd1dpZHRoO1xuICAgICAgICB0aGlzLmVGbG9hdGluZ1RvcENvbnRhaW5lci5zdHlsZS53aWR0aCA9IG1haW5Sb3dXaWR0aDtcbiAgICAgICAgdGhpcy5zZXRQaW5uZWRMZWZ0V2lkdGgoKTtcbiAgICAgICAgdGhpcy5zZXRQaW5uZWRSaWdodFdpZHRoKCk7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLnNldFBpbm5lZExlZnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBpbm5lZExlZnRXaWR0aCA9IHRoaXMuc2Nyb2xsVmlzaWJsZVNlcnZpY2UuZ2V0UGlubmVkTGVmdFdpZHRoKCkgKyAncHgnO1xuICAgICAgICB2YXIgcGlubmVkTGVmdFdpZHRoV2l0aFNjcm9sbCA9IHRoaXMuc2Nyb2xsVmlzaWJsZVNlcnZpY2UuZ2V0UGlubmVkTGVmdFdpdGhTY3JvbGxXaWR0aCgpICsgJ3B4JztcbiAgICAgICAgdGhpcy5lUGlubmVkTGVmdENvbHNWaWV3cG9ydC5zdHlsZS53aWR0aCA9IHBpbm5lZExlZnRXaWR0aFdpdGhTY3JvbGw7XG4gICAgICAgIHRoaXMuZUJvZHlWaWV3cG9ydFdyYXBwZXIuc3R5bGUubWFyZ2luTGVmdCA9IHBpbm5lZExlZnRXaWR0aFdpdGhTY3JvbGw7XG4gICAgICAgIHRoaXMuZVBpbm5lZExlZnRGbG9hdGluZ0JvdHRvbS5zdHlsZS53aWR0aCA9IHBpbm5lZExlZnRXaWR0aFdpdGhTY3JvbGw7XG4gICAgICAgIHRoaXMuZVBpbm5lZExlZnRGbG9hdGluZ1RvcC5zdHlsZS53aWR0aCA9IHBpbm5lZExlZnRXaWR0aFdpdGhTY3JvbGw7XG4gICAgICAgIHRoaXMuZVBpbm5lZExlZnRDb2xzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gcGlubmVkTGVmdFdpZHRoO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5zZXRQaW5uZWRSaWdodFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGlubmVkUmlnaHRXaWR0aCA9IHRoaXMuc2Nyb2xsVmlzaWJsZVNlcnZpY2UuZ2V0UGlubmVkUmlnaHRXaWR0aCgpICsgJ3B4JztcbiAgICAgICAgdmFyIHBpbm5lZFJpZ2h0V2lkdGhXaXRoU2Nyb2xsID0gdGhpcy5zY3JvbGxWaXNpYmxlU2VydmljZS5nZXRQaW5uZWRSaWdodFdpdGhTY3JvbGxXaWR0aCgpICsgJ3B4JztcbiAgICAgICAgdGhpcy5lUGlubmVkUmlnaHRDb2xzVmlld3BvcnQuc3R5bGUud2lkdGggPSBwaW5uZWRSaWdodFdpZHRoV2l0aFNjcm9sbDtcbiAgICAgICAgdGhpcy5lQm9keVZpZXdwb3J0V3JhcHBlci5zdHlsZS5tYXJnaW5SaWdodCA9IHBpbm5lZFJpZ2h0V2lkdGhXaXRoU2Nyb2xsO1xuICAgICAgICB0aGlzLmVQaW5uZWRSaWdodEZsb2F0aW5nQm90dG9tLnN0eWxlLndpZHRoID0gcGlubmVkUmlnaHRXaWR0aFdpdGhTY3JvbGw7XG4gICAgICAgIHRoaXMuZVBpbm5lZFJpZ2h0RmxvYXRpbmdUb3Auc3R5bGUud2lkdGggPSBwaW5uZWRSaWdodFdpZHRoV2l0aFNjcm9sbDtcbiAgICAgICAgdGhpcy5lUGlubmVkUmlnaHRDb2xzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gcGlubmVkUmlnaHRXaWR0aDtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuc2V0UGlubmVkQ29udGFpbmVyc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gZG8gdGhpcyBpZiBub3QgdXNpbmcgc2Nyb2xsc1xuICAgICAgICBpZiAodGhpcy5mb3JQcmludCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFuZ2VEZXRlY3RlZCA9IGZhbHNlO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgdiBzY3JvbGxpbmcsIHRoZW4gb25lIG9mIHRoZXNlIHdpbGwgaGF2ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICAvLyB3ZSB1cyB0aGlzIGluc2lkZSB0aGUgaWYoY2hhbmdlZERldGVjdGVkKSwgc28gd2UgZG9uJ3QgYWx3YXlzIHVzZSBpdCwgaG93ZXZlclxuICAgICAgICAvLyBpdCBpcyBjaGFuZ2VkIHdoZW4gd2UgbWFrZSBhIHBpbm5lZCBwYW5lbCBub3QgdmlzaWJsZSwgc28gd2UgaGF2ZSB0byBjaGVjayBpdFxuICAgICAgICAvLyBiZWZvcmUgd2UgY2hhbmdlIGRpc3BsYXkgb24gdGhlIHBpbm5lZCBwYW5lbHNcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IE1hdGgubWF4KHRoaXMuZUJvZHlWaWV3cG9ydC5zY3JvbGxUb3AsIHRoaXMuZVBpbm5lZExlZnRDb2xzVmlld3BvcnQuc2Nyb2xsVG9wLCB0aGlzLmVQaW5uZWRSaWdodENvbHNWaWV3cG9ydC5zY3JvbGxUb3ApO1xuICAgICAgICB2YXIgc2hvd0xlZnRQaW5uZWQgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nTGVmdCgpO1xuICAgICAgICBpZiAoc2hvd0xlZnRQaW5uZWQgIT09IHRoaXMucGlubmluZ0xlZnQpIHtcbiAgICAgICAgICAgIHRoaXMucGlubmluZ0xlZnQgPSBzaG93TGVmdFBpbm5lZDtcbiAgICAgICAgICAgIHRoaXMuZVBpbm5lZExlZnRIZWFkZXIuc3R5bGUuZGlzcGxheSA9IHNob3dMZWZ0UGlubmVkID8gJ2lubGluZS1ibG9jaycgOiAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmVQaW5uZWRMZWZ0Q29sc1ZpZXdwb3J0LnN0eWxlLmRpc3BsYXkgPSBzaG93TGVmdFBpbm5lZCA/ICdpbmxpbmUnIDogJ25vbmUnO1xuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG93UmlnaHRQaW5uZWQgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nUmlnaHQoKTtcbiAgICAgICAgaWYgKHNob3dSaWdodFBpbm5lZCAhPT0gdGhpcy5waW5uaW5nUmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMucGlubmluZ1JpZ2h0ID0gc2hvd1JpZ2h0UGlubmVkO1xuICAgICAgICAgICAgdGhpcy5lUGlubmVkUmlnaHRIZWFkZXIuc3R5bGUuZGlzcGxheSA9IHNob3dSaWdodFBpbm5lZCA/ICdpbmxpbmUtYmxvY2snIDogJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5lUGlubmVkUmlnaHRDb2xzVmlld3BvcnQuc3R5bGUuZGlzcGxheSA9IHNob3dSaWdodFBpbm5lZCA/ICdpbmxpbmUnIDogJ25vbmUnO1xuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VEZXRlY3RlZCkge1xuICAgICAgICAgICAgdmFyIGJvZHlWU2Nyb2xsQWN0aXZlID0gdGhpcy5pc0JvZHlWZXJ0aWNhbFNjcm9sbEFjdGl2ZSgpO1xuICAgICAgICAgICAgdGhpcy5lQm9keVZpZXdwb3J0LnN0eWxlLm92ZXJmbG93WSA9IGJvZHlWU2Nyb2xsQWN0aXZlID8gJ2F1dG8nIDogJ2hpZGRlbic7XG4gICAgICAgICAgICAvLyB0aGUgYm9keSBlaXRoZXIgdXNlcyBpdCdzIHNjcm9sbCAod2hlbiBzY3JvbGxpbmcpIG9yIGl0J3Mgc3R5bGUudG9wXG4gICAgICAgICAgICAvLyAod2hlbiBmb2xsb3dpbmcgdGhlIHNjcm9sbCBvZiBhIHBpbm5lZCBzZWN0aW9uKSwgc28gd2UgbmVlZCB0byBzZXQgaXRcbiAgICAgICAgICAgIC8vIGJhY2sgd2hlbiBjaGFuZ2luZyBmcm9tIG9uZSB0byB0aGUgb3RoZXJcbiAgICAgICAgICAgIGlmIChib2R5VlNjcm9sbEFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmFrZVNjcm9sbCh0aGlzLmVCb2R5Q29udGFpbmVyLCAwKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmVCb2R5Q29udGFpbmVyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lQm9keVZpZXdwb3J0LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3aGVuIGNoYW5naW5nIHRoZSBwcmltYXJ5IHNjcm9sbCB2aWV3cG9ydCwgd2UgY29weSBvdmVyIHRoZSBzY3JvbGwgcG9zaXRpb24sXG4gICAgICAgICAgICAvLyBlZyBpZiBib2R5IHdhcyBnZXR0aW5nIHNjcm9sbGVkIGFuZCB3ZSB3ZXJlIGF0IHBvc2l0aW9uIDEwMHB4LCB0aGVuIHdlIHN0YXJ0XG4gICAgICAgICAgICAvLyBwaW5uaW5nIGFuZCBwaW5uZWQgdmlld3BvcnQgaXMgbm93IHRoZSBwcmltYXJ5LCB3ZSBuZWVkIHRvIHNldCBpdCB0byAxMDBweFxuICAgICAgICAgICAgdmFyIHByaW1hcnlTY3JvbGxWaWV3cG9ydCA9IHRoaXMuZ2V0UHJpbWFyeVNjcm9sbFZpZXdwb3J0KCk7XG4gICAgICAgICAgICBwcmltYXJ5U2Nyb2xsVmlld3BvcnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgLy8gdGhpcyBhZGp1c3RzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgYWxsIHRoZSBmYWtpbmcgcGFuZWxzLiB0aGV5IHNob3VsZCBhbHJlYWR5XG4gICAgICAgICAgICAvLyBiZSBjb3JyZWN0IGV4Y2VwdCBib2R5IHdoaWNoIGhhcyBwb3RlbnRpYWxseSBqdXN0IHR1cm5lZCB0byBiZSBmYWtlLlxuICAgICAgICAgICAgdGhpcy5mYWtlVmVydGljYWxTY3JvbGwoc2Nyb2xsVG9wKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gaW5pdCwgbGF5b3V0Q2hhbmdlZCwgZmxvYXRpbmdEYXRhQ2hhbmdlZCwgaGVhZGVySGVpZ2h0Q2hhbmdlZFxuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuc2V0Qm9keUFuZEhlYWRlckhlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvclByaW50KSB7XG4gICAgICAgICAgICAvLyBpZiBkb2luZyAnZm9yIHByaW50JyBvciAnYXV0byBoZWlnaHQnLCB0aGVuIHRoZSBoZWFkZXIgYW5kIGZvb3RlcnMgYXJlIGxhaWRcbiAgICAgICAgICAgIC8vIG91dCBuYXR1cmFsbHkgYnkgdGhlIGJyb3dzZXIuIGl0J3Mgd2hhdGV2ZXIgaGVpZ2h0IHRoYXQncyBuZWVkZWQgdG8gZml0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWlnaHRPZkNvbnRhaW5lciA9IHRoaXMubGF5b3V0LmdldENlbnRyZUhlaWdodCgpO1xuICAgICAgICBpZiAoIWhlaWdodE9mQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciB0b3RhbEhlYWRlckhlaWdodDtcbiAgICAgICAgdmFyIG51bWJlck9mRmxvYXRpbmcgPSAwO1xuICAgICAgICB2YXIgZ3JvdXBIZWlnaHQ7XG4gICAgICAgIHZhciBoZWFkZXJIZWlnaHQ7XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGl2b3RNb2RlKCkpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlQ3NzQ2xhc3ModGhpcy5lSGVhZGVyLCAnYWctcGl2b3Qtb24nKTtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkQ3NzQ2xhc3ModGhpcy5lSGVhZGVyLCAnYWctcGl2b3Qtb2ZmJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNGbG9hdGluZ0ZpbHRlcigpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUm93Q291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWJlck9mRmxvYXRpbmcgPSAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNGbG9hdGluZ0ZpbHRlcigpKSA/IDEgOiAwO1xuICAgICAgICAgICAgZ3JvdXBIZWlnaHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRHcm91cEhlYWRlckhlaWdodCgpO1xuICAgICAgICAgICAgaGVhZGVySGVpZ2h0ID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0SGVhZGVySGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUNzc0NsYXNzKHRoaXMuZUhlYWRlciwgJ2FnLXBpdm90LW9mZicpO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRDc3NDbGFzcyh0aGlzLmVIZWFkZXIsICdhZy1waXZvdC1vbicpO1xuICAgICAgICAgICAgbnVtYmVyT2ZGbG9hdGluZyA9IDA7XG4gICAgICAgICAgICBncm91cEhlaWdodCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldFBpdm90R3JvdXBIZWFkZXJIZWlnaHQoKTtcbiAgICAgICAgICAgIGhlYWRlckhlaWdodCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldFBpdm90SGVhZGVySGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWJlck9mTm9uR3JvdXBzID0gMSArIG51bWJlck9mRmxvYXRpbmc7XG4gICAgICAgIHZhciBudW1iZXJPZkdyb3VwcyA9IGhlYWRlclJvd0NvdW50IC0gbnVtYmVyT2ZOb25Hcm91cHM7XG4gICAgICAgIHRvdGFsSGVhZGVySGVpZ2h0ID0gbnVtYmVyT2ZGbG9hdGluZyAqIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEZsb2F0aW5nRmlsdGVyc0hlaWdodCgpO1xuICAgICAgICB0b3RhbEhlYWRlckhlaWdodCArPSBudW1iZXJPZkdyb3VwcyAqIGdyb3VwSGVpZ2h0O1xuICAgICAgICB0b3RhbEhlYWRlckhlaWdodCArPSBoZWFkZXJIZWlnaHQ7XG4gICAgICAgIHRoaXMuZUhlYWRlci5zdHlsZVsnaGVpZ2h0J10gPSB0b3RhbEhlYWRlckhlaWdodCArICdweCc7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWhlaWdodCwgd2Ugb25seSBzaXplIHRoZSBoZWFkZXIsIHdlIGRvbid0IHNpemUgdGhlXG4gICAgICAgIC8vIG90aGVyIHBhcnRzIGFzIHdlIHVzZSB0aGUgbm9ybWFsIGJyb3dzZXIgbGF5b3V0IGZvciB0aGF0XG4gICAgICAgIGlmICh0aGlzLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkaW5nIHRvcCBjb3ZlcnMgdGhlIGhlYWRlciBhbmQgdGhlIHBpbm5lZCByb3dzIG9uIHRvcFxuICAgICAgICB2YXIgZmxvYXRpbmdUb3BIZWlnaHQgPSB0aGlzLnBpbm5lZFJvd01vZGVsLmdldFBpbm5lZFRvcFRvdGFsSGVpZ2h0KCk7XG4gICAgICAgIHZhciBwYWRkaW5nVG9wID0gdG90YWxIZWFkZXJIZWlnaHQgKyBmbG9hdGluZ1RvcEhlaWdodDtcbiAgICAgICAgLy8gYm90dG9tIGlzIGp1c3QgdGhlIGJvdHRvbSBwaW5uZWQgcm93c1xuICAgICAgICB2YXIgZmxvYXRpbmdCb3R0b21IZWlnaHQgPSB0aGlzLnBpbm5lZFJvd01vZGVsLmdldFBpbm5lZEJvdHRvbVRvdGFsSGVpZ2h0KCk7XG4gICAgICAgIHZhciBmbG9hdGluZ0JvdHRvbVRvcCA9IGhlaWdodE9mQ29udGFpbmVyIC0gZmxvYXRpbmdCb3R0b21IZWlnaHQ7XG4gICAgICAgIHZhciBib2R5SGVpZ2h0ID0gaGVpZ2h0T2ZDb250YWluZXIgLSB0b3RhbEhlYWRlckhlaWdodCAtIGZsb2F0aW5nQm90dG9tSGVpZ2h0IC0gZmxvYXRpbmdUb3BIZWlnaHQ7XG4gICAgICAgIHRoaXMuZUJvZHkuc3R5bGUudG9wID0gcGFkZGluZ1RvcCArICdweCc7XG4gICAgICAgIHRoaXMuZUJvZHkuc3R5bGUuaGVpZ2h0ID0gYm9keUhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuZUZsb2F0aW5nVG9wLnN0eWxlLnRvcCA9IHRvdGFsSGVhZGVySGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5lRmxvYXRpbmdUb3Auc3R5bGUuaGVpZ2h0ID0gZmxvYXRpbmdUb3BIZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmVGbG9hdGluZ0JvdHRvbS5zdHlsZS5oZWlnaHQgPSBmbG9hdGluZ0JvdHRvbUhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuZUZsb2F0aW5nQm90dG9tLnN0eWxlLnRvcCA9IGZsb2F0aW5nQm90dG9tVG9wICsgJ3B4JztcbiAgICAgICAgdGhpcy5lUGlubmVkTGVmdENvbHNWaWV3cG9ydC5zdHlsZS5oZWlnaHQgPSBib2R5SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5lUGlubmVkUmlnaHRDb2xzVmlld3BvcnQuc3R5bGUuaGVpZ2h0ID0gYm9keUhlaWdodCArICdweCc7XG4gICAgICAgIC8vIGJvZHlIZWlnaHQgcHJvcGVydHkgaXMgdXNlZCBieSBwYWdpbmF0aW9uIHNlcnZpY2UsIHRoYXQgbWF5IGNoYW5nZSBudW1iZXIgb2Ygcm93c1xuICAgICAgICAvLyBpbiB0aGlzIHBhZ2UgYmFzZWQgb24gdGhlIGhlaWdodCBvZiB0aGUgZ3JpZFxuICAgICAgICBpZiAodGhpcy5ib2R5SGVpZ2h0ICE9PSBib2R5SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmJvZHlIZWlnaHQgPSBib2R5SGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0JPRFlfSEVJR0hUX0NIQU5HRUQsXG4gICAgICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnRfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuZ2V0Qm9keUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keUhlaWdodDtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuc2V0SG9yaXpvbnRhbFNjcm9sbFBvc2l0aW9uID0gZnVuY3Rpb24gKGhTY3JvbGxQb3NpdGlvbikge1xuICAgICAgICB0aGlzLmVCb2R5Vmlld3BvcnQuc2Nyb2xsTGVmdCA9IGhTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBtYW51YWxseSBkbyB0aGUgZXZlbnQgaGFuZGxpbmcgKHJhdGhlciB0aGFuIHdhaXQgZm9yIHRoZSBldmVudClcbiAgICAgICAgLy8gZm9yIHRoZSBhbGlnbmVkR3JpZHNTZXJ2aWNlLCBhcyBpZiB3ZSBkb24ndCwgdGhlIGFsaWduZWQgZ3JpZCBzZXJ2aWNlIGdldHNcbiAgICAgICAgLy8gbm90aWZpZWQgYXN5bmMsIGFuZCB0aGVuIGl0J3MgJ2NvbnN1bWluZycgZmxhZyBkb2Vzbid0IGdldCB1c2VkIHJpZ2h0LCBhbmRcbiAgICAgICAgLy8gd2UgY2FuIGVuZCB1cCB3aXRoIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgaWYgKHRoaXMubmV4dFNjcm9sbExlZnQgIT09IGhTY3JvbGxQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5uZXh0U2Nyb2xsTGVmdCA9IGhTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZG9Ib3Jpem9udGFsU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHRyaWVzIHRvIHNjcm9sbCBieSBwaXhlbHMsIGJ1dCByZXR1cm5zIHdoYXQgdGhlIHJlc3VsdCBhY3R1YWxseSB3YXNcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLnNjcm9sbEhvcml6b250YWxseSA9IGZ1bmN0aW9uIChwaXhlbHMpIHtcbiAgICAgICAgdmFyIG9sZFNjcm9sbFBvc2l0aW9uID0gdGhpcy5lQm9keVZpZXdwb3J0LnNjcm9sbExlZnQ7XG4gICAgICAgIHRoaXMuc2V0SG9yaXpvbnRhbFNjcm9sbFBvc2l0aW9uKG9sZFNjcm9sbFBvc2l0aW9uICsgcGl4ZWxzKTtcbiAgICAgICAgdmFyIG5ld1Njcm9sbFBvc2l0aW9uID0gdGhpcy5lQm9keVZpZXdwb3J0LnNjcm9sbExlZnQ7XG4gICAgICAgIHJldHVybiBuZXdTY3JvbGxQb3NpdGlvbiAtIG9sZFNjcm9sbFBvc2l0aW9uO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5hZGRTY3JvbGxMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gaWYgcHJpbnRpbmcsIHRoZW4gbm8gc2Nyb2xsaW5nLCBzbyBubyBwb2ludCBpbiBsaXN0ZW5pbmcgZm9yIHNjcm9sbCBldmVudHNcbiAgICAgICAgaWYgKHRoaXMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVCb2R5Vmlld3BvcnQsICdzY3JvbGwnLCB0aGlzLm9uQm9keVNjcm9sbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gYmVsb3cgd2UgYWRkIHR3byB0aGluZ3M6XG4gICAgICAgIC8vIHBpbm5lZFNjcm9sbExpc3RlbmVyIC0+IHdoZW4gcGlubmVkIHBhbmVsIHdpdGggc2Nyb2xsYmFyIGdldHMgc2Nyb2xsZWQsIGl0IHVwZGF0ZXMgYm9keSBhbmQgb3RoZXIgcGlubmVkXG4gICAgICAgIC8vIHN1cHByZXNzU2Nyb2xsIC0+IHN0b3BzIHNjcm9sbGluZyB3aGVuIHBpbm5lZCBwYW5lbCB3YXMgbW92ZWQgLSB3aGljaCBjYW4gb25seSBoYXBwZW4gd2hlbiB1c2VyIGlzIG5hdmlnYXRpbmdcbiAgICAgICAgLy8gICAgIGluIHRoZSBwaW5uZWQgY29udGFpbmVyLCBhcyB0aGUgcGlubmVkIGNvbCBzaG91bGQgbmV2ZXIgc2Nyb2xsLiBzbyB3ZSByb2xsYmFjayB0aGUgc2Nyb2xsIG9uIHRoZSBwaW5uZWQuXG4gICAgICAgIHZhciBvblBpbm5lZExlZnRWZXJ0aWNhbFNjcm9sbCA9IHRoaXMub25WZXJ0aWNhbFNjcm9sbC5iaW5kKHRoaXMsIHRoaXMuZVBpbm5lZExlZnRDb2xzVmlld3BvcnQpO1xuICAgICAgICB2YXIgb25QaW5uZWRSaWdodFZlcnRpY2FsU2Nyb2xsID0gdGhpcy5vblZlcnRpY2FsU2Nyb2xsLmJpbmQodGhpcywgdGhpcy5lUGlubmVkUmlnaHRDb2xzVmlld3BvcnQpO1xuICAgICAgICBpZiAodGhpcy5lbmFibGVSdGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZVBpbm5lZExlZnRDb2xzVmlld3BvcnQsICdzY3JvbGwnLCBvblBpbm5lZExlZnRWZXJ0aWNhbFNjcm9sbCk7XG4gICAgICAgICAgICB2YXIgc3VwcHJlc3NSaWdodFNjcm9sbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmVQaW5uZWRSaWdodENvbHNWaWV3cG9ydC5zY3JvbGxUb3AgPSAwOyB9O1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lUGlubmVkUmlnaHRDb2xzVmlld3BvcnQsICdzY3JvbGwnLCBzdXBwcmVzc1JpZ2h0U2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZVBpbm5lZFJpZ2h0Q29sc1ZpZXdwb3J0LCAnc2Nyb2xsJywgb25QaW5uZWRSaWdodFZlcnRpY2FsU2Nyb2xsKTtcbiAgICAgICAgICAgIHZhciBzdXBwcmVzc0xlZnRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lUGlubmVkTGVmdENvbHNWaWV3cG9ydC5zY3JvbGxUb3AgPSAwOyB9O1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lUGlubmVkTGVmdENvbHNWaWV3cG9ydCwgJ3Njcm9sbCcsIHN1cHByZXNzTGVmdFNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1cHByZXNzQ2VudGVyU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmdldFByaW1hcnlTY3JvbGxWaWV3cG9ydCgpICE9PSBfdGhpcy5lQm9keVZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZUJvZHlWaWV3cG9ydC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVCb2R5Vmlld3BvcnQsICdzY3JvbGwnLCBzdXBwcmVzc0NlbnRlclNjcm9sbCk7XG4gICAgICAgIHRoaXMuYWRkSUVQaW5GaXgob25QaW5uZWRSaWdodFZlcnRpY2FsU2Nyb2xsLCBvblBpbm5lZExlZnRWZXJ0aWNhbFNjcm9sbCk7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLm9uQm9keVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbkJvZHlIb3Jpem9udGFsU2Nyb2xsKCk7XG4gICAgICAgIHRoaXMub25Cb2R5VmVydGljYWxTY3JvbGwoKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUub25Cb2R5SG9yaXpvbnRhbFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSB0aGlzLmVCb2R5Vmlld3BvcnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgaWYgKHRoaXMubmV4dFNjcm9sbExlZnQgIT09IHNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lU2VydmljZS5zY2hlZHVsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0hvcml6b250YWxTY3JvbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5kb0hvcml6b250YWxTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMubmV4dFNjcm9sbExlZnQ7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9CT0RZX1NDUk9MTCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgbGVmdDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgdG9wOiB0aGlzLnNjcm9sbFRvcFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsbHlTY3JvbGxIZWFkZXJDZW50ZXJBbmRGbG9hdGluZ0NlbnRlcigpO1xuICAgICAgICB0aGlzLnNldExlZnRBbmRSaWdodEJvdW5kcygpO1xuICAgICAgICAvLyB0aGlzLmFsaWduZWRHcmlkc1NlcnZpY2UuZmlyZUhvcml6b250YWxTY3JvbGxFdmVudCh0aGlzLnNjcm9sbExlZnQpO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5vbkJvZHlWZXJ0aWNhbFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJvZHlWU2Nyb2xsQWN0aXZlID0gdGhpcy5pc0JvZHlWZXJ0aWNhbFNjcm9sbEFjdGl2ZSgpO1xuICAgICAgICBpZiAoYm9keVZTY3JvbGxBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMub25WZXJ0aWNhbFNjcm9sbCh0aGlzLmVCb2R5Vmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLm9uVmVydGljYWxTY3JvbGwgPSBmdW5jdGlvbiAoc291cmNlRWxlbWVudCkge1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gc291cmNlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIGlmICh0aGlzLnVzZUFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0U2Nyb2xsVG9wICE9PSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25GcmFtZVNlcnZpY2Uuc2NoZWR1bGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxUb3AgIT09IHRoaXMuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlVmVydGljYWxTY3JvbGwoc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHJhd1Jvd3NBZnRlclNjcm9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLmV4ZWN1dGVGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsTGVmdCAhPT0gdGhpcy5uZXh0U2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgdGhpcy5kb0hvcml6b250YWxTY3JvbGwoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsVG9wICE9PSB0aGlzLm5leHRTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5uZXh0U2Nyb2xsVG9wO1xuICAgICAgICAgICAgdGhpcy5mYWtlVmVydGljYWxTY3JvbGwodGhpcy5zY3JvbGxUb3ApO1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbFJlZHJhd05lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnZlcnRpY2FsUmVkcmF3TmVlZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZHJhd1Jvd3NBZnRlclNjcm9sbCgpO1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbFJlZHJhd05lZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUucmVkcmF3Um93c0FmdGVyU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfQk9EWV9TQ1JPTEwsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGksXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLnJvd1JlbmRlcmVyLnJlZHJhd0FmdGVyU2Nyb2xsKCk7XG4gICAgfTtcbiAgICAvLyBpZiBMVFIsIHdlIGhpZGUgYm9keSBzY3JvbGwgaWYgcGlubmluZyByaWdodCAoYXMgc2Nyb2xsIGlzIGluIHJpZ2h0IHBpbm5lZCksXG4gICAgLy8gaWYgUlRMLCB3ZSBoaWRlIGJvZHkgc2Nyb2xsIGlmIHBpbm5pbmcgbGVmdCAoYXMgc2Nyb2xsIGlzIGluIGxlZnQgcGlubmVkKVxuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuaXNCb2R5VmVydGljYWxTY3JvbGxBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwaW5uaW5nUmlnaHQgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nUmlnaHQoKTtcbiAgICAgICAgdmFyIHBpbm5pbmdMZWZ0ID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGlubmluZ0xlZnQoKTtcbiAgICAgICAgdmFyIGNlbnRlckhhc1Njcm9sbCA9IHRoaXMuZW5hYmxlUnRsID8gIXBpbm5pbmdMZWZ0IDogIXBpbm5pbmdSaWdodDtcbiAgICAgICAgcmV0dXJuIGNlbnRlckhhc1Njcm9sbDtcbiAgICB9O1xuICAgIC8vIHRoaXMgYml0IGlzIGEgZml4IC8gaGFjayBmb3IgSUUgZHVlIHRvIHRoaXM6XG4gICAgLy8gaHR0cHM6Ly93d3cuYWctZ3JpZC5jb20vZm9ydW0vc2hvd3RocmVhZC5waHA/dGlkPTQzMDNcbiAgICAvLyBpdCBnZXRzIHRoZSBsZWZ0IHBhbmVsIHRvIHJlcG9zaXRpb24gaXRzZWxmIGFmdGVyIGEgbW9kZWwgY2hhbmdlXG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5hZGRJRVBpbkZpeCA9IGZ1bmN0aW9uIChvblBpbm5lZFJpZ2h0U2Nyb2xsLCBvblBpbm5lZExlZnRTY3JvbGwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nUmlnaHQoKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZW5hYmxlUnRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblBpbm5lZExlZnRTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUGlubmVkUmlnaHRTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX01PREVMX1VQREFURUQsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIC8vIHRoaXMgZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgYSBjaGFuZ2UgaW4gdGhlIHZpZXdwb3J0LCBzbyB3ZSBjYW4gaW5mb3JtIGNvbHVtbiBjb250cm9sbGVyIGl0IGhhcyB0byB3b3JrXG4gICAgLy8gb3V0IHRoZSB2aXJ0dWFsIGNvbHVtbnMgYWdhaW4uIGdldHMgY2FsbGVkIGZyb20gZm9sbG93aW5nIGxvY2F0aW9uczpcbiAgICAvLyArIGVuc3VyZUNvbFZpc2libGUsIHNjcm9sbCwgaW5pdCwgbGF5b3V0Q2hhbmdlZCwgZGlzcGxheWVkQ29sdW1uc0NoYW5nZWRcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLnNldExlZnRBbmRSaWdodEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxXaWR0aCA9IHRoaXMuZUJvZHlWaWV3cG9ydC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIHNjcm9sbFBvc2l0aW9uID0gdGhpcy5nZXRCb2R5Vmlld3BvcnRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHRoaXMuY29sdW1uQ29udHJvbGxlci5zZXRWaXJ0dWFsVmlld3BvcnRQb3NpdGlvbihzY3JvbGxXaWR0aCwgc2Nyb2xsUG9zaXRpb24pO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5nZXRCb2R5Vmlld3BvcnRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5mb3JQcmludCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZGVmZXIgdG8gYSB1dGlsLCBhcyBob3cgeW91IGNhbGN1bGF0ZWQgc2Nyb2xsTGVmdCB3aGVuIGRvaW5nIFJUTCBkZXBlbmRzIG9uIHRoZSBicm93c2VyXG4gICAgICAgIHJldHVybiB1dGlsc18xLlV0aWxzLmdldFNjcm9sbExlZnQodGhpcy5lQm9keVZpZXdwb3J0LCB0aGlzLmVuYWJsZVJ0bCk7XG4gICAgfTtcbiAgICBHcmlkUGFuZWwucHJvdG90eXBlLnNldEJvZHlWaWV3cG9ydFNjcm9sbExlZnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBkZWZlciB0byBhIHV0aWwsIGFzIGhvdyB5b3UgY2FsY3VsYXRlZCBzY3JvbGxMZWZ0IHdoZW4gZG9pbmcgUlRMIGRlcGVuZHMgb24gdGhlIGJyb3dzZXJcbiAgICAgICAgdXRpbHNfMS5VdGlscy5zZXRTY3JvbGxMZWZ0KHRoaXMuZUJvZHlWaWV3cG9ydCwgdmFsdWUsIHRoaXMuZW5hYmxlUnRsKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuaG9yaXpvbnRhbGx5U2Nyb2xsSGVhZGVyQ2VudGVyQW5kRmxvYXRpbmdDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gdGhpcy5nZXRCb2R5Vmlld3BvcnRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmVuYWJsZVJ0bCA/IHNjcm9sbExlZnQgOiAtc2Nyb2xsTGVmdDtcbiAgICAgICAgdGhpcy5lSGVhZGVyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBvZmZzZXQgKyAncHgnO1xuICAgICAgICB0aGlzLmVGbG9hdGluZ0JvdHRvbUNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gb2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5lRmxvYXRpbmdUb3BDb250YWluZXIuc3R5bGUubGVmdCA9IG9mZnNldCArICdweCc7XG4gICAgfTtcbiAgICAvLyB3ZSBzYXkgZmFrZSBzY3JvbGwgYXMgb25seSBvbmUgcGFuZWwgKGxlZnQsIHJpZ2h0IG9yIGJvZHkpIGhhcyBzY3JvbGxzLFxuICAgIC8vIHRoZSBvdGhlciBwYW5lbHMgbWltaWMgdGhlIHNjcm9sbCBieSBnZXR0aW5nIGl0J3MgdG9wIHBvc2l0aW9uIHVwZGF0ZWQuXG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5mYWtlVmVydGljYWxTY3JvbGwgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUnRsKSB7XG4gICAgICAgICAgICAvLyBSVExcbiAgICAgICAgICAgIC8vIGlmIHBpbm5pbmcgbGVmdCwgdGhlbiBib2R5IHNjcm9sbCBpcyBmYWtpbmdcbiAgICAgICAgICAgIHZhciBwaW5uaW5nTGVmdCA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5pc1Bpbm5pbmdMZWZ0KCk7XG4gICAgICAgICAgICBpZiAocGlubmluZ0xlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZha2VTY3JvbGwodGhpcy5lQm9keUNvbnRhaW5lciwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmlnaHQgaXMgYWx3YXlzIGZha2luZ1xuICAgICAgICAgICAgdGhpcy5zZXRGYWtlU2Nyb2xsKHRoaXMuZVBpbm5lZFJpZ2h0Q29sc0NvbnRhaW5lciwgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTFRSXG4gICAgICAgICAgICAvLyBpZiBwaW5uaW5nIHJpZ2h0LCB0aGVuIGJvZHkgc2Nyb2xsIGlzIGZha2luZ1xuICAgICAgICAgICAgdmFyIHBpbm5pbmdSaWdodCA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5pc1Bpbm5pbmdSaWdodCgpO1xuICAgICAgICAgICAgaWYgKHBpbm5pbmdSaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmFrZVNjcm9sbCh0aGlzLmVCb2R5Q29udGFpbmVyLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsZWZ0IGlzIGFsd2F5cyBmYWtpbmdcbiAgICAgICAgICAgIHRoaXMuc2V0RmFrZVNjcm9sbCh0aGlzLmVQaW5uZWRMZWZ0Q29sc0NvbnRhaW5lciwgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsd2F5cyBzY3JvbGwgZnVsbFdpZHRoIGNvbnRhaW5lciwgYXMgdGhpcyBpcyBuZXZlciByZXNwb25zaWJsZSBmb3IgYSBzY3JvbGxcbiAgICAgICAgdGhpcy5zZXRGYWtlU2Nyb2xsKHRoaXMuZUZ1bGxXaWR0aENlbGxDb250YWluZXIsIHBvc2l0aW9uKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuc2V0RmFrZVNjcm9sbCA9IGZ1bmN0aW9uIChlQ29udGFpbmVyLCBwaXhlbHMpIHtcbiAgICAgICAgZUNvbnRhaW5lci5zdHlsZS50b3AgPSAtcGl4ZWxzICsgJ3B4JztcbiAgICAgICAgLy8gZUNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgkey1waXhlbHN9cHgpYDtcbiAgICB9O1xuICAgIEdyaWRQYW5lbC5wcm90b3R5cGUuYWRkU2Nyb2xsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmVCb2R5Vmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgR3JpZFBhbmVsLnByb3RvdHlwZS5yZW1vdmVTY3JvbGxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZUJvZHlWaWV3cG9ydC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnYWxpZ25lZEdyaWRzU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgYWxpZ25lZEdyaWRzU2VydmljZV8xLkFsaWduZWRHcmlkc1NlcnZpY2UpXG4gICAgXSwgR3JpZFBhbmVsLnByb3RvdHlwZSwgXCJhbGlnbmVkR3JpZHNTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiY29sdW1uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdyb3dSZW5kZXJlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgcm93UmVuZGVyZXJfMS5Sb3dSZW5kZXJlcilcbiAgICBdLCBHcmlkUGFuZWwucHJvdG90eXBlLCBcInJvd1JlbmRlcmVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3Bpbm5lZFJvd01vZGVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBwaW5uZWRSb3dNb2RlbF8xLlBpbm5lZFJvd01vZGVsKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwicGlubmVkUm93TW9kZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgR3JpZFBhbmVsLnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29udGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29udGV4dF8xLkNvbnRleHQpXG4gICAgXSwgR3JpZFBhbmVsLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2FuaW1hdGlvbkZyYW1lU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgYW5pbWF0aW9uRnJhbWVTZXJ2aWNlXzEuQW5pbWF0aW9uRnJhbWVTZXJ2aWNlKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uRnJhbWVTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ25hdmlnYXRpb25TZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBuYXZpZ2F0aW9uU2VydmljZV8xLk5hdmlnYXRpb25TZXJ2aWNlKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwibmF2aWdhdGlvblNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncGFnaW5hdGlvblByb3h5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBwYWdpbmF0aW9uUHJveHlfMS5QYWdpbmF0aW9uUHJveHkpXG4gICAgXSwgR3JpZFBhbmVsLnByb3RvdHlwZSwgXCJwYWdpbmF0aW9uUHJveHlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiY29sdW1uQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRBcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRBcGlfMS5HcmlkQXBpKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiZ3JpZEFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuT3B0aW9uYWwoJ3JhbmdlQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwicmFuZ2VDb250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2RyYWdTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBkcmFnU2VydmljZV8xLkRyYWdTZXJ2aWNlKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiZHJhZ1NlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnc2VsZWN0aW9uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgc2VsZWN0aW9uQ29udHJvbGxlcl8xLlNlbGVjdGlvbkNvbnRyb2xsZXIpXG4gICAgXSwgR3JpZFBhbmVsLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5PcHRpb25hbCgnY2xpcGJvYXJkU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiY2xpcGJvYXJkU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjc3ZDcmVhdG9yJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjc3ZDcmVhdG9yXzEuQ3N2Q3JlYXRvcilcbiAgICBdLCBHcmlkUGFuZWwucHJvdG90eXBlLCBcImNzdkNyZWF0b3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnbW91c2VFdmVudFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIG1vdXNlRXZlbnRTZXJ2aWNlXzEuTW91c2VFdmVudFNlcnZpY2UpXG4gICAgXSwgR3JpZFBhbmVsLnByb3RvdHlwZSwgXCJtb3VzZUV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdmb2N1c2VkQ2VsbENvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGZvY3VzZWRDZWxsQ29udHJvbGxlcl8xLkZvY3VzZWRDZWxsQ29udHJvbGxlcilcbiAgICBdLCBHcmlkUGFuZWwucHJvdG90eXBlLCBcImZvY3VzZWRDZWxsQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCckc2NvcGUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHcmlkUGFuZWwucHJvdG90eXBlLCBcIiRzY29wZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdzY3JvbGxWaXNpYmxlU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgc2Nyb2xsVmlzaWJsZVNlcnZpY2VfMS5TY3JvbGxWaXNpYmxlU2VydmljZSlcbiAgICBdLCBHcmlkUGFuZWwucHJvdG90eXBlLCBcInNjcm9sbFZpc2libGVTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5PcHRpb25hbCgnY29udGV4dE1lbnVGYWN0b3J5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR3JpZFBhbmVsLnByb3RvdHlwZSwgXCJjb250ZXh0TWVudUZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZnJhbWV3b3JrRmFjdG9yeScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiZnJhbWV3b3JrRmFjdG9yeVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBfX3BhcmFtKDAsIGNvbnRleHRfMS5RdWFsaWZpZXIoJ2xvZ2dlckZhY3RvcnknKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbbG9nZ2VyXzEuTG9nZ2VyRmFjdG9yeV0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiYWdXaXJlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUHJlRGVzdHJveSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBHcmlkUGFuZWwucHJvdG90eXBlLCBcImRlc3Ryb3lcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEdyaWRQYW5lbC5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICBHcmlkUGFuZWwgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2dyaWRQYW5lbCcpXG4gICAgXSwgR3JpZFBhbmVsKTtcbiAgICByZXR1cm4gR3JpZFBhbmVsO1xufShiZWFuU3R1Yl8xLkJlYW5TdHViKSk7XG5leHBvcnRzLkdyaWRQYW5lbCA9IEdyaWRQYW5lbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2dyaWRQYW5lbC9ncmlkUGFuZWwuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29udGV4dF8yID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIExvZ2dlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlckZhY3RvcnkoKSB7XG4gICAgfVxuICAgIExvZ2dlckZhY3RvcnkucHJvdG90eXBlLnNldEJlYW5zID0gZnVuY3Rpb24gKGdyaWRPcHRpb25zV3JhcHBlcikge1xuICAgICAgICB0aGlzLmxvZ2dpbmcgPSBncmlkT3B0aW9uc1dyYXBwZXIuaXNEZWJ1ZygpO1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIobmFtZSwgdGhpcy5pc0xvZ2dpbmcuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5LnByb3RvdHlwZS5pc0xvZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ2dpbmc7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgX19wYXJhbSgwLCBjb250ZXh0XzIuUXVhbGlmaWVyKCdncmlkT3B0aW9uc1dyYXBwZXInKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGUsIFwic2V0QmVhbnNcIiwgbnVsbCk7XG4gICAgTG9nZ2VyRmFjdG9yeSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignbG9nZ2VyRmFjdG9yeScpXG4gICAgXSwgTG9nZ2VyRmFjdG9yeSk7XG4gICAgcmV0dXJuIExvZ2dlckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5Mb2dnZXJGYWN0b3J5ID0gTG9nZ2VyRmFjdG9yeTtcbnZhciBMb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBpc0xvZ2dpbmdGdW5jKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaXNMb2dnaW5nRnVuYyA9IGlzTG9nZ2luZ0Z1bmM7XG4gICAgfVxuICAgIExvZ2dlci5wcm90b3R5cGUuaXNMb2dnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xvZ2dpbmdGdW5jKCk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9nZ2luZ0Z1bmMoKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FnLUdyaWQuJyArIHRoaXMubmFtZSArICc6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2xvZ2dlci5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gUXVlcnlTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHJldHVybiBxdWVyeVNlbGVjdG9yRnVuYy5iaW5kKHRoaXMsIHNlbGVjdG9yKTtcbn1cbmV4cG9ydHMuUXVlcnlTZWxlY3RvciA9IFF1ZXJ5U2VsZWN0b3I7XG5mdW5jdGlvbiBSZWZTZWxlY3RvcihyZWYpIHtcbiAgICByZXR1cm4gcXVlcnlTZWxlY3RvckZ1bmMuYmluZCh0aGlzLCAnW3JlZj0nICsgcmVmICsgJ10nKTtcbn1cbmV4cG9ydHMuUmVmU2VsZWN0b3IgPSBSZWZTZWxlY3RvcjtcbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JGdW5jKHNlbGVjdG9yLCBjbGFzc1Byb3RvdHlwZSwgbWV0aG9kT3JBdHRyaWJ1dGVOYW1lLCBpbmRleCkge1xuICAgIGlmIChzZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBRdWVyeVNlbGVjdG9yIHNlbGVjdG9yIHNob3VsZCBub3QgYmUgbnVsbCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FnLUdyaWQ6IFF1ZXJ5U2VsZWN0b3Igc2hvdWxkIGJlIG9uIGFuIGF0dHJpYnV0ZScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGl0J3MgYW4gYXR0cmlidXRlIG9uIHRoZSBjbGFzc1xuICAgIHZhciBwcm9wcyA9IGdldE9yQ3JlYXRlUHJvcHMoY2xhc3NQcm90b3R5cGUsIGNsYXNzUHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIGlmICghcHJvcHMucXVlcnlTZWxlY3RvcnMpIHtcbiAgICAgICAgcHJvcHMucXVlcnlTZWxlY3RvcnMgPSBbXTtcbiAgICB9XG4gICAgcHJvcHMucXVlcnlTZWxlY3RvcnMucHVzaCh7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IG1ldGhvZE9yQXR0cmlidXRlTmFtZSxcbiAgICAgICAgcXVlcnlTZWxlY3Rvcjogc2VsZWN0b3JcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIExpc3RlbmVyKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBsaXN0ZW5lckZ1bmMuYmluZCh0aGlzLCBldmVudE5hbWUpO1xufVxuZXhwb3J0cy5MaXN0ZW5lciA9IExpc3RlbmVyO1xuZnVuY3Rpb24gbGlzdGVuZXJGdW5jKGV2ZW50TmFtZSwgdGFyZ2V0LCBtZXRob2ROYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBFdmVudExpc3RlbmVyIGV2ZW50TmFtZSBzaG91bGQgbm90IGJlIG51bGwnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpdCdzIGFuIGF0dHJpYnV0ZSBvbiB0aGUgY2xhc3NcbiAgICB2YXIgcHJvcHMgPSBnZXRPckNyZWF0ZVByb3BzKHRhcmdldCwgdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIGlmICghcHJvcHMubGlzdGVuZXJNZXRob2RzKSB7XG4gICAgICAgIHByb3BzLmxpc3RlbmVyTWV0aG9kcyA9IFtdO1xuICAgIH1cbiAgICBwcm9wcy5saXN0ZW5lck1ldGhvZHMucHVzaCh7XG4gICAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgIGV2ZW50TmFtZTogZXZlbnROYW1lXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVByb3BzKHRhcmdldCwgaW5zdGFuY2VOYW1lKSB7XG4gICAgaWYgKCF0YXJnZXQuX19hZ0NvbXBvbmVudE1ldGFEYXRhKSB7XG4gICAgICAgIHRhcmdldC5fX2FnQ29tcG9uZW50TWV0YURhdGEgPSB7fTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXQuX19hZ0NvbXBvbmVudE1ldGFEYXRhW2luc3RhbmNlTmFtZV0pIHtcbiAgICAgICAgdGFyZ2V0Ll9fYWdDb21wb25lbnRNZXRhRGF0YVtpbnN0YW5jZU5hbWVdID0ge307XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQuX19hZ0NvbXBvbmVudE1ldGFEYXRhW2luc3RhbmNlTmFtZV07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi93aWRnZXRzL2NvbXBvbmVudEFubm90YXRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIEJlYW5TdHViID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCZWFuU3R1YigpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95RnVuY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgfVxuICAgIEJlYW5TdHViLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gZnVuYygpOyB9KTtcbiAgICAgICAgdGhpcy5kZXN0cm95RnVuY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEJlYW5TdHViLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsRXZlbnRTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsRXZlbnRTZXJ2aWNlID0gbmV3IGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxFdmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIEJlYW5TdHViLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxFdmVudFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxFdmVudFNlcnZpY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmVhblN0dWIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnRBc3luYyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpOyB9LCAwKTtcbiAgICB9O1xuICAgIEJlYW5TdHViLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsRXZlbnRTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsRXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCZWFuU3R1Yi5wcm90b3R5cGUuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVFbGVtZW50LCBldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5hZGRTYWZlUGFzc2l2ZUV2ZW50TGlzdGVuZXIoZUVsZW1lbnQsIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZUVsZW1lbnQgaW5zdGFuY2VvZiBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpIHtcbiAgICAgICAgICAgIGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3Ryb3lGdW5jdGlvbnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVFbGVtZW50IGluc3RhbmNlb2YgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJlYW5TdHViLnByb3RvdHlwZS5pc0FsaXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGVzdHJveWVkO1xuICAgIH07XG4gICAgQmVhblN0dWIucHJvdG90eXBlLmFkZERlc3Ryb3lGdW5jID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIGFscmVhZHkgZGVzdHJveWVkLCB3ZSBleGVjdXRlIHRoZSBmdW5jIG5vd1xuICAgICAgICBpZiAodGhpcy5pc0FsaXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUZ1bmN0aW9ucy5wdXNoKGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmVhblN0dWI7XG59KCkpO1xuZXhwb3J0cy5CZWFuU3R1YiA9IEJlYW5TdHViO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29udGV4dC9iZWFuU3R1Yi5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi92ZW5kb3JcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCIuL3ZlbmRvclwiXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2V2ZW50U2VydmljZVwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi9ldmVudHNcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIHNlbGVjdGlvbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9zZWxlY3Rpb25Db250cm9sbGVyXCIpO1xudmFyIHZhbHVlU2VydmljZV8xID0gcmVxdWlyZShcIi4uL3ZhbHVlU2VydmljZS92YWx1ZVNlcnZpY2VcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIHZhbHVlQ2FjaGVfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZVNlcnZpY2UvdmFsdWVDYWNoZVwiKTtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi4vZ3JpZEFwaVwiKTtcbnZhciBSb3dOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3dOb2RlKCkge1xuICAgICAgICAvKiogQ2hpbGRyZW4gbWFwcGVkIGJ5IHRoZSBwaXZvdCBjb2x1bW5zICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW5NYXBwZWQgPSB7fTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBSb3dOb2RlLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMudmFsdWVDYWNoZS5vbkRhdGFDaGFuZ2VkKCk7XG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuY3JlYXRlRGF0YUNoYW5nZWRFdmVudChkYXRhLCBvbGREYXRhLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMb2NhbEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFuZ2VkRXZlbnQgPSBmdW5jdGlvbiAobmV3RGF0YSwgb2xkRGF0YSwgdXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBSb3dOb2RlLkVWRU5UX0RBVEFfQ0hBTkdFRCxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBvbGREYXRhOiBvbGREYXRhLFxuICAgICAgICAgICAgbmV3RGF0YTogbmV3RGF0YSxcbiAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5jcmVhdGVMb2NhbFJvd0V2ZW50ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBub2RlOiB0aGlzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBzaW1pbGFyIHRvIHNldFJvd0RhdGEsIGhvd2V2ZXIgaXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgZGF0YSBpcyB0aGUgc2FtZSBkYXRhIGl0ZW0uIHRoaXNcbiAgICAvLyBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggUmVkdXggdHlwZSBzdG9yZXMsIHdoZXJlIHRoZSB3aG9sZSBkYXRhIGNhbiBiZSBjaGFuZ2VkLiB3ZSBhcmVcbiAgICAvLyBndWFyYW50ZWVkIHRoYXQgdGhlIGRhdGEgaXMgdGhlIHNhbWUgZW50aXR5IChzbyBncmlkIGRvZXNuJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGUgaWQgb2YgdGhlXG4gICAgLy8gdW5kZXJseWluZyBkYXRhIGNoYW5naW5nLCBoZW5jZSBkb2Vzbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgc2VsZWN0aW9uKS4gdGhlIGdyaWQsIHVwb24gcmVjZWl2aW5nXG4gICAgLy8gZGF0YUNoYW5nZWQgZXZlbnQsIHdpbGwgcmVmcmVzaCB0aGUgY2VsbHMgcmF0aGVyIHRoYW4gcmlwIHRoZW0gYWxsIG91dCAoc28gdXNlciBjYW4gc2hvdyB0cmFuc2l0aW9ucykuXG4gICAgUm93Tm9kZS5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBvbGREYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmNyZWF0ZURhdGFDaGFuZ2VkRXZlbnQoZGF0YSwgb2xkRGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMb2NhbEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLmdldFJvd0luZGV4U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yb3dQaW5uZWQgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfVE9QKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3QtJyArIHRoaXMucm93SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yb3dQaW5uZWQgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfQk9UVE9NKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2ItJyArIHRoaXMucm93SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmRleC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5jcmVhdGVEYWVtb25Ob2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2xkTm9kZSA9IG5ldyBSb3dOb2RlKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC53aXJlQmVhbihvbGROb2RlKTtcbiAgICAgICAgLy8ganVzdCBjb3B5IHRoZSBpZCBhbmQgZGF0YSwgdGhpcyBpcyBlbm91Z2ggZm9yIHRoZSBub2RlIHRvIGJlIHVzZWRcbiAgICAgICAgLy8gaW4gdGhlIHNlbGVjdGlvbiBjb250cm9sbGVyICh0aGUgc2VsZWN0aW9uIGNvbnRyb2xsZXIgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gcGxhY2Ugd2hlcmUgZGFlbW9uIG5vZGVzIGNhbiBsaXZlKS5cbiAgICAgICAgb2xkTm9kZS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgIG9sZE5vZGUuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgb2xkTm9kZS5kYWVtb24gPSB0cnVlO1xuICAgICAgICBvbGROb2RlLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZDtcbiAgICAgICAgb2xkTm9kZS5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgIHJldHVybiBvbGROb2RlO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuc2V0RGF0YUFuZElkID0gZnVuY3Rpb24gKGRhdGEsIGlkKSB7XG4gICAgICAgIHZhciBvbGROb2RlID0gdXRpbHNfMS5VdGlscy5leGlzdHModGhpcy5pZCkgPyB0aGlzLmNyZWF0ZURhZW1vbk5vZGUoKSA6IG51bGw7XG4gICAgICAgIHZhciBvbGREYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnNldElkKGlkKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLnN5bmNJblJvd05vZGUodGhpcywgb2xkTm9kZSk7XG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuY3JlYXRlRGF0YUNoYW5nZWRFdmVudChkYXRhLCBvbGREYXRhLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMb2NhbEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLnNldElkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIC8vIHNlZSBpZiB1c2VyIGlzIHByb3ZpZGluZyB0aGUgaWQnc1xuICAgICAgICB2YXIgZ2V0Um93Tm9kZUlkID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Um93Tm9kZUlkRnVuYygpO1xuICAgICAgICBpZiAoZ2V0Um93Tm9kZUlkKSB7XG4gICAgICAgICAgICAvLyBpZiB1c2VyIGlzIHByb3ZpZGluZyB0aGUgaWQncywgdGhlbiB3ZSBzZXQgdGhlIGlkIG9ubHkgYWZ0ZXIgdGhlIGRhdGEgaGFzIGJlZW4gc2V0LlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgZm9yIHZpcnR1YWwgcGFnaW5hdGlvbiBhbmQgdmlld3BvcnQsIHdoZXJlIGVtcHR5IHJvd3MgZXhpc3QuXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IGdldFJvd05vZGVJZCh0aGlzLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gaGFwcGVuIGlmIHVzZXIgaGFzIHNldCBibGFuayBpbnRvIHRoZSByb3dOb2RlIGFmdGVyIHRoZSByb3cgcHJldmlvdXNseVxuICAgICAgICAgICAgICAgIC8vIGhhdmluZyBkYXRhLiB0aGlzIGhhcHBlbnMgaW4gdmlydHVhbCBwYWdlIHJvdyBtb2RlbCwgd2hlbiBkYXRhIGlzIGRlbGV0ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFnZSBpcyByZWZyZXNoZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuaXNQaXhlbEluUmFuZ2UgPSBmdW5jdGlvbiAocGl4ZWwpIHtcbiAgICAgICAgcmV0dXJuIHBpeGVsID49IHRoaXMucm93VG9wICYmIHBpeGVsIDwgKHRoaXMucm93VG9wICsgdGhpcy5yb3dIZWlnaHQpO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuY2xlYXJSb3dUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2xkUm93VG9wID0gdGhpcy5yb3dUb3A7XG4gICAgICAgIHRoaXMuc2V0Um93VG9wKG51bGwpO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuc2V0Rmlyc3RDaGlsZCA9IGZ1bmN0aW9uIChmaXJzdENoaWxkKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQgPT09IGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xuICAgICAgICBpZiAodGhpcy5ldmVudFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVMb2NhbFJvd0V2ZW50KFJvd05vZGUuRVZFTlRfRklSU1RfQ0hJTERfQ0hBTkdFRCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5zZXRMYXN0Q2hpbGQgPSBmdW5jdGlvbiAobGFzdENoaWxkKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RDaGlsZCA9PT0gbGFzdENoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBsYXN0Q2hpbGQ7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50U2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUxvY2FsUm93RXZlbnQoUm93Tm9kZS5FVkVOVF9MQVNUX0NISUxEX0NIQU5HRUQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuc2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChjaGlsZEluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkSW5kZXggPT09IGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkSW5kZXggPSBjaGlsZEluZGV4O1xuICAgICAgICBpZiAodGhpcy5ldmVudFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVMb2NhbFJvd0V2ZW50KFJvd05vZGUuRVZFTlRfQ0hJTERfSU5ERVhfQ0hBTkdFRCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5zZXRSb3dUb3AgPSBmdW5jdGlvbiAocm93VG9wKSB7XG4gICAgICAgIGlmICh0aGlzLnJvd1RvcCA9PT0gcm93VG9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dUb3AgPSByb3dUb3A7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50U2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUxvY2FsUm93RXZlbnQoUm93Tm9kZS5FVkVOVF9UT1BfQ0hBTkdFRCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5zZXRBbGxDaGlsZHJlbkNvdW50ID0gZnVuY3Rpb24gKGFsbENoaWxkcmVuQ291bnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsQ2hpbGRyZW5Db3VudCA9PT0gYWxsQ2hpbGRyZW5Db3VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsQ2hpbGRyZW5Db3VudCA9IGFsbENoaWxkcmVuQ291bnQ7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50U2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUxvY2FsUm93RXZlbnQoUm93Tm9kZS5FVkVOVF9BTExfQ0hJTERSRU5fQ09VTlRfQ0hBTkdFRCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5zZXRSb3dIZWlnaHQgPSBmdW5jdGlvbiAocm93SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucm93SGVpZ2h0ID0gcm93SGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5ldmVudFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVMb2NhbFJvd0V2ZW50KFJvd05vZGUuRVZFTlRfSEVJR0hUX0NIQU5HRUQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuc2V0Um93SW5kZXggPSBmdW5jdGlvbiAocm93SW5kZXgpIHtcbiAgICAgICAgdGhpcy5yb3dJbmRleCA9IHJvd0luZGV4O1xuICAgICAgICBpZiAodGhpcy5ldmVudFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVMb2NhbFJvd0V2ZW50KFJvd05vZGUuRVZFTlRfUk9XX0lOREVYX0NIQU5HRUQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuc2V0VWlMZXZlbCA9IGZ1bmN0aW9uICh1aUxldmVsKSB7XG4gICAgICAgIGlmICh0aGlzLnVpTGV2ZWwgPT09IHVpTGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpTGV2ZWwgPSB1aUxldmVsO1xuICAgICAgICBpZiAodGhpcy5ldmVudFNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVMb2NhbFJvd0V2ZW50KFJvd05vZGUuRVZFTlRfVUlfTEVWRUxfQ0hBTkdFRCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5zZXRFeHBhbmRlZCA9IGZ1bmN0aW9uIChleHBhbmRlZCkge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCA9PT0gZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZXhwYW5kZWQ7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50U2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUxvY2FsUm93RXZlbnQoUm93Tm9kZS5FVkVOVF9FWFBBTkRFRF9DSEFOR0VEKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5jcmVhdGVHbG9iYWxSb3dFdmVudChldmVudHNfMS5FdmVudHMuRVZFTlRfUk9XX0dST1VQX09QRU5FRCk7XG4gICAgICAgIHRoaXMubWFpbkV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLmNyZWF0ZUdsb2JhbFJvd0V2ZW50ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICByb3dJbmRleDogdGhpcy5yb3dJbmRleCxcbiAgICAgICAgICAgIHJvd1Bpbm5lZDogdGhpcy5yb3dQaW5uZWQsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb2x1bW5BcGkoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5kaXNwYXRjaExvY2FsRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gd2UgYWxzbyBhbGxvdyBlZGl0aW5nIHRoZSB2YWx1ZSB2aWEgdGhlIGVkaXRvcnMuIHdoZW4gaXQgaXMgZG9uZSB2aWFcbiAgICAvLyB0aGUgZWRpdG9ycywgbm8gJ2NlbGwgY2hhbmdlZCcgZXZlbnQgZ2V0cyBmaXJlZCwgYXMgaXQncyBhc3N1bWVkIHRoYXRcbiAgICAvLyB0aGUgY2VsbCBrbm93cyBhYm91dCB0aGUgY2hhbmdlIGdpdmVuIGl0J3MgaW4gY2hhcmdlIG9mIHRoZSBlZGl0aW5nLlxuICAgIC8vIHRoaXMgbWV0aG9kIGlzIGZvciB0aGUgY2xpZW50IHRvIGNhbGwsIHNvIHRoZSBjZWxsIGxpc3RlbnMgZm9yIHRoZSBjaGFuZ2VcbiAgICAvLyBldmVudCwgYW5kIGFsc28gZmxhc2hlcyB0aGUgY2VsbCB3aGVuIHRoZSBjaGFuZ2Ugb2NjdXJzLlxuICAgIFJvd05vZGUucHJvdG90eXBlLnNldERhdGFWYWx1ZSA9IGZ1bmN0aW9uIChjb2xLZXksIG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0UHJpbWFyeUNvbHVtbihjb2xLZXkpO1xuICAgICAgICB0aGlzLnZhbHVlU2VydmljZS5zZXRWYWx1ZSh0aGlzLCBjb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaENlbGxDaGFuZ2VkRXZlbnQoY29sdW1uLCBuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5zZXRHcm91cFZhbHVlID0gZnVuY3Rpb24gKGNvbEtleSwgbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRHcmlkQ29sdW1uKGNvbEtleSk7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5ncm91cERhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwRGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JvdXBEYXRhW2NvbHVtbi5nZXRDb2xJZCgpXSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoQ2VsbENoYW5nZWRFdmVudChjb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICB9O1xuICAgIC8vIHNldHMgdGhlIGRhdGEgZm9yIGFuIGFnZ3JlZ2F0aW9uXG4gICAgUm93Tm9kZS5wcm90b3R5cGUuc2V0QWdnRGF0YSA9IGZ1bmN0aW9uIChuZXdBZ2dEYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGZpbmQgb3V0IGFsbCBrZXlzIHRoYXQgY291bGQgcG90ZW50aWFsbHkgY2hhbmdlXG4gICAgICAgIHZhciBjb2xJZHMgPSB1dGlsc18xLlV0aWxzLmdldEFsbEtleXNJbk9iamVjdHMoW3RoaXMuYWdnRGF0YSwgbmV3QWdnRGF0YV0pO1xuICAgICAgICB0aGlzLmFnZ0RhdGEgPSBuZXdBZ2dEYXRhO1xuICAgICAgICAvLyBpZiBubyBldmVudCBzZXJ2aWNlLCBub2JvZHkgaGFzIHJlZ2lzdGVyZWQgZm9yIGV2ZW50cywgc28gbm8gbmVlZCBmaXJlIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLmV2ZW50U2VydmljZSkge1xuICAgICAgICAgICAgY29sSWRzLmZvckVhY2goZnVuY3Rpb24gKGNvbElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IF90aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0R3JpZENvbHVtbihjb2xJZCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMuYWdnRGF0YSA/IF90aGlzLmFnZ0RhdGFbY29sSWRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoQ2VsbENoYW5nZWRFdmVudChjb2x1bW4sIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5oYXNDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZXR1cm4gdHJ1ZSB3aGVuIHRoaXMuZ3JvdXA9dHJ1ZSwgYXMgdGhpcyBpcyB1c2VkIGJ5IGVudGVycHJpc2Ugcm93IG1vZGVsXG4gICAgICAgIC8vIChhcyBjaGlsZHJlbiBhcmUgbGF6eSBsb2FkZWQgYW5kIHN0b3JlZCBpbiBhIGNhY2hlIGFueXdheSkuIG90aGVyd2lzZSB3ZSByZXR1cm4gdHJ1ZVxuICAgICAgICAvLyBpZiBjaGlsZHJlbiBleGlzdC5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAgfHwgKHRoaXMuY2hpbGRyZW5BZnRlckdyb3VwICYmIHRoaXMuY2hpbGRyZW5BZnRlckdyb3VwLmxlbmd0aCA+IDApO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuaXNFbXB0eUZpbGxlck5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwICYmIHV0aWxzXzEuVXRpbHMubWlzc2luZ09yRW1wdHkodGhpcy5jaGlsZHJlbkFmdGVyR3JvdXApO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuZGlzcGF0Y2hDZWxsQ2hhbmdlZEV2ZW50ID0gZnVuY3Rpb24gKGNvbHVtbiwgbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIGNlbGxDaGFuZ2VkRXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBSb3dOb2RlLkVWRU5UX0NFTExfQ0hBTkdFRCxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRpc3BhdGNoTG9jYWxFdmVudChjZWxsQ2hhbmdlZEV2ZW50KTtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLnJlc2V0UXVpY2tGaWx0ZXJBZ2dyZWdhdGVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnF1aWNrRmlsdGVyQWdncmVnYXRlVGV4dCA9IG51bGw7XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5pc0V4cGFuZGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NoaWxkcmVuKCkgfHwgdGhpcy5jYW5GbG93ZXI7XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBmb3IgZm9vdGVycywgd2UganVzdCByZXR1cm4gd2hhdCBvdXIgc2libGluZyBzZWxlY3RlZCBzdGF0ZSBpcywgYXMgY2Fubm90IHNlbGVjdCBhIGZvb3RlclxuICAgICAgICBpZiAodGhpcy5mb290ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpYmxpbmcuaXNTZWxlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuZGVwdGhGaXJzdFNlYXJjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbkFmdGVyR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5BZnRlckdyb3VwLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5kZXB0aEZpcnN0U2VhcmNoKGNhbGxiYWNrKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgfTtcbiAgICAvLyArIHJvd0NvbnRyb2xsZXIudXBkYXRlR3JvdXBzSW5TZWxlY3Rpb24oKVxuICAgIFJvd05vZGUucHJvdG90eXBlLmNhbGN1bGF0ZVNlbGVjdGVkRnJvbUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXRMZWFzdE9uZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBhdExlYXN0T25lRGVTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgYXRMZWFzdE9uZU1peGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBuZXdTZWxlY3RlZFZhbHVlO1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbkFmdGVyR3JvdXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbkFmdGVyR3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRTdGF0ZSA9IHRoaXMuY2hpbGRyZW5BZnRlckdyb3VwW2ldLmlzU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoaWxkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZURlU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lTWl4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdExlYXN0T25lTWl4ZWQpIHtcbiAgICAgICAgICAgIG5ld1NlbGVjdGVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXRMZWFzdE9uZVNlbGVjdGVkICYmICFhdExlYXN0T25lRGVTZWxlY3RlZCkge1xuICAgICAgICAgICAgbmV3U2VsZWN0ZWRWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWF0TGVhc3RPbmVTZWxlY3RlZCAmJiBhdExlYXN0T25lRGVTZWxlY3RlZCkge1xuICAgICAgICAgICAgbmV3U2VsZWN0ZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3U2VsZWN0ZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdFRoaXNOb2RlKG5ld1NlbGVjdGVkVmFsdWUpO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuY2FsY3VsYXRlU2VsZWN0ZWRGcm9tQ2hpbGRyZW5CdWJibGVVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVTZWxlY3RlZEZyb21DaGlsZHJlbigpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNhbGN1bGF0ZVNlbGVjdGVkRnJvbUNoaWxkcmVuQnViYmxlVXAoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuc2V0U2VsZWN0ZWRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAobmV3VmFsdWUsIGNsZWFyU2VsZWN0aW9uLCB0YWlsaW5nTm9kZUluU2VxdWVuY2UpIHtcbiAgICAgICAgaWYgKGNsZWFyU2VsZWN0aW9uID09PSB2b2lkIDApIHsgY2xlYXJTZWxlY3Rpb24gPSBmYWxzZTsgfVxuICAgICAgICBpZiAodGFpbGluZ05vZGVJblNlcXVlbmNlID09PSB2b2lkIDApIHsgdGFpbGluZ05vZGVJblNlcXVlbmNlID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZFBhcmFtcyh7XG4gICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICBjbGVhclNlbGVjdGlvbjogY2xlYXJTZWxlY3Rpb24sXG4gICAgICAgICAgICB0YWlsaW5nTm9kZUluU2VxdWVuY2U6IHRhaWxpbmdOb2RlSW5TZXF1ZW5jZSxcbiAgICAgICAgICAgIHJhbmdlU2VsZWN0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLmlzUm93UGlubmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dQaW5uZWQgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfVE9QIHx8IHRoaXMucm93UGlubmVkID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuUElOTkVEX0JPVFRPTTtcbiAgICB9O1xuICAgIC8vIHRvIG1ha2UgY2FsbGluZyBjb2RlIG1vcmUgcmVhZGFibGUsIHRoaXMgaXMgdGhlIHNhbWUgbWV0aG9kIGFzIHNldFNlbGVjdGVkIGV4Y2VwdCBpdCB0YWtlcyBuYW1lcyBwYXJhbWV0ZXJzXG4gICAgUm93Tm9kZS5wcm90b3R5cGUuc2V0U2VsZWN0ZWRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBncm91cFNlbGVjdHNDaGlsZHJlbiA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzR3JvdXBTZWxlY3RzQ2hpbGRyZW4oKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gcGFyYW1zLm5ld1ZhbHVlID09PSB0cnVlO1xuICAgICAgICB2YXIgY2xlYXJTZWxlY3Rpb24gPSBwYXJhbXMuY2xlYXJTZWxlY3Rpb24gPT09IHRydWU7XG4gICAgICAgIHZhciB0YWlsaW5nTm9kZUluU2VxdWVuY2UgPSBwYXJhbXMudGFpbGluZ05vZGVJblNlcXVlbmNlID09PSB0cnVlO1xuICAgICAgICB2YXIgcmFuZ2VTZWxlY3QgPSBwYXJhbXMucmFuZ2VTZWxlY3QgPT09IHRydWU7XG4gICAgICAgIC8vIGdyb3VwU2VsZWN0c0ZpbHRlcmVkIG9ubHkgbWFrZXMgc2Vuc2Ugd2hlbiBncm91cCBzZWxlY3RzIGNoaWxkcmVuXG4gICAgICAgIHZhciBncm91cFNlbGVjdHNGaWx0ZXJlZCA9IGdyb3VwU2VsZWN0c0NoaWxkcmVuICYmIChwYXJhbXMuZ3JvdXBTZWxlY3RzRmlsdGVyZWQgPT09IHRydWUpO1xuICAgICAgICBpZiAodGhpcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IGNhbm5vdCBzZWxlY3Qgbm9kZSB1bnRpbCBpZCBmb3Igbm9kZSBpcyBrbm93bicpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucm93UGlubmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogY2Fubm90IHNlbGVjdCBwaW5uZWQgcm93cycpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgYXJlIGEgZm9vdGVyLCB3ZSBkb24ndCBkbyBzZWxlY3Rpb24sIGp1c3QgcGFzcyB0aGUgaW5mb1xuICAgICAgICAvLyB0byB0aGUgc2libGluZyAodGhlIHBhcmVudCBvZiB0aGUgZ3JvdXApXG4gICAgICAgIGlmICh0aGlzLmZvb3Rlcikge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5zaWJsaW5nLnNldFNlbGVjdGVkUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlU2VsZWN0KSB7XG4gICAgICAgICAgICB2YXIgbmV3Um93Q2xpY2tlZCA9IHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5nZXRMYXN0U2VsZWN0ZWROb2RlKCkgIT09IHRoaXM7XG4gICAgICAgICAgICB2YXIgYWxsb3dNdWx0aVNlbGVjdCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzUm93U2VsZWN0aW9uTXVsdGkoKTtcbiAgICAgICAgICAgIGlmIChuZXdSb3dDbGlja2VkICYmIGFsbG93TXVsdGlTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb1Jvd1JhbmdlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZWRDb3VudCA9IDA7XG4gICAgICAgIC8vIHdoZW4gZ3JvdXBTZWxlY3RzRmlsdGVyZWQsIHRoZW4gdGhpcyBub2RlIG1heSBlbmQgdXAgaW50ZXJtZWRpYXRlIGRlc3BpdGVcbiAgICAgICAgLy8gdHJ5aW5nIHRvIHNldCBpdCB0byB0cnVlIC8gZmFsc2UuIHRoaXMgZ3JvdXAgd2lsbCBiZSBjYWxjdWxhdGVkIGZ1cnRoZXIgb25cbiAgICAgICAgLy8gZG93biB3aGVuIHdlIGNhbGwgY2FsY3VsYXRlZFNlbGVjdGVkRm9yQWxsR3JvdXBOb2RlcygpLiB3ZSBuZWVkIHRvIHNraXAgaXRcbiAgICAgICAgLy8gaGVyZSwgb3RoZXJ3aXNlIHRoZSB1cGRhdGVkQ291bnQgd291bGQgaW5jbHVkZSBpdC5cbiAgICAgICAgdmFyIHNraXBUaGlzTm9kZSA9IGdyb3VwU2VsZWN0c0ZpbHRlcmVkICYmIHRoaXMuZ3JvdXA7XG4gICAgICAgIGlmICghc2tpcFRoaXNOb2RlKSB7XG4gICAgICAgICAgICB2YXIgdGhpc05vZGVXYXNTZWxlY3RlZCA9IHRoaXMuc2VsZWN0VGhpc05vZGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXNOb2RlV2FzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBTZWxlY3RzQ2hpbGRyZW4gJiYgdGhpcy5ncm91cCkge1xuICAgICAgICAgICAgdXBkYXRlZENvdW50ICs9IHRoaXMuc2VsZWN0Q2hpbGROb2RlcyhuZXdWYWx1ZSwgZ3JvdXBTZWxlY3RzRmlsdGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIG90aGVyIG5vZGVzIGlmIG5vdCBkb2luZyBtdWx0aSBzZWxlY3RcbiAgICAgICAgdmFyIGFjdGlvbldhc09uVGhpc05vZGUgPSAhdGFpbGluZ05vZGVJblNlcXVlbmNlO1xuICAgICAgICBpZiAoYWN0aW9uV2FzT25UaGlzTm9kZSkge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICYmIChjbGVhclNlbGVjdGlvbiB8fCAhdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNSb3dTZWxlY3Rpb25NdWx0aSgpKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRDb3VudCArPSB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIuY2xlYXJPdGhlck5vZGVzKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSBpZiB3ZSBzZWxlY3RlZCBzb21ldGhpbmcsIHRoZW4gdXBkYXRlIGdyb3VwcyBhbmQgZmlyZSBldmVudHNcbiAgICAgICAgICAgIGlmICh1cGRhdGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGdyb3Vwc1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNlbGVjdHNGaWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZ3JvdXAgd2FzIHNlbGVjdGluZyBmaWx0ZXJlZCwgdGhlbiBhbGwgbm9kZXMgYWJvdmUgYW5kIG9yIGJlbG93XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBjb3VsZCBoYXZlIGNoZWNrLCB1bmNoZWNrZWQgb3IgaW50ZXJtZWRpYXRlLCBzbyBlYXNpZXN0IGlzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIHNlbGVjdGVkIHN0YXRlIGZvciBhbGwgZ3JvdXAgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVkU2VsZWN0ZWRGb3JBbGxHcm91cE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBzZWxlY3RpbmcgZmlsdGVyZWQsIHRoZW4gZXZlcnl0aGluZyBiZWxvdyB0aGUgZ3JvdXAgbm9kZSB3YXMgZWl0aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdGVkIG9yIG5vdCBzZWxlY3RlZCwgbm8gaW50ZXJtZWRpYXRlLCBzbyBubyBuZWVkIHRvIGNoZWNrIGl0ZW1zIGJlbG93XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb25lLCBqdXN0IHRoZSBwYXJlbnRzIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSByb290XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cFNlbGVjdHNDaGlsZHJlbiAmJiB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2FsY3VsYXRlU2VsZWN0ZWRGcm9tQ2hpbGRyZW5CdWJibGVVcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgdmVyeSBlbmQgb2YgdGhlICdhY3Rpb24gbm9kZScsIHNvIHdlIGFyZSBmaW5pc2hlZCBhbGwgdGhlIHVwZGF0ZXMsXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBhbnkgcGFyZW50IC8gY2hpbGQgY2hhbmdlcyB0aGF0IHRoaXMgbWV0aG9kIGNhdXNlZFxuICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfU0VMRUNUSU9OX0NIQU5HRUQsXG4gICAgICAgICAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5FdmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudF8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvIGlmIHVzZXIgbmV4dCBkb2VzIHNoaWZ0LXNlbGVjdCwgd2Uga25vdyB3aGVyZSB0byBzdGFydCB0aGUgc2VsZWN0aW9uIGZyb21cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5zZXRMYXN0U2VsZWN0ZWROb2RlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVkQ291bnQ7XG4gICAgfTtcbiAgICAvLyBzZWxlY3RzIGFsbCByb3dzIGJldHdlZW4gdGhpcyBub2RlIGFuZCB0aGUgbGFzdCBzZWxlY3RlZCBub2RlIChvciB0aGUgdG9wIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHNlbGVjdGlvbikuXG4gICAgLy8gbm90IHRvIGJlIG1peGVkIHVwIHdpdGggJ2NlbGwgcmFuZ2Ugc2VsZWN0aW9uJyB3aGVyZSB5b3UgZHJhZyB0aGUgbW91c2UsIHRoaXMgaXMgcm93IHJhbmdlIHNlbGVjdGlvbiwgYnlcbiAgICAvLyBob2xkaW5nIGRvd24gJ3NoaWZ0Jy5cbiAgICBSb3dOb2RlLnByb3RvdHlwZS5kb1Jvd1JhbmdlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXBkYXRlZENvdW50ID0gMDtcbiAgICAgICAgdmFyIGdyb3Vwc1NlbGVjdENoaWxkcmVuID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNHcm91cFNlbGVjdHNDaGlsZHJlbigpO1xuICAgICAgICB2YXIgbGFzdFNlbGVjdGVkTm9kZSA9IHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5nZXRMYXN0U2VsZWN0ZWROb2RlKCk7XG4gICAgICAgIHZhciBub2Rlc1RvU2VsZWN0ID0gdGhpcy5yb3dNb2RlbC5nZXROb2Rlc0luUmFuZ2VGb3JTZWxlY3Rpb24obGFzdFNlbGVjdGVkTm9kZSwgdGhpcyk7XG4gICAgICAgIG5vZGVzVG9TZWxlY3QuZm9yRWFjaChmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHJvd05vZGUuZ3JvdXAgJiYgZ3JvdXBzU2VsZWN0Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZVdhc1NlbGVjdGVkID0gcm93Tm9kZS5zZWxlY3RUaGlzTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIGlmIChub2RlV2FzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChncm91cHNTZWxlY3RDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVkU2VsZWN0ZWRGb3JBbGxHcm91cE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1NFTEVDVElPTl9DSEFOR0VELFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFpbkV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRDb3VudDtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLmlzUGFyZW50T2ZOb2RlID0gZnVuY3Rpb24gKHBvdGVudGlhbFBhcmVudCkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHBvdGVudGlhbFBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLmNhbGN1bGF0ZWRTZWxlY3RlZEZvckFsbEdyb3VwTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHdlIGRvIHRoaXMgZGVwdCBmaXJzdCwgYXMgcGFyZW50IG5vZGVzXG4gICAgICAgIC8vIHdpbGwgaGF2ZSBkZXBlbmRlbmNpZXMgb24gdGhlIGNoaWxkcmVuIGhhdmluZyBjb3JyZWN0IHZhbHVlc1xuICAgICAgICB2YXIgaW5NZW1vcnlSb3dNb2RlbCA9IHRoaXMucm93TW9kZWw7XG4gICAgICAgIGluTWVtb3J5Um93TW9kZWwuZ2V0VG9wTGV2ZWxOb2RlcygpLmZvckVhY2goZnVuY3Rpb24gKHRvcExldmVsTm9kZSkge1xuICAgICAgICAgICAgaWYgKHRvcExldmVsTm9kZS5ncm91cCkge1xuICAgICAgICAgICAgICAgIHRvcExldmVsTm9kZS5kZXB0aEZpcnN0U2VhcmNoKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmNhbGN1bGF0ZVNlbGVjdGVkRnJvbUNoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbE5vZGUuY2FsY3VsYXRlU2VsZWN0ZWRGcm9tQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5zZWxlY3RUaGlzTm9kZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gbmV3VmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50U2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaExvY2FsRXZlbnQodGhpcy5jcmVhdGVMb2NhbFJvd0V2ZW50KFJvd05vZGUuRVZFTlRfUk9XX1NFTEVDVEVEKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5jcmVhdGVHbG9iYWxSb3dFdmVudChldmVudHNfMS5FdmVudHMuRVZFTlRfUk9XX1NFTEVDVEVEKTtcbiAgICAgICAgdGhpcy5tYWluRXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLnNlbGVjdENoaWxkTm9kZXMgPSBmdW5jdGlvbiAobmV3VmFsdWUsIGdyb3VwU2VsZWN0c0ZpbHRlcmVkKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGdyb3VwU2VsZWN0c0ZpbHRlcmVkID8gdGhpcy5jaGlsZHJlbkFmdGVyRmlsdGVyIDogdGhpcy5jaGlsZHJlbkFmdGVyR3JvdXA7XG4gICAgICAgIHZhciB1cGRhdGVkQ291bnQgPSAwO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHVwZGF0ZWRDb3VudCArPSBjaGlsZHJlbltpXS5zZXRTZWxlY3RlZFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgIGNsZWFyU2VsZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YWlsaW5nTm9kZUluU2VxdWVuY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVkQ291bnQ7XG4gICAgfTtcbiAgICBSb3dOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50U2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UgPSBuZXcgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFJvd05vZGUucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUub25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTG9jYWxFdmVudCh0aGlzLmNyZWF0ZUxvY2FsUm93RXZlbnQoUm93Tm9kZS5FVkVOVF9NT1VTRV9FTlRFUikpO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTG9jYWxFdmVudCh0aGlzLmNyZWF0ZUxvY2FsUm93RXZlbnQoUm93Tm9kZS5FVkVOVF9NT1VTRV9MRUFWRSkpO1xuICAgIH07XG4gICAgUm93Tm9kZS5wcm90b3R5cGUuZ2V0Rmlyc3RDaGlsZE9mRmlyc3RDaGlsZCA9IGZ1bmN0aW9uIChyb3dHcm91cENvbHVtbikge1xuICAgICAgICB2YXIgY3VycmVudFJvd05vZGUgPSB0aGlzO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgaGlkaW5nIGdyb3VwcywgdGhlbiBpZiB3ZSBhcmUgdGhlIGZpcnN0IGNoaWxkLCBvZiB0aGUgZmlyc3QgY2hpbGQsXG4gICAgICAgIC8vIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBjb2x1bW4gd2UgYXJlIGludGVyZXN0ZWQgaW4sIHRoZW4gd2Ugc2hvdyB0aGUgZ3JvdXAgY2VsbC5cbiAgICAgICAgdmFyIGlzQ2FuZGlkYXRlID0gdHJ1ZTtcbiAgICAgICAgdmFyIGZvdW5kRmlyc3RDaGlsZFBhdGggPSBmYWxzZTtcbiAgICAgICAgdmFyIG5vZGVUb1N3YXBJbjtcbiAgICAgICAgd2hpbGUgKGlzQ2FuZGlkYXRlICYmICFmb3VuZEZpcnN0Q2hpbGRQYXRoKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Um93Tm9kZSA9IGN1cnJlbnRSb3dOb2RlLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBmaXJzdENoaWxkID0gdXRpbHNfMS5VdGlscy5leGlzdHMocGFyZW50Um93Tm9kZSkgJiYgY3VycmVudFJvd05vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFJvd05vZGUucm93R3JvdXBDb2x1bW4gPT09IHJvd0dyb3VwQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRmlyc3RDaGlsZFBhdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlVG9Td2FwSW4gPSBwYXJlbnRSb3dOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzQ2FuZGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Um93Tm9kZSA9IHBhcmVudFJvd05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kRmlyc3RDaGlsZFBhdGggPyBub2RlVG9Td2FwSW4gOiBudWxsO1xuICAgIH07XG4gICAgUm93Tm9kZS5FVkVOVF9ST1dfU0VMRUNURUQgPSAncm93U2VsZWN0ZWQnO1xuICAgIFJvd05vZGUuRVZFTlRfREFUQV9DSEFOR0VEID0gJ2RhdGFDaGFuZ2VkJztcbiAgICBSb3dOb2RlLkVWRU5UX0NFTExfQ0hBTkdFRCA9ICdjZWxsQ2hhbmdlZCc7XG4gICAgUm93Tm9kZS5FVkVOVF9BTExfQ0hJTERSRU5fQ09VTlRfQ0hBTkdFRCA9ICdhbGxDaGlsZHJlbkNvdW50Q2hhbmdlZCc7XG4gICAgUm93Tm9kZS5FVkVOVF9NT1VTRV9FTlRFUiA9ICdtb3VzZUVudGVyJztcbiAgICBSb3dOb2RlLkVWRU5UX01PVVNFX0xFQVZFID0gJ21vdXNlTGVhdmUnO1xuICAgIFJvd05vZGUuRVZFTlRfSEVJR0hUX0NIQU5HRUQgPSAnaGVpZ2h0Q2hhbmdlZCc7XG4gICAgUm93Tm9kZS5FVkVOVF9UT1BfQ0hBTkdFRCA9ICd0b3BDaGFuZ2VkJztcbiAgICBSb3dOb2RlLkVWRU5UX0ZJUlNUX0NISUxEX0NIQU5HRUQgPSAnZmlyc3RDaGlsZENoYW5nZWQnO1xuICAgIFJvd05vZGUuRVZFTlRfTEFTVF9DSElMRF9DSEFOR0VEID0gJ2xhc3RDaGlsZENoYW5nZWQnO1xuICAgIFJvd05vZGUuRVZFTlRfQ0hJTERfSU5ERVhfQ0hBTkdFRCA9ICdjaGlsZEluZGV4Q2hhbmdlZCc7XG4gICAgUm93Tm9kZS5FVkVOVF9ST1dfSU5ERVhfQ0hBTkdFRCA9ICdyb3dJbmRleENoYW5nZWQnO1xuICAgIFJvd05vZGUuRVZFTlRfRVhQQU5ERURfQ0hBTkdFRCA9ICdleHBhbmRlZENoYW5nZWQnO1xuICAgIFJvd05vZGUuRVZFTlRfVUlfTEVWRUxfQ0hBTkdFRCA9ICd1aUxldmVsQ2hhbmdlZCc7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIFJvd05vZGUucHJvdG90eXBlLCBcIm1haW5FdmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgUm93Tm9kZS5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3NlbGVjdGlvbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNlbGVjdGlvbkNvbnRyb2xsZXJfMS5TZWxlY3Rpb25Db250cm9sbGVyKVxuICAgIF0sIFJvd05vZGUucHJvdG90eXBlLCBcInNlbGVjdGlvbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgUm93Tm9kZS5wcm90b3R5cGUsIFwiY29sdW1uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCd2YWx1ZVNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHZhbHVlU2VydmljZV8xLlZhbHVlU2VydmljZSlcbiAgICBdLCBSb3dOb2RlLnByb3RvdHlwZSwgXCJ2YWx1ZVNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncm93TW9kZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBSb3dOb2RlLnByb3RvdHlwZSwgXCJyb3dNb2RlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBSb3dOb2RlLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3ZhbHVlQ2FjaGUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHZhbHVlQ2FjaGVfMS5WYWx1ZUNhY2hlKVxuICAgIF0sIFJvd05vZGUucHJvdG90eXBlLCBcInZhbHVlQ2FjaGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIFJvd05vZGUucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBSb3dOb2RlLnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFJvd05vZGU7XG59KCkpO1xuZXhwb3J0cy5Sb3dOb2RlID0gUm93Tm9kZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2VudGl0aWVzL3Jvd05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgcG9wdXBTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9wb3B1cFNlcnZpY2VcIik7XG52YXIgdmFsdWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVTZXJ2aWNlL3ZhbHVlU2VydmljZVwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4uL2V2ZW50c1wiKTtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi4vZ3JpZEFwaVwiKTtcbnZhciBjb21wb25lbnRSZXNvbHZlcl8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvZnJhbWV3b3JrL2NvbXBvbmVudFJlc29sdmVyXCIpO1xudmFyIEZpbHRlck1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbHRlck1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuYWxsRmlsdGVycyA9IHt9O1xuICAgICAgICB0aGlzLnF1aWNrRmlsdGVyID0gbnVsbDtcbiAgICB9XG4gICAgRmlsdGVyTWFuYWdlcl8xID0gRmlsdGVyTWFuYWdlcjtcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9ST1dfREFUQV9DSEFOR0VELCB0aGlzLm9uTmV3Um93c0xvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfTkVXX0NPTFVNTlNfTE9BREVELCB0aGlzLm9uTmV3Q29sdW1uc0xvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5xdWlja0ZpbHRlciA9IHRoaXMucGFyc2VRdWlja0ZpbHRlcih0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRRdWlja0ZpbHRlclRleHQoKSk7XG4gICAgICAgIC8vIGNoZWNrIHRoaXMgaGVyZSwgaW4gY2FzZSB0aGVyZSBpcyBhIGZpbHRlciBmcm9tIHRoZSBzdGFydFxuICAgICAgICB0aGlzLmNoZWNrRXh0ZXJuYWxGaWx0ZXIoKTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnNldEZpbHRlck1vZGVsID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbGxQcm9taXNlcyA9IFtdO1xuICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIC8vIG1hcmsgdGhlIGZpbHRlcnMgYXMgd2Ugc2V0IHRoZW0sIHNvIGFueSBhY3RpdmUgZmlsdGVycyBsZWZ0IG92ZXIgd2Ugc3RvcFxuICAgICAgICAgICAgdmFyIG1vZGVsS2V5c18xID0gT2JqZWN0LmtleXMobW9kZWwpO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMuYWxsRmlsdGVycywgZnVuY3Rpb24gKGNvbElkLCBmaWx0ZXJXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVGcm9tQXJyYXkobW9kZWxLZXlzXzEsIGNvbElkKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TW9kZWwgPSBtb2RlbFtjb2xJZF07XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0TW9kZWxPbkZpbHRlcldyYXBwZXIoZmlsdGVyV3JhcHBlci5maWx0ZXJQcm9taXNlLCBuZXdNb2RlbCk7XG4gICAgICAgICAgICAgICAgYWxsUHJvbWlzZXMucHVzaChmaWx0ZXJXcmFwcGVyLmZpbHRlclByb21pc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCBwcm9jZXNzZWRGaWVsZHMgY29udGFpbnMgZGF0YSBmb3Igd2hpY2ggd2UgZG9uJ3QgaGF2ZSBhIGZpbHRlciB3b3JraW5nIHlldFxuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlQXJyYXkobW9kZWxLZXlzXzEsIGZ1bmN0aW9uIChjb2xJZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBfdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldFByaW1hcnlDb2x1bW4oY29sSWQpO1xuICAgICAgICAgICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZyBhZy1ncmlkIHNldEZpbHRlck1vZGVsIC0gbm8gY29sdW1uIGZvdW5kIGZvciBjb2xJZCAnICsgY29sSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJXcmFwcGVyID0gX3RoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJXcmFwcGVyKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0TW9kZWxPbkZpbHRlcldyYXBwZXIoZmlsdGVyV3JhcHBlci5maWx0ZXJQcm9taXNlLCBtb2RlbFtjb2xJZF0pO1xuICAgICAgICAgICAgICAgIGFsbFByb21pc2VzLnB1c2goZmlsdGVyV3JhcHBlci5maWx0ZXJQcm9taXNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMuYWxsRmlsdGVycywgZnVuY3Rpb24gKGtleSwgZmlsdGVyV3JhcHBlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldE1vZGVsT25GaWx0ZXJXcmFwcGVyKGZpbHRlcldyYXBwZXIuZmlsdGVyUHJvbWlzZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYWxsUHJvbWlzZXMucHVzaChmaWx0ZXJXcmFwcGVyLmZpbHRlclByb21pc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbHNfMS5Qcm9taXNlLmFsbChhbGxQcm9taXNlcykudGhlbihmdW5jdGlvbiAod2hhdGV2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLm9uRmlsdGVyQ2hhbmdlZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnNldE1vZGVsT25GaWx0ZXJXcmFwcGVyID0gZnVuY3Rpb24gKGZpbHRlclByb21pc2UsIG5ld01vZGVsKSB7XG4gICAgICAgIGZpbHRlclByb21pc2UudGhlbihmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlci5zZXRNb2RlbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZyBhZy1ncmlkIC0gZmlsdGVyIG1pc3Npbmcgc2V0TW9kZWwgbWV0aG9kLCB3aGljaCBpcyBuZWVkZWQgZm9yIHNldEZpbHRlck1vZGVsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyLnNldE1vZGVsKG5ld01vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5nZXRGaWx0ZXJNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5hbGxGaWx0ZXJzLCBmdW5jdGlvbiAoa2V5LCBmaWx0ZXJXcmFwcGVyKSB7XG4gICAgICAgICAgICAvLyBiZWNhdXNlIHVzZXIgY2FuIHByb3ZpZGUgZmlsdGVycywgd2UgcHJvdmlkZSB1c2VmdWwgZXJyb3IgY2hlY2tpbmcgYW5kIG1lc3NhZ2VzXG4gICAgICAgICAgICB2YXIgZmlsdGVyUHJvbWlzZSA9IGZpbHRlcldyYXBwZXIuZmlsdGVyUHJvbWlzZTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJQcm9taXNlLnJlc29sdmVOb3cobnVsbCwgZnVuY3Rpb24gKGZpbHRlcikgeyByZXR1cm4gZmlsdGVyOyB9KTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyLmdldE1vZGVsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nIGFnLWdyaWQgLSBmaWx0ZXIgQVBJIG1pc3NpbmcgZ2V0TW9kZWwgbWV0aG9kLCB3aGljaCBpcyBuZWVkZWQgZm9yIGdldEZpbHRlck1vZGVsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vZGVsID0gZmlsdGVyLmdldE1vZGVsKCk7XG4gICAgICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMobW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBtb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIHRydWUgaWYgYW55IGFkdmFuY2VkIGZpbHRlciAoaWUgbm90IHF1aWNrIGZpbHRlcikgYWN0aXZlXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuaXNBZHZhbmNlZEZpbHRlclByZXNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkdmFuY2VkRmlsdGVyUHJlc2VudDtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnNldEFkdmFuY2VkRmlsdGVyUHJlc2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF0TGVhc3RPbmVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMuYWxsRmlsdGVycywgZnVuY3Rpb24gKGtleSwgZmlsdGVyV3JhcHBlcikge1xuICAgICAgICAgICAgaWYgKGZpbHRlcldyYXBwZXIuZmlsdGVyUHJvbWlzZS5yZXNvbHZlTm93KGZhbHNlLCBmdW5jdGlvbiAoZmlsdGVyKSB7IHJldHVybiBmaWx0ZXIuaXNGaWx0ZXJBY3RpdmUoKTsgfSkpIHtcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWR2YW5jZWRGaWx0ZXJQcmVzZW50ID0gYXRMZWFzdE9uZUFjdGl2ZTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUZpbHRlckZsYWdJbkNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuaXRlcmF0ZU9iamVjdCh0aGlzLmFsbEZpbHRlcnMsIGZ1bmN0aW9uIChrZXksIGZpbHRlcldyYXBwZXIpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJBY3RpdmUgPSBmaWx0ZXJXcmFwcGVyLmZpbHRlclByb21pc2UucmVzb2x2ZU5vdyhmYWxzZSwgZnVuY3Rpb24gKGZpbHRlcikgeyByZXR1cm4gZmlsdGVyLmlzRmlsdGVyQWN0aXZlKCk7IH0pO1xuICAgICAgICAgICAgZmlsdGVyV3JhcHBlci5jb2x1bW4uc2V0RmlsdGVyQWN0aXZlKGZpbHRlckFjdGl2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gcmV0dXJucyB0cnVlIGlmIHF1aWNrRmlsdGVyIG9yIGFkdmFuY2VkRmlsdGVyXG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuaXNBbnlGaWx0ZXJQcmVzZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1F1aWNrRmlsdGVyUHJlc2VudCgpIHx8IHRoaXMuYWR2YW5jZWRGaWx0ZXJQcmVzZW50IHx8IHRoaXMuZXh0ZXJuYWxGaWx0ZXJQcmVzZW50O1xuICAgIH07XG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZG9lc0ZpbHRlclBhc3MgPSBmdW5jdGlvbiAobm9kZSwgZmlsdGVyVG9Ta2lwKSB7XG4gICAgICAgIHZhciBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgICB2YXIgY29sS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuYWxsRmlsdGVycyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29sS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2xJZCA9IGNvbEtleXNbaV07XG4gICAgICAgICAgICB2YXIgZmlsdGVyV3JhcHBlciA9IHRoaXMuYWxsRmlsdGVyc1tjb2xJZF07XG4gICAgICAgICAgICAvLyBpZiBubyBmaWx0ZXIsIGFsd2F5cyBwYXNzXG4gICAgICAgICAgICBpZiAoZmlsdGVyV3JhcHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gZmlsdGVyV3JhcHBlci5maWx0ZXJQcm9taXNlLnJlc29sdmVOb3codW5kZWZpbmVkLCBmdW5jdGlvbiAoZmlsdGVyKSB7IHJldHVybiBmaWx0ZXI7IH0pO1xuICAgICAgICAgICAgLy8gaWYgZmlsdGVyIG5vdCB5ZXQgdGhlcmUsIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXIgPT09IGZpbHRlclRvU2tpcCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgYm90aGVyIHdpdGggZmlsdGVycyB0aGF0IGFyZSBub3QgYWN0aXZlXG4gICAgICAgICAgICBpZiAoIWZpbHRlci5pc0ZpbHRlckFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZpbHRlci5kb2VzRmlsdGVyUGFzcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZpbHRlciBpcyBtaXNzaW5nIG1ldGhvZCBkb2VzRmlsdGVyUGFzcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWZpbHRlci5kb2VzRmlsdGVyUGFzcyhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsbCBmaWx0ZXJzIHBhc3NlZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnBhcnNlUXVpY2tGaWx0ZXIgPSBmdW5jdGlvbiAobmV3RmlsdGVyKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcobmV3RmlsdGVyKSB8fCBuZXdGaWx0ZXIgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1Jvd01vZGVsSW5maW5pdGUoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBjYW5ub3QgZG8gcXVpY2sgZmlsdGVyaW5nIHdoZW4gZG9pbmcgdmlydHVhbCBwYWdpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdGaWx0ZXIudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBoYXMgY2hhbmdlZCAobm90IGp1c3Qgc2FtZSB2YWx1ZSBhZ2FpbilcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXRRdWlja0ZpbHRlciA9IGZ1bmN0aW9uIChuZXdGaWx0ZXIpIHtcbiAgICAgICAgdmFyIHBhcnNlZEZpbHRlciA9IHRoaXMucGFyc2VRdWlja0ZpbHRlcihuZXdGaWx0ZXIpO1xuICAgICAgICBpZiAodGhpcy5xdWlja0ZpbHRlciAhPT0gcGFyc2VkRmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnF1aWNrRmlsdGVyID0gcGFyc2VkRmlsdGVyO1xuICAgICAgICAgICAgdGhpcy5vbkZpbHRlckNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuY2hlY2tFeHRlcm5hbEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZpbHRlclByZXNlbnQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0V4dGVybmFsRmlsdGVyUHJlc2VudCgpO1xuICAgIH07XG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUub25GaWx0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldEFkdmFuY2VkRmlsdGVyUHJlc2VudCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlckZsYWdJbkNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jaGVja0V4dGVybmFsRmlsdGVyKCk7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuaXRlcmF0ZU9iamVjdCh0aGlzLmFsbEZpbHRlcnMsIGZ1bmN0aW9uIChrZXksIGZpbHRlcldyYXBwZXIpIHtcbiAgICAgICAgICAgIGZpbHRlcldyYXBwZXIuZmlsdGVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLm9uQW55RmlsdGVyQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIub25BbnlGaWx0ZXJDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfRklMVEVSX0NIQU5HRUQsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5pc1F1aWNrRmlsdGVyUHJlc2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVpY2tGaWx0ZXIgIT09IG51bGw7XG4gICAgfTtcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5kb2VzUm93UGFzc090aGVyRmlsdGVycyA9IGZ1bmN0aW9uIChmaWx0ZXJUb1NraXAsIG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9lc1Jvd1Bhc3NGaWx0ZXIobm9kZSwgZmlsdGVyVG9Ta2lwKTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmRvZXNSb3dQYXNzUXVpY2tGaWx0ZXJOb0NhY2hlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0QWxsUHJpbWFyeUNvbHVtbnMoKTtcbiAgICAgICAgdmFyIGZpbHRlclBhc3NlcyA9IGZhbHNlO1xuICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgaWYgKGZpbHRlclBhc3Nlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJ0ID0gX3RoaXMuZ2V0UXVpY2tGaWx0ZXJUZXh0Rm9yQ29sdW1uKGNvbHVtbiwgbm9kZSk7XG4gICAgICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5pbmRleE9mKF90aGlzLnF1aWNrRmlsdGVyKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclBhc3NlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlclBhc3NlcztcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmRvZXNSb3dQYXNzUXVpY2tGaWx0ZXJDYWNoZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5xdWlja0ZpbHRlckFnZ3JlZ2F0ZVRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWdncmVnYXRlUm93Rm9yUXVpY2tGaWx0ZXIobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbHRlclBhc3NlcyA9IG5vZGUucXVpY2tGaWx0ZXJBZ2dyZWdhdGVUZXh0LmluZGV4T2YodGhpcy5xdWlja0ZpbHRlcikgPj0gMDtcbiAgICAgICAgcmV0dXJuIGZpbHRlclBhc3NlcztcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmRvZXNSb3dQYXNzUXVpY2tGaWx0ZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgZmlsdGVyUGFzc2VzO1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNDYWNoZVF1aWNrRmlsdGVyKCkpIHtcbiAgICAgICAgICAgIGZpbHRlclBhc3NlcyA9IHRoaXMuZG9lc1Jvd1Bhc3NRdWlja0ZpbHRlckNhY2hlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlsdGVyUGFzc2VzID0gdGhpcy5kb2VzUm93UGFzc1F1aWNrRmlsdGVyTm9DYWNoZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyUGFzc2VzO1xuICAgIH07XG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZG9lc1Jvd1Bhc3NGaWx0ZXIgPSBmdW5jdGlvbiAobm9kZSwgZmlsdGVyVG9Ta2lwKSB7XG4gICAgICAgIC8vIHRoZSByb3cgbXVzdCBwYXNzIEFMTCBvZiB0aGUgZmlsdGVycywgc28gaWYgYW55IG9mIHRoZW0gZmFpbCxcbiAgICAgICAgLy8gd2UgcmV0dXJuIHRydWUuIHRoYXQgbWVhbnMgaWYgYSByb3cgcGFzc2VzIHRoZSBxdWljayBmaWx0ZXIsXG4gICAgICAgIC8vIGJ1dCBmYWlscyB0aGUgY29sdW1uIGZpbHRlciwgaXQgZmFpbHMgb3ZlcmFsbFxuICAgICAgICAvLyBmaXJzdCB1cCwgY2hlY2sgcXVpY2sgZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmlzUXVpY2tGaWx0ZXJQcmVzZW50KCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb2VzUm93UGFzc1F1aWNrRmlsdGVyKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlY29uZGx5LCBnaXZlIHRoZSBjbGllbnQgYSBjaGFuY2UgdG8gcmVqZWN0IHRoaXMgcm93XG4gICAgICAgIGlmICh0aGlzLmV4dGVybmFsRmlsdGVyUHJlc2VudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5kb2VzRXh0ZXJuYWxGaWx0ZXJQYXNzKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxhc3RseSwgY2hlY2sgb3VyIGludGVybmFsIGFkdmFuY2VkIGZpbHRlclxuICAgICAgICBpZiAodGhpcy5hZHZhbmNlZEZpbHRlclByZXNlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb2VzRmlsdGVyUGFzcyhub2RlLCBmaWx0ZXJUb1NraXApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGdvdCB0aGlzIGZhciwgYWxsIGZpbHRlcnMgcGFzc1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmdldFF1aWNrRmlsdGVyVGV4dEZvckNvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW4sIHJvd05vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZVNlcnZpY2UuZ2V0VmFsdWUoY29sdW1uLCByb3dOb2RlKTtcbiAgICAgICAgdmFyIHZhbHVlQWZ0ZXJDYWxsYmFjaztcbiAgICAgICAgdmFyIGNvbERlZiA9IGNvbHVtbi5nZXRDb2xEZWYoKTtcbiAgICAgICAgaWYgKGNvbHVtbi5nZXRDb2xEZWYoKS5nZXRRdWlja0ZpbHRlclRleHQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG5vZGU6IHJvd05vZGUsXG4gICAgICAgICAgICAgICAgZGF0YTogcm93Tm9kZS5kYXRhLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIGNvbERlZjogY29sRGVmXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWVBZnRlckNhbGxiYWNrID0gY29sdW1uLmdldENvbERlZigpLmdldFF1aWNrRmlsdGVyVGV4dChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVBZnRlckNhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlQWZ0ZXJDYWxsYmFjayAmJiB2YWx1ZUFmdGVyQ2FsbGJhY2sgIT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVBZnRlckNhbGxiYWNrLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5hZ2dyZWdhdGVSb3dGb3JRdWlja0ZpbHRlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdHJpbmdQYXJ0cyA9IFtdO1xuICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRBbGxQcmltYXJ5Q29sdW1ucygpO1xuICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBfdGhpcy5nZXRRdWlja0ZpbHRlclRleHRGb3JDb2x1bW4oY29sdW1uLCBub2RlKTtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHN0cmluZ1BhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLnF1aWNrRmlsdGVyQWdncmVnYXRlVGV4dCA9IHN0cmluZ1BhcnRzLmpvaW4oRmlsdGVyTWFuYWdlcl8xLlFVSUNLX0ZJTFRFUl9TRVBBUkFUT1IpO1xuICAgIH07XG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUub25OZXdSb3dzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5hbGxGaWx0ZXJzLCBmdW5jdGlvbiAoa2V5LCBmaWx0ZXJXcmFwcGVyKSB7XG4gICAgICAgICAgICBmaWx0ZXJXcmFwcGVyLmZpbHRlclByb21pc2UudGhlbihmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlci5vbk5ld1Jvd3NMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLm9uTmV3Um93c0xvYWRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVGaWx0ZXJGbGFnSW5Db2x1bW5zKCk7XG4gICAgICAgIHRoaXMuc2V0QWR2YW5jZWRGaWx0ZXJQcmVzZW50KCk7XG4gICAgfTtcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVWYWx1ZUdldHRlciA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdmFsdWVHZXR0ZXIobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoYXQudmFsdWVTZXJ2aWNlLmdldFZhbHVlKGNvbHVtbiwgbm9kZSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5nZXRGaWx0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHZhciBmaWx0ZXJXcmFwcGVyID0gdGhpcy5nZXRPckNyZWF0ZUZpbHRlcldyYXBwZXIoY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcldyYXBwZXIuZmlsdGVyUHJvbWlzZTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmdldE9yQ3JlYXRlRmlsdGVyV3JhcHBlciA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIGZpbHRlcldyYXBwZXIgPSB0aGlzLmNhY2hlZEZpbHRlcihjb2x1bW4pO1xuICAgICAgICBpZiAoIWZpbHRlcldyYXBwZXIpIHtcbiAgICAgICAgICAgIGZpbHRlcldyYXBwZXIgPSB0aGlzLmNyZWF0ZUZpbHRlcldyYXBwZXIoY29sdW1uKTtcbiAgICAgICAgICAgIHRoaXMuYWxsRmlsdGVyc1tjb2x1bW4uZ2V0Q29sSWQoKV0gPSBmaWx0ZXJXcmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXJXcmFwcGVyO1xuICAgIH07XG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuY2FjaGVkRmlsdGVyID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxGaWx0ZXJzW2NvbHVtbi5nZXRDb2xJZCgpXTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUZpbHRlckluc3RhbmNlID0gZnVuY3Rpb24gKGNvbHVtbiwgJHNjb3BlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZhdWx0RmlsdGVyID0gJ3RleHRDb2x1bW5GaWx0ZXInO1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbnRlcnByaXNlKCkpIHtcbiAgICAgICAgICAgIGRlZmF1bHRGaWx0ZXIgPSAnc2V0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2FuaXRpc2VkQ29sRGVmID0gdXRpbHNfMS5VdGlscy5jbG9uZU9iamVjdChjb2x1bW4uZ2V0Q29sRGVmKCkpO1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfRklMVEVSX01PRElGSUVELFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNsYXRlRmlsdGVyKHNhbml0aXNlZENvbERlZiwgJ3NldCcpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZUZpbHRlcihzYW5pdGlzZWRDb2xEZWYsICd0ZXh0Jyk7XG4gICAgICAgIHRoaXMudHJhbnNsYXRlRmlsdGVyKHNhbml0aXNlZENvbERlZiwgJ251bWJlcicpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZUZpbHRlcihzYW5pdGlzZWRDb2xEZWYsICdkYXRlJyk7XG4gICAgICAgIHZhciBmaWx0ZXJDaGFuZ2VkQ2FsbGJhY2sgPSB0aGlzLm9uRmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB2YXIgZmlsdGVyTW9kaWZpZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgfTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgY29sRGVmOiBzYW5pdGlzZWRDb2xEZWYsXG4gICAgICAgICAgICByb3dNb2RlbDogdGhpcy5yb3dNb2RlbCxcbiAgICAgICAgICAgIGZpbHRlckNoYW5nZWRDYWxsYmFjazogZmlsdGVyQ2hhbmdlZENhbGxiYWNrLFxuICAgICAgICAgICAgZmlsdGVyTW9kaWZpZWRDYWxsYmFjazogZmlsdGVyTW9kaWZpZWRDYWxsYmFjayxcbiAgICAgICAgICAgIHZhbHVlR2V0dGVyOiB0aGlzLmNyZWF0ZVZhbHVlR2V0dGVyKGNvbHVtbiksXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICBkb2VzUm93UGFzc090aGVyRmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgJHNjb3BlOiAkc2NvcGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50UmVzb2x2ZXIuY3JlYXRlQWdHcmlkQ29tcG9uZW50KHNhbml0aXNlZENvbERlZiwgcGFyYW1zLCAnZmlsdGVyJywgZGVmYXVsdEZpbHRlciwgdHJ1ZSwgZnVuY3Rpb24gKHBhcmFtcywgZmlsdGVyKSB7IHJldHVybiB1dGlsc18xLlV0aWxzLmFzc2lnbihwYXJhbXMsIHtcbiAgICAgICAgICAgIGRvZXNSb3dQYXNzT3RoZXJGaWx0ZXI6IF90aGlzLmRvZXNSb3dQYXNzT3RoZXJGaWx0ZXJzLmJpbmQoX3RoaXMsIGZpbHRlciksXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnRyYW5zbGF0ZUZpbHRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHRvVHJhbnNsYXRlKSB7XG4gICAgICAgIGlmICh0YXJnZXQuZmlsdGVyID09PSB0b1RyYW5zbGF0ZSkge1xuICAgICAgICAgICAgdGFyZ2V0LmZpbHRlciA9IHRvVHJhbnNsYXRlICsgXCJDb2x1bW5GaWx0ZXJcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlRmlsdGVyV3JhcHBlciA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIGZpbHRlcldyYXBwZXIgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGZpbHRlclByb21pc2U6IG51bGwsXG4gICAgICAgICAgICBzY29wZTogbnVsbCxcbiAgICAgICAgICAgIGd1aVByb21pc2U6IHV0aWxzXzEuUHJvbWlzZS5leHRlcm5hbCgpXG4gICAgICAgIH07XG4gICAgICAgIHZhciAkc2NvcGUgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0FuZ3VsYXJDb21waWxlRmlsdGVycygpID8gdGhpcy4kc2NvcGUuJG5ldygpIDogbnVsbDtcbiAgICAgICAgZmlsdGVyV3JhcHBlci5maWx0ZXJQcm9taXNlID0gdGhpcy5jcmVhdGVGaWx0ZXJJbnN0YW5jZShjb2x1bW4sICRzY29wZSk7XG4gICAgICAgIHRoaXMucHV0SW50b0d1aShmaWx0ZXJXcmFwcGVyKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcldyYXBwZXI7XG4gICAgfTtcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5wdXRJbnRvR3VpID0gZnVuY3Rpb24gKGZpbHRlcldyYXBwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVGaWx0ZXJHdWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZUZpbHRlckd1aS5jbGFzc05hbWUgPSAnYWctZmlsdGVyJztcbiAgICAgICAgZmlsdGVyV3JhcHBlci5maWx0ZXJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgdmFyIGd1aUZyb21GaWx0ZXIgPSBmaWx0ZXIuZ2V0R3VpKCk7XG4gICAgICAgICAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBBbmd1bGFyIDEgLSB3ZVxuICAgICAgICAgICAgLy8gdXNlZCB0byBhbGxvdyBwcm92aWRpbmcgYmFjayBIVE1MIGZyb20gZ2V0R3VpKCkuXG4gICAgICAgICAgICAvLyBvbmNlIHdlIG1vdmUgYXdheSBmcm9tIHN1cHBvcnRpbmcgQW5ndWxhciAxXG4gICAgICAgICAgICAvLyBkaXJlY3RseSwgd2UgY2FuIGNoYW5nZSB0aGlzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBndWlGcm9tRmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGd1aUZyb21GaWx0ZXIgPSB1dGlsc18xLlV0aWxzLmxvYWRUZW1wbGF0ZShndWlGcm9tRmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVGaWx0ZXJHdWkuYXBwZW5kQ2hpbGQoZ3VpRnJvbUZpbHRlcik7XG4gICAgICAgICAgICBpZiAoZmlsdGVyV3JhcHBlci5zY29wZSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcldyYXBwZXIuZ3VpUHJvbWlzZS5yZXNvbHZlKF90aGlzLiRjb21waWxlKGVGaWx0ZXJHdWkpKGZpbHRlcldyYXBwZXIuc2NvcGUpWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlcldyYXBwZXIuZ3VpUHJvbWlzZS5yZXNvbHZlKGVGaWx0ZXJHdWkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLm9uTmV3Q29sdW1uc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvLyBkZXN0cm95cyB0aGUgZmlsdGVyLCBzbyBpdCBub3QgbG9uZ2VyIHRha2VzIHBhcnRcbiAgICBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95RmlsdGVyID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgZmlsdGVyV3JhcHBlciA9IHRoaXMuYWxsRmlsdGVyc1tjb2x1bW4uZ2V0Q29sSWQoKV07XG4gICAgICAgIGlmIChmaWx0ZXJXcmFwcGVyKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VGaWx0ZXJXcmFwcGVyKGZpbHRlcldyYXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5vbkZpbHRlckNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZUZpbHRlcldyYXBwZXIgPSBmdW5jdGlvbiAoZmlsdGVyV3JhcHBlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBmaWx0ZXJXcmFwcGVyLmZpbHRlclByb21pc2UudGhlbihmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICBmaWx0ZXIuc2V0TW9kZWwobnVsbCk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyV3JhcHBlci5jb2x1bW4uc2V0RmlsdGVyQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5hbGxGaWx0ZXJzW2ZpbHRlcldyYXBwZXIuY29sdW1uLmdldENvbElkKCldO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuaXRlcmF0ZU9iamVjdCh0aGlzLmFsbEZpbHRlcnMsIGZ1bmN0aW9uIChrZXksIGZpbHRlcldyYXBwZXIpIHtcbiAgICAgICAgICAgIF90aGlzLmRpc3Bvc2VGaWx0ZXJXcmFwcGVyKGZpbHRlcldyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZpbHRlck1hbmFnZXIuUVVJQ0tfRklMVEVSX1NFUEFSQVRPUiA9ICdcXG4nO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCckY29tcGlsZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLCBcIiRjb21waWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJyRzY29wZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLCBcIiRzY29wZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZENvcmUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZSwgXCJncmlkQ29yZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdwb3B1cFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHBvcHVwU2VydmljZV8xLlBvcHVwU2VydmljZSlcbiAgICBdLCBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZSwgXCJwb3B1cFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgndmFsdWVTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB2YWx1ZVNlcnZpY2VfMS5WYWx1ZVNlcnZpY2UpXG4gICAgXSwgRmlsdGVyTWFuYWdlci5wcm90b3R5cGUsIFwidmFsdWVTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncm93TW9kZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZSwgXCJyb3dNb2RlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdldmVudFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSlcbiAgICBdLCBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZW50ZXJwcmlzZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZSwgXCJlbnRlcnByaXNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbXBvbmVudFJlc29sdmVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb21wb25lbnRSZXNvbHZlcl8xLkNvbXBvbmVudFJlc29sdmVyKVxuICAgIF0sIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLCBcImNvbXBvbmVudFJlc29sdmVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5QcmVEZXN0cm95LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEZpbHRlck1hbmFnZXIucHJvdG90eXBlLCBcImRlc3Ryb3lcIiwgbnVsbCk7XG4gICAgRmlsdGVyTWFuYWdlciA9IEZpbHRlck1hbmFnZXJfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignZmlsdGVyTWFuYWdlcicpXG4gICAgXSwgRmlsdGVyTWFuYWdlcik7XG4gICAgcmV0dXJuIEZpbHRlck1hbmFnZXI7XG4gICAgdmFyIEZpbHRlck1hbmFnZXJfMTtcbn0oKSk7XG5leHBvcnRzLkZpbHRlck1hbmFnZXIgPSBGaWx0ZXJNYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZmlsdGVyL2ZpbHRlck1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbnRleHRfMiA9IHJlcXVpcmUoXCIuL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2V2ZW50U2VydmljZVwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcbnZhciBjb250ZXh0XzMgPSByZXF1aXJlKFwiLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgY29udGV4dF80ID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi9ncmlkQXBpXCIpO1xudmFyIFNlbGVjdGlvbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdGlvbkNvbnRyb2xsZXIoKSB7XG4gICAgfVxuICAgIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnNldEJlYW5zID0gZnVuY3Rpb24gKGxvZ2dlckZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXJGYWN0b3J5LmNyZWF0ZSgnU2VsZWN0aW9uQ29udHJvbGxlcicpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1Jvd01vZGVsRGVmYXVsdCgpKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9ST1dfREFUQV9DSEFOR0VELCB0aGlzLnJlc2V0LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdkb250IGtub3cgd2hhdCB0byBkbyBoZXJlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBTZWxlY3RzQ2hpbGRyZW4gPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwU2VsZWN0c0NoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1JPV19TRUxFQ1RFRCwgdGhpcy5vblJvd1NlbGVjdGVkLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0TGFzdFNlbGVjdGVkTm9kZSA9IGZ1bmN0aW9uIChyb3dOb2RlKSB7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGVkTm9kZSA9IHJvd05vZGU7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZS5nZXRMYXN0U2VsZWN0ZWROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0U2VsZWN0ZWROb2RlO1xuICAgIH07XG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBbXTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMuc2VsZWN0ZWROb2RlcywgZnVuY3Rpb24gKGtleSwgcm93Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHJvd05vZGUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE5vZGVzLnB1c2gocm93Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWROb2RlcztcbiAgICB9O1xuICAgIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldFNlbGVjdGVkUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IFtdO1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5zZWxlY3RlZE5vZGVzLCBmdW5jdGlvbiAoa2V5LCByb3dOb2RlKSB7XG4gICAgICAgICAgICBpZiAocm93Tm9kZSAmJiByb3dOb2RlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChyb3dOb2RlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkUm93cztcbiAgICB9O1xuICAgIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZUdyb3Vwc0Zyb21TZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuaXRlcmF0ZU9iamVjdCh0aGlzLnNlbGVjdGVkTm9kZXMsIGZ1bmN0aW9uIChrZXksIHJvd05vZGUpIHtcbiAgICAgICAgICAgIGlmIChyb3dOb2RlICYmIHJvd05vZGUuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RlZE5vZGVzW3Jvd05vZGUuaWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiBncm91cFNlbGVjdHNDaGlsZHJlbj10cnVlXG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlR3JvdXBzRnJvbUNoaWxkcmVuU2VsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucm93TW9kZWwuZ2V0VHlwZSgpICE9PSBjb25zdGFudHNfMS5Db25zdGFudHMuUk9XX01PREVMX1RZUEVfSU5fTUVNT1JZKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VwZGF0ZUdyb3Vwc0Zyb21DaGlsZHJlblNlbGVjdGlvbnMgbm90IGF2YWlsYWJsZSB3aGVuIHJvd01vZGVsIGlzIG5vdCBub3JtYWwnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5NZW1vcnlSb3dNb2RlbCA9IHRoaXMucm93TW9kZWw7XG4gICAgICAgIGluTWVtb3J5Um93TW9kZWwuZ2V0VG9wTGV2ZWxOb2RlcygpLmZvckVhY2goZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgICAgIHJvd05vZGUuZGVwdGhGaXJzdFNlYXJjaChmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dOb2RlLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd05vZGUuY2FsY3VsYXRlU2VsZWN0ZWRGcm9tQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZS5nZXROb2RlRm9ySWRJZlNlbGVjdGVkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkTm9kZXNbaWRdO1xuICAgIH07XG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJPdGhlck5vZGVzID0gZnVuY3Rpb24gKHJvd05vZGVUb0tlZXBTZWxlY3RlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JvdXBzVG9SZWZyZXNoID0ge307XG4gICAgICAgIHZhciB1cGRhdGVkQ291bnQgPSAwO1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5zZWxlY3RlZE5vZGVzLCBmdW5jdGlvbiAoa2V5LCBvdGhlclJvd05vZGUpIHtcbiAgICAgICAgICAgIGlmIChvdGhlclJvd05vZGUgJiYgb3RoZXJSb3dOb2RlLmlkICE9PSByb3dOb2RlVG9LZWVwU2VsZWN0ZWQuaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93Tm9kZSA9IF90aGlzLnNlbGVjdGVkTm9kZXNbb3RoZXJSb3dOb2RlLmlkXTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkQ291bnQgKz0gcm93Tm9kZS5zZXRTZWxlY3RlZFBhcmFtcyh7IG5ld1ZhbHVlOiBmYWxzZSwgY2xlYXJTZWxlY3Rpb246IGZhbHNlLCB0YWlsaW5nTm9kZUluU2VxdWVuY2U6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmdyb3VwU2VsZWN0c0NoaWxkcmVuICYmIG90aGVyUm93Tm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzVG9SZWZyZXNoW290aGVyUm93Tm9kZS5wYXJlbnQuaWRdID0gb3RoZXJSb3dOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QoZ3JvdXBzVG9SZWZyZXNoLCBmdW5jdGlvbiAoa2V5LCBncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAuY2FsY3VsYXRlU2VsZWN0ZWRGcm9tQ2hpbGRyZW4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cGRhdGVkQ291bnQ7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZS5vblJvd1NlbGVjdGVkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciByb3dOb2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgLy8gd2UgZG8gbm90IHN0b3JlIHRoZSBncm91cCByb3dzIHdoZW4gdGhlIGdyb3VwcyBzZWxlY3QgY2hpbGRyZW5cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBTZWxlY3RzQ2hpbGRyZW4gJiYgcm93Tm9kZS5ncm91cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3dOb2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzW3Jvd05vZGUuaWRdID0gcm93Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWROb2Rlc1tyb3dOb2RlLmlkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuc3luY0luUm93Tm9kZSA9IGZ1bmN0aW9uIChyb3dOb2RlLCBvbGROb2RlKSB7XG4gICAgICAgIHRoaXMuc3luY0luT2xkUm93Tm9kZShyb3dOb2RlLCBvbGROb2RlKTtcbiAgICAgICAgdGhpcy5zeW5jSW5OZXdSb3dOb2RlKHJvd05vZGUpO1xuICAgIH07XG4gICAgLy8gaWYgdGhlIGlkIGhhcyBjaGFuZ2VkIGZvciB0aGUgbm9kZSwgdGhlbiB0aGlzIG1lYW5zIHRoZSByb3dOb2RlXG4gICAgLy8gaXMgZ2V0dGluZyB1c2VkIGZvciBhIGRpZmZlcmVudCBkYXRhIGl0ZW0sIHdoaWNoIGJyZWFrc1xuICAgIC8vIG91ciBzZWxlY3RlZE5vZGVzLCBhcyB0aGUgbm9kZSBub3cgaXMgbWFwcGVkIGJ5IHRoZSBvbGQgaWRcbiAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQuIHNvIHRvIGtlZXAgdGhlIG9sZCBub2RlIGFzIHNlbGVjdGVkLFxuICAgIC8vIHdlIHN3YXAgaW4gdGhlIGNsb25lICh3aXRoIHRoZSBvbGQgaWQgYW5kIG9sZCBkYXRhKS4gdGhpcyBtZWFuc1xuICAgIC8vIHRoZSBvbGROb2RlIGlzIGVmZmVjdGl2ZWx5IGEgZGFlbW9uIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8sXG4gICAgLy8gc28gaWYgY2xpZW50IGNhbGxzIGFwaS5nZXRTZWxlY3RlZE5vZGVzKCksIGl0IGdldHMgdGhlIGRhZW1vblxuICAgIC8vIGluIHRoZSByZXN1bHQuIHdoZW4gdGhlIGNsaWVudCB1bi1zZWxlY3RzLCB0aGUgcmVmZXJlbmNlIHRvIHRoZVxuICAgIC8vIGRhZW1vbiBpcyByZW1vdmVkLiB0aGUgZGFlbW9uLCBiZWNhdXNlIGl0J3MgYW4gb2xkTm9kZSwgaXMgbm90XG4gICAgLy8gdXNlZCBieSB0aGUgZ3JpZCBmb3IgcmVuZGVyaW5nLCBpdCdzIGEgY29weSBvZiB3aGF0IHRoZSBub2RlIHVzZWRcbiAgICAvLyB0byBiZSBsaWtlIGJlZm9yZSB0aGUgaWQgd2FzIGNoYW5nZWQuXG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuc3luY0luT2xkUm93Tm9kZSA9IGZ1bmN0aW9uIChyb3dOb2RlLCBvbGROb2RlKSB7XG4gICAgICAgIHZhciBvbGROb2RlSGFzRGlmZmVyZW50SWQgPSB1dGlsc18xLlV0aWxzLmV4aXN0cyhvbGROb2RlKSAmJiAocm93Tm9kZS5pZCAhPT0gb2xkTm9kZS5pZCk7XG4gICAgICAgIGlmIChvbGROb2RlSGFzRGlmZmVyZW50SWQpIHtcbiAgICAgICAgICAgIHZhciBvbGROb2RlU2VsZWN0ZWQgPSB1dGlsc18xLlV0aWxzLmV4aXN0cyh0aGlzLnNlbGVjdGVkTm9kZXNbb2xkTm9kZS5pZF0pO1xuICAgICAgICAgICAgaWYgKG9sZE5vZGVTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWROb2Rlc1tvbGROb2RlLmlkXSA9IG9sZE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnN5bmNJbk5ld1Jvd05vZGUgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHModGhpcy5zZWxlY3RlZE5vZGVzW3Jvd05vZGUuaWRdKSkge1xuICAgICAgICAgICAgcm93Tm9kZS5zZXRTZWxlY3RlZEluaXRpYWxWYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWROb2Rlc1tyb3dOb2RlLmlkXSA9IHJvd05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dOb2RlLnNldFNlbGVjdGVkSW5pdGlhbFZhbHVlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygncmVzZXQnKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzID0ge307XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGVkTm9kZSA9IG51bGw7XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIGEgbGlzdCBvZiBhbGwgbm9kZXMgYXQgJ2Jlc3QgY29zdCcgLSBhIGZlYXR1cmUgdG8gYmUgdXNlZFxuICAgIC8vIHdpdGggZ3JvdXBzIC8gdHJlZXMuIGlmIGEgZ3JvdXAgaGFzIGFsbCBpdCdzIGNoaWxkcmVuIHNlbGVjdGVkLFxuICAgIC8vIHRoZW4gdGhlIGdyb3VwIGFwcGVhcnMgaW4gdGhlIHJlc3VsdCwgYnV0IG5vdCB0aGUgY2hpbGRyZW4uXG4gICAgLy8gRGVzaWduZWQgZm9yIHVzZSB3aXRoICdjaGlsZHJlbicgYXMgdGhlIGdyb3VwIHNlbGVjdGlvbiB0eXBlLFxuICAgIC8vIHdoZXJlIGdyb3VwcyBkb24ndCBhY3R1YWxseSBhcHBlYXIgaW4gdGhlIHNlbGVjdGlvbiBub3JtYWxseS5cbiAgICBTZWxlY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZS5nZXRCZXN0Q29zdE5vZGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvd01vZGVsLmdldFR5cGUoKSAhPT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0lOX01FTU9SWSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdnZXRCZXN0Q29zdE5vZGVTZWxlY3Rpb24gaXMgb25seSBhdmlsYWJsZSB3aGVuIHVzaW5nIG5vcm1hbCByb3cgbW9kZWwnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5NZW1vcnlSb3dNb2RlbCA9IHRoaXMucm93TW9kZWw7XG4gICAgICAgIHZhciB0b3BMZXZlbE5vZGVzID0gaW5NZW1vcnlSb3dNb2RlbC5nZXRUb3BMZXZlbE5vZGVzKCk7XG4gICAgICAgIGlmICh0b3BMZXZlbE5vZGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlbGVjdEFsbCBub3QgYXZhaWxhYmxlIGRvaW5nIHJvd01vZGVsPXZpcnR1YWwnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBmdW5jdGlvbiwgdG8gZmluZCB0aGUgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAgZnVuY3Rpb24gdHJhdmVyc2Uobm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3Qgc2VsZWN0ZWQsIHRoZW4gaWYgaXQncyBhIGdyb3VwLCBhbmQgdGhlIGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBjaGlsZHJlbiwgY29udGludWUgdG8gc2VhcmNoIGZvciBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdyb3VwICYmIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlKG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyYXZlcnNlKHRvcExldmVsTm9kZXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0Um93TW9kZWwgPSBmdW5jdGlvbiAocm93TW9kZWwpIHtcbiAgICAgICAgdGhpcy5yb3dNb2RlbCA9IHJvd01vZGVsO1xuICAgIH07XG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMuc2VsZWN0ZWROb2RlcywgZnVuY3Rpb24gKG5vZGVJZCwgcm93Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHJvd05vZGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvdW50ID09PSAwO1xuICAgIH07XG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuZGVzZWxlY3RBbGxSb3dOb2RlcyA9IGZ1bmN0aW9uIChqdXN0RmlsdGVyZWQpIHtcbiAgICAgICAgaWYgKGp1c3RGaWx0ZXJlZCA9PT0gdm9pZCAwKSB7IGp1c3RGaWx0ZXJlZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChyb3dOb2RlKSB7IHJldHVybiByb3dOb2RlLnNlbGVjdFRoaXNOb2RlKGZhbHNlKTsgfTtcbiAgICAgICAgdmFyIHJvd01vZGVsSW5NZW1vcnkgPSB0aGlzLnJvd01vZGVsLmdldFR5cGUoKSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0lOX01FTU9SWTtcbiAgICAgICAgaWYgKGp1c3RGaWx0ZXJlZCkge1xuICAgICAgICAgICAgaWYgKCFyb3dNb2RlbEluTWVtb3J5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogc2VsZWN0aW5nIGp1c3QgZmlsdGVyZWQgb25seSB3b3JrcyB3aXRoIEluIE1lbW9yeSBSb3cgTW9kZWwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5NZW1vcnlSb3dNb2RlbCA9IHRoaXMucm93TW9kZWw7XG4gICAgICAgICAgICBpbk1lbW9yeVJvd01vZGVsLmZvckVhY2hOb2RlQWZ0ZXJGaWx0ZXIoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMuc2VsZWN0ZWROb2RlcywgZnVuY3Rpb24gKGlkLCByb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIHJlZmVyZW5jZSBjYW4gYmUgdG8gbnVsbCwgYXMgd2UgbmV2ZXIgJ2RlbGV0ZScgZnJvbSB0aGUgbWFwXG4gICAgICAgICAgICAgICAgaWYgKHJvd05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socm93Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0aGlzIGNsZWFycyBkb3duIHRoZSBtYXAgKHdoZXJlYXMgYWJvdmUgb25seSBzZXRzIHRoZSBpdGVtcyBpbiBtYXAgdG8gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGFib3ZlIGRvZXMgbm90IGNsZWFuIHVwIHRoZSBwYXJlbnQgcm93cyBpZiB0aGV5IGFyZSBzZWxlY3RlZFxuICAgICAgICBpZiAocm93TW9kZWxJbk1lbW9yeSAmJiB0aGlzLmdyb3VwU2VsZWN0c0NoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdyb3Vwc0Zyb21DaGlsZHJlblNlbGVjdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfU0VMRUNUSU9OX0NIQU5HRUQsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZS5zZWxlY3RBbGxSb3dOb2RlcyA9IGZ1bmN0aW9uIChqdXN0RmlsdGVyZWQpIHtcbiAgICAgICAgaWYgKGp1c3RGaWx0ZXJlZCA9PT0gdm9pZCAwKSB7IGp1c3RGaWx0ZXJlZCA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0aGlzLnJvd01vZGVsLmdldFR5cGUoKSAhPT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0lOX01FTU9SWSkge1xuICAgICAgICAgICAgdGhyb3cgXCJzZWxlY3RBbGwgb25seSBhdmFpbGFibGUgd2l0aCBub3JtYWwgcm93IG1vZGVsLCBpZSBub3QgXCIgKyB0aGlzLnJvd01vZGVsLmdldFR5cGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5NZW1vcnlSb3dNb2RlbCA9IHRoaXMucm93TW9kZWw7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChyb3dOb2RlKSB7IHJldHVybiByb3dOb2RlLnNlbGVjdFRoaXNOb2RlKHRydWUpOyB9O1xuICAgICAgICBpZiAoanVzdEZpbHRlcmVkKSB7XG4gICAgICAgICAgICBpbk1lbW9yeVJvd01vZGVsLmZvckVhY2hOb2RlQWZ0ZXJGaWx0ZXIoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5NZW1vcnlSb3dNb2RlbC5mb3JFYWNoTm9kZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGFib3ZlIGRvZXMgbm90IGNsZWFuIHVwIHRoZSBwYXJlbnQgcm93cyBpZiB0aGV5IGFyZSBzZWxlY3RlZFxuICAgICAgICBpZiAodGhpcy5yb3dNb2RlbC5nZXRUeXBlKCkgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5ST1dfTU9ERUxfVFlQRV9JTl9NRU1PUlkgJiYgdGhpcy5ncm91cFNlbGVjdHNDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVHcm91cHNGcm9tQ2hpbGRyZW5TZWxlY3Rpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1NFTEVDVElPTl9DSEFOR0VELFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgLy8gRGVwcmVjYXRlZCBtZXRob2RcbiAgICBTZWxlY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZS5zZWxlY3ROb2RlID0gZnVuY3Rpb24gKHJvd05vZGUsIHRyeU11bHRpKSB7XG4gICAgICAgIHJvd05vZGUuc2V0U2VsZWN0ZWRQYXJhbXMoeyBuZXdWYWx1ZTogdHJ1ZSwgY2xlYXJTZWxlY3Rpb246ICF0cnlNdWx0aSB9KTtcbiAgICB9O1xuICAgIC8vIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuZGVzZWxlY3RJbmRleCA9IGZ1bmN0aW9uIChyb3dJbmRleCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm93TW9kZWwuZ2V0Um93KHJvd0luZGV4KTtcbiAgICAgICAgdGhpcy5kZXNlbGVjdE5vZGUobm9kZSk7XG4gICAgfTtcbiAgICAvLyBEZXByZWNhdGVkIG1ldGhvZFxuICAgIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLmRlc2VsZWN0Tm9kZSA9IGZ1bmN0aW9uIChyb3dOb2RlKSB7XG4gICAgICAgIHJvd05vZGUuc2V0U2VsZWN0ZWRQYXJhbXMoeyBuZXdWYWx1ZTogZmFsc2UsIGNsZWFyU2VsZWN0aW9uOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIC8vIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuc2VsZWN0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIHRyeU11bHRpKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5yb3dNb2RlbC5nZXRSb3coaW5kZXgpO1xuICAgICAgICB0aGlzLnNlbGVjdE5vZGUobm9kZSwgdHJ5TXVsdGkpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMy5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzMuQXV0b3dpcmVkKCdyb3dNb2RlbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcInJvd01vZGVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMy5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzMuQXV0b3dpcmVkKCdjb2x1bW5BcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5BcGkpXG4gICAgXSwgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUsIFwiY29sdW1uQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMy5BdXRvd2lyZWQoJ2dyaWRBcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRBcGlfMS5HcmlkQXBpKVxuICAgIF0sIFNlbGVjdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcImdyaWRBcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgX19wYXJhbSgwLCBjb250ZXh0XzIuUXVhbGlmaWVyKCdsb2dnZXJGYWN0b3J5JykpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2xvZ2dlcl8xLkxvZ2dlckZhY3RvcnldKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBTZWxlY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZSwgXCJzZXRCZWFuc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF80LlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgU2VsZWN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICBTZWxlY3Rpb25Db250cm9sbGVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdzZWxlY3Rpb25Db250cm9sbGVyJylcbiAgICBdLCBTZWxlY3Rpb25Db250cm9sbGVyKTtcbiAgICByZXR1cm4gU2VsZWN0aW9uQ29udHJvbGxlcjtcbn0oKSk7XG5leHBvcnRzLlNlbGVjdGlvbkNvbnRyb2xsZXIgPSBTZWxlY3Rpb25Db250cm9sbGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvc2VsZWN0aW9uQ29udHJvbGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgZ3JpZFBhbmVsXzEgPSByZXF1aXJlKFwiLi4vZ3JpZFBhbmVsL2dyaWRQYW5lbFwiKTtcbnZhciBleHByZXNzaW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4uL3ZhbHVlU2VydmljZS9leHByZXNzaW9uU2VydmljZVwiKTtcbnZhciB0ZW1wbGF0ZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi90ZW1wbGF0ZVNlcnZpY2VcIik7XG52YXIgdmFsdWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVTZXJ2aWNlL3ZhbHVlU2VydmljZVwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgcm93Q29tcF8xID0gcmVxdWlyZShcIi4vcm93Q29tcFwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi9ldmVudHNcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIGNlbGxDb21wXzEgPSByZXF1aXJlKFwiLi9jZWxsQ29tcFwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRDb3JlXzEgPSByZXF1aXJlKFwiLi4vZ3JpZENvcmVcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG52YXIgZm9jdXNlZENlbGxDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vZm9jdXNlZENlbGxDb250cm9sbGVyXCIpO1xudmFyIGNlbGxOYXZpZ2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2NlbGxOYXZpZ2F0aW9uU2VydmljZVwiKTtcbnZhciBncmlkQ2VsbF8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2dyaWRDZWxsXCIpO1xudmFyIGJlYW5TdHViXzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9iZWFuU3R1YlwiKTtcbnZhciBwYWdpbmF0aW9uUHJveHlfMSA9IHJlcXVpcmUoXCIuLi9yb3dNb2RlbHMvcGFnaW5hdGlvblByb3h5XCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi9ncmlkQXBpXCIpO1xudmFyIHBpbm5lZFJvd01vZGVsXzEgPSByZXF1aXJlKFwiLi4vcm93TW9kZWxzL3Bpbm5lZFJvd01vZGVsXCIpO1xudmFyIGJlYW5zXzEgPSByZXF1aXJlKFwiLi9iZWFuc1wiKTtcbnZhciBhbmltYXRpb25GcmFtZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9taXNjL2FuaW1hdGlvbkZyYW1lU2VydmljZVwiKTtcbnZhciBSb3dSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvd1JlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvd1JlbmRlcmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbWFwIG9mIHJvdyBpZHMgdG8gcm93IG9iamVjdHMuIGtlZXBzIHRyYWNrIG9mIHdoaWNoIGVsZW1lbnRzXG4gICAgICAgIC8vIGFyZSByZW5kZXJlZCBmb3Igd2hpY2ggcm93cyBpbiB0aGUgZG9tLlxuICAgICAgICBfdGhpcy5yb3dDb21wc0J5SW5kZXggPSB7fTtcbiAgICAgICAgX3RoaXMuZmxvYXRpbmdUb3BSb3dDb21wcyA9IFtdO1xuICAgICAgICBfdGhpcy5mbG9hdGluZ0JvdHRvbVJvd0NvbXBzID0gW107XG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgb25lIHJlZnJlc2ggYXQgYSB0aW1lLCBvdGhlcndpc2UgdGhlIGludGVybmFsIG1lbW9yeSBzdHJ1Y3R1cmUgaGVyZVxuICAgICAgICAvLyB3aWxsIGdldCBtZXNzZWQgdXAuIHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgdXNlciBoYXMgYSBjZWxsUmVuZGVyZXIsIGFuZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHJlbmRlcmVyIHRoZXkgY2FsbCBhbiBBUEkgbWV0aG9kIHRoYXQgcmVzdWx0cyBpbiBhbm90aGVyIHBhc3Mgb2YgdGhlIHJlZnJlc2gsXG4gICAgICAgIC8vIHRoZW4gaXQgd2lsbCBiZSB0cnlpbmcgdG8gZHJhdyByb3dzIGluIHRoZSBtaWRkbGUgb2YgYSByZWZyZXNoLlxuICAgICAgICBfdGhpcy5yZWZyZXNoSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5hZ1dpcmUgPSBmdW5jdGlvbiAobG9nZ2VyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlckZhY3RvcnkuY3JlYXRlKCdSb3dSZW5kZXJlcicpO1xuICAgIH07XG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm9yUHJpbnQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0ZvclByaW50KCk7XG4gICAgICAgIHRoaXMuYXV0b0hlaWdodCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzQXV0b0hlaWdodCgpO1xuICAgICAgICB0aGlzLnJvd0NvbnRhaW5lcnMgPSB0aGlzLmdyaWRQYW5lbC5nZXRSb3dDb250YWluZXJzKCk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfUEFHSU5BVElPTl9DSEFOR0VELCB0aGlzLm9uUGFnZUxvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9QSU5ORURfUk9XX0RBVEFfQ0hBTkdFRCwgdGhpcy5vblBpbm5lZFJvd0RhdGFDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0RJU1BMQVlFRF9DT0xVTU5TX0NIQU5HRUQsIHRoaXMub25EaXNwbGF5ZWRDb2x1bW5zQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5yZWRyYXdBZnRlck1vZGVsVXBkYXRlKCk7XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUub25QYWdlTG9hZGVkID0gZnVuY3Rpb24gKHJlZnJlc2hFdmVudCkge1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHJlZnJlc2hFdmVudCkpIHtcbiAgICAgICAgICAgIHJlZnJlc2hFdmVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfTU9ERUxfVVBEQVRFRCxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtlZXBSZW5kZXJlZFJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5ld0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5ld1BhZ2U6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Nb2RlbFVwZGF0ZWQocmVmcmVzaEV2ZW50KTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5nZXRBbGxDZWxsc0ZvckNvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIGVDZWxscyA9IFtdO1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5yb3dDb21wc0J5SW5kZXgsIGNhbGxiYWNrKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMuZmxvYXRpbmdCb3R0b21Sb3dDb21wcywgY2FsbGJhY2spO1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5mbG9hdGluZ1RvcFJvd0NvbXBzLCBjYWxsYmFjayk7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGtleSwgcm93Q29tcCkge1xuICAgICAgICAgICAgdmFyIGVDZWxsID0gcm93Q29tcC5nZXRDZWxsRm9yQ29sKGNvbHVtbik7XG4gICAgICAgICAgICBpZiAoZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBlQ2VsbHMucHVzaChlQ2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVDZWxscztcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5yZWZyZXNoRmxvYXRpbmdSb3dDb21wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoRmxvYXRpbmdSb3dzKHRoaXMuZmxvYXRpbmdUb3BSb3dDb21wcywgdGhpcy5waW5uZWRSb3dNb2RlbC5nZXRQaW5uZWRUb3BSb3dEYXRhKCksIHRoaXMucm93Q29udGFpbmVycy5mbG9hdGluZ1RvcFBpbm5lZExlZnQsIHRoaXMucm93Q29udGFpbmVycy5mbG9hdGluZ1RvcFBpbm5lZFJpZ2h0LCB0aGlzLnJvd0NvbnRhaW5lcnMuZmxvYXRpbmdUb3AsIHRoaXMucm93Q29udGFpbmVycy5mbG9hdGluZ1RvcEZ1bGxXaWR0aCk7XG4gICAgICAgIHRoaXMucmVmcmVzaEZsb2F0aW5nUm93cyh0aGlzLmZsb2F0aW5nQm90dG9tUm93Q29tcHMsIHRoaXMucGlubmVkUm93TW9kZWwuZ2V0UGlubmVkQm90dG9tUm93RGF0YSgpLCB0aGlzLnJvd0NvbnRhaW5lcnMuZmxvYXRpbmdCb3R0b21QaW5uZWRMZWZ0LCB0aGlzLnJvd0NvbnRhaW5lcnMuZmxvYXRpbmdCb3R0b21QaW5uZWRSaWdodCwgdGhpcy5yb3dDb250YWluZXJzLmZsb2F0aW5nQm90dG9tLCB0aGlzLnJvd0NvbnRhaW5lcnMuZmxvYXRpbmdCb3R0b21GdWxsV2l0aCk7XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUucmVmcmVzaEZsb2F0aW5nUm93cyA9IGZ1bmN0aW9uIChyb3dDb21wcywgcm93Tm9kZXMsIHBpbm5lZExlZnRDb250YWluZXJDb21wLCBwaW5uZWRSaWdodENvbnRhaW5lckNvbXAsIGJvZHlDb250YWluZXJDb21wLCBmdWxsV2lkdGhDb250YWluZXJDb21wKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJvd0NvbXBzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgcm93LmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvd0NvbXBzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIGlmIG5vIGNvbHMsIGRvbid0IGRyYXcgcm93IC0gY2FuIHdlIGdldCByaWQgb2YgdGhpcz8/P1xuICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmdPckVtcHR5KGNvbHVtbnMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvd05vZGVzKSB7XG4gICAgICAgICAgICByb3dOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0NvbXAgPSBuZXcgcm93Q29tcF8xLlJvd0NvbXAoX3RoaXMuJHNjb3BlLCBib2R5Q29udGFpbmVyQ29tcCwgcGlubmVkTGVmdENvbnRhaW5lckNvbXAsIHBpbm5lZFJpZ2h0Q29udGFpbmVyQ29tcCwgZnVsbFdpZHRoQ29udGFpbmVyQ29tcCwgbm9kZSwgX3RoaXMuYmVhbnMsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcm93Q29tcC5pbml0KCk7XG4gICAgICAgICAgICAgICAgcm93Q29tcHMucHVzaChyb3dDb21wKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2hDb250YWluZXJzKHJvd0NvbXBzKTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5vblBpbm5lZFJvd0RhdGFDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlZHJhd0FmdGVyTW9kZWxVcGRhdGUoKTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5vbk1vZGVsVXBkYXRlZCA9IGZ1bmN0aW9uIChyZWZyZXNoRXZlbnQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHJlY3ljbGVSb3dzOiByZWZyZXNoRXZlbnQua2VlcFJlbmRlcmVkUm93cyxcbiAgICAgICAgICAgIGFuaW1hdGU6IHJlZnJlc2hFdmVudC5hbmltYXRlLFxuICAgICAgICAgICAgbmV3RGF0YTogcmVmcmVzaEV2ZW50Lm5ld0RhdGEsXG4gICAgICAgICAgICBuZXdQYWdlOiByZWZyZXNoRXZlbnQubmV3UGFnZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlZHJhd0FmdGVyTW9kZWxVcGRhdGUocGFyYW1zKTtcbiAgICAgICAgLy8gdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChFdmVudHMuREVQUkVDQVRFRF9FVkVOVF9QQUdJTkFUSU9OX1BBR0VfTE9BREVEKTtcbiAgICB9O1xuICAgIC8vIGlmIHRoZSByb3cgbm9kZXMgYXJlIG5vdCByZW5kZXJlZCwgbm8gaW5kZXggaXMgcmV0dXJuZWRcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUuZ2V0UmVuZGVyZWRJbmRleGVzRm9yUm93Tm9kZXMgPSBmdW5jdGlvbiAocm93Tm9kZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHJvd05vZGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5yb3dDb21wc0J5SW5kZXgsIGZ1bmN0aW9uIChpbmRleCwgcmVuZGVyZWRSb3cpIHtcbiAgICAgICAgICAgIHZhciByb3dOb2RlID0gcmVuZGVyZWRSb3cuZ2V0Um93Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKHJvd05vZGVzLmluZGV4T2Yocm93Tm9kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUucmVkcmF3Um93cyA9IGZ1bmN0aW9uIChyb3dOb2Rlcykge1xuICAgICAgICBpZiAoIXJvd05vZGVzIHx8IHJvd05vZGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugb25seSBuZWVkIHRvIGJlIHdvcnJpZWQgYWJvdXQgcmVuZGVyZWQgcm93cywgYXMgdGhpcyBtZXRob2QgaXNcbiAgICAgICAgLy8gY2FsbGVkIHRvIHdoYXRzIHJlbmRlcmVkLiBpZiB0aGUgcm93IGlzbid0IHJlbmRlcmVkLCB3ZSBkb24ndCBjYXJlXG4gICAgICAgIHZhciBpbmRleGVzVG9SZW1vdmUgPSB0aGlzLmdldFJlbmRlcmVkSW5kZXhlc0ZvclJvd05vZGVzKHJvd05vZGVzKTtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSByb3dzXG4gICAgICAgIHRoaXMucmVtb3ZlUm93Q29tcHMoaW5kZXhlc1RvUmVtb3ZlKTtcbiAgICAgICAgLy8gYWRkIGRyYXcgdGhlbSBhZ2FpblxuICAgICAgICB0aGlzLnJlZHJhd0FmdGVyTW9kZWxVcGRhdGUoe1xuICAgICAgICAgICAgcmVjeWNsZVJvd3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q2VsbFRvUmVzdG9yZUZvY3VzVG9BZnRlclJlZnJlc2ggPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBmb2N1c2VkQ2VsbCA9IHBhcmFtcy5zdXBwcmVzc0tlZXBGb2N1cyA/IG51bGwgOiB0aGlzLmZvY3VzZWRDZWxsQ29udHJvbGxlci5nZXRGb2N1c0NlbGxUb1VzZUFmdGVyUmVmcmVzaCgpO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKGZvY3VzZWRDZWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGRvbSBpcyBub3QgYWN0dWFsbHkgZm9jdXNlZCBvbiBhIGNlbGwsIHRoZW4gd2UgZG9uJ3QgdHJ5IHRvIHJlZm9jdXMuIHRoZSBwcm9ibGVtIHRoaXNcbiAgICAgICAgLy8gc29sdmVzIGlzIHdpdGggZWRpdGluZyAtIGlmIHRoZSB1c2VyIGlzIGVkaXRpbmcsIGVnIGZvY3VzIGlzIG9uIGEgdGV4dCBmaWVsZCwgYW5kIG5vdCBvbiB0aGVcbiAgICAgICAgLy8gY2VsbCBpdHNlbGYsIHRoZW4gdGhlIGNlbGwgY2FuIGJlIHJlZ2lzdGVyZWQgYXMgaGF2aW5nIGZvY3VzLCBob3dldmVyIGl0J3MgdGhlIHRleHQgZmllbGQgdGhhdFxuICAgICAgICAvLyBoYXMgdGhlIGZvY3VzIGFuZCBub3QgdGhlIGNlbGwgZGl2LiB0aGVyZWZvcmUsIHdoZW4gdGhlIHJlZnJlc2ggaXMgZmluaXNoZWQsIHRoZSBncmlkIHdpbGwgZm9jdXNcbiAgICAgICAgLy8gdGhlIGNlbGwsIGFuZCBub3QgdGhlIHRleHRmaWVsZC4gdGhhdCBtZWFucyBpZiB0aGUgdXNlciBpcyBpbiBhIHRleHQgZmllbGQsIGFuZCB0aGUgZ3JpZCByZWZyZXNoZXMsXG4gICAgICAgIC8vIHRoZSBmb2N1cyBpcyBsb3N0IGZyb20gdGhlIHRleHQgZmllbGQuIHdlIGRvIG5vdCB3YW50IHRoaXMuXG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIGRvbURhdGEgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXREb21EYXRhKGFjdGl2ZUVsZW1lbnQsIGNlbGxDb21wXzEuQ2VsbENvbXAuRE9NX0RBVEFfS0VZX0NFTExfQ09NUCk7XG4gICAgICAgIHZhciBlbGVtZW50SXNOb3RBQ2VsbERldiA9IHV0aWxzXzEuVXRpbHMubWlzc2luZyhkb21EYXRhKTtcbiAgICAgICAgaWYgKGVsZW1lbnRJc05vdEFDZWxsRGV2KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9jdXNlZENlbGw7XG4gICAgfTtcbiAgICAvLyBnZXRzIGNhbGxlZCBhZnRlciBjaGFuZ2VzIHRvIHRoZSBtb2RlbC5cbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUucmVkcmF3QWZ0ZXJNb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIHRoaXMuZ2V0TG9ja09uUmVmcmVzaCgpO1xuICAgICAgICB2YXIgZm9jdXNlZENlbGwgPSB0aGlzLmdldENlbGxUb1Jlc3RvcmVGb2N1c1RvQWZ0ZXJSZWZyZXNoKHBhcmFtcyk7XG4gICAgICAgIGlmICghdGhpcy5mb3JQcmludCkge1xuICAgICAgICAgICAgdGhpcy5zaXplQ29udGFpbmVyVG9QYWdlSGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxUb1RvcElmTmV3RGF0YShwYXJhbXMpO1xuICAgICAgICAvLyBuZXZlciBrZWVwIHJlbmRlcmVkIHJvd3MgaWYgZG9pbmcgZm9yUHJpbnQgb3IgYXV0b0hlaWdodCwgYXMgd2UgZG8gbm90IHVzZSAndG9wJyB0b1xuICAgICAgICAvLyBwb3NpdGlvbiB0aGUgcm93cyAoaXQgdXNlcyBub3JtYWwgZmxvdyksIHNvIHdlIGhhdmUgdG8gcmVtb3ZlXG4gICAgICAgIC8vIGFsbCByb3dzIGFuZCBpbnNlcnQgdGhlbSBhZ2FpbiBmcm9tIHNjcmF0Y2hcbiAgICAgICAgdmFyIHJvd3NVc2luZ0Zsb3cgPSB0aGlzLmZvclByaW50IHx8IHRoaXMuYXV0b0hlaWdodDtcbiAgICAgICAgdmFyIHJlY3ljbGVSb3dzID0gcm93c1VzaW5nRmxvdyA/IGZhbHNlIDogcGFyYW1zLnJlY3ljbGVSb3dzO1xuICAgICAgICB2YXIgYW5pbWF0ZSA9IHJvd3NVc2luZ0Zsb3cgPyBmYWxzZSA6IChwYXJhbXMuYW5pbWF0ZSAmJiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0FuaW1hdGVSb3dzKCkpO1xuICAgICAgICB2YXIgcm93c1RvUmVjeWNsZSA9IHRoaXMuYmluUm93Q29tcHMocmVjeWNsZVJvd3MpO1xuICAgICAgICB0aGlzLnJlZHJhdyhyb3dzVG9SZWN5Y2xlLCBhbmltYXRlKTtcbiAgICAgICAgaWYgKCFwYXJhbXMub25seUJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEZsb2F0aW5nUm93Q29tcHMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3RvcmVGb2N1c2VkQ2VsbChmb2N1c2VkQ2VsbCk7XG4gICAgICAgIHRoaXMucmVsZWFzZUxvY2tPblJlZnJlc2goKTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxUb1RvcElmTmV3RGF0YSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNjcm9sbFRvVG9wID0gcGFyYW1zLm5ld0RhdGEgfHwgcGFyYW1zLm5ld1BhZ2U7XG4gICAgICAgIHZhciBzdXBwcmVzc1Njcm9sbFRvVG9wID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc1Njcm9sbE9uTmV3RGF0YSgpO1xuICAgICAgICBpZiAoc2Nyb2xsVG9Ub3AgJiYgIXN1cHByZXNzU2Nyb2xsVG9Ub3ApIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFBhbmVsLnNjcm9sbFRvVG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5zaXplQ29udGFpbmVyVG9QYWdlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0Q3VycmVudFBhZ2VIZWlnaHQoKTtcbiAgICAgICAgLy8gd2UgbmVlZCBhdCBsZWFzdCAxIHBpeGVsIGZvciB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgdG8gd29yay4gc28gaWYgdGhlcmUgYXJlIG5vdyByb3dzLFxuICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRoZSBzY3JvbGwgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIHRoZXJlIHdvdWxkIGJlIG5vIHdheSB0byBhY2Nlc3MgdGhlIGNvbHVtbnNcbiAgICAgICAgLy8gb24gdGhlIFJIUyAtIGFuZCBpZiB0aGF0IHdhcyB3aGVyZSB0aGUgZmlsdGVyIHdhcyB0aGF0IGNhdXNlIG5vIHJvd3MgdG8gYmUgcHJlc2VudGVkLCB0aGVyZVxuICAgICAgICAvLyBpcyBubyB3YXkgdG8gcmVtb3ZlIHRoZSBmaWx0ZXIuXG4gICAgICAgIGlmIChjb250YWluZXJIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dDb250YWluZXJzLmJvZHkuc2V0SGVpZ2h0KGNvbnRhaW5lckhlaWdodCk7XG4gICAgICAgIHRoaXMucm93Q29udGFpbmVycy5mdWxsV2lkdGguc2V0SGVpZ2h0KGNvbnRhaW5lckhlaWdodCk7XG4gICAgICAgIHRoaXMucm93Q29udGFpbmVycy5waW5uZWRMZWZ0LnNldEhlaWdodChjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB0aGlzLnJvd0NvbnRhaW5lcnMucGlubmVkUmlnaHQuc2V0SGVpZ2h0KGNvbnRhaW5lckhlaWdodCk7XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUuZ2V0TG9ja09uUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHRocm93ICdhZy1HcmlkOiBjYW5ub3QgZ2V0IGdyaWQgdG8gZHJhdyByb3dzIHdoZW4gaXQgaXMgaW4gdGhlIG1pZGRsZSBvZiBkcmF3aW5nIHJvd3MuICcgK1xuICAgICAgICAgICAgICAgICdZb3VyIGNvZGUgcHJvYmFibHkgY2FsbGVkIGEgZ3JpZCBBUEkgbWV0aG9kIHdoaWxlIHRoZSBncmlkIHdhcyBpbiB0aGUgcmVuZGVyIHN0YWdlLiBUbyBvdmVyY29tZSAnICtcbiAgICAgICAgICAgICAgICAndGhpcywgcHV0IHRoZSBBUEkgY2FsbCBpbnRvIGEgdGltZW91dCwgZWcgaW5zdGVhZCBvZiBhcGkucmVmcmVzaFZpZXcoKSwgJyArXG4gICAgICAgICAgICAgICAgJ2NhbGwgc2V0VGltZW91dChmdW5jdGlvbigpe2FwaS5yZWZyZXNoVmlldygpLDB9KS4gVG8gc2VlIHdoYXQgcGFydCBvZiB5b3VyIGNvZGUgJyArXG4gICAgICAgICAgICAgICAgJ3RoYXQgY2F1c2VkIHRoZSByZWZyZXNoIGNoZWNrIHRoaXMgc3RhY2t0cmFjZS4nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaEluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgIH07XG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLnJlbGVhc2VMb2NrT25SZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hJblByb2dyZXNzID0gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBzZXRzIHRoZSBmb2N1cyB0byB0aGUgcHJvdmlkZWQgY2VsbCwgaWYgdGhlIGNlbGwgaXMgcHJvdmlkZWQuIHRoaXMgd2F5LCB0aGUgdXNlciBjYW4gY2FsbCByZWZyZXNoIHdpdGhvdXRcbiAgICAvLyB3b3JyeSBhYm91dCB0aGUgZm9jdXMgYmVlbiBsb3N0LiB0aGlzIGlzIGltcG9ydGFudCB3aGVuIHRoZSB1c2VyIGlzIHVzaW5nIGtleWJvYXJkIG5hdmlnYXRpb24gdG8gZG8gZWRpdHNcbiAgICAvLyBhbmQgdGhlIGNlbGxFZGl0b3IgaXMgY2FsbGluZyAncmVmcmVzaCcgdG8gZ2V0IG90aGVyIGNlbGxzIHRvIHVwZGF0ZSAoYXMgb3RoZXIgY2VsbHMgbWlnaHQgZGVwZW5kIG9uIHRoZVxuICAgIC8vIGVkaXRlZCBjZWxsKS5cbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUucmVzdG9yZUZvY3VzZWRDZWxsID0gZnVuY3Rpb24gKGdyaWRDZWxsKSB7XG4gICAgICAgIGlmIChncmlkQ2VsbCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbENvbnRyb2xsZXIuc2V0Rm9jdXNlZENlbGwoZ3JpZENlbGwucm93SW5kZXgsIGdyaWRDZWxsLmNvbHVtbiwgZ3JpZENlbGwuZmxvYXRpbmcsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUuc3RvcEVkaXRpbmcgPSBmdW5jdGlvbiAoY2FuY2VsKSB7XG4gICAgICAgIGlmIChjYW5jZWwgPT09IHZvaWQgMCkgeyBjYW5jZWwgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmZvckVhY2hSb3dDb21wKGZ1bmN0aW9uIChrZXksIHJlbmRlcmVkUm93KSB7XG4gICAgICAgICAgICByZW5kZXJlZFJvdy5zdG9wRWRpdGluZyhjYW5jZWwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5mb3JFYWNoQ2VsbENvbXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMucm93Q29tcHNCeUluZGV4LCBmdW5jdGlvbiAoaW5kZXgsIHJlbmRlcmVkUm93KSB7XG4gICAgICAgICAgICByZW5kZXJlZFJvdy5mb3JFYWNoQ2VsbENvbXAoY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5mb3JFYWNoUm93Q29tcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5yb3dDb21wc0J5SW5kZXgsIGNhbGxiYWNrKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMuZmxvYXRpbmdUb3BSb3dDb21wcywgY2FsbGJhY2spO1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5mbG9hdGluZ0JvdHRvbVJvd0NvbXBzLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUuYWRkUmVuZGVyZWRSb3dMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHJvd0luZGV4LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcm93Q29tcCA9IHRoaXMucm93Q29tcHNCeUluZGV4W3Jvd0luZGV4XTtcbiAgICAgICAgaWYgKHJvd0NvbXApIHtcbiAgICAgICAgICAgIHJvd0NvbXAuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLnJlZnJlc2hDZWxscyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIHZhciByb3dJZHNNYXA7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhwYXJhbXMucm93Tm9kZXMpKSB7XG4gICAgICAgICAgICByb3dJZHNNYXAgPSB7XG4gICAgICAgICAgICAgICAgdG9wOiB7fSxcbiAgICAgICAgICAgICAgICBib3R0b206IHt9LFxuICAgICAgICAgICAgICAgIG5vcm1hbDoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXJhbXMucm93Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dOb2RlLnJvd1Bpbm5lZCA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9UT1ApIHtcbiAgICAgICAgICAgICAgICAgICAgcm93SWRzTWFwLnRvcFtyb3dOb2RlLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvd05vZGUucm93UGlubmVkID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuUElOTkVEX0JPVFRPTSkge1xuICAgICAgICAgICAgICAgICAgICByb3dJZHNNYXAuYm90dG9tW3Jvd05vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd0lkc01hcC5ub3JtYWxbcm93Tm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xJZHNNYXA7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhwYXJhbXMuY29sdW1ucykpIHtcbiAgICAgICAgICAgIGNvbElkc01hcCA9IHt9O1xuICAgICAgICAgICAgcGFyYW1zLmNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sS2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IF90aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0R3JpZENvbHVtbihjb2xLZXkpO1xuICAgICAgICAgICAgICAgIGNvbElkc01hcFtjb2x1bW4uZ2V0SWQoKV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2Nlc3NSb3cgPSBmdW5jdGlvbiAocm93Q29tcCkge1xuICAgICAgICAgICAgdmFyIHJvd05vZGUgPSByb3dDb21wLmdldFJvd05vZGUoKTtcbiAgICAgICAgICAgIHZhciBpZCA9IHJvd05vZGUuaWQ7XG4gICAgICAgICAgICB2YXIgZmxvYXRpbmcgPSByb3dOb2RlLnJvd1Bpbm5lZDtcbiAgICAgICAgICAgIC8vIHNraXAgdGhpcyByb3cgaWYgaXQgaXMgbWlzc2luZyBmcm9tIHRoZSBwcm92aWRlZCBsaXN0XG4gICAgICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMocm93SWRzTWFwKSkge1xuICAgICAgICAgICAgICAgIGlmIChmbG9hdGluZyA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9CT1RUT00pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3dJZHNNYXAuYm90dG9tW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZsb2F0aW5nID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuUElOTkVEX1RPUCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJvd0lkc01hcC50b3BbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcm93SWRzTWFwLm5vcm1hbFtpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd0NvbXAuZm9yRWFjaENlbGxDb21wKGZ1bmN0aW9uIChjZWxsQ29tcCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xJZCA9IGNlbGxDb21wLmdldENvbHVtbigpLmdldElkKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4Y2x1ZGVDb2xGcm9tUmVmcmVzaCA9IGNvbElkc01hcCAmJiAhY29sSWRzTWFwW2NvbElkXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZUNvbEZyb21SZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbENvbXAucmVmcmVzaENlbGwoe1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVJlZnJlc2g6IHBhcmFtcy5mb3JjZSxcbiAgICAgICAgICAgICAgICAgICAgdm9sYXRpbGU6IHBhcmFtcy52b2xhdGlsZSxcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5yb3dDb21wc0J5SW5kZXgsIGZ1bmN0aW9uIChpbmRleCwgcm93Q29tcCkge1xuICAgICAgICAgICAgcHJvY2Vzc1Jvdyhyb3dDb21wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmZsb2F0aW5nVG9wUm93Q29tcHMpIHtcbiAgICAgICAgICAgIHRoaXMuZmxvYXRpbmdUb3BSb3dDb21wcy5mb3JFYWNoKHByb2Nlc3NSb3cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZsb2F0aW5nQm90dG9tUm93Q29tcHMpIHtcbiAgICAgICAgICAgIHRoaXMuZmxvYXRpbmdCb3R0b21Sb3dDb21wcy5mb3JFYWNoKHByb2Nlc3NSb3cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgIHZhciByb3dJbmRleGVzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyh0aGlzLnJvd0NvbXBzQnlJbmRleCk7XG4gICAgICAgIHRoaXMucmVtb3ZlUm93Q29tcHMocm93SW5kZXhlc1RvUmVtb3ZlKTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5iaW5Sb3dDb21wcyA9IGZ1bmN0aW9uIChyZWN5Y2xlUm93cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaW5kZXhlc1RvUmVtb3ZlO1xuICAgICAgICB2YXIgcm93c1RvUmVjeWNsZSA9IHt9O1xuICAgICAgICBpZiAocmVjeWNsZVJvd3MpIHtcbiAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZSA9IFtdO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMucm93Q29tcHNCeUluZGV4LCBmdW5jdGlvbiAoaW5kZXgsIHJvd0NvbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93Tm9kZSA9IHJvd0NvbXAuZ2V0Um93Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhyb3dOb2RlLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICByb3dzVG9SZWN5Y2xlW3Jvd05vZGUuaWRdID0gcm93Q29tcDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJvd0NvbXBzQnlJbmRleFtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzVG9SZW1vdmUucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleGVzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyh0aGlzLnJvd0NvbXBzQnlJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVSb3dDb21wcyhpbmRleGVzVG9SZW1vdmUpO1xuICAgICAgICByZXR1cm4gcm93c1RvUmVjeWNsZTtcbiAgICB9O1xuICAgIC8vIHRha2VzIGFycmF5IG9mIHJvdyBpbmRleGVzXG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZVJvd0NvbXBzID0gZnVuY3Rpb24gKHJvd3NUb1JlbW92ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBpZiBubyBmcm9tSW5kZXggdGhlbiBzZXQgdG8gLTEsIHdoaWNoIHdpbGwgcmVmcmVzaCBldmVyeXRoaW5nXG4gICAgICAgIC8vIGxldCByZWFsRnJvbUluZGV4ID0gLTE7XG4gICAgICAgIHJvd3NUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRSb3cgPSBfdGhpcy5yb3dDb21wc0J5SW5kZXhbaW5kZXhUb1JlbW92ZV07XG4gICAgICAgICAgICByZW5kZXJlZFJvdy5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMucm93Q29tcHNCeUluZGV4W2luZGV4VG9SZW1vdmVdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGdldHMgY2FsbGVkIHdoZW4gcm93cyBkb24ndCBjaGFuZ2UsIGJ1dCB2aWV3cG9ydCBkb2VzLCBzbyBhZnRlcjpcbiAgICAvLyAxKSBzaXplIG9mIGdyaWQgY2hhbmdlZFxuICAgIC8vIDIpIGdyaWQgc2Nyb2xsZWQgdG8gbmV3IHBvc2l0aW9uXG4gICAgLy8gMykgZW5zdXJlIGluZGV4IHZpc2libGUgKHdoaWNoIGlzIGEgc2Nyb2xsKVxuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5yZWRyYXdBZnRlclNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRMb2NrT25SZWZyZXNoKCk7XG4gICAgICAgIHRoaXMucmVkcmF3KG51bGwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5yZWxlYXNlTG9ja09uUmVmcmVzaCgpO1xuICAgIH07XG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZVJvd0NvbXBzTm90VG9EcmF3ID0gZnVuY3Rpb24gKGluZGV4ZXNUb0RyYXcpIHtcbiAgICAgICAgLy8gZm9yIHNwZWVkeSBsb29rdXAsIGR1bXAgaW50byBtYXBcbiAgICAgICAgdmFyIGluZGV4ZXNUb0RyYXdNYXAgPSB7fTtcbiAgICAgICAgaW5kZXhlc1RvRHJhdy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gaW5kZXhlc1RvRHJhd01hcFtpbmRleF0gPSB0cnVlOyB9KTtcbiAgICAgICAgdmFyIGV4aXN0aW5nSW5kZXhlcyA9IE9iamVjdC5rZXlzKHRoaXMucm93Q29tcHNCeUluZGV4KTtcbiAgICAgICAgdmFyIGluZGV4ZXNOb3RUb0RyYXcgPSB1dGlsc18xLlV0aWxzLmZpbHRlcihleGlzdGluZ0luZGV4ZXMsIGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gIWluZGV4ZXNUb0RyYXdNYXBbaW5kZXhdOyB9KTtcbiAgICAgICAgdGhpcy5yZW1vdmVSb3dDb21wcyhpbmRleGVzTm90VG9EcmF3KTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5jYWxjdWxhdGVJbmRleGVzVG9EcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBhbGwgaW4gYWxsIGluZGV4ZXMgaW4gdGhlIHZpZXdwb3J0XG4gICAgICAgIHZhciBpbmRleGVzVG9EcmF3ID0gdXRpbHNfMS5VdGlscy5jcmVhdGVBcnJheU9mTnVtYmVycyh0aGlzLmZpcnN0UmVuZGVyZWRSb3csIHRoaXMubGFzdFJlbmRlcmVkUm93KTtcbiAgICAgICAgLy8gYWRkIGluIGluZGV4ZXMgb2Ygcm93cyB3ZSB3YW50IHRvIGtlZXAsIGJlY2F1c2UgdGhleSBhcmUgY3VycmVudGx5IGVkaXRpbmdcbiAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KHRoaXMucm93Q29tcHNCeUluZGV4LCBmdW5jdGlvbiAoaW5kZXhTdHIsIHJvd0NvbXApIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IE51bWJlcihpbmRleFN0cik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBfdGhpcy5maXJzdFJlbmRlcmVkUm93IHx8IGluZGV4ID4gX3RoaXMubGFzdFJlbmRlcmVkUm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmtlZXBSb3dCZWNhdXNlRWRpdGluZyhyb3dDb21wKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzVG9EcmF3LnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ZXNUb0RyYXcuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICAgICAgICByZXR1cm4gaW5kZXhlc1RvRHJhdztcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAocm93c1RvUmVjeWNsZSwgYW5pbWF0ZSwgYWZ0ZXJTY3JvbGwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFuaW1hdGUgPT09IHZvaWQgMCkgeyBhbmltYXRlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGFmdGVyU2Nyb2xsID09PSB2b2lkIDApIHsgYWZ0ZXJTY3JvbGwgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLndvcmtPdXRGaXJzdEFuZExhc3RSb3dzVG9SZW5kZXIoKTtcbiAgICAgICAgLy8gdGhlIHJvdyBjYW4gYWxyZWFkeSBleGlzdCBhbmQgYmUgaW4gdGhlIGZvbGxvd2luZzpcbiAgICAgICAgLy8gcm93c1RvUmVjeWNsZSAtPiBpZiBtb2RlbCBjaGFuZ2UsIHRoZW4gdGhlIGluZGV4IG1heSBiZSBkaWZmZXJlbnQsIGhvd2V2ZXIgcm93IG1heVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdCBoZXJlIGZyb20gcHJldmlvdXMgdGltZSAobWFwcGVkIGJ5IGlkKS5cbiAgICAgICAgLy8gdGhpcy5yb3dDb21wc0J5SW5kZXggLT4gaWYganVzdCBhIHNjcm9sbCwgdGhlbiB0aGlzIHdpbGwgY29udGFpbiB3aGF0IGlzIGN1cnJlbnRseSBpbiB0aGUgdmlld3BvcnRcbiAgICAgICAgLy8gdGhpcyBpcyBhbGwgdGhlIGluZGV4ZXMgd2Ugd2FudCwgaW5jbHVkaW5nIHRob3NlIHRoYXQgYWxyZWFkeSBleGlzdCwgc28gdGhpcyBtZXRob2RcbiAgICAgICAgLy8gd2lsbCBlbmQgdXAgZ29pbmcgdGhyb3VnaCBlYWNoIGluZGV4IGFuZCBkcmF3aW5nIG9ubHkgaWYgdGhlIHJvdyBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgdmFyIGluZGV4ZXNUb0RyYXcgPSB0aGlzLmNhbGN1bGF0ZUluZGV4ZXNUb0RyYXcoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVSb3dDb21wc05vdFRvRHJhdyhpbmRleGVzVG9EcmF3KTtcbiAgICAgICAgLy8gYWRkIGluIG5ldyByb3dzXG4gICAgICAgIHZhciBuZXh0Vm1UdXJuRnVuY3Rpb25zID0gW107XG4gICAgICAgIHZhciByb3dDb21wcyA9IFtdO1xuICAgICAgICBpbmRleGVzVG9EcmF3LmZvckVhY2goZnVuY3Rpb24gKHJvd0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgcm93Q29tcCA9IF90aGlzLmNyZWF0ZU9yVXBkYXRlUm93Q29tcChyb3dJbmRleCwgcm93c1RvUmVjeWNsZSwgYW5pbWF0ZSwgYWZ0ZXJTY3JvbGwpO1xuICAgICAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHJvd0NvbXApKSB7XG4gICAgICAgICAgICAgICAgcm93Q29tcHMucHVzaChyb3dDb21wKTtcbiAgICAgICAgICAgICAgICB1dGlsc18xLlV0aWxzLnB1c2hBbGwobmV4dFZtVHVybkZ1bmN0aW9ucywgcm93Q29tcC5nZXRBbmRDbGVhck5leHRWTVR1cm5GdW5jdGlvbnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZsdXNoQ29udGFpbmVycyhyb3dDb21wcyk7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuZXhlY3V0ZU5leHRWTVR1cm4obmV4dFZtVHVybkZ1bmN0aW9ucyk7XG4gICAgICAgIGlmIChhZnRlclNjcm9sbCAmJiAhdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc0FuaW1hdGlvbkZyYW1lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmVhbnMudGFza1F1ZXVlLmFkZFAyVGFzayh0aGlzLmRlc3Ryb3lSb3dDb21wcy5iaW5kKHRoaXMsIHJvd3NUb1JlY3ljbGUsIGFuaW1hdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJvd0NvbXBzKHJvd3NUb1JlY3ljbGUsIGFuaW1hdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tBbmd1bGFyQ29tcGlsZSgpO1xuICAgIH07XG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLmZsdXNoQ29udGFpbmVycyA9IGZ1bmN0aW9uIChyb3dDb21wcykge1xuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3QodGhpcy5yb3dDb250YWluZXJzLCBmdW5jdGlvbiAoa2V5LCByb3dDb250YWluZXJDb21wKSB7XG4gICAgICAgICAgICBpZiAocm93Q29udGFpbmVyQ29tcCkge1xuICAgICAgICAgICAgICAgIHJvd0NvbnRhaW5lckNvbXAuZmx1c2hSb3dUZW1wbGF0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJvd0NvbXBzLmZvckVhY2goZnVuY3Rpb24gKHJvd0NvbXApIHsgcmV0dXJuIHJvd0NvbXAuYWZ0ZXJGbHVzaCgpOyB9KTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5vbkRpc3BsYXllZENvbHVtbnNDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGlubmluZ0xlZnQgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaW5uaW5nTGVmdCgpO1xuICAgICAgICB2YXIgcGlubmluZ1JpZ2h0ID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGlubmluZ1JpZ2h0KCk7XG4gICAgICAgIHZhciBhdExlYXN0T25lQ2hhbmdlZCA9IHRoaXMucGlubmluZ0xlZnQgIT09IHBpbm5pbmdMZWZ0IHx8IHBpbm5pbmdSaWdodCAhPT0gdGhpcy5waW5uaW5nUmlnaHQ7XG4gICAgICAgIGlmIChhdExlYXN0T25lQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5waW5uaW5nTGVmdCA9IHBpbm5pbmdMZWZ0O1xuICAgICAgICAgICAgdGhpcy5waW5uaW5nUmlnaHQgPSBwaW5uaW5nUmlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbWJlZEZ1bGxXaWR0aFJvd3MoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3RnVsbFdpZHRoRW1iZWRkZWRSb3dzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHdoZW4gZW1iZWRkaW5nLCB3aGF0IGdldHMgc2hvd2VkIGluIGVhY2ggc2VjdGlvbiBkZXBlbmRzIG9uIHdoYXQgaXMgcGlubmVkLiBlZyBpZiBlbWJlZGRpbmcgZ3JvdXAgZXhwYW5kIC8gY29sbGFwc2UsXG4gICAgLy8gdGhlbiBpdCBzaG91bGQgZ28gaW50byB0aGUgcGlubmVkIGxlZnQgYXJlYSBpZiBwaW5uaW5nIGxlZnQsIG9yIHRoZSBjZW50ZXIgYXJlYSBpZiBub3QgcGlubmluZy5cbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUucmVkcmF3RnVsbFdpZHRoRW1iZWRkZWRSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpZiBlaXRoZXIgb2YgdGhlIHBpbm5lZCBwYW5lbHMgaGFzIHNob3duIC8gaGlkZGVuLCB0aGVuIG5lZWQgdG8gcmVkcmF3IHRoZSBmdWxsV2lkdGggYml0cyB3aGVuXG4gICAgICAgIC8vIGVtYmVkZGVkLCBhcyB3aGF0IGFwcGVhcnMgaW4gZWFjaCBzZWN0aW9uIGRlcGVuZHMgb24gd2hldGhlciB3ZSBhcmUgcGlubmVkIG9yIG5vdFxuICAgICAgICB2YXIgcm93c1RvUmVtb3ZlID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaFJvd0NvbXAoZnVuY3Rpb24gKGlkLCByb3dDb21wKSB7XG4gICAgICAgICAgICBpZiAocm93Q29tcC5pc0Z1bGxXaWR0aCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0luZGV4ID0gcm93Q29tcC5nZXRSb3dOb2RlKCkucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgcm93c1RvUmVtb3ZlLnB1c2gocm93SW5kZXgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbW92ZVJvd0NvbXBzKHJvd3NUb1JlbW92ZSk7XG4gICAgICAgIHRoaXMucmVkcmF3QWZ0ZXJTY3JvbGwoKTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVPclVwZGF0ZVJvd0NvbXAgPSBmdW5jdGlvbiAocm93SW5kZXgsIHJvd3NUb1JlY3ljbGUsIGFuaW1hdGUsIGFmdGVyU2Nyb2xsKSB7XG4gICAgICAgIHZhciByb3dOb2RlO1xuICAgICAgICB2YXIgcm93Q29tcCA9IHRoaXMucm93Q29tcHNCeUluZGV4W3Jvd0luZGV4XTtcbiAgICAgICAgLy8gaWYgbm8gcm93IGNvbXAsIHNlZSBpZiB3ZSBjYW4gZ2V0IGl0IGZyb20gdGhlIHByZXZpb3VzIHJvd0NvbXBzXG4gICAgICAgIGlmICghcm93Q29tcCkge1xuICAgICAgICAgICAgcm93Tm9kZSA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFJvdyhyb3dJbmRleCk7XG4gICAgICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMocm93Tm9kZSkgJiYgdXRpbHNfMS5VdGlscy5leGlzdHMocm93c1RvUmVjeWNsZSkgJiYgcm93c1RvUmVjeWNsZVtyb3dOb2RlLmlkXSkge1xuICAgICAgICAgICAgICAgIHJvd0NvbXAgPSByb3dzVG9SZWN5Y2xlW3Jvd05vZGUuaWRdO1xuICAgICAgICAgICAgICAgIHJvd3NUb1JlY3ljbGVbcm93Tm9kZS5pZF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjcmVhdGluZ05ld1Jvd0NvbXAgPSAhcm93Q29tcDtcbiAgICAgICAgaWYgKGNyZWF0aW5nTmV3Um93Q29tcCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgICAgaWYgKCFyb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgcm93Tm9kZSA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFJvdyhyb3dJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMocm93Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICByb3dDb21wID0gdGhpcy5jcmVhdGVSb3dDb21wKHJvd05vZGUsIGFuaW1hdGUsIGFmdGVyU2Nyb2xsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiAtIGlmIHNvbWVob3cgd2UgYXJlIHRyeWluZyB0byBjcmVhdGVcbiAgICAgICAgICAgICAgICAvLyBhIHJvdyBmb3IgYSByb3dOb2RlIHRoYXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHJvdyBjb21wIGlzIGluIHJpZ2h0IHBvc2l0aW9uIGluIERPTVxuICAgICAgICAgICAgcm93Q29tcC5lbnN1cmVEb21PcmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93Q29tcHNCeUluZGV4W3Jvd0luZGV4XSA9IHJvd0NvbXA7XG4gICAgICAgIHJldHVybiByb3dDb21wO1xuICAgIH07XG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3lSb3dDb21wcyA9IGZ1bmN0aW9uIChyb3dDb21wc01hcCwgYW5pbWF0ZSkge1xuICAgICAgICB2YXIgZGVsYXllZEZ1bmNzID0gW107XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuaXRlcmF0ZU9iamVjdChyb3dDb21wc01hcCwgZnVuY3Rpb24gKG5vZGVJZCwgcm93Q29tcCkge1xuICAgICAgICAgICAgLy8gaWYgcm93IHdhcyB1c2VkLCB0aGVuIGl0J3MgbnVsbFxuICAgICAgICAgICAgaWYgKCFyb3dDb21wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93Q29tcC5kZXN0cm95KGFuaW1hdGUpO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5wdXNoQWxsKGRlbGF5ZWRGdW5jcywgcm93Q29tcC5nZXRBbmRDbGVhckRlbGF5ZWREZXN0cm95RnVuY3Rpb25zKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5leGVjdXRlSW5BV2hpbGUoZGVsYXllZEZ1bmNzKTtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5jaGVja0FuZ3VsYXJDb21waWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgZG9pbmcgYW5ndWxhciBjb21waWxpbmcsIHRoZW4gZG8gZGlnZXN0IHRoZSBzY29wZSBoZXJlXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0FuZ3VsYXJDb21waWxlUm93cygpKSB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBpdCBpbiBhIHRpbWVvdXQsIGluIGNhc2Ugd2UgYXJlIGFscmVhZHkgaW4gYW4gYXBwbHlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBfdGhpcy4kc2NvcGUuJGFwcGx5KCk7IH0sIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUud29ya091dEZpcnN0QW5kTGFzdFJvd3NUb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0ZpcnN0O1xuICAgICAgICB2YXIgbmV3TGFzdDtcbiAgICAgICAgaWYgKCF0aGlzLnBhZ2luYXRpb25Qcm94eS5pc1Jvd3NUb1JlbmRlcigpKSB7XG4gICAgICAgICAgICBuZXdGaXJzdCA9IDA7XG4gICAgICAgICAgICBuZXdMYXN0ID0gLTE7IC8vIHNldHRpbmcgdG8gLTEgbWVhbnMgbm90aGluZyBpbiByYW5nZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhZ2VGaXJzdFJvdyA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFBhZ2VGaXJzdFJvdygpO1xuICAgICAgICAgICAgdmFyIHBhZ2VMYXN0Um93ID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0UGFnZUxhc3RSb3coKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvclByaW50KSB7XG4gICAgICAgICAgICAgICAgbmV3Rmlyc3QgPSBwYWdlRmlyc3RSb3c7XG4gICAgICAgICAgICAgICAgbmV3TGFzdCA9IHBhZ2VMYXN0Um93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsT2Zmc2V0ID0gdGhpcy5wYWdpbmF0aW9uUHJveHkgPyB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRQaXhlbE9mZnNldCgpIDogMDtcbiAgICAgICAgICAgICAgICB2YXIgYm9keVZSYW5nZSA9IHRoaXMuZ3JpZFBhbmVsLmdldFZlcnRpY2FsUGl4ZWxSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHZhciB0b3BQaXhlbCA9IGJvZHlWUmFuZ2UudG9wO1xuICAgICAgICAgICAgICAgIHZhciBib3R0b21QaXhlbCA9IGJvZHlWUmFuZ2UuYm90dG9tO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFJvd0luZGV4QXRQaXhlbCh0b3BQaXhlbCArIHBpeGVsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFJvd0luZGV4QXRQaXhlbChib3R0b21QaXhlbCArIHBpeGVsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvL2FkZCBpbiBidWZmZXJcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Um93QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmaXJzdCAtIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBsYXN0ID0gbGFzdCArIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAvLyBhZGp1c3QsIGluIGNhc2UgYnVmZmVyIGV4dGVuZGVkIGFjdHVhbCBzaXplXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0IDwgcGFnZUZpcnN0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gcGFnZUZpcnN0Um93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdCA+IHBhZ2VMYXN0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBwYWdlTGFzdFJvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3Rmlyc3QgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICBuZXdMYXN0ID0gbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3REaWZmZXJzID0gbmV3Rmlyc3QgIT09IHRoaXMuZmlyc3RSZW5kZXJlZFJvdztcbiAgICAgICAgdmFyIGxhc3REaWZmZXJzID0gbmV3TGFzdCAhPT0gdGhpcy5sYXN0UmVuZGVyZWRSb3c7XG4gICAgICAgIGlmIChmaXJzdERpZmZlcnMgfHwgbGFzdERpZmZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RSZW5kZXJlZFJvdyA9IG5ld0ZpcnN0O1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVuZGVyZWRSb3cgPSBuZXdMYXN0O1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1ZJRVdQT1JUX0NIQU5HRUQsXG4gICAgICAgICAgICAgICAgZmlyc3RSb3c6IG5ld0ZpcnN0LFxuICAgICAgICAgICAgICAgIGxhc3RSb3c6IG5ld0xhc3QsXG4gICAgICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnRfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5nZXRGaXJzdFZpcnR1YWxSZW5kZXJlZFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RSZW5kZXJlZFJvdztcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5nZXRMYXN0VmlydHVhbFJlbmRlcmVkUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVuZGVyZWRSb3c7XG4gICAgfTtcbiAgICAvLyBjaGVjayB0aGF0IG5vbmUgb2YgdGhlIHJvd3MgdG8gcmVtb3ZlIGFyZSBlZGl0aW5nIG9yIGZvY3VzZWQgYXM6XG4gICAgLy8gYSkgaWYgZWRpdGluZywgd2Ugd2FudCB0byBrZWVwIHRoZW0sIG90aGVyd2lzZSB0aGUgdXNlciB3aWxsIGxvb3NlIHRoZSBjb250ZXh0IG9mIHRoZSBlZGl0LFxuICAgIC8vICAgIGVnIHVzZXIgc3RhcnRzIGVkaXRpbmcsIGVudGVycyBzb21lIHRleHQsIHRoZW4gc2Nyb2xscyBkb3duIGFuZCB0aGVuIHVwLCBuZXh0IHRpbWUgcm93IHJlbmRlcmVkXG4gICAgLy8gICAgdGhlIGVkaXQgaXMgcmVzZXQgLSBzbyB3ZSB3YW50IHRvIGtlZXAgaXQgcmVuZGVyZWQuXG4gICAgLy8gYikgaWYgZm9jdXNlZCwgd2Ugd2FudCBvdCBrZWVwIGtleWJvYXJkIGZvY3VzLCBzbyBpZiB1c2VyIGN0cmwrYywgaXQgZ29lcyB0byBjbGlwYm9hcmQsXG4gICAgLy8gICAgb3RoZXJ3aXNlIHRoZSB1c2VyIGNhbiByYW5nZSBzZWxlY3QgYW5kIGRyYWcgKHdpdGggZm9jdXMgY2VsbCBnb2luZyBvdXQgb2YgdGhlIHZpZXdwb3J0KVxuICAgIC8vICAgIGFuZCB0aGVuIGN0cmwrYywgbm90aGluZyB3aWxsIGhhcHBlbiBpZiBjZWxsIGlzIHJlbW92ZWQgZnJvbSBkb20uXG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLmtlZXBSb3dCZWNhdXNlRWRpdGluZyA9IGZ1bmN0aW9uIChyb3dDb21wKSB7XG4gICAgICAgIHZhciBSRU1PVkVfUk9XID0gZmFsc2U7XG4gICAgICAgIHZhciBLRUVQX1JPVyA9IHRydWU7XG4gICAgICAgIHZhciByb3dOb2RlID0gcm93Q29tcC5nZXRSb3dOb2RlKCk7XG4gICAgICAgIHZhciByb3dIYXNGb2N1cyA9IHRoaXMuZm9jdXNlZENlbGxDb250cm9sbGVyLmlzUm93Tm9kZUZvY3VzZWQocm93Tm9kZSk7XG4gICAgICAgIHZhciByb3dJc0VkaXRpbmcgPSByb3dDb21wLmlzRWRpdGluZygpO1xuICAgICAgICB2YXIgbWlnaHRXYW50VG9LZWVwUm93ID0gcm93SGFzRm9jdXMgfHwgcm93SXNFZGl0aW5nO1xuICAgICAgICAvLyBpZiB3ZSBkZWZmbyBkb24ndCB3YW50IHRvIGtlZXAgaXQsXG4gICAgICAgIGlmICghbWlnaHRXYW50VG9LZWVwUm93KSB7XG4gICAgICAgICAgICByZXR1cm4gUkVNT1ZFX1JPVztcbiAgICAgICAgfVxuICAgICAgICAvLyBlZGl0aW5nIHJvdywgb25seSByZW1vdmUgaWYgaXQgaXMgbm8gbG9uZ2VyIHJlbmRlcmVkLCBlZyBmaWx0ZXJlZCBvdXQgb3IgbmV3IGRhdGEgc2V0LlxuICAgICAgICAvLyB0aGUgcmVhc29uIHdlIHdhbnQgdG8ga2VlcCBpcyBpZiB1c2VyIGlzIHNjcm9sbGluZyB1cCBhbmQgZG93biwgd2UgZG9uJ3Qgd2FudCB0byBsb29zZVxuICAgICAgICAvLyB0aGUgY29udGV4dCBvZiB0aGUgZWRpdGluZyBpbiBwcm9jZXNzLlxuICAgICAgICB2YXIgcm93Tm9kZVByZXNlbnQgPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5pc1Jvd1ByZXNlbnQocm93Tm9kZSk7XG4gICAgICAgIHJldHVybiByb3dOb2RlUHJlc2VudCA/IEtFRVBfUk9XIDogUkVNT1ZFX1JPVztcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVSb3dDb21wID0gZnVuY3Rpb24gKHJvd05vZGUsIGFuaW1hdGUsIGFmdGVyU2Nyb2xsKSB7XG4gICAgICAgIHZhciB1c2VBbmltYXRpb25GcmFtZUZvckNyZWF0ZSA9IGFmdGVyU2Nyb2xsICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzQW5pbWF0aW9uRnJhbWUoKTtcbiAgICAgICAgdmFyIHJvd0NvbXAgPSBuZXcgcm93Q29tcF8xLlJvd0NvbXAodGhpcy4kc2NvcGUsIHRoaXMucm93Q29udGFpbmVycy5ib2R5LCB0aGlzLnJvd0NvbnRhaW5lcnMucGlubmVkTGVmdCwgdGhpcy5yb3dDb250YWluZXJzLnBpbm5lZFJpZ2h0LCB0aGlzLnJvd0NvbnRhaW5lcnMuZnVsbFdpZHRoLCByb3dOb2RlLCB0aGlzLmJlYW5zLCBhbmltYXRlLCB1c2VBbmltYXRpb25GcmFtZUZvckNyZWF0ZSk7XG4gICAgICAgIHJvd0NvbXAuaW5pdCgpO1xuICAgICAgICByZXR1cm4gcm93Q29tcDtcbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5nZXRSZW5kZXJlZE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWRSb3dzID0gdGhpcy5yb3dDb21wc0J5SW5kZXg7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZW5kZXJlZFJvd3MpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZWRSb3dzW2tleV0uZ2V0Um93Tm9kZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHdlIHVzZSBpbmRleCBmb3Igcm93cywgYnV0IGNvbHVtbiBvYmplY3QgZm9yIGNvbHVtbnMsIGFzIHRoZSBuZXh0IGNvbHVtbiAoYnkgaW5kZXgpIG1pZ2h0IG5vdFxuICAgIC8vIGJlIHZpc2libGUgKGhlYWRlciBncm91cGluZykgc28gaXQncyBub3QgcmVsaWFibGUsIHNvIHVzaW5nIHRoZSBjb2x1bW4gb2JqZWN0IGluc3RlYWQuXG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLm5hdmlnYXRlVG9OZXh0Q2VsbCA9IGZ1bmN0aW9uIChldmVudCwga2V5LCByb3dJbmRleCwgY29sdW1uLCBmbG9hdGluZykge1xuICAgICAgICB2YXIgcHJldmlvdXNDZWxsID0gbmV3IGdyaWRDZWxsXzEuR3JpZENlbGwoeyByb3dJbmRleDogcm93SW5kZXgsIGZsb2F0aW5nOiBmbG9hdGluZywgY29sdW1uOiBjb2x1bW4gfSk7XG4gICAgICAgIHZhciBuZXh0Q2VsbCA9IHByZXZpb3VzQ2VsbDtcbiAgICAgICAgLy8gd2Uga2VlcCBzZWFyY2hpbmcgZm9yIGEgbmV4dCBjZWxsIHVudGlsIHdlIGZpbmQgb25lLiB0aGlzIGlzIGhvdyB0aGUgZ3JvdXAgcm93cyBnZXQgc2tpcHBlZFxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbmV4dENlbGwgPSB0aGlzLmNlbGxOYXZpZ2F0aW9uU2VydmljZS5nZXROZXh0Q2VsbFRvRm9jdXMoa2V5LCBuZXh0Q2VsbCk7XG4gICAgICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKG5leHRDZWxsKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNraXBHcm91cFJvd3MgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwVXNlRW50aXJlUm93KCk7XG4gICAgICAgICAgICBpZiAoc2tpcEdyb3VwUm93cykge1xuICAgICAgICAgICAgICAgIHZhciByb3dOb2RlID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0Um93KG5leHRDZWxsLnJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvd05vZGUuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgdXNlciB0byBvdmVycmlkZSB3aGF0IGNlbGwgdG8gZ28gdG8gbmV4dFxuICAgICAgICB2YXIgdXNlckZ1bmMgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXROYXZpZ2F0ZVRvTmV4dENlbGxGdW5jKCk7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyh1c2VyRnVuYykpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgcHJldmlvdXNDZWxsRGVmOiBwcmV2aW91c0NlbGwsXG4gICAgICAgICAgICAgICAgbmV4dENlbGxEZWY6IG5leHRDZWxsID8gbmV4dENlbGwuZ2V0R3JpZENlbGxEZWYoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG5leHRDZWxsRGVmID0gdXNlckZ1bmMocGFyYW1zKTtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhuZXh0Q2VsbERlZikpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2VsbCA9IG5ldyBncmlkQ2VsbF8xLkdyaWRDZWxsKG5leHRDZWxsRGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHRDZWxsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBubyBuZXh0IGNlbGwgbWVhbnMgd2UgaGF2ZSByZWFjaGVkIGEgZ3JpZCBib3VuZGFyeSwgZWcgbGVmdCwgcmlnaHQsIHRvcCBvciBib3R0b20gb2YgZ3JpZFxuICAgICAgICBpZiAoIW5leHRDZWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBzY3JvbGxzIHRoZSByb3cgaW50byB2aWV3XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcobmV4dENlbGwuZmxvYXRpbmcpKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRQYW5lbC5lbnN1cmVJbmRleFZpc2libGUobmV4dENlbGwucm93SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmV4dENlbGwuY29sdW1uLmlzUGlubmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFBhbmVsLmVuc3VyZUNvbHVtblZpc2libGUobmV4dENlbGwuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWVkIHRvIG51ZGdlIHRoZSBzY3JvbGxzIGZvciB0aGUgZmxvYXRpbmcgaXRlbXMuIG90aGVyd2lzZSB3aGVuIHdlIHNldCBmb2N1cyBvbiBhIG5vbi12aXNpYmxlXG4gICAgICAgIC8vIGZsb2F0aW5nIGNlbGwsIHRoZSBzY3JvbGxzIGdldCBvdXQgb2Ygc3luY1xuICAgICAgICB0aGlzLmdyaWRQYW5lbC5ob3Jpem9udGFsbHlTY3JvbGxIZWFkZXJDZW50ZXJBbmRGbG9hdGluZ0NlbnRlcigpO1xuICAgICAgICAvLyBuZWVkIHRvIGZsdXNoIGZyYW1lcywgdG8gbWFrZSBzdXJlIHRoZSBjb3JyZWN0IGNlbGxzIGFyZSByZW5kZXJlZFxuICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lU2VydmljZS5mbHVzaEFsbEZyYW1lcygpO1xuICAgICAgICB0aGlzLmZvY3VzZWRDZWxsQ29udHJvbGxlci5zZXRGb2N1c2VkQ2VsbChuZXh0Q2VsbC5yb3dJbmRleCwgbmV4dENlbGwuY29sdW1uLCBuZXh0Q2VsbC5mbG9hdGluZywgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIGdyaWRDZWxsID0gbmV3IGdyaWRDZWxsXzEuR3JpZENlbGwoeyByb3dJbmRleDogbmV4dENlbGwucm93SW5kZXgsIGZsb2F0aW5nOiBuZXh0Q2VsbC5mbG9hdGluZywgY29sdW1uOiBuZXh0Q2VsbC5jb2x1bW4gfSk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlQ29udHJvbGxlci5zZXRSYW5nZVRvQ2VsbChncmlkQ2VsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5zdGFydEVkaXRpbmdDZWxsID0gZnVuY3Rpb24gKGdyaWRDZWxsLCBrZXlQcmVzcywgY2hhclByZXNzKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRDb21wb25lbnRGb3JDZWxsKGdyaWRDZWxsKTtcbiAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgIGNlbGwuc3RhcnRSb3dPckNlbGxFZGl0KGtleVByZXNzLCBjaGFyUHJlc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q29tcG9uZW50Rm9yQ2VsbCA9IGZ1bmN0aW9uIChncmlkQ2VsbCkge1xuICAgICAgICB2YXIgcm93Q29tcG9uZW50O1xuICAgICAgICBzd2l0Y2ggKGdyaWRDZWxsLmZsb2F0aW5nKSB7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfVE9QOlxuICAgICAgICAgICAgICAgIHJvd0NvbXBvbmVudCA9IHRoaXMuZmxvYXRpbmdUb3BSb3dDb21wc1tncmlkQ2VsbC5yb3dJbmRleF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfQk9UVE9NOlxuICAgICAgICAgICAgICAgIHJvd0NvbXBvbmVudCA9IHRoaXMuZmxvYXRpbmdCb3R0b21Sb3dDb21wc1tncmlkQ2VsbC5yb3dJbmRleF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJvd0NvbXBvbmVudCA9IHRoaXMucm93Q29tcHNCeUluZGV4W2dyaWRDZWxsLnJvd0luZGV4XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvd0NvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlbGxDb21wb25lbnQgPSByb3dDb21wb25lbnQuZ2V0UmVuZGVyZWRDZWxsRm9yQ29sdW1uKGdyaWRDZWxsLmNvbHVtbik7XG4gICAgICAgIHJldHVybiBjZWxsQ29tcG9uZW50O1xuICAgIH07XG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLm9uVGFiS2V5RG93biA9IGZ1bmN0aW9uIChwcmV2aW91c1JlbmRlcmVkQ2VsbCwga2V5Ym9hcmRFdmVudCkge1xuICAgICAgICB2YXIgYmFja3dhcmRzID0ga2V5Ym9hcmRFdmVudC5zaGlmdEtleTtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSB0aGlzLm1vdmVUb0NlbGxBZnRlcihwcmV2aW91c1JlbmRlcmVkQ2VsbCwgYmFja3dhcmRzKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLnRhYlRvTmV4dENlbGwgPSBmdW5jdGlvbiAoYmFja3dhcmRzKSB7XG4gICAgICAgIHZhciBmb2N1c2VkQ2VsbCA9IHRoaXMuZm9jdXNlZENlbGxDb250cm9sbGVyLmdldEZvY3VzZWRDZWxsKCk7XG4gICAgICAgIC8vIGlmIG5vIGZvY3VzLCB0aGVuIGNhbm5vdCBuYXZpZ2F0ZVxuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKGZvY3VzZWRDZWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW5kZXJlZENlbGwgPSB0aGlzLmdldENvbXBvbmVudEZvckNlbGwoZm9jdXNlZENlbGwpO1xuICAgICAgICAvLyBpZiBjZWxsIGlzIG5vdCByZW5kZXJlZCwgbWVhbnMgdXNlciBoYXMgc2Nyb2xsZWQgYXdheSBmcm9tIHRoZSBjZWxsXG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcocmVuZGVyZWRDZWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1vdmVUb0NlbGxBZnRlcihyZW5kZXJlZENlbGwsIGJhY2t3YXJkcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIHRydWUgaWYgbW92aW5nIHRvIG5leHQgY2VsbCB3YXMgc3VjY2Vzc2Z1bFxuICAgIFJvd1JlbmRlcmVyLnByb3RvdHlwZS5tb3ZlVG9DZWxsQWZ0ZXIgPSBmdW5jdGlvbiAocHJldmlvdXNSZW5kZXJlZENlbGwsIGJhY2t3YXJkcykge1xuICAgICAgICB2YXIgZWRpdGluZyA9IHByZXZpb3VzUmVuZGVyZWRDZWxsLmlzRWRpdGluZygpO1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBwcmV2aW91c1JlbmRlcmVkQ2VsbC5nZXRHcmlkQ2VsbCgpO1xuICAgICAgICAvLyBmaW5kIHRoZSBuZXh0IGNlbGwgdG8gc3RhcnQgZWRpdGluZ1xuICAgICAgICB2YXIgbmV4dFJlbmRlcmVkQ2VsbCA9IHRoaXMuZmluZE5leHRDZWxsVG9Gb2N1c09uKGdyaWRDZWxsLCBiYWNrd2FyZHMsIGVkaXRpbmcpO1xuICAgICAgICB2YXIgZm91bmRDZWxsID0gdXRpbHNfMS5VdGlscy5leGlzdHMobmV4dFJlbmRlcmVkQ2VsbCk7XG4gICAgICAgIC8vIG9ubHkgcHJldmVudCBkZWZhdWx0IGlmIHdlIGZvdW5kIGEgY2VsbC4gc28gaWYgdXNlciBpcyBvbiBsYXN0IGNlbGwgYW5kIGhpdHMgdGFiLCB0aGVuIHdlIGRlZmF1bHRcbiAgICAgICAgLy8gdG8gdGhlIG5vcm1hbCB0YWJiaW5nIHNvIHVzZXIgY2FuIGV4aXQgdGhlIGdyaWQuXG4gICAgICAgIGlmIChmb3VuZENlbGwpIHtcbiAgICAgICAgICAgIGlmIChlZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRnVsbFJvd0VkaXQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVFZGl0VG9OZXh0Q2VsbE9yUm93KHByZXZpb3VzUmVuZGVyZWRDZWxsLCBuZXh0UmVuZGVyZWRDZWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUVkaXRUb05leHRDZWxsKHByZXZpb3VzUmVuZGVyZWRDZWxsLCBuZXh0UmVuZGVyZWRDZWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0UmVuZGVyZWRDZWxsLmZvY3VzQ2VsbCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUubW92ZUVkaXRUb05leHRDZWxsID0gZnVuY3Rpb24gKHByZXZpb3VzUmVuZGVyZWRDZWxsLCBuZXh0UmVuZGVyZWRDZWxsKSB7XG4gICAgICAgIHByZXZpb3VzUmVuZGVyZWRDZWxsLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIG5leHRSZW5kZXJlZENlbGwuc3RhcnRFZGl0aW5nSWZFbmFibGVkKG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgICBuZXh0UmVuZGVyZWRDZWxsLmZvY3VzQ2VsbChmYWxzZSk7XG4gICAgfTtcbiAgICBSb3dSZW5kZXJlci5wcm90b3R5cGUubW92ZUVkaXRUb05leHRDZWxsT3JSb3cgPSBmdW5jdGlvbiAocHJldmlvdXNSZW5kZXJlZENlbGwsIG5leHRSZW5kZXJlZENlbGwpIHtcbiAgICAgICAgdmFyIHBHcmlkQ2VsbCA9IHByZXZpb3VzUmVuZGVyZWRDZWxsLmdldEdyaWRDZWxsKCk7XG4gICAgICAgIHZhciBuR3JpZENlbGwgPSBuZXh0UmVuZGVyZWRDZWxsLmdldEdyaWRDZWxsKCk7XG4gICAgICAgIHZhciByb3dzTWF0Y2ggPSAocEdyaWRDZWxsLnJvd0luZGV4ID09PSBuR3JpZENlbGwucm93SW5kZXgpXG4gICAgICAgICAgICAmJiAocEdyaWRDZWxsLmZsb2F0aW5nID09PSBuR3JpZENlbGwuZmxvYXRpbmcpO1xuICAgICAgICBpZiAocm93c01hdGNoKSB7XG4gICAgICAgICAgICAvLyBzYW1lIHJvdywgc28gd2UgZG9uJ3Qgc3RhcnQgLyBzdG9wIGVkaXRpbmcsIHdlIGp1c3QgbW92ZSB0aGUgZm9jdXMgYWxvbmdcbiAgICAgICAgICAgIHByZXZpb3VzUmVuZGVyZWRDZWxsLnNldEZvY3VzT3V0T25FZGl0b3IoKTtcbiAgICAgICAgICAgIG5leHRSZW5kZXJlZENlbGwuc2V0Rm9jdXNJbk9uRWRpdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcFJvdyA9IHByZXZpb3VzUmVuZGVyZWRDZWxsLmdldFJlbmRlcmVkUm93KCk7XG4gICAgICAgICAgICB2YXIgblJvdyA9IG5leHRSZW5kZXJlZENlbGwuZ2V0UmVuZGVyZWRSb3coKTtcbiAgICAgICAgICAgIHByZXZpb3VzUmVuZGVyZWRDZWxsLnNldEZvY3VzT3V0T25FZGl0b3IoKTtcbiAgICAgICAgICAgIHBSb3cuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgIG5Sb3cuc3RhcnRSb3dFZGl0aW5nKCk7XG4gICAgICAgICAgICBuZXh0UmVuZGVyZWRDZWxsLnNldEZvY3VzSW5PbkVkaXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRSZW5kZXJlZENlbGwuZm9jdXNDZWxsKCk7XG4gICAgfTtcbiAgICAvLyBjYWxsZWQgYnkgdGhlIGNlbGwsIHdoZW4gdGFiIGlzIHByZXNzZWQgd2hpbGUgZWRpdGluZy5cbiAgICAvLyBAcmV0dXJuOiBSZW5kZXJlZENlbGwgd2hlbiBuYXZpZ2F0aW9uIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBudWxsXG4gICAgUm93UmVuZGVyZXIucHJvdG90eXBlLmZpbmROZXh0Q2VsbFRvRm9jdXNPbiA9IGZ1bmN0aW9uIChncmlkQ2VsbCwgYmFja3dhcmRzLCBzdGFydEVkaXRpbmcpIHtcbiAgICAgICAgdmFyIG5leHRDZWxsID0gZ3JpZENlbGw7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBuZXh0Q2VsbCA9IHRoaXMuY2VsbE5hdmlnYXRpb25TZXJ2aWNlLmdldE5leHRUYWJiZWRDZWxsKG5leHRDZWxsLCBiYWNrd2FyZHMpO1xuICAgICAgICAgICAgLy8gYWxsb3cgdXNlciB0byBvdmVycmlkZSB3aGF0IGNlbGwgdG8gZ28gdG8gbmV4dFxuICAgICAgICAgICAgdmFyIHVzZXJGdW5jID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0VGFiVG9OZXh0Q2VsbEZ1bmMoKTtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyh1c2VyRnVuYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBiYWNrd2FyZHM6IGJhY2t3YXJkcyxcbiAgICAgICAgICAgICAgICAgICAgZWRpdGluZzogc3RhcnRFZGl0aW5nLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NlbGxEZWY6IGdyaWRDZWxsLmdldEdyaWRDZWxsRGVmKCksXG4gICAgICAgICAgICAgICAgICAgIG5leHRDZWxsRGVmOiBuZXh0Q2VsbCA/IG5leHRDZWxsLmdldEdyaWRDZWxsRGVmKCkgOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENlbGxEZWYgPSB1c2VyRnVuYyhwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhuZXh0Q2VsbERlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENlbGwgPSBuZXcgZ3JpZENlbGxfMS5HcmlkQ2VsbChuZXh0Q2VsbERlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q2VsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgbm8gJ25leHQgY2VsbCcsIG1lYW5zIHdlIGhhdmUgZ290IHRvIGxhc3QgY2VsbCBvZiBncmlkLCBzbyBub3RoaW5nIHRvIG1vdmUgdG8sXG4gICAgICAgICAgICAvLyBzbyBib3R0b20gcmlnaHQgY2VsbCBnb2luZyBmb3J3YXJkcywgb3IgdG9wIGxlZnQgZ29pbmcgYmFja3dhcmRzXG4gICAgICAgICAgICBpZiAoIW5leHRDZWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIHNjcm9sbHMgdGhlIHJvdyBpbnRvIHZpZXdcbiAgICAgICAgICAgIHZhciBjZWxsSXNOb3RGbG9hdGluZyA9IHV0aWxzXzEuVXRpbHMubWlzc2luZyhuZXh0Q2VsbC5mbG9hdGluZyk7XG4gICAgICAgICAgICBpZiAoY2VsbElzTm90RmxvYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRQYW5lbC5lbnN1cmVJbmRleFZpc2libGUobmV4dENlbGwucm93SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcGlubmVkIGNvbHVtbnMgZG9uJ3Qgc2Nyb2xsLCBzbyBubyBuZWVkIHRvIGVuc3VyZSBpbmRleCB2aXNpYmxlXG4gICAgICAgICAgICBpZiAoIW5leHRDZWxsLmNvbHVtbi5pc1Bpbm5lZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkUGFuZWwuZW5zdXJlQ29sdW1uVmlzaWJsZShuZXh0Q2VsbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmVlZCB0byBudWRnZSB0aGUgc2Nyb2xscyBmb3IgdGhlIGZsb2F0aW5nIGl0ZW1zLiBvdGhlcndpc2Ugd2hlbiB3ZSBzZXQgZm9jdXMgb24gYSBub24tdmlzaWJsZVxuICAgICAgICAgICAgLy8gZmxvYXRpbmcgY2VsbCwgdGhlIHNjcm9sbHMgZ2V0IG91dCBvZiBzeW5jXG4gICAgICAgICAgICB0aGlzLmdyaWRQYW5lbC5ob3Jpem9udGFsbHlTY3JvbGxIZWFkZXJDZW50ZXJBbmRGbG9hdGluZ0NlbnRlcigpO1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBncmlkIHBhbmVsIHRvIGZsdXNoIGFsbCBhbmltYXRpb24gZnJhbWVzIC0gb3RoZXJ3aXNlIHRoZSBjYWxsIGJlbG93IHRvIGdldCB0aGUgY2VsbENvbXBcbiAgICAgICAgICAgIC8vIGNvdWxkIGZhaWwsIGlmIHdlIGp1c3Qgc2Nyb2xsZWQgdGhlIGdyaWQgKHRvIG1ha2UgYSBjZWxsIHZpc2libGUpIGFuZCB0aGUgcmVuZGVyaW5nIGhhc24ndCBmaW5pc2hlZC5cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVTZXJ2aWNlLmZsdXNoQWxsRnJhbWVzKCk7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGNhbGwgdGhpcyBhZnRlciBlbnN1cmVDb2x1bW5WaXNpYmxlIC0gb3RoZXJ3aXNlIGl0IGNvdWxkIGJlIGEgdmlydHVhbCBjb2x1bW5cbiAgICAgICAgICAgIC8vIG9yIHJvdyB0aGF0IGlzIG5vdCBjdXJyZW50bHkgaW4gdmlldywgaGVuY2UgdGhlIHJlbmRlcmVkQ2VsbCB3b3VsZCBub3QgZXhpc3RcbiAgICAgICAgICAgIHZhciBuZXh0Q2VsbENvbXAgPSB0aGlzLmdldENvbXBvbmVudEZvckNlbGwobmV4dENlbGwpO1xuICAgICAgICAgICAgLy8gaWYgbmV4dCBjZWxsIGlzIGZ1bGxXaWR0aCByb3csIHRoZW4gbm8gcmVuZGVyZWQgY2VsbCxcbiAgICAgICAgICAgIC8vIGFzIGZ1bGxXaWR0aCByb3dzIGhhdmUgbm8gY2VsbHMsIHNvIHdlIHNraXAgaXRcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcobmV4dENlbGxDb21wKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgZWRpdGluZywgYnV0IGNlbGwgbm90IGVkaXRhYmxlLCBza2lwIGNlbGxcbiAgICAgICAgICAgIGlmIChzdGFydEVkaXRpbmcgJiYgIW5leHRDZWxsQ29tcC5pc0NlbGxFZGl0YWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dENlbGxDb21wLmlzU3VwcHJlc3NOYXZpZ2FibGUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCwgd2hlbiB3ZSBjbGljayBhIGNlbGwsIGl0IGdldHMgc2VsZWN0ZWQgaW50byBhIHJhbmdlLCBzbyB0byBrZWVwIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgIC8vIGNvbnNpc3RlbnQsIHdlIHNldCBpbnRvIHJhbmdlIGhlcmUgYWxzby5cbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHZhciBncmlkQ2VsbF8yID0gbmV3IGdyaWRDZWxsXzEuR3JpZENlbGwoeyByb3dJbmRleDogbmV4dENlbGwucm93SW5kZXgsIGZsb2F0aW5nOiBuZXh0Q2VsbC5mbG9hdGluZywgY29sdW1uOiBuZXh0Q2VsbC5jb2x1bW4gfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZUNvbnRyb2xsZXIuc2V0UmFuZ2VUb0NlbGwoZ3JpZENlbGxfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBzdWNjZXNzZnVsbHkgdGFiYmVkIG9udG8gYSBncmlkIGNlbGwsIHNvIHJldHVybiB0cnVlXG4gICAgICAgICAgICByZXR1cm4gbmV4dENlbGxDb21wO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncGFnaW5hdGlvblByb3h5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBwYWdpbmF0aW9uUHJveHlfMS5QYWdpbmF0aW9uUHJveHkpXG4gICAgXSwgUm93UmVuZGVyZXIucHJvdG90eXBlLCBcInBhZ2luYXRpb25Qcm94eVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5Db250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQ29udHJvbGxlcilcbiAgICBdLCBSb3dSZW5kZXJlci5wcm90b3R5cGUsIFwiY29sdW1uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBSb3dSZW5kZXJlci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRDb3JlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQ29yZV8xLkdyaWRDb3JlKVxuICAgIF0sIFJvd1JlbmRlcmVyLnByb3RvdHlwZSwgXCJncmlkQ29yZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkUGFuZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRQYW5lbF8xLkdyaWRQYW5lbClcbiAgICBdLCBSb3dSZW5kZXJlci5wcm90b3R5cGUsIFwiZ3JpZFBhbmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJyRzY29wZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFJvd1JlbmRlcmVyLnByb3RvdHlwZSwgXCIkc2NvcGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXhwcmVzc2lvblNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGV4cHJlc3Npb25TZXJ2aWNlXzEuRXhwcmVzc2lvblNlcnZpY2UpXG4gICAgXSwgUm93UmVuZGVyZXIucHJvdG90eXBlLCBcImV4cHJlc3Npb25TZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3RlbXBsYXRlU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdGVtcGxhdGVTZXJ2aWNlXzEuVGVtcGxhdGVTZXJ2aWNlKVxuICAgIF0sIFJvd1JlbmRlcmVyLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgndmFsdWVTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB2YWx1ZVNlcnZpY2VfMS5WYWx1ZVNlcnZpY2UpXG4gICAgXSwgUm93UmVuZGVyZXIucHJvdG90eXBlLCBcInZhbHVlU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdldmVudFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSlcbiAgICBdLCBSb3dSZW5kZXJlci5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3Bpbm5lZFJvd01vZGVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBwaW5uZWRSb3dNb2RlbF8xLlBpbm5lZFJvd01vZGVsKVxuICAgIF0sIFJvd1JlbmRlcmVyLnByb3RvdHlwZSwgXCJwaW5uZWRSb3dNb2RlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBSb3dSZW5kZXJlci5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdsb2dnZXJGYWN0b3J5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBsb2dnZXJfMS5Mb2dnZXJGYWN0b3J5KVxuICAgIF0sIFJvd1JlbmRlcmVyLnByb3RvdHlwZSwgXCJsb2dnZXJGYWN0b3J5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZvY3VzZWRDZWxsQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZm9jdXNlZENlbGxDb250cm9sbGVyXzEuRm9jdXNlZENlbGxDb250cm9sbGVyKVxuICAgIF0sIFJvd1JlbmRlcmVyLnByb3RvdHlwZSwgXCJmb2N1c2VkQ2VsbENvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY2VsbE5hdmlnYXRpb25TZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjZWxsTmF2aWdhdGlvblNlcnZpY2VfMS5DZWxsTmF2aWdhdGlvblNlcnZpY2UpXG4gICAgXSwgUm93UmVuZGVyZXIucHJvdG90eXBlLCBcImNlbGxOYXZpZ2F0aW9uU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5BcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5BcGkpXG4gICAgXSwgUm93UmVuZGVyZXIucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBSb3dSZW5kZXJlci5wcm90b3R5cGUsIFwiZ3JpZEFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdiZWFucycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgYmVhbnNfMS5CZWFucylcbiAgICBdLCBSb3dSZW5kZXJlci5wcm90b3R5cGUsIFwiYmVhbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnYW5pbWF0aW9uRnJhbWVTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBhbmltYXRpb25GcmFtZVNlcnZpY2VfMS5BbmltYXRpb25GcmFtZVNlcnZpY2UpXG4gICAgXSwgUm93UmVuZGVyZXIucHJvdG90eXBlLCBcImFuaW1hdGlvbkZyYW1lU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuT3B0aW9uYWwoJ3JhbmdlQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFJvd1JlbmRlcmVyLnByb3RvdHlwZSwgXCJyYW5nZUNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgX19wYXJhbSgwLCBjb250ZXh0XzEuUXVhbGlmaWVyKCdsb2dnZXJGYWN0b3J5JykpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2xvZ2dlcl8xLkxvZ2dlckZhY3RvcnldKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBSb3dSZW5kZXJlci5wcm90b3R5cGUsIFwiYWdXaXJlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBSb3dSZW5kZXJlci5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlByZURlc3Ryb3ksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgUm93UmVuZGVyZXIucHJvdG90eXBlLCBcImRlc3Ryb3lcIiwgbnVsbCk7XG4gICAgUm93UmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ3Jvd1JlbmRlcmVyJylcbiAgICBdLCBSb3dSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJvd1JlbmRlcmVyO1xufShiZWFuU3R1Yl8xLkJlYW5TdHViKSk7XG5leHBvcnRzLlJvd1JlbmRlcmVyID0gUm93UmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvcm93UmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb250ZXh0XzIgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIEV4cHJlc3Npb25TZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uU2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uVG9GdW5jdGlvbkNhY2hlID0ge307XG4gICAgfVxuICAgIEV4cHJlc3Npb25TZXJ2aWNlLnByb3RvdHlwZS5zZXRCZWFucyA9IGZ1bmN0aW9uIChsb2dnZXJGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyRmFjdG9yeS5jcmVhdGUoJ0V4cHJlc3Npb25TZXJ2aWNlJyk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uU2VydmljZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbk9yRnVuYywgcGFyYW1zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbk9yRnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gdmFsdWVHZXR0ZXIgaXMgYSBmdW5jdGlvbiwgc28ganVzdCBjYWxsIGl0XG4gICAgICAgICAgICB2YXIgZnVuYyA9IGV4cHJlc3Npb25PckZ1bmM7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBleHByZXNzaW9uT3JGdW5jID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gdmFsdWVHZXR0ZXIgaXMgYW4gZXhwcmVzc2lvbiwgc28gZXhlY3V0ZSB0aGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uT3JGdW5jO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiB2YWx1ZSBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24nLCBleHByZXNzaW9uT3JGdW5jKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXhwcmVzc2lvblNlcnZpY2UucHJvdG90eXBlLmV2YWx1YXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBqYXZhU2NyaXB0RnVuY3Rpb24gPSB0aGlzLmNyZWF0ZUV4cHJlc3Npb25GdW5jdGlvbihleHByZXNzaW9uKTtcbiAgICAgICAgICAgIC8vIHRoZSBwYXJhbXMgZG9uJ3QgaGF2ZSBhbGwgdGhlc2UgdmFsdWVzLCByYXRoZXIgd2UgYWRkIGV2ZXJ5IHBvc3NpYmxlXG4gICAgICAgICAgICAvLyB2YWx1ZSBhIHBhcmFtcyBjYW4gaGF2ZSwgd2hpY2ggbWFrZXMgd2hhdGV2ZXIgaXMgaW4gdGhlIHBhcmFtcyBhdmFpbGFibGUuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gamF2YVNjcmlwdEZ1bmN0aW9uKHBhcmFtcy52YWx1ZSwgcGFyYW1zLmNvbnRleHQsIHBhcmFtcy5vbGRWYWx1ZSwgcGFyYW1zLm5ld1ZhbHVlLCBwYXJhbXMudmFsdWUsIHBhcmFtcy5ub2RlLCBwYXJhbXMuZGF0YSwgcGFyYW1zLmNvbERlZiwgcGFyYW1zLnJvd0luZGV4LCBwYXJhbXMuYXBpLCBwYXJhbXMuY29sdW1uQXBpLCBwYXJhbXMuZ2V0VmFsdWUsIHBhcmFtcy5jb2x1bW4sIHBhcmFtcy5jb2x1bW5Hcm91cCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyB0aGUgZXhwcmVzc2lvbiBmYWlsZWQsIHdoaWNoIGNhbiBoYXBwZW4sIGFzIGl0J3MgdGhlIGNsaWVudCB0aGF0XG4gICAgICAgICAgICAvLyBwcm92aWRlcyB0aGUgZXhwcmVzc2lvbi4gc28gcHJpbnQgYSBuaWNlIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIG9mIHRoZSBleHByZXNzaW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4cHJlc3Npb24gPSAnICsgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXhjZXB0aW9uID0gJyArIGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4cHJlc3Npb25TZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGVFeHByZXNzaW9uRnVuY3Rpb24gPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAvLyBjaGVjayBjYWNoZSBmaXJzdFxuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uVG9GdW5jdGlvbkNhY2hlW2V4cHJlc3Npb25dKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uVG9GdW5jdGlvbkNhY2hlW2V4cHJlc3Npb25dO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vdCBmb3VuZCBpbiBjYWNoZSwgcmV0dXJuIHRoZSBmdW5jdGlvblxuICAgICAgICB2YXIgZnVuY3Rpb25Cb2R5ID0gdGhpcy5jcmVhdGVGdW5jdGlvbkJvZHkoZXhwcmVzc2lvbik7XG4gICAgICAgIHZhciB0aGVGdW5jdGlvbiA9IG5ldyBGdW5jdGlvbigneCwgY3R4LCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHZhbHVlLCBub2RlLCBkYXRhLCBjb2xEZWYsIHJvd0luZGV4LCBhcGksIGNvbHVtbkFwaSwgZ2V0VmFsdWUsIGNvbHVtbiwgY29sdW1uR3JvdXAnLCBmdW5jdGlvbkJvZHkpO1xuICAgICAgICAvLyBzdG9yZSBpbiBjYWNoZVxuICAgICAgICB0aGlzLmV4cHJlc3Npb25Ub0Z1bmN0aW9uQ2FjaGVbZXhwcmVzc2lvbl0gPSB0aGVGdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoZUZ1bmN0aW9uO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgIC8vIGlmIHRoZSBleHByZXNzaW9uIGhhcyB0aGUgJ3JldHVybicgd29yZCBpbiBpdCwgdGhlbiB1c2UgYXMgaXMsXG4gICAgICAgIC8vIGlmIG5vdCwgdGhlbiB3cmFwIGl0IHdpdGggcmV0dXJuIGFuZCAnOycgdG8gbWFrZSBhIGZ1bmN0aW9uXG4gICAgICAgIGlmIChleHByZXNzaW9uLmluZGV4T2YoJ3JldHVybicpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdyZXR1cm4gJyArIGV4cHJlc3Npb24gKyAnOyc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBfX3BhcmFtKDAsIGNvbnRleHRfMi5RdWFsaWZpZXIoJ2xvZ2dlckZhY3RvcnknKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbbG9nZ2VyXzEuTG9nZ2VyRmFjdG9yeV0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEV4cHJlc3Npb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJzZXRCZWFuc1wiLCBudWxsKTtcbiAgICBFeHByZXNzaW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignZXhwcmVzc2lvblNlcnZpY2UnKVxuICAgIF0sIEV4cHJlc3Npb25TZXJ2aWNlKTtcbiAgICByZXR1cm4gRXhwcmVzc2lvblNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5FeHByZXNzaW9uU2VydmljZSA9IEV4cHJlc3Npb25TZXJ2aWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvdmFsdWVTZXJ2aWNlL2V4cHJlc3Npb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBleHByZXNzaW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vZXhwcmVzc2lvblNlcnZpY2VcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2V2ZW50U2VydmljZVwiKTtcbnZhciB2YWx1ZUNhY2hlXzEgPSByZXF1aXJlKFwiLi92YWx1ZUNhY2hlXCIpO1xudmFyIFZhbHVlU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFsdWVTZXJ2aWNlKCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIFZhbHVlU2VydmljZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jZWxsRXhwcmVzc2lvbnMgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZUNlbGxFeHByZXNzaW9ucygpO1xuICAgICAgICB0aGlzLmluaXRpYWxpc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFZhbHVlU2VydmljZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoY29sdW1uLCByb3dOb2RlLCBpZ25vcmVBZ2dEYXRhKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGB0dXJuQWN0aXZlID0gJHt0aGlzLnR1cm5BY3RpdmV9YCk7XG4gICAgICAgIGlmIChpZ25vcmVBZ2dEYXRhID09PSB2b2lkIDApIHsgaWdub3JlQWdnRGF0YSA9IGZhbHNlOyB9XG4gICAgICAgIC8vIGhhY2sgLSB0aGUgZ3JpZCBpcyBnZXR0aW5nIHJlZnJlc2hlZCBiZWZvcmUgdGhpcyBiZWFuIGdldHMgaW5pdGlhbGlzZWQsIHJhY2UgY29uZGl0aW9uLlxuICAgICAgICAvLyByZWFsbHkgc2hvdWxkIGhhdmUgYSB3YXkgc28gdGhleSBnZXQgaW5pdGlhbGlzZWQgaW4gdGhlIHJpZ2h0IG9yZGVyPz8/XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXNlZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHVsbCB0aGVzZSBvdXQgdG8gbWFrZSBjb2RlIGJlbG93IGVhc2llciB0byByZWFkXG4gICAgICAgIHZhciBjb2xEZWYgPSBjb2x1bW4uZ2V0Q29sRGVmKCk7XG4gICAgICAgIHZhciBmaWVsZCA9IGNvbERlZi5maWVsZDtcbiAgICAgICAgdmFyIGNvbElkID0gY29sdW1uLmdldElkKCk7XG4gICAgICAgIHZhciBkYXRhID0gcm93Tm9kZS5kYXRhO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHZhbHVlIGdldHRlciwgdGhpcyBnZXRzIHByZWNlZGVuY2Ugb3ZlciBhIGZpZWxkXG4gICAgICAgIHZhciBncm91cERhdGFFeGlzdHMgPSByb3dOb2RlLmdyb3VwRGF0YSAmJiByb3dOb2RlLmdyb3VwRGF0YVtjb2xJZF0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFnZ0RhdGFFeGlzdHMgPSAhaWdub3JlQWdnRGF0YSAmJiByb3dOb2RlLmFnZ0RhdGEgJiYgcm93Tm9kZS5hZ2dEYXRhW2NvbElkXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZ3JvdXBEYXRhRXhpc3RzKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByb3dOb2RlLmdyb3VwRGF0YVtjb2xJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWdnRGF0YUV4aXN0cykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcm93Tm9kZS5hZ2dEYXRhW2NvbElkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2xEZWYudmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZXhlY3V0ZVZhbHVlR2V0dGVyKGNvbERlZi52YWx1ZUdldHRlciwgZGF0YSwgY29sdW1uLCByb3dOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZCAmJiBkYXRhKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB1dGlsc18xLl8uZ2V0VmFsdWVVc2luZ0ZpZWxkKGRhdGEsIGZpZWxkLCBjb2x1bW4uaXNGaWVsZENvbnRhaW5zRG90cygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgcmVzdWx0IGNvdWxkIGJlIGFuIGV4cHJlc3Npb24gaXRzZWxmLCBpZiB3ZSBhcmUgYWxsb3dpbmcgY2VsbCB2YWx1ZXMgdG8gYmUgZXhwcmVzc2lvbnNcbiAgICAgICAgaWYgKHRoaXMuY2VsbEV4cHJlc3Npb25zICYmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykgJiYgcmVzdWx0LmluZGV4T2YoJz0nKSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGNlbGxWYWx1ZUdldHRlciA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmV4ZWN1dGVWYWx1ZUdldHRlcihjZWxsVmFsdWVHZXR0ZXIsIGRhdGEsIGNvbHVtbiwgcm93Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFZhbHVlU2VydmljZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAocm93Tm9kZSwgY29sS2V5LCBuZXdWYWx1ZSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldFByaW1hcnlDb2x1bW4oY29sS2V5KTtcbiAgICAgICAgaWYgKCFyb3dOb2RlIHx8ICFjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIHdpbGwgb25seSBoYXBwZW4gaWYgdXNlciBpcyB0cnlpbmcgdG8gcGFzdGUgaW50byBhIGdyb3VwIHJvdywgd2hpY2ggZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgICAgIC8vIHRoZSB1c2VyIHNob3VsZCBub3QgYmUgdHJ5aW5nIHRvIHBhc3RlIGludG8gZ3JvdXAgcm93c1xuICAgICAgICB2YXIgZGF0YSA9IHJvd05vZGUuZGF0YTtcbiAgICAgICAgaWYgKHV0aWxzXzEuXy5taXNzaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICByb3dOb2RlLmRhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2UgYXJlIGFsc28gcmV0cmlldmluZyB0aGUgbmV3VmFsdWVIYW5kbGVyIGFzIHdlbGwgYXMgdGhlIHZhbHVlU2V0dGVyXG4gICAgICAgIHZhciBfYSA9IGNvbHVtbi5nZXRDb2xEZWYoKSwgZmllbGQgPSBfYS5maWVsZCwgbmV3VmFsdWVIYW5kbGVyID0gX2EubmV3VmFsdWVIYW5kbGVyLCB2YWx1ZVNldHRlciA9IF9hLnZhbHVlU2V0dGVyO1xuICAgICAgICAvLyBuZWVkIGVpdGhlciBhIGZpZWxkIG9yIGEgbmV3VmFsdWVIYW5kbGVyIGZvciB0aGlzIHRvIHdvcmtcbiAgICAgICAgaWYgKHV0aWxzXzEuXy5taXNzaW5nKGZpZWxkKSAmJiB1dGlsc18xLl8ubWlzc2luZyhuZXdWYWx1ZUhhbmRsZXIpICYmIHV0aWxzXzEuXy5taXNzaW5nKHZhbHVlU2V0dGVyKSkge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgdGVsbCB1c2VyIGFib3V0IG5ld1ZhbHVlSGFuZGxlciwgYXMgdGhhdCBpcyBkZXByZWNhdGVkXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1HcmlkOiB5b3UgbmVlZCBlaXRoZXIgZmllbGQgb3IgdmFsdWVTZXR0ZXIgc2V0IG9uIGNvbERlZiBmb3IgZWRpdGluZyB0byB3b3JrXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBub2RlOiByb3dOb2RlLFxuICAgICAgICAgICAgZGF0YTogcm93Tm9kZS5kYXRhLFxuICAgICAgICAgICAgb2xkVmFsdWU6IHRoaXMuZ2V0VmFsdWUoY29sdW1uLCByb3dOb2RlKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIGNvbERlZjogY29sdW1uLmdldENvbERlZigpLFxuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb2x1bW5BcGkoKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKVxuICAgICAgICB9O1xuICAgICAgICBwYXJhbXMubmV3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIHZhbHVlV2FzRGlmZmVyZW50O1xuICAgICAgICBpZiAodXRpbHNfMS5fLmV4aXN0cyhuZXdWYWx1ZUhhbmRsZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZVdhc0RpZmZlcmVudCA9IG5ld1ZhbHVlSGFuZGxlcihwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHV0aWxzXzEuXy5leGlzdHModmFsdWVTZXR0ZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZVdhc0RpZmZlcmVudCA9IHRoaXMuZXhwcmVzc2lvblNlcnZpY2UuZXZhbHVhdGUodmFsdWVTZXR0ZXIsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZVdhc0RpZmZlcmVudCA9IHRoaXMuc2V0VmFsdWVVc2luZ0ZpZWxkKGRhdGEsIGZpZWxkLCBuZXdWYWx1ZSwgY29sdW1uLmlzRmllbGRDb250YWluc0RvdHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSB1c2VyIGZvcmdvdCB0byByZXR1cm4gc29tZXRoaW5nIChwb3NzaWJsZSBpZiB0aGV5IGFyZSBub3QgdXNpbmcgVHlwZVNjcmlwdFxuICAgICAgICAvLyBhbmQganVzdCBmb3Jnb3QsIG9yIHVzaW5nIGFuIG9sZCBuZXdWYWx1ZUhhbmRsZXIgd2UgZGlkbid0IGFsd2F5cyBleHBlY3QgYSByZXR1cm5cbiAgICAgICAgLy8gdmFsdWUgaGVyZSksIHdlIGRlZmF1bHQgdGhlIHJldHVybiB2YWx1ZSB0byB0cnVlLCBzbyB3ZSBhbHdheXMgcmVmcmVzaC5cbiAgICAgICAgaWYgKHZhbHVlV2FzRGlmZmVyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlV2FzRGlmZmVyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBubyBjaGFuZ2UgdG8gdGhlIHZhbHVlLCB0aGVuIG5vIG5lZWQgdG8gZG8gdGhlIHVwZGF0aW5nLCBvciBub3RpZnlpbmcgdmlhIGV2ZW50cy5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSB1c2VyIGNvdWxkIGJlIHRhYmJpbmcgYXJvdW5kIHRoZSBncmlkLCBhbmQgY2VsbFZhbHVlQ2hhbmdlIHdvdWxkIGdldCBjYWxsZWRcbiAgICAgICAgLy8gYWxsIHRoZSB0aW1lLlxuICAgICAgICBpZiAoIXZhbHVlV2FzRGlmZmVyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgcXVpY2sgZmlsdGVyIG9uIHRoaXMgcm93XG4gICAgICAgIHJvd05vZGUucmVzZXRRdWlja0ZpbHRlckFnZ3JlZ2F0ZVRleHQoKTtcbiAgICAgICAgdGhpcy52YWx1ZUNhY2hlLm9uRGF0YUNoYW5nZWQoKTtcbiAgICAgICAgcGFyYW1zLm5ld1ZhbHVlID0gdGhpcy5nZXRWYWx1ZShjb2x1bW4sIHJvd05vZGUpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbHVtbi5nZXRDb2xEZWYoKS5vbkNlbGxWYWx1ZUNoYW5nZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbHVtbi5nZXRDb2xEZWYoKS5vbkNlbGxWYWx1ZUNoYW5nZWQocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfQ0VMTF9WQUxVRV9DSEFOR0VELFxuICAgICAgICAgICAgZXZlbnQ6IG51bGwsXG4gICAgICAgICAgICByb3dJbmRleDogcm93Tm9kZS5yb3dJbmRleCxcbiAgICAgICAgICAgIHJvd1Bpbm5lZDogcm93Tm9kZS5yb3dQaW5uZWQsXG4gICAgICAgICAgICBjb2x1bW46IHBhcmFtcy5jb2x1bW4sXG4gICAgICAgICAgICBhcGk6IHBhcmFtcy5hcGksXG4gICAgICAgICAgICBjb2xEZWY6IHBhcmFtcy5jb2xEZWYsXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHBhcmFtcy5jb2x1bW5BcGksXG4gICAgICAgICAgICBjb250ZXh0OiBwYXJhbXMuY29udGV4dCxcbiAgICAgICAgICAgIGRhdGE6IHJvd05vZGUuZGF0YSxcbiAgICAgICAgICAgIG5vZGU6IHJvd05vZGUsXG4gICAgICAgICAgICBvbGRWYWx1ZTogcGFyYW1zLm9sZFZhbHVlLFxuICAgICAgICAgICAgbmV3VmFsdWU6IHBhcmFtcy5uZXdWYWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJhbXMubmV3VmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcbiAgICBWYWx1ZVNlcnZpY2UucHJvdG90eXBlLnNldFZhbHVlVXNpbmdGaWVsZCA9IGZ1bmN0aW9uIChkYXRhLCBmaWVsZCwgbmV3VmFsdWUsIGlzRmllbGRDb250YWluc0RvdHMpIHtcbiAgICAgICAgLy8gaWYgbm8gJy4nLCB0aGVuIGl0J3Mgbm90IGEgZGVlcCB2YWx1ZVxuICAgICAgICB2YXIgdmFsdWVzQXJlU2FtZTtcbiAgICAgICAgaWYgKCFpc0ZpZWxkQ29udGFpbnNEb3RzKSB7XG4gICAgICAgICAgICBkYXRhW2ZpZWxkXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IGlzIGEgZGVlcCB2YWx1ZSwgc28gbmVlZCB0byBkaWcgZm9yIGl0XG4gICAgICAgICAgICB2YXIgZmllbGRQaWVjZXMgPSBmaWVsZC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRPYmplY3QgPSBkYXRhO1xuICAgICAgICAgICAgd2hpbGUgKGZpZWxkUGllY2VzLmxlbmd0aCA+IDAgJiYgY3VycmVudE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZFBpZWNlID0gZmllbGRQaWVjZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRQaWVjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYmplY3RbZmllbGRQaWVjZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYmplY3QgPSBjdXJyZW50T2JqZWN0W2ZpZWxkUGllY2VdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXZhbHVlc0FyZVNhbWU7XG4gICAgfTtcbiAgICBWYWx1ZVNlcnZpY2UucHJvdG90eXBlLmV4ZWN1dGVWYWx1ZUdldHRlciA9IGZ1bmN0aW9uICh2YWx1ZUdldHRlciwgZGF0YSwgY29sdW1uLCByb3dOb2RlKSB7XG4gICAgICAgIHZhciBjb2xJZCA9IGNvbHVtbi5nZXRJZCgpO1xuICAgICAgICAvLyBpZiBpbnNpZGUgdGhlIHNhbWUgdHVybiwganVzdCByZXR1cm4gYmFjayB0aGUgdmFsdWUgd2UgZ290IGxhc3QgdGltZVxuICAgICAgICB2YXIgdmFsdWVGcm9tQ2FjaGUgPSB0aGlzLnZhbHVlQ2FjaGUuZ2V0VmFsdWUocm93Tm9kZSwgY29sSWQpO1xuICAgICAgICBpZiAodmFsdWVGcm9tQ2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlRnJvbUNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbm9kZTogcm93Tm9kZSxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgY29sRGVmOiBjb2x1bW4uZ2V0Q29sRGVmKCksXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb2x1bW5BcGkoKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgIGdldFZhbHVlOiB0aGlzLmdldFZhbHVlQ2FsbGJhY2suYmluZCh0aGlzLCByb3dOb2RlKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5leHByZXNzaW9uU2VydmljZS5ldmFsdWF0ZSh2YWx1ZUdldHRlciwgcGFyYW1zKTtcbiAgICAgICAgLy8gaWYgYSB0dXJuIGlzIGFjdGl2ZSwgc3RvcmUgdGhlIHZhbHVlIGluIGNhc2UgdGhlIGdyaWQgYXNrcyBmb3IgaXQgYWdhaW5cbiAgICAgICAgdGhpcy52YWx1ZUNhY2hlLnNldFZhbHVlKHJvd05vZGUsIGNvbElkLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgVmFsdWVTZXJ2aWNlLnByb3RvdHlwZS5nZXRWYWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKG5vZGUsIGZpZWxkKSB7XG4gICAgICAgIHZhciBvdGhlckNvbHVtbiA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRQcmltYXJ5Q29sdW1uKGZpZWxkKTtcbiAgICAgICAgaWYgKG90aGVyQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZShvdGhlckNvbHVtbiwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIFZhbHVlU2VydmljZS5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V4cHJlc3Npb25TZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBleHByZXNzaW9uU2VydmljZV8xLkV4cHJlc3Npb25TZXJ2aWNlKVxuICAgIF0sIFZhbHVlU2VydmljZS5wcm90b3R5cGUsIFwiZXhwcmVzc2lvblNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgVmFsdWVTZXJ2aWNlLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIFZhbHVlU2VydmljZS5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3ZhbHVlQ2FjaGUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHZhbHVlQ2FjaGVfMS5WYWx1ZUNhY2hlKVxuICAgIF0sIFZhbHVlU2VydmljZS5wcm90b3R5cGUsIFwidmFsdWVDYWNoZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBWYWx1ZVNlcnZpY2UucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgVmFsdWVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCd2YWx1ZVNlcnZpY2UnKVxuICAgIF0sIFZhbHVlU2VydmljZSk7XG4gICAgcmV0dXJuIFZhbHVlU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlZhbHVlU2VydmljZSA9IFZhbHVlU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3ZhbHVlU2VydmljZS92YWx1ZVNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBkcmFnU2VydmljZV8xID0gcmVxdWlyZShcIi4vZHJhZ1NlcnZpY2VcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIERyYWdTb3VyY2VUeXBlO1xuKGZ1bmN0aW9uIChEcmFnU291cmNlVHlwZSkge1xuICAgIERyYWdTb3VyY2VUeXBlW0RyYWdTb3VyY2VUeXBlW1wiVG9vbFBhbmVsXCJdID0gMF0gPSBcIlRvb2xQYW5lbFwiO1xuICAgIERyYWdTb3VyY2VUeXBlW0RyYWdTb3VyY2VUeXBlW1wiSGVhZGVyQ2VsbFwiXSA9IDFdID0gXCJIZWFkZXJDZWxsXCI7XG59KShEcmFnU291cmNlVHlwZSA9IGV4cG9ydHMuRHJhZ1NvdXJjZVR5cGUgfHwgKGV4cG9ydHMuRHJhZ1NvdXJjZVR5cGUgPSB7fSkpO1xudmFyIFZEaXJlY3Rpb247XG4oZnVuY3Rpb24gKFZEaXJlY3Rpb24pIHtcbiAgICBWRGlyZWN0aW9uW1ZEaXJlY3Rpb25bXCJVcFwiXSA9IDBdID0gXCJVcFwiO1xuICAgIFZEaXJlY3Rpb25bVkRpcmVjdGlvbltcIkRvd25cIl0gPSAxXSA9IFwiRG93blwiO1xufSkoVkRpcmVjdGlvbiA9IGV4cG9ydHMuVkRpcmVjdGlvbiB8fCAoZXhwb3J0cy5WRGlyZWN0aW9uID0ge30pKTtcbnZhciBIRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChIRGlyZWN0aW9uKSB7XG4gICAgSERpcmVjdGlvbltIRGlyZWN0aW9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XG4gICAgSERpcmVjdGlvbltIRGlyZWN0aW9uW1wiUmlnaHRcIl0gPSAxXSA9IFwiUmlnaHRcIjtcbn0pKEhEaXJlY3Rpb24gPSBleHBvcnRzLkhEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSERpcmVjdGlvbiA9IHt9KSk7XG52YXIgRHJhZ0FuZERyb3BTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcmFnQW5kRHJvcFNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZUFuZFBhcmFtc0xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5kcm9wVGFyZ2V0cyA9IFtdO1xuICAgIH1cbiAgICBEcmFnQW5kRHJvcFNlcnZpY2VfMSA9IERyYWdBbmREcm9wU2VydmljZTtcbiAgICBEcmFnQW5kRHJvcFNlcnZpY2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZVBpbm5lZEljb24gPSB1dGlsc18xLlV0aWxzLmNyZWF0ZUljb24oJ2NvbHVtbk1vdmVQaW4nLCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgbnVsbCk7XG4gICAgICAgIHRoaXMuZVBsdXNJY29uID0gdXRpbHNfMS5VdGlscy5jcmVhdGVJY29uKCdjb2x1bW5Nb3ZlQWRkJywgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIG51bGwpO1xuICAgICAgICB0aGlzLmVIaWRkZW5JY29uID0gdXRpbHNfMS5VdGlscy5jcmVhdGVJY29uKCdjb2x1bW5Nb3ZlSGlkZScsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBudWxsKTtcbiAgICAgICAgdGhpcy5lTW92ZUljb24gPSB1dGlsc18xLlV0aWxzLmNyZWF0ZUljb24oJ2NvbHVtbk1vdmVNb3ZlJywgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIG51bGwpO1xuICAgICAgICB0aGlzLmVMZWZ0SWNvbiA9IHV0aWxzXzEuVXRpbHMuY3JlYXRlSWNvbignY29sdW1uTW92ZUxlZnQnLCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgbnVsbCk7XG4gICAgICAgIHRoaXMuZVJpZ2h0SWNvbiA9IHV0aWxzXzEuVXRpbHMuY3JlYXRlSWNvbignY29sdW1uTW92ZVJpZ2h0JywgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIG51bGwpO1xuICAgICAgICB0aGlzLmVHcm91cEljb24gPSB1dGlsc18xLlV0aWxzLmNyZWF0ZUljb24oJ2NvbHVtbk1vdmVHcm91cCcsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBudWxsKTtcbiAgICAgICAgdGhpcy5lQWdncmVnYXRlSWNvbiA9IHV0aWxzXzEuVXRpbHMuY3JlYXRlSWNvbignY29sdW1uTW92ZVZhbHVlJywgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIG51bGwpO1xuICAgICAgICB0aGlzLmVQaXZvdEljb24gPSB1dGlsc18xLlV0aWxzLmNyZWF0ZUljb24oJ2NvbHVtbk1vdmVQaXZvdCcsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBudWxsKTtcbiAgICAgICAgdGhpcy5lRHJvcE5vdEFsbG93ZWRJY29uID0gdXRpbHNfMS5VdGlscy5jcmVhdGVJY29uKCdkcm9wTm90QWxsb3dlZCcsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBudWxsKTtcbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUuc2V0QmVhbnMgPSBmdW5jdGlvbiAobG9nZ2VyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlckZhY3RvcnkuY3JlYXRlKCdPbGRUb29sUGFuZWxEcmFnQW5kRHJvcFNlcnZpY2UnKTtcbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUuYWRkRHJhZ1NvdXJjZSA9IGZ1bmN0aW9uIChkcmFnU291cmNlLCBhbGxvd1RvdWNoKSB7XG4gICAgICAgIGlmIChhbGxvd1RvdWNoID09PSB2b2lkIDApIHsgYWxsb3dUb3VjaCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBlRWxlbWVudDogZHJhZ1NvdXJjZS5lRWxlbWVudCxcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQodGhpcywgZHJhZ1NvdXJjZSksXG4gICAgICAgICAgICBvbkRyYWdTdG9wOiB0aGlzLm9uRHJhZ1N0b3AuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uRHJhZ2dpbmc6IHRoaXMub25EcmFnZ2luZy5iaW5kKHRoaXMpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZUFuZFBhcmFtc0xpc3QucHVzaCh7IHBhcmFtczogcGFyYW1zLCBkcmFnU291cmNlOiBkcmFnU291cmNlIH0pO1xuICAgICAgICB0aGlzLmRyYWdTZXJ2aWNlLmFkZERyYWdTb3VyY2UocGFyYW1zLCBhbGxvd1RvdWNoKTtcbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUucmVtb3ZlRHJhZ1NvdXJjZSA9IGZ1bmN0aW9uIChkcmFnU291cmNlKSB7XG4gICAgICAgIHZhciBzb3VyY2VBbmRQYXJhbXMgPSB1dGlsc18xLlV0aWxzLmZpbmQodGhpcy5kcmFnU291cmNlQW5kUGFyYW1zTGlzdCwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uZHJhZ1NvdXJjZSA9PT0gZHJhZ1NvdXJjZTsgfSk7XG4gICAgICAgIGlmIChzb3VyY2VBbmRQYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlcnZpY2UucmVtb3ZlRHJhZ1NvdXJjZShzb3VyY2VBbmRQYXJhbXMucGFyYW1zKTtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbUFycmF5KHRoaXMuZHJhZ1NvdXJjZUFuZFBhcmFtc0xpc3QsIHNvdXJjZUFuZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5kcmFnU291cmNlQW5kUGFyYW1zTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VBbmRQYXJhbXMpIHtcbiAgICAgICAgICAgIF90aGlzLmRyYWdTZXJ2aWNlLnJlbW92ZURyYWdTb3VyY2Uoc291cmNlQW5kUGFyYW1zLnBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRyYWdTb3VyY2VBbmRQYXJhbXNMaXN0Lmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBEcmFnQW5kRHJvcFNlcnZpY2UucHJvdG90eXBlLm51ZGdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdnaW5nKHRoaXMuZXZlbnRMYXN0VGltZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUub25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZHJhZ1NvdXJjZSwgbW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnU291cmNlID0gZHJhZ1NvdXJjZTtcbiAgICAgICAgdGhpcy5ldmVudExhc3RUaW1lID0gbW91c2VFdmVudDtcbiAgICAgICAgdGhpcy5kcmFnSXRlbSA9IHRoaXMuZHJhZ1NvdXJjZS5kcmFnSXRlbUNhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuZHJhZ0l0ZW0uY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5zZXRNb3ZpbmcodHJ1ZSk7IH0pO1xuICAgICAgICB0aGlzLmxhc3REcm9wVGFyZ2V0ID0gdGhpcy5kcmFnU291cmNlLmRyYWdTb3VyY2VEcm9wVGFyZ2V0O1xuICAgICAgICB0aGlzLmNyZWF0ZUdob3N0KCk7XG4gICAgfTtcbiAgICBEcmFnQW5kRHJvcFNlcnZpY2UucHJvdG90eXBlLm9uRHJhZ1N0b3AgPSBmdW5jdGlvbiAobW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLmV2ZW50TGFzdFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZ0l0ZW0uY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5zZXRNb3ZpbmcoZmFsc2UpOyB9KTtcbiAgICAgICAgaWYgKHRoaXMubGFzdERyb3BUYXJnZXQgJiYgdGhpcy5sYXN0RHJvcFRhcmdldC5vbkRyYWdTdG9wKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmdFdmVudCA9IHRoaXMuY3JlYXRlRHJvcFRhcmdldEV2ZW50KHRoaXMubGFzdERyb3BUYXJnZXQsIG1vdXNlRXZlbnQsIG51bGwsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdERyb3BUYXJnZXQub25EcmFnU3RvcChkcmFnZ2luZ0V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3REcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnSXRlbSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVtb3ZlR2hvc3QoKTtcbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUub25EcmFnZ2luZyA9IGZ1bmN0aW9uIChtb3VzZUV2ZW50LCBmcm9tTnVkZ2UpIHtcbiAgICAgICAgdmFyIGhEaXJlY3Rpb24gPSB0aGlzLndvcmtPdXRIRGlyZWN0aW9uKG1vdXNlRXZlbnQpO1xuICAgICAgICB2YXIgdkRpcmVjdGlvbiA9IHRoaXMud29ya091dFZEaXJlY3Rpb24obW91c2VFdmVudCk7XG4gICAgICAgIHRoaXMuZXZlbnRMYXN0VGltZSA9IG1vdXNlRXZlbnQ7XG4gICAgICAgIHRoaXMucG9zaXRpb25HaG9zdChtb3VzZUV2ZW50KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgbW91c2VFdmVudCBpbnRlcnNlY3RzIHdpdGggYW55IG9mIHRoZSBkcm9wIHRhcmdldHNcbiAgICAgICAgdmFyIGRyb3BUYXJnZXQgPSB1dGlsc18xLlV0aWxzLmZpbmQodGhpcy5kcm9wVGFyZ2V0cywgdGhpcy5pc01vdXNlT25Ecm9wVGFyZ2V0LmJpbmQodGhpcywgbW91c2VFdmVudCkpO1xuICAgICAgICBpZiAoZHJvcFRhcmdldCAhPT0gdGhpcy5sYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5sZWF2ZUxhc3RUYXJnZXRJZkV4aXN0cyhtb3VzZUV2ZW50LCBoRGlyZWN0aW9uLCB2RGlyZWN0aW9uLCBmcm9tTnVkZ2UpO1xuICAgICAgICAgICAgdGhpcy5lbnRlckRyYWdUYXJnZXRJZkV4aXN0cyhkcm9wVGFyZ2V0LCBtb3VzZUV2ZW50LCBoRGlyZWN0aW9uLCB2RGlyZWN0aW9uLCBmcm9tTnVkZ2UpO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJvcFRhcmdldCA9IGRyb3BUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nRXZlbnQgPSB0aGlzLmNyZWF0ZURyb3BUYXJnZXRFdmVudChkcm9wVGFyZ2V0LCBtb3VzZUV2ZW50LCBoRGlyZWN0aW9uLCB2RGlyZWN0aW9uLCBmcm9tTnVkZ2UpO1xuICAgICAgICAgICAgZHJvcFRhcmdldC5vbkRyYWdnaW5nKGRyYWdnaW5nRXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcmFnQW5kRHJvcFNlcnZpY2UucHJvdG90eXBlLmVudGVyRHJhZ1RhcmdldElmRXhpc3RzID0gZnVuY3Rpb24gKGRyb3BUYXJnZXQsIG1vdXNlRXZlbnQsIGhEaXJlY3Rpb24sIHZEaXJlY3Rpb24sIGZyb21OdWRnZSkge1xuICAgICAgICBpZiAoIWRyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhZ0VudGVyRXZlbnQgPSB0aGlzLmNyZWF0ZURyb3BUYXJnZXRFdmVudChkcm9wVGFyZ2V0LCBtb3VzZUV2ZW50LCBoRGlyZWN0aW9uLCB2RGlyZWN0aW9uLCBmcm9tTnVkZ2UpO1xuICAgICAgICBkcm9wVGFyZ2V0Lm9uRHJhZ0VudGVyKGRyYWdFbnRlckV2ZW50KTtcbiAgICAgICAgdGhpcy5zZXRHaG9zdEljb24oZHJvcFRhcmdldC5nZXRJY29uTmFtZSA/IGRyb3BUYXJnZXQuZ2V0SWNvbk5hbWUoKSA6IG51bGwpO1xuICAgIH07XG4gICAgRHJhZ0FuZERyb3BTZXJ2aWNlLnByb3RvdHlwZS5sZWF2ZUxhc3RUYXJnZXRJZkV4aXN0cyA9IGZ1bmN0aW9uIChtb3VzZUV2ZW50LCBoRGlyZWN0aW9uLCB2RGlyZWN0aW9uLCBmcm9tTnVkZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYWdMZWF2ZUV2ZW50ID0gdGhpcy5jcmVhdGVEcm9wVGFyZ2V0RXZlbnQodGhpcy5sYXN0RHJvcFRhcmdldCwgbW91c2VFdmVudCwgaERpcmVjdGlvbiwgdkRpcmVjdGlvbiwgZnJvbU51ZGdlKTtcbiAgICAgICAgdGhpcy5sYXN0RHJvcFRhcmdldC5vbkRyYWdMZWF2ZShkcmFnTGVhdmVFdmVudCk7XG4gICAgICAgIHRoaXMuc2V0R2hvc3RJY29uKG51bGwpO1xuICAgIH07XG4gICAgRHJhZ0FuZERyb3BTZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxDb250YWluZXJzRnJvbURyb3BUYXJnZXQgPSBmdW5jdGlvbiAoZHJvcFRhcmdldCkge1xuICAgICAgICB2YXIgY29udGFpbmVycyA9IFtkcm9wVGFyZ2V0LmdldENvbnRhaW5lcigpXTtcbiAgICAgICAgdmFyIHNlY29uZGFyeUNvbnRhaW5lcnMgPSBkcm9wVGFyZ2V0LmdldFNlY29uZGFyeUNvbnRhaW5lcnMgPyBkcm9wVGFyZ2V0LmdldFNlY29uZGFyeUNvbnRhaW5lcnMoKSA6IG51bGw7XG4gICAgICAgIGlmIChzZWNvbmRhcnlDb250YWluZXJzKSB7XG4gICAgICAgICAgICBjb250YWluZXJzID0gY29udGFpbmVycy5jb25jYXQoc2Vjb25kYXJ5Q29udGFpbmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcnM7XG4gICAgfTtcbiAgICAvLyBjaGVja3MgaWYgdGhlIG1vdXNlIGlzIG9uIHRoZSBkcm9wIHRhcmdldC4gaXQgY2hlY2tzIGVDb250YWluZXIgYW5kIGVTZWNvbmRhcnlDb250YWluZXJzXG4gICAgRHJhZ0FuZERyb3BTZXJ2aWNlLnByb3RvdHlwZS5pc01vdXNlT25Ecm9wVGFyZ2V0ID0gZnVuY3Rpb24gKG1vdXNlRXZlbnQsIGRyb3BUYXJnZXQpIHtcbiAgICAgICAgdmFyIGFsbENvbnRhaW5lcnMgPSB0aGlzLmdldEFsbENvbnRhaW5lcnNGcm9tRHJvcFRhcmdldChkcm9wVGFyZ2V0KTtcbiAgICAgICAgdmFyIGdvdE1hdGNoID0gZmFsc2U7XG4gICAgICAgIGFsbENvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKCFlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSAvLyBzZWNvbmRhcnkgY2FuIGJlIG1pc3NpbmdcbiAgICAgICAgICAgIHZhciByZWN0ID0gZUNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIC8vIGlmIGVsZW1lbnQgaXMgbm90IHZpc2libGUsIHRoZW4gd2lkdGggYW5kIGhlaWdodCBhcmUgemVyb1xuICAgICAgICAgICAgaWYgKHJlY3Qud2lkdGggPT09IDAgfHwgcmVjdC5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbEZpdCA9IG1vdXNlRXZlbnQuY2xpZW50WCA+PSByZWN0LmxlZnQgJiYgbW91c2VFdmVudC5jbGllbnRYIDw9IHJlY3QucmlnaHQ7XG4gICAgICAgICAgICB2YXIgdmVydGljYWxGaXQgPSBtb3VzZUV2ZW50LmNsaWVudFkgPj0gcmVjdC50b3AgJiYgbW91c2VFdmVudC5jbGllbnRZIDw9IHJlY3QuYm90dG9tO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhgcmVjdC53aWR0aCA9ICR7cmVjdC53aWR0aH0gfHwgcmVjdC5oZWlnaHQgPSAke3JlY3QuaGVpZ2h0fSAjIyB2ZXJ0aWNhbEZpdCA9ICR7dmVydGljYWxGaXR9LCBob3Jpem9udGFsRml0ID0gJHtob3Jpem9udGFsRml0fSwgYCk7XG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbEZpdCAmJiB2ZXJ0aWNhbEZpdCkge1xuICAgICAgICAgICAgICAgIGdvdE1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnb3RNYXRjaDtcbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUuYWRkRHJvcFRhcmdldCA9IGZ1bmN0aW9uIChkcm9wVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldHMucHVzaChkcm9wVGFyZ2V0KTtcbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUud29ya091dEhEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRMYXN0VGltZS5jbGllbnRYID4gZXZlbnQuY2xpZW50WCkge1xuICAgICAgICAgICAgcmV0dXJuIEhEaXJlY3Rpb24uTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmV2ZW50TGFzdFRpbWUuY2xpZW50WCA8IGV2ZW50LmNsaWVudFgpIHtcbiAgICAgICAgICAgIHJldHVybiBIRGlyZWN0aW9uLlJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUud29ya091dFZEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRMYXN0VGltZS5jbGllbnRZID4gZXZlbnQuY2xpZW50WSkge1xuICAgICAgICAgICAgcmV0dXJuIFZEaXJlY3Rpb24uVXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ldmVudExhc3RUaW1lLmNsaWVudFkgPCBldmVudC5jbGllbnRZKSB7XG4gICAgICAgICAgICByZXR1cm4gVkRpcmVjdGlvbi5Eb3duO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUuY3JlYXRlRHJvcFRhcmdldEV2ZW50ID0gZnVuY3Rpb24gKGRyb3BUYXJnZXQsIGV2ZW50LCBoRGlyZWN0aW9uLCB2RGlyZWN0aW9uLCBmcm9tTnVkZ2UpIHtcbiAgICAgICAgLy8gbG9jYWxpc2UgeCBhbmQgeSB0byB0aGUgdGFyZ2V0IGNvbXBvbmVudFxuICAgICAgICB2YXIgcmVjdCA9IGRyb3BUYXJnZXQuZ2V0Q29udGFpbmVyKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB4ID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgdmFyIHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICAgIHZhciBkcm9wVGFyZ2V0RXZlbnQgPSB7XG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHZEaXJlY3Rpb246IHZEaXJlY3Rpb24sXG4gICAgICAgICAgICBoRGlyZWN0aW9uOiBoRGlyZWN0aW9uLFxuICAgICAgICAgICAgZHJhZ1NvdXJjZTogdGhpcy5kcmFnU291cmNlLFxuICAgICAgICAgICAgZnJvbU51ZGdlOiBmcm9tTnVkZ2UsXG4gICAgICAgICAgICBkcmFnSXRlbTogdGhpcy5kcmFnSXRlbVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZHJvcFRhcmdldEV2ZW50O1xuICAgIH07XG4gICAgRHJhZ0FuZERyb3BTZXJ2aWNlLnByb3RvdHlwZS5wb3NpdGlvbkdob3N0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBnaG9zdFJlY3QgPSB0aGlzLmVHaG9zdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGdob3N0SGVpZ2h0ID0gZ2hvc3RSZWN0LmhlaWdodDtcbiAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uLCB3aXRob3V0IHRoZSAnLTInLCBpdCBzdGlsbCBvdmVybGFwcGVkIGJ5IDEgb3IgMiBwaXhlbHMsIHdoaWNoXG4gICAgICAgIC8vIHRoZW4gYnJvdWdodCBpbiBzY3JvbGxiYXJzIHRvIHRoZSBicm93c2VyLiBubyBpZGVhIHdoeSwgYnV0IHB1dHRpbmcgaW4gLTIgaGVyZVxuICAgICAgICAvLyB3b3JrcyBhcm91bmQgaXQgd2hpY2ggaXMgZ29vZCBlbm91Z2ggZm9yIG1lLlxuICAgICAgICB2YXIgYnJvd3NlcldpZHRoID0gdXRpbHNfMS5VdGlscy5nZXRCb2R5V2lkdGgoKSAtIDI7XG4gICAgICAgIHZhciBicm93c2VySGVpZ2h0ID0gdXRpbHNfMS5VdGlscy5nZXRCb2R5SGVpZ2h0KCkgLSAyO1xuICAgICAgICAvLyBwdXQgZ2hvc3QgdmVydGljYWxseSBpbiBtaWRkbGUgb2YgY3Vyc29yXG4gICAgICAgIHZhciB0b3AgPSBldmVudC5wYWdlWSAtIChnaG9zdEhlaWdodCAvIDIpO1xuICAgICAgICAvLyBob3Jpem9udGFsbHksIHBsYWNlIGN1cnNvciBqdXN0IHJpZ2h0IG9mIGljb25cbiAgICAgICAgdmFyIGxlZnQgPSBldmVudC5wYWdlWCAtIDMwO1xuICAgICAgICB2YXIgdXNyRG9jdW1lbnQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXREb2N1bWVudCgpO1xuICAgICAgICB2YXIgd2luZG93U2Nyb2xsWSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCB1c3JEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgd2luZG93U2Nyb2xsWCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCB1c3JEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgLy8gY2hlY2sgZ2hvc3QgaXMgbm90IHBvc2l0aW9uZWQgb3V0c2lkZSBvZiB0aGUgYnJvd3NlclxuICAgICAgICBpZiAoYnJvd3NlcldpZHRoID4gMCkge1xuICAgICAgICAgICAgaWYgKChsZWZ0ICsgdGhpcy5lR2hvc3QuY2xpZW50V2lkdGgpID4gKGJyb3dzZXJXaWR0aCArIHdpbmRvd1Njcm9sbFgpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGJyb3dzZXJXaWR0aCArIHdpbmRvd1Njcm9sbFggLSB0aGlzLmVHaG9zdC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChicm93c2VySGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgaWYgKCh0b3AgKyB0aGlzLmVHaG9zdC5jbGllbnRIZWlnaHQpID4gKGJyb3dzZXJIZWlnaHQgKyB3aW5kb3dTY3JvbGxZKSkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGJyb3dzZXJIZWlnaHQgKyB3aW5kb3dTY3JvbGxZIC0gdGhpcy5lR2hvc3QuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgICB0b3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZUdob3N0LnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5lR2hvc3Quc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUucmVtb3ZlR2hvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVHaG9zdCAmJiB0aGlzLmVHaG9zdFBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5lR2hvc3RQYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5lR2hvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZUdob3N0ID0gbnVsbDtcbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUuY3JlYXRlR2hvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZUdob3N0ID0gdXRpbHNfMS5VdGlscy5sb2FkVGVtcGxhdGUoRHJhZ0FuZERyb3BTZXJ2aWNlXzEuR0hPU1RfVEVNUExBVEUpO1xuICAgICAgICB0aGlzLmVHaG9zdC5jbGFzc0xpc3QuYWRkKHRoaXMuZW52aXJvbm1lbnQuZ2V0VGhlbWUoKSk7XG4gICAgICAgIHRoaXMuZUdob3N0SWNvbiA9IHRoaXMuZUdob3N0LnF1ZXJ5U2VsZWN0b3IoJy5hZy1kbmQtZ2hvc3QtaWNvbicpO1xuICAgICAgICB0aGlzLnNldEdob3N0SWNvbihudWxsKTtcbiAgICAgICAgdmFyIGVUZXh0ID0gdGhpcy5lR2hvc3QucXVlcnlTZWxlY3RvcignLmFnLWRuZC1naG9zdC1sYWJlbCcpO1xuICAgICAgICBlVGV4dC5pbm5lckhUTUwgPSB0aGlzLmRyYWdTb3VyY2UuZHJhZ0l0ZW1OYW1lO1xuICAgICAgICB0aGlzLmVHaG9zdC5zdHlsZS5oZWlnaHQgPSAnMjVweCc7XG4gICAgICAgIHRoaXMuZUdob3N0LnN0eWxlLnRvcCA9ICcyMHB4JztcbiAgICAgICAgdGhpcy5lR2hvc3Quc3R5bGUubGVmdCA9ICcyMHB4JztcbiAgICAgICAgdmFyIHVzckRvY3VtZW50ID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgdGhpcy5lR2hvc3RQYXJlbnQgPSB1c3JEb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gICAgICAgIGlmICghdGhpcy5lR2hvc3RQYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogY291bGQgbm90IGZpbmQgZG9jdW1lbnQgYm9keSwgaXQgaXMgbmVlZGVkIGZvciBkcmFnZ2luZyBjb2x1bW5zJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVHaG9zdFBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmVHaG9zdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUuc2V0R2hvc3RJY29uID0gZnVuY3Rpb24gKGljb25OYW1lLCBzaGFrZSkge1xuICAgICAgICBpZiAoc2hha2UgPT09IHZvaWQgMCkgeyBzaGFrZSA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5lR2hvc3RJY29uKTtcbiAgICAgICAgdmFyIGVJY29uO1xuICAgICAgICBzd2l0Y2ggKGljb25OYW1lKSB7XG4gICAgICAgICAgICBjYXNlIERyYWdBbmREcm9wU2VydmljZV8xLklDT05fQUREOlxuICAgICAgICAgICAgICAgIGVJY29uID0gdGhpcy5lUGx1c0ljb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERyYWdBbmREcm9wU2VydmljZV8xLklDT05fUElOTkVEOlxuICAgICAgICAgICAgICAgIGVJY29uID0gdGhpcy5lUGlubmVkSWNvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRHJhZ0FuZERyb3BTZXJ2aWNlXzEuSUNPTl9NT1ZFOlxuICAgICAgICAgICAgICAgIGVJY29uID0gdGhpcy5lTW92ZUljb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERyYWdBbmREcm9wU2VydmljZV8xLklDT05fTEVGVDpcbiAgICAgICAgICAgICAgICBlSWNvbiA9IHRoaXMuZUxlZnRJY29uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEcmFnQW5kRHJvcFNlcnZpY2VfMS5JQ09OX1JJR0hUOlxuICAgICAgICAgICAgICAgIGVJY29uID0gdGhpcy5lUmlnaHRJY29uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEcmFnQW5kRHJvcFNlcnZpY2VfMS5JQ09OX0dST1VQOlxuICAgICAgICAgICAgICAgIGVJY29uID0gdGhpcy5lR3JvdXBJY29uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEcmFnQW5kRHJvcFNlcnZpY2VfMS5JQ09OX0FHR1JFR0FURTpcbiAgICAgICAgICAgICAgICBlSWNvbiA9IHRoaXMuZUFnZ3JlZ2F0ZUljb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERyYWdBbmREcm9wU2VydmljZV8xLklDT05fUElWT1Q6XG4gICAgICAgICAgICAgICAgZUljb24gPSB0aGlzLmVQaXZvdEljb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERyYWdBbmREcm9wU2VydmljZV8xLklDT05fTk9UX0FMTE9XRUQ6XG4gICAgICAgICAgICAgICAgZUljb24gPSB0aGlzLmVEcm9wTm90QWxsb3dlZEljb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGVJY29uID0gdGhpcy5lSGlkZGVuSWNvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVHaG9zdEljb24uYXBwZW5kQ2hpbGQoZUljb24pO1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5lR2hvc3RJY29uLCAnYWctc2hha2UtbGVmdC10by1yaWdodCcsIHNoYWtlKTtcbiAgICB9O1xuICAgIERyYWdBbmREcm9wU2VydmljZS5JQ09OX1BJTk5FRCA9ICdwaW5uZWQnO1xuICAgIERyYWdBbmREcm9wU2VydmljZS5JQ09OX0FERCA9ICdhZGQnO1xuICAgIERyYWdBbmREcm9wU2VydmljZS5JQ09OX01PVkUgPSAnbW92ZSc7XG4gICAgRHJhZ0FuZERyb3BTZXJ2aWNlLklDT05fTEVGVCA9ICdsZWZ0JztcbiAgICBEcmFnQW5kRHJvcFNlcnZpY2UuSUNPTl9SSUdIVCA9ICdyaWdodCc7XG4gICAgRHJhZ0FuZERyb3BTZXJ2aWNlLklDT05fR1JPVVAgPSAnZ3JvdXAnO1xuICAgIERyYWdBbmREcm9wU2VydmljZS5JQ09OX0FHR1JFR0FURSA9ICdhZ2dyZWdhdGUnO1xuICAgIERyYWdBbmREcm9wU2VydmljZS5JQ09OX1BJVk9UID0gJ3Bpdm90JztcbiAgICBEcmFnQW5kRHJvcFNlcnZpY2UuSUNPTl9OT1RfQUxMT1dFRCA9ICdub3RBbGxvd2VkJztcbiAgICBEcmFnQW5kRHJvcFNlcnZpY2UuR0hPU1RfVEVNUExBVEUgPSAnPGRpdiBjbGFzcz1cImFnLWRuZC1naG9zdFwiPicgK1xuICAgICAgICAnICA8c3BhbiBjbGFzcz1cImFnLWRuZC1naG9zdC1pY29uIGFnLXNoYWtlLWxlZnQtdG8tcmlnaHRcIj48L3NwYW4+JyArXG4gICAgICAgICcgIDxkaXYgY2xhc3M9XCJhZy1kbmQtZ2hvc3QtbGFiZWxcIj4nICtcbiAgICAgICAgJyAgPC9kaXY+JyArXG4gICAgICAgICc8L2Rpdj4nO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBEcmFnQW5kRHJvcFNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdkcmFnU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZHJhZ1NlcnZpY2VfMS5EcmFnU2VydmljZSlcbiAgICBdLCBEcmFnQW5kRHJvcFNlcnZpY2UucHJvdG90eXBlLCBcImRyYWdTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2Vudmlyb25tZW50JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50KVxuICAgIF0sIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUsIFwiZW52aXJvbm1lbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgRHJhZ0FuZERyb3BTZXJ2aWNlLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIERyYWdBbmREcm9wU2VydmljZS5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgX19wYXJhbSgwLCBjb250ZXh0XzEuUXVhbGlmaWVyKCdsb2dnZXJGYWN0b3J5JykpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2xvZ2dlcl8xLkxvZ2dlckZhY3RvcnldKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBEcmFnQW5kRHJvcFNlcnZpY2UucHJvdG90eXBlLCBcInNldEJlYW5zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUHJlRGVzdHJveSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBEcmFnQW5kRHJvcFNlcnZpY2UucHJvdG90eXBlLCBcImRlc3Ryb3lcIiwgbnVsbCk7XG4gICAgRHJhZ0FuZERyb3BTZXJ2aWNlID0gRHJhZ0FuZERyb3BTZXJ2aWNlXzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2RyYWdBbmREcm9wU2VydmljZScpXG4gICAgXSwgRHJhZ0FuZERyb3BTZXJ2aWNlKTtcbiAgICByZXR1cm4gRHJhZ0FuZERyb3BTZXJ2aWNlO1xuICAgIHZhciBEcmFnQW5kRHJvcFNlcnZpY2VfMTtcbn0oKSk7XG5leHBvcnRzLkRyYWdBbmREcm9wU2VydmljZSA9IERyYWdBbmREcm9wU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2RyYWdBbmREcm9wL2RyYWdBbmREcm9wU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIG5hbWVkQ29tcG9uZW50UmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL25hbWVkQ29tcG9uZW50UmVzb2x2ZXJcIik7XG52YXIgYWdDb21wb25lbnRVdGlsc18xID0gcmVxdWlyZShcIi4vYWdDb21wb25lbnRVdGlsc1wiKTtcbnZhciBjb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXCIpO1xudmFyIENvbXBvbmVudFR5cGU7XG4oZnVuY3Rpb24gKENvbXBvbmVudFR5cGUpIHtcbiAgICBDb21wb25lbnRUeXBlW0NvbXBvbmVudFR5cGVbXCJBR19HUklEXCJdID0gMF0gPSBcIkFHX0dSSURcIjtcbiAgICBDb21wb25lbnRUeXBlW0NvbXBvbmVudFR5cGVbXCJGUkFNRVdPUktcIl0gPSAxXSA9IFwiRlJBTUVXT1JLXCI7XG59KShDb21wb25lbnRUeXBlID0gZXhwb3J0cy5Db21wb25lbnRUeXBlIHx8IChleHBvcnRzLkNvbXBvbmVudFR5cGUgPSB7fSkpO1xudmFyIENvbXBvbmVudFNvdXJjZTtcbihmdW5jdGlvbiAoQ29tcG9uZW50U291cmNlKSB7XG4gICAgQ29tcG9uZW50U291cmNlW0NvbXBvbmVudFNvdXJjZVtcIkRFRkFVTFRcIl0gPSAwXSA9IFwiREVGQVVMVFwiO1xuICAgIENvbXBvbmVudFNvdXJjZVtDb21wb25lbnRTb3VyY2VbXCJSRUdJU1RFUkVEX0JZX05BTUVcIl0gPSAxXSA9IFwiUkVHSVNURVJFRF9CWV9OQU1FXCI7XG4gICAgQ29tcG9uZW50U291cmNlW0NvbXBvbmVudFNvdXJjZVtcIkhBUkRDT0RFRFwiXSA9IDJdID0gXCJIQVJEQ09ERURcIjtcbn0pKENvbXBvbmVudFNvdXJjZSA9IGV4cG9ydHMuQ29tcG9uZW50U291cmNlIHx8IChleHBvcnRzLkNvbXBvbmVudFNvdXJjZSA9IHt9KSk7XG52YXIgQ29tcG9uZW50UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlc29sdmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wb25lbnQgdG8gYmUgY3JlYXRlZC4gaWUgZm9yIEphdmFzY3JpcHQgdGhlXG4gICAgICogdW5kZXJseWluZyBmdW5jdGlvbiB3aGVyZSB3ZSBzaG91bGQgYmUgY2FsbGluZyBuZXcgaW50by4gSW4gY2FzZSBvZiB0aGUgZnJhbWV3b3JrcywgdGhlIGZyYW1ld29yayBjbGFzc1xuICAgICAqIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbXBvbmVudCB0byBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaGFuZHkgZm9yIGRpZmZlcmVudCByZWFzb25zLCBmb3IgZXhhbXBsZSBpZiB5b3Ugd2FudCB0byBjaGVjayBpZiBhIGNvbXBvbmVudCBoYXMgYSBwYXJ0aWN1bGFyXG4gICAgICogbWV0aG9kIGltcGxlbWVudGVkIHdpdGhvdXQgaGF2aW5nIHRvIGNyZWF0ZSB0aGUgY29tcG9uZW50LCBqdXN0IGJ5IGluc3BlY3RpbmcgdGhlIHNvdXJjZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIEl0IHRha2VzXG4gICAgICogIEBwYXJhbSBob2xkZXI6IFRoaXMgaXMgdGhlIGNvbnRleHQgZm9yIHdoaWNoIHRoaXMgY29tcG9uZW50IG5lZWRzIHRvIGJlIGNyZWF0ZWQsIGl0IGNhbiBiZSBncmlkT3B0aW9uc1xuICAgICAqICAgICAgKGdsb2JhbCkgb3IgY29sdW1uRGVmIG1vc3RseS5cbiAgICAgKiAgQHBhcmFtIHByb3BlcnR5TmFtZTogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHVzZWQgaW4gYWctZ3JpZCBhcyBhIGNvbnZlbnRpb24gdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudCwgaXQgY2FuIGJlOlxuICAgICAqICAgICAgJ2Zsb2F0aW5nRmlsdGVyJywgJ2NlbGxSZW5kZXJlcicsIGlzIHVzZWQgdG8gZmluZCBpZiB0aGUgdXNlciBpcyBzcGVjaWZ5aW5nIGEgY3VzdG9tIGNvbXBvbmVudFxuICAgICAqICBAcGFyYW0gY29tcG9uZW50TmFtZU9wdDogVGhlIGFjdHVhbCBuYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gaW5zdGFudGlhdGUsIHRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSBhcyBwcm9wZXJ0eU5hbWUsIGJ1dCBpblxuICAgICAqICAgICAgc29tZSBjYXNlcyBpcyBub3QsIGxpa2UgZmxvYXRpbmdGaWx0ZXIsIGlmIGl0IGlzIHRoZSBzYW1lIGlzIG5vdCBuZWNlc3NhcnkgdG8gc3BlY2lmeVxuICAgICAqICBAcGFyYW0gbWFuZGF0b3J5OiBIYW5keSBtZXRob2QgdG8gdGVsbCBpZiB0aGlzIHNob3VsZCByZXR1cm4gYSBjb21wb25lbnQgQUxXQVlTLiBpZiB0aGF0IGlzIHRoZSBjYXNlLCBidXQgdGhlcmUgaXMgbm9cbiAgICAgKiAgICAgIGNvbXBvbmVudCBmb3VuZCwgaXQgdGhyb3dzIGFuIGVycm9yLCBieSBkZWZhdWx0IGFsbCBjb21wb25lbnRzIGFyZSBNQU5EQVRPUllcbiAgICAgKi9cbiAgICBDb21wb25lbnRSZXNvbHZlci5wcm90b3R5cGUuZ2V0Q29tcG9uZW50VG9Vc2UgPSBmdW5jdGlvbiAoaG9sZGVyLCBwcm9wZXJ0eU5hbWUsIGNvbXBvbmVudE5hbWVPcHQpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lT3B0ID09IG51bGwgPyBwcm9wZXJ0eU5hbWUgOiBjb21wb25lbnROYW1lT3B0O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlcmUgYXJlIGZpdmUgdGhpbmdzIHRoYXQgY2FuIGhhcHBlbiB3aGVuIHJlc29sdmluZyBhIGNvbXBvbmVudC5cbiAgICAgICAgICogIGEpIEhhcmRjb2RlZEZ3Q29tcG9uZW50OiBUaGF0IGhvbGRlcltwcm9wZXJ0eU5hbWVdRnJhbWV3b3JrIGhhcyBhc3NvY2lhdGVkIGEgRnJhbWV3b3JrIG5hdGl2ZSBjb21wb25lbnRcbiAgICAgICAgICogIGIpIEhhcmRjb2RlZEpzQ29tcG9uZW50OiBUaGF0IGhvbGRlcltwcm9wZXJ0eU5hbWVdIGhhcyBhc3NvY2lhdGUgYSBKUyBjb21wb25lbnRcbiAgICAgICAgICogIGMpIGhhcmRjb2RlZEpzRnVuY3Rpb246IFRoYXQgaG9sZGVyW3Byb3BlcnR5TmFtZV0gaGFzIGFzc29jaWF0ZSBhIEpTIGZ1bmN0aW9uXG4gICAgICAgICAqICBkKSBoYXJkY29kZWROYW1lQ29tcG9uZW50OiBUaGF0IGhvbGRlcltwcm9wZXJ0eU5hbWVdIGhhcyBhc3NvY2lhdGUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgY29tcG9uZW50IHRvIGxvYWRcbiAgICAgICAgICogIGUpIFRoYXQgbm9uZSBvZiB0aGUgdGhyZWUgcHJldmlvdXMgYXJlIHNwZWNpZmllZCwgdGhlbiB3ZSBuZWVkIHRvIHVzZSB0aGUgRGVmYXVsdFJlZ2lzdGVyZWRDb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBoYXJkY29kZWROYW1lQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgdmFyIEhhcmRjb2RlZEpzQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgdmFyIGhhcmRjb2RlZEpzRnVuY3Rpb24gPSBudWxsO1xuICAgICAgICB2YXIgSGFyZGNvZGVkRndDb21wb25lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaG9sZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRQcm9wZXJ0eVZhbHVlID0gaG9sZGVyW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50UHJvcGVydHlWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRQcm9wZXJ0eVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBoYXJkY29kZWROYW1lQ29tcG9uZW50ID0gY29tcG9uZW50UHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZ0NvbXBvbmVudFV0aWxzLmRvZXNJbXBsZW1lbnRJQ29tcG9uZW50KGNvbXBvbmVudFByb3BlcnR5VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIEhhcmRjb2RlZEpzQ29tcG9uZW50ID0gY29tcG9uZW50UHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhcmRjb2RlZEpzRnVuY3Rpb24gPSBjb21wb25lbnRQcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhhcmRjb2RlZEZ3Q29tcG9uZW50ID0gaG9sZGVyW3Byb3BlcnR5TmFtZSArIFwiRnJhbWV3b3JrXCJdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaW5jZSB3ZSBhbGxvdyBtYW55IHR5cGVzIG9mIGZsYXZvcnMgZm9yIHNwZWNpZnlpbmcgdGhlIGNvbXBvbmVudHMsIGxldCdzIG1ha2Ugc3VyZSB0aGlzIGlzIG5vdCBhbiBpbGxlZ2FsXG4gICAgICAgICAqIGNvbWJpbmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoKEhhcmRjb2RlZEpzQ29tcG9uZW50ICYmIEhhcmRjb2RlZEZ3Q29tcG9uZW50KSB8fFxuICAgICAgICAgICAgKGhhcmRjb2RlZE5hbWVDb21wb25lbnQgJiYgSGFyZGNvZGVkRndDb21wb25lbnQpIHx8XG4gICAgICAgICAgICAoaGFyZGNvZGVkSnNGdW5jdGlvbiAmJiBIYXJkY29kZWRGd0NvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiWW91IGFyZSB0cnlpbmcgdG8gc3BlY2lmeTogXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIiB0d2ljZSBhcyBhIGNvbXBvbmVudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhhcmRjb2RlZEZ3Q29tcG9uZW50ICYmICF0aGlzLmZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiWW91IGFyZSBzcGVjaWZ5aW5nIGEgZnJhbWV3b3JrIGNvbXBvbmVudCBidXQgeW91IGFyZSBub3QgdXNpbmcgYSBmcmFtZXdvcmsgdmVyc2lvbiBvZiBhZy1ncmlkIGZvciA6IFwiICsgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXQgdGhpcyBzdGFnZSB3ZSBhcmUgZ3VhcmFudGVlZCB0byBlaXRoZXIgaGF2ZSxcbiAgICAgICAgICogREVQUkVDQVRFRFxuICAgICAgICAgKiAtIEEgdW5pcXVlIEhhcmRjb2RlZEZ3Q29tcG9uZW50XG4gICAgICAgICAqIC0gQSB1bmlxdWUgSGFyZGNvZGVkSnNDb21wb25lbnRcbiAgICAgICAgICogLSBBIHVuaXF1ZSBoYXJkY29kZWRKc0Z1bmN0aW9uXG4gICAgICAgICAqIEJZIE5BTUUtIEZBVk9VUkVEIEFQUFJPQUNIXG4gICAgICAgICAqIC0gQSB1bmlxdWUgaGFyZGNvZGVkTmFtZUNvbXBvbmVudFxuICAgICAgICAgKiAtIE5vbmUgb2YgdGhlIHByZXZpb3VzLCBoZW5jZSB3ZSByZXZlcnQgdG86IFJlZ2lzdGVyZWRDb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChIYXJkY29kZWRGd0NvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGBhZy1ncmlkOiBTaW5jZSB2ZXJzaW9uIDEyLjEuMCBzcGVjaWZ5aW5nIGEgY29tcG9uZW50IGRpcmVjdGx5IGlzIGRlcHJlY2F0ZWQsIHlvdSBzaG91bGQgcmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBieSBuYW1lYCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oYCR7SGFyZGNvZGVkRndDb21wb25lbnR9YCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudFR5cGUuRlJBTUVXT1JLLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogSGFyZGNvZGVkRndDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBDb21wb25lbnRTb3VyY2UuSEFSRENPREVEXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChIYXJkY29kZWRKc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGBhZy1ncmlkOiBTaW5jZSB2ZXJzaW9uIDEyLjEuMCBzcGVjaWZ5aW5nIGEgY29tcG9uZW50IGRpcmVjdGx5IGlzIGRlcHJlY2F0ZWQsIHlvdSBzaG91bGQgcmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBieSBuYW1lYCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oYCR7SGFyZGNvZGVkSnNDb21wb25lbnR9YCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudFR5cGUuQUdfR1JJRCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IEhhcmRjb2RlZEpzQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogQ29tcG9uZW50U291cmNlLkhBUkRDT0RFRFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFyZGNvZGVkSnNGdW5jdGlvbikge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGBhZy1ncmlkOiBTaW5jZSB2ZXJzaW9uIDEyLjEuMCBzcGVjaWZ5aW5nIGEgZnVuY3Rpb24gZGlyZWN0bHkgaXMgZGVwcmVjYXRlZCwgeW91IHNob3VsZCByZWdpc3RlciB0aGUgY29tcG9uZW50IGJ5IG5hbWVgKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihgJHtoYXJkY29kZWRKc0Z1bmN0aW9ufWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWdDb21wb25lbnRVdGlscy5hZGFwdEZ1bmN0aW9uKHByb3BlcnR5TmFtZSwgaGFyZGNvZGVkSnNGdW5jdGlvbiwgQ29tcG9uZW50VHlwZS5BR19HUklELCBDb21wb25lbnRTb3VyY2UuSEFSRENPREVEKTtcbiAgICAgICAgfVxuICAgICAgICAvL15eXl5eQUJPVkUgREVQUkVDQVRFRFxuICAgICAgICB2YXIgY29tcG9uZW50TmFtZVRvVXNlO1xuICAgICAgICBpZiAoaGFyZGNvZGVkTmFtZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZVRvVXNlID0gaGFyZGNvZGVkTmFtZUNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVUb1VzZSA9IGNvbXBvbmVudE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRDb21wb25lbnRSZXNvbHZlci5yZXNvbHZlKHByb3BlcnR5TmFtZSwgY29tcG9uZW50TmFtZVRvVXNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZWZ1bCB0byBjaGVjayB3aGF0IHdvdWxkIGJlIHRoZSByZXN1bHRhbnQgcGFyYW1zIGZvciBhIGdpdmVuIG9iamVjdFxuICAgICAqICBAcGFyYW0gaG9sZGVyOiBUaGlzIGlzIHRoZSBjb250ZXh0IGZvciB3aGljaCB0aGlzIGNvbXBvbmVudCBuZWVkcyB0byBiZSBjcmVhdGVkLCBpdCBjYW4gYmUgZ3JpZE9wdGlvbnNcbiAgICAgKiAgICAgIChnbG9iYWwpIG9yIGNvbHVtbkRlZiBtb3N0bHkuXG4gICAgICogIEBwYXJhbSBwcm9wZXJ0eU5hbWU6IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB1c2VkIGluIGFnLWdyaWQgYXMgYSBjb252ZW50aW9uIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQsIGl0IGNhbiBiZTpcbiAgICAgKiAgICAgICdmbG9hdGluZ0ZpbHRlcicsICdjZWxsUmVuZGVyZXInLCBpcyB1c2VkIHRvIGZpbmQgaWYgdGhlIHVzZXIgaXMgc3BlY2lmeWluZyBhIGN1c3RvbSBjb21wb25lbnRcbiAgICAgKiAgQHBhcmFtIGFnR3JpZFBhcmFtczogUGFyYW1zIHRvIGJlIHBhc3NlZCB0byB0aGUgY29tcG9uZW50IGFuZCBwYXNzZWQgYnkgYWctR3JpZC4gVGhpcyB3aWxsIGdldCBtZXJnZWQgd2l0aCBhbnkgcGFyYW1zXG4gICAgICogICAgICBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgaW4gdGhlIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7YW55fSBJdCBtZXJnZXMgdGhlIHVzZXIgYWdHcmlkUGFyYW1zIHdpdGggdGhlIGFjdHVhbCBwYXJhbXMgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIENvbXBvbmVudFJlc29sdmVyLnByb3RvdHlwZS5tZXJnZVBhcmFtcyA9IGZ1bmN0aW9uIChob2xkZXIsIHByb3BlcnR5TmFtZSwgYWdHcmlkUGFyYW1zKSB7XG4gICAgICAgIHZhciBjdXN0b21QYXJhbXMgPSBob2xkZXIgPyBob2xkZXJbcHJvcGVydHlOYW1lICsgXCJQYXJhbXNcIl0gOiBudWxsO1xuICAgICAgICB2YXIgZmluYWxQYXJhbXMgPSB7fTtcbiAgICAgICAgdXRpbHNfMS5fLm1lcmdlRGVlcChmaW5hbFBhcmFtcywgYWdHcmlkUGFyYW1zKTtcbiAgICAgICAgdXRpbHNfMS5fLm1lcmdlRGVlcChmaW5hbFBhcmFtcywgY3VzdG9tUGFyYW1zKTtcbiAgICAgICAgaWYgKCFmaW5hbFBhcmFtcy5hcGkpIHtcbiAgICAgICAgICAgIGZpbmFsUGFyYW1zLmFwaSA9IHRoaXMuZ3JpZE9wdGlvbnMuYXBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbFBhcmFtcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBjb21wb25lbnQgZ2l2ZW4gZXZlcnl0aGluZyBuZWVkZWQgdG8gZ3Vlc3Mgd2hhdCBzb3J0IG9mIGNvbXBvbmVudCBuZWVkcyB0byBiZSBpbnN0YW50aWF0ZWRcbiAgICAgKiBJdCB0YWtlc1xuICAgICAqICBAcGFyYW0gaG9sZGVyT3B0OiBUaGlzIGlzIHRoZSBjb250ZXh0IGZvciB3aGljaCB0aGlzIGNvbXBvbmVudCBuZWVkcyB0byBiZSBjcmVhdGVkLCBpdCBjYW4gYmUgZ3JpZE9wdGlvbnNcbiAgICAgKiAgICAgIChnbG9iYWwpIG9yIGNvbHVtbkRlZiBtb3N0bHkuXG4gICAgICogIEBwYXJhbSBhZ0dyaWRQYXJhbXM6IFBhcmFtcyB0byBiZSBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCBhbmQgcGFzc2VkIGJ5IGFnLUdyaWQuIFRoaXMgd2lsbCBnZXQgbWVyZ2VkIHdpdGggYW55IHBhcmFtc1xuICAgICAqICAgICAgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGluIHRoZSBjb25maWd1cmF0aW9uXG4gICAgICogIEBwYXJhbSBwcm9wZXJ0eU5hbWU6IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB1c2VkIGluIGFnLWdyaWQgYXMgYSBjb252ZW50aW9uIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQsIGl0IGNhbiBiZTpcbiAgICAgKiAgICAgICdmbG9hdGluZ0ZpbHRlcicsICdjZWxsUmVuZGVyZXInLCBpcyB1c2VkIHRvIGZpbmQgaWYgdGhlIHVzZXIgaXMgc3BlY2lmeWluZyBhIGN1c3RvbSBjb21wb25lbnRcbiAgICAgKiAgQHBhcmFtIGNvbXBvbmVudE5hbWVPcHQ6IFRoZSBhY3R1YWwgbmFtZSBvZiB0aGUgY29tcG9uZW50IHRvIGluc3RhbnRpYXRlLCB0aGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgYXMgcHJvcGVydHlOYW1lLCBidXQgaW5cbiAgICAgKiAgICAgIHNvbWUgY2FzZXMgaXMgbm90LCBsaWtlIGZsb2F0aW5nRmlsdGVyLCBpZiBpdCBpcyB0aGUgc2FtZSBpcyBub3QgbmVjZXNzYXJ5IHRvIHNwZWNpZnlcbiAgICAgKiAgQHBhcmFtIG1hbmRhdG9yeTogSGFuZHkgbWV0aG9kIHRvIHRlbGwgaWYgdGhpcyBzaG91bGQgcmV0dXJuIGEgY29tcG9uZW50IEFMV0FZUy4gaWYgdGhhdCBpcyB0aGUgY2FzZSwgYnV0IHRoZXJlIGlzIG5vXG4gICAgICogICAgICBjb21wb25lbnQgZm91bmQsIGl0IHRocm93cyBhbiBlcnJvciwgYnkgZGVmYXVsdCBhbGwgY29tcG9uZW50cyBhcmUgTUFOREFUT1JZXG4gICAgICogIEBwYXJhbSBjdXN0b21Jbml0UGFyYW1zQ2I6IEEgY2hhbmNlIHRvIGN1c3RvbWlzZSB0aGUgcGFyYW1zIHBhc3NlZCB0byB0aGUgaW5pdCBtZXRob2QuIEl0IHJlY2VpdmVzIHdoYXQgdGhlIGN1cnJlbnRcbiAgICAgKiAgcGFyYW1zIGFyZSBhbmQgdGhlIGNvbXBvbmVudCB0aGF0IGluaXQgaXMgYWJvdXQgdG8gZ2V0IGNhbGxlZCBmb3JcbiAgICAgKi9cbiAgICBDb21wb25lbnRSZXNvbHZlci5wcm90b3R5cGUuY3JlYXRlQWdHcmlkQ29tcG9uZW50ID0gZnVuY3Rpb24gKGhvbGRlck9wdCwgYWdHcmlkUGFyYW1zLCBwcm9wZXJ0eU5hbWUsIGNvbXBvbmVudE5hbWVPcHQsIG1hbmRhdG9yeSwgY3VzdG9tSW5pdFBhcmFtc0NiKSB7XG4gICAgICAgIGlmIChtYW5kYXRvcnkgPT09IHZvaWQgMCkgeyBtYW5kYXRvcnkgPSB0cnVlOyB9XG4gICAgICAgIHZhciBob2xkZXIgPSBob2xkZXJPcHQgPT0gbnVsbCA/IHRoaXMuZ3JpZE9wdGlvbnMgOiBob2xkZXJPcHQ7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZU9wdCA9PSBudWxsID8gcHJvcGVydHlOYW1lIDogY29tcG9uZW50TmFtZU9wdDtcbiAgICAgICAgLy9DcmVhdGUgdGhlIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5uZXdBZ0dyaWRDb21wb25lbnQoaG9sZGVyLCBwcm9wZXJ0eU5hbWUsIGNvbXBvbmVudE5hbWUsIG1hbmRhdG9yeSk7XG4gICAgICAgIGlmICghY29tcG9uZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vV2lyZSB0aGUgY29tcG9uZW50IGFuZCBjYWxsIHRoZSBpbml0IG1ldGhvZCB3aXRoIHRoZSBjb3JyZWN0IHBhcmFtc1xuICAgICAgICB2YXIgZmluYWxQYXJhbXMgPSB0aGlzLm1lcmdlUGFyYW1zKGhvbGRlciwgcHJvcGVydHlOYW1lLCBhZ0dyaWRQYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbnRleHQud2lyZUJlYW4oY29tcG9uZW50KTtcbiAgICAgICAgdmFyIGRlZmVycmVkSW5pdDtcbiAgICAgICAgaWYgKGN1c3RvbUluaXRQYXJhbXNDYiA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZlcnJlZEluaXQgPSBjb21wb25lbnQuaW5pdChmaW5hbFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZEluaXQgPSBjb21wb25lbnQuaW5pdChjdXN0b21Jbml0UGFyYW1zQ2IoZmluYWxQYXJhbXMsIGNvbXBvbmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZlcnJlZEluaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuUHJvbWlzZS5yZXNvbHZlKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAvLyByZXR1cm4gbmV3IFByb21pc2U8QT4gKHJlc29sdmU9PntcbiAgICAgICAgICAgIC8vICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgLy8gICAgICAgICAoKT0+cmVzb2x2ZShjb21wb25lbnQpLFxuICAgICAgICAgICAgLy8gICAgICAgICA1MDBcbiAgICAgICAgICAgIC8vICAgICApXG4gICAgICAgICAgICAvLyB9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFzUHJvbWlzZSA9IGRlZmVycmVkSW5pdDtcbiAgICAgICAgICAgIHJldHVybiBhc1Byb21pc2UubWFwKGZ1bmN0aW9uIChub3RSZWxldmFudCkgeyByZXR1cm4gY29tcG9uZW50OyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcG9uZW50UmVzb2x2ZXIucHJvdG90eXBlLm5ld0FnR3JpZENvbXBvbmVudCA9IGZ1bmN0aW9uIChob2xkZXIsIHByb3BlcnR5TmFtZSwgY29tcG9uZW50TmFtZSwgbWFuZGF0b3J5KSB7XG4gICAgICAgIGlmIChtYW5kYXRvcnkgPT09IHZvaWQgMCkgeyBtYW5kYXRvcnkgPSB0cnVlOyB9XG4gICAgICAgIHZhciBjb21wb25lbnRUb1VzZSA9IHRoaXMuZ2V0Q29tcG9uZW50VG9Vc2UoaG9sZGVyLCBwcm9wZXJ0eU5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICBpZiAoIWNvbXBvbmVudFRvVXNlIHx8ICFjb21wb25lbnRUb1VzZS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChtYW5kYXRvcnkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgY29tcG9uZW50IFwiICsgcHJvcGVydHlOYW1lICsgXCI9PlwiICsgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50VG9Vc2UudHlwZSA9PT0gQ29tcG9uZW50VHlwZS5BR19HUklEKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbXBvbmVudFRvVXNlLmNvbXBvbmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vVXNpbmcgZnJhbWV3b3JrIGNvbXBvbmVudFxuICAgICAgICB2YXIgRnJhbWV3b3JrQ29tcG9uZW50UmF3ID0gY29tcG9uZW50VG9Vc2UuY29tcG9uZW50O1xuICAgICAgICB2YXIgdGhpc0NvbXBvbmVudENvbmZpZyA9IHRoaXMuY29tcG9uZW50TWV0YWRhdGFQcm92aWRlci5yZXRyaWV2ZShwcm9wZXJ0eU5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXdvcmtDb21wb25lbnRXcmFwcGVyLndyYXAoRnJhbWV3b3JrQ29tcG9uZW50UmF3LCB0aGlzQ29tcG9uZW50Q29uZmlnLm1hbmRhdG9yeU1ldGhvZExpc3QsIHRoaXNDb21wb25lbnRDb25maWcub3B0aW9uYWxNZXRob2RMaXN0LCBjb21wb25lbnROYW1lKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKFwiZ3JpZE9wdGlvbnNcIiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ29tcG9uZW50UmVzb2x2ZXIucHJvdG90eXBlLCBcImdyaWRPcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoXCJncmlkT3B0aW9uc1dyYXBwZXJcIiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgQ29tcG9uZW50UmVzb2x2ZXIucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKFwiY29udGV4dFwiKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIENvbXBvbmVudFJlc29sdmVyLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoXCJuYW1lZENvbXBvbmVudFJlc29sdmVyXCIpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgbmFtZWRDb21wb25lbnRSZXNvbHZlcl8xLk5hbWVkQ29tcG9uZW50UmVzb2x2ZXIpXG4gICAgXSwgQ29tcG9uZW50UmVzb2x2ZXIucHJvdG90eXBlLCBcIm5hbWVkQ29tcG9uZW50UmVzb2x2ZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZChcImFnQ29tcG9uZW50VXRpbHNcIiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBhZ0NvbXBvbmVudFV0aWxzXzEuQWdDb21wb25lbnRVdGlscylcbiAgICBdLCBDb21wb25lbnRSZXNvbHZlci5wcm90b3R5cGUsIFwiYWdDb21wb25lbnRVdGlsc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKFwiY29tcG9uZW50TWV0YWRhdGFQcm92aWRlclwiKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXJfMS5Db21wb25lbnRNZXRhZGF0YVByb3ZpZGVyKVxuICAgIF0sIENvbXBvbmVudFJlc29sdmVyLnByb3RvdHlwZSwgXCJjb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5PcHRpb25hbChcImZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXJcIiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ29tcG9uZW50UmVzb2x2ZXIucHJvdG90eXBlLCBcImZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBDb21wb25lbnRSZXNvbHZlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignY29tcG9uZW50UmVzb2x2ZXInKVxuICAgIF0sIENvbXBvbmVudFJlc29sdmVyKTtcbiAgICByZXR1cm4gQ29tcG9uZW50UmVzb2x2ZXI7XG59KCkpO1xuZXhwb3J0cy5Db21wb25lbnRSZXNvbHZlciA9IENvbXBvbmVudFJlc29sdmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UmVzb2x2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGdyaWRSb3dfMSA9IHJlcXVpcmUoXCIuL2dyaWRSb3dcIik7XG52YXIgR3JpZENlbGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyaWRDZWxsKGdyaWRDZWxsRGVmKSB7XG4gICAgICAgIHRoaXMucm93SW5kZXggPSBncmlkQ2VsbERlZi5yb3dJbmRleDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBncmlkQ2VsbERlZi5jb2x1bW47XG4gICAgICAgIHRoaXMuZmxvYXRpbmcgPSB1dGlsc18xLlV0aWxzLm1ha2VOdWxsKGdyaWRDZWxsRGVmLmZsb2F0aW5nKTtcbiAgICB9XG4gICAgR3JpZENlbGwucHJvdG90eXBlLmdldEdyaWRDZWxsRGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93SW5kZXg6IHRoaXMucm93SW5kZXgsXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgZmxvYXRpbmc6IHRoaXMuZmxvYXRpbmdcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEdyaWRDZWxsLnByb3RvdHlwZS5nZXRHcmlkUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGdyaWRSb3dfMS5HcmlkUm93KHRoaXMucm93SW5kZXgsIHRoaXMuZmxvYXRpbmcpO1xuICAgIH07XG4gICAgR3JpZENlbGwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJyb3dJbmRleCA9IFwiICsgdGhpcy5yb3dJbmRleCArIFwiLCBmbG9hdGluZyA9IFwiICsgdGhpcy5mbG9hdGluZyArIFwiLCBjb2x1bW4gPSBcIiArICh0aGlzLmNvbHVtbiA/IHRoaXMuY29sdW1uLmdldElkKCkgOiBudWxsKTtcbiAgICB9O1xuICAgIEdyaWRDZWxsLnByb3RvdHlwZS5jcmVhdGVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93SW5kZXggKyBcIi5cIiArIHRoaXMuZmxvYXRpbmcgKyBcIi5cIiArIHRoaXMuY29sdW1uLmdldElkKCk7XG4gICAgfTtcbiAgICByZXR1cm4gR3JpZENlbGw7XG59KCkpO1xuZXhwb3J0cy5HcmlkQ2VsbCA9IEdyaWRDZWxsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZW50aXRpZXMvZ3JpZENlbGwuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgZ3JpZENlbGxfMSA9IHJlcXVpcmUoXCIuL2VudGl0aWVzL2dyaWRDZWxsXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuL2dyaWRBcGlcIik7XG52YXIgY2VsbENvbXBfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmluZy9jZWxsQ29tcFwiKTtcbnZhciBGb2N1c2VkQ2VsbENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvY3VzZWRDZWxsQ29udHJvbGxlcigpIHtcbiAgICB9XG4gICAgRm9jdXNlZENlbGxDb250cm9sbGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUElWT1RfTU9ERV9DSEFOR0VELCB0aGlzLmNsZWFyRm9jdXNlZENlbGwuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9FVkVSWVRISU5HX0NIQU5HRUQsIHRoaXMuY2xlYXJGb2N1c2VkQ2VsbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX0dST1VQX09QRU5FRCwgdGhpcy5jbGVhckZvY3VzZWRDZWxsLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fTU9WRUQsIHRoaXMuY2xlYXJGb2N1c2VkQ2VsbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1BJTk5FRCwgdGhpcy5jbGVhckZvY3VzZWRDZWxsLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUk9XX0dST1VQX0NIQU5HRUQsIHRoaXMuY2xlYXJGb2N1c2VkQ2VsbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1ZJU0lCTEUsIHRoaXMuY2xlYXJGb2N1c2VkQ2VsbC5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIEZvY3VzZWRDZWxsQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJGb2N1c2VkQ2VsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbCA9IG51bGw7XG4gICAgICAgIHRoaXMub25DZWxsRm9jdXNlZChmYWxzZSk7XG4gICAgfTtcbiAgICBGb2N1c2VkQ2VsbENvbnRyb2xsZXIucHJvdG90eXBlLmdldEZvY3VzZWRDZWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c2VkQ2VsbDtcbiAgICB9O1xuICAgIC8vIHdlIGNoZWNrIGlmIHRoZSBicm93c2VyIGlzIGZvY3VzaW5nIHNvbWV0aGluZywgYW5kIGlmIGl0IGlzLCBhbmRcbiAgICAvLyBpdCdzIHRoZSBjZWxsIHdlIHRoaW5rIGlzIGZvY3VzZWQsIHRoZW4gcmV0dXJuIHRoZSBjZWxsLiBzbyB0aGlzXG4gICAgLy8gbWV0aG9kcyByZXR1cm5zIHRoZSBjZWxsIGlmIGEpIHdlIHRoaW5rIGl0IGhhcyBmb2N1cyBhbmQgYikgdGhlXG4gICAgLy8gYnJvd3NlciB0aGlua3MgaXQgaGFzIGZvY3VzLiB0aGlzIHRoZW4gcmV0dXJucyBub3RoaW5nIGlmIHdlXG4gICAgLy8gZmlyc3QgZm9jdXMgYSBjZWxsLCB0aGVuIHNlY29uZCBjbGljayBvdXRzaWRlIHRoZSBncmlkLCBhcyB0aGVuIHRoZVxuICAgIC8vIGdyaWQgY2VsbCB3aWxsIHN0aWxsIGJlIGZvY3VzZWQgYXMgZmFyIGFzIHRoZSBncmlkIGlzIGNvbmNlcm5lZCxcbiAgICAvLyBob3dldmVyIHRoZSBicm93c2VyIGZvY3VzIHdpbGwgaGF2ZSBtb3ZlZCBzb21ld2hlcmUgZWxzZS5cbiAgICBGb2N1c2VkQ2VsbENvbnRyb2xsZXIucHJvdG90eXBlLmdldEZvY3VzQ2VsbFRvVXNlQWZ0ZXJSZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc0ZvY3VzQWZ0ZXJSZWZyZXNoKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5mb2N1c2VkQ2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJyb3dzZXJGb2N1c2VkQ2VsbCA9IHRoaXMuZ2V0R3JpZENlbGxGb3JEb21FbGVtZW50KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAoIWJyb3dzZXJGb2N1c2VkQ2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyaWRGb2N1c0lkID0gdGhpcy5mb2N1c2VkQ2VsbC5jcmVhdGVJZCgpO1xuICAgICAgICB2YXIgYnJvd3NlckZvY3VzSWQgPSBicm93c2VyRm9jdXNlZENlbGwuY3JlYXRlSWQoKTtcbiAgICAgICAgaWYgKGdyaWRGb2N1c0lkID09PSBicm93c2VyRm9jdXNJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZENlbGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRm9jdXNlZENlbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRHcmlkQ2VsbEZvckRvbUVsZW1lbnQgPSBmdW5jdGlvbiAoZUJyb3dzZXJDZWxsKSB7XG4gICAgICAgIHZhciBlUG9pbnRlciA9IGVCcm93c2VyQ2VsbDtcbiAgICAgICAgd2hpbGUgKGVQb2ludGVyKSB7XG4gICAgICAgICAgICB2YXIgY2VsbENvbXAgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXREb21EYXRhKGVQb2ludGVyLCBjZWxsQ29tcF8xLkNlbGxDb21wLkRPTV9EQVRBX0tFWV9DRUxMX0NPTVApO1xuICAgICAgICAgICAgaWYgKGNlbGxDb21wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxDb21wLmdldEdyaWRDZWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlUG9pbnRlciA9IGVQb2ludGVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBGb2N1c2VkQ2VsbENvbnRyb2xsZXIucHJvdG90eXBlLnNldEZvY3VzZWRDZWxsID0gZnVuY3Rpb24gKHJvd0luZGV4LCBjb2xLZXksIGZsb2F0aW5nLCBmb3JjZUJyb3dzZXJGb2N1cykge1xuICAgICAgICBpZiAoZm9yY2VCcm93c2VyRm9jdXMgPT09IHZvaWQgMCkgeyBmb3JjZUJyb3dzZXJGb2N1cyA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzQ2VsbFNlbGVjdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbHVtbiA9IHV0aWxzXzEuVXRpbHMubWFrZU51bGwodGhpcy5jb2x1bW5Db250cm9sbGVyLmdldEdyaWRDb2x1bW4oY29sS2V5KSk7XG4gICAgICAgIHRoaXMuZm9jdXNlZENlbGwgPSBuZXcgZ3JpZENlbGxfMS5HcmlkQ2VsbCh7IHJvd0luZGV4OiByb3dJbmRleCxcbiAgICAgICAgICAgIGZsb2F0aW5nOiB1dGlsc18xLlV0aWxzLm1ha2VOdWxsKGZsb2F0aW5nKSxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uIH0pO1xuICAgICAgICB0aGlzLm9uQ2VsbEZvY3VzZWQoZm9yY2VCcm93c2VyRm9jdXMpO1xuICAgIH07XG4gICAgRm9jdXNlZENlbGxDb250cm9sbGVyLnByb3RvdHlwZS5pc0NlbGxGb2N1c2VkID0gZnVuY3Rpb24gKGdyaWRDZWxsKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5mb2N1c2VkQ2VsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c2VkQ2VsbC5jb2x1bW4gPT09IGdyaWRDZWxsLmNvbHVtbiAmJiB0aGlzLmlzUm93Rm9jdXNlZChncmlkQ2VsbC5yb3dJbmRleCwgZ3JpZENlbGwuZmxvYXRpbmcpO1xuICAgIH07XG4gICAgRm9jdXNlZENlbGxDb250cm9sbGVyLnByb3RvdHlwZS5pc1Jvd05vZGVGb2N1c2VkID0gZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSb3dGb2N1c2VkKHJvd05vZGUucm93SW5kZXgsIHJvd05vZGUucm93UGlubmVkKTtcbiAgICB9O1xuICAgIEZvY3VzZWRDZWxsQ29udHJvbGxlci5wcm90b3R5cGUuaXNBbnlDZWxsRm9jdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5mb2N1c2VkQ2VsbDtcbiAgICB9O1xuICAgIEZvY3VzZWRDZWxsQ29udHJvbGxlci5wcm90b3R5cGUuaXNSb3dGb2N1c2VkID0gZnVuY3Rpb24gKHJvd0luZGV4LCBmbG9hdGluZykge1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMuZm9jdXNlZENlbGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsb2F0aW5nT3JOdWxsID0gdXRpbHNfMS5VdGlscy5tYWtlTnVsbChmbG9hdGluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzZWRDZWxsLnJvd0luZGV4ID09PSByb3dJbmRleCAmJiB0aGlzLmZvY3VzZWRDZWxsLmZsb2F0aW5nID09PSBmbG9hdGluZ09yTnVsbDtcbiAgICB9O1xuICAgIEZvY3VzZWRDZWxsQ29udHJvbGxlci5wcm90b3R5cGUub25DZWxsRm9jdXNlZCA9IGZ1bmN0aW9uIChmb3JjZUJyb3dzZXJGb2N1cykge1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfQ0VMTF9GT0NVU0VELFxuICAgICAgICAgICAgZm9yY2VCcm93c2VyRm9jdXM6IGZvcmNlQnJvd3NlckZvY3VzLFxuICAgICAgICAgICAgcm93SW5kZXg6IG51bGwsXG4gICAgICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgICAgICBmbG9hdGluZzogbnVsbCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaSxcbiAgICAgICAgICAgIHJvd1Bpbm5lZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5mb2N1c2VkQ2VsbCkge1xuICAgICAgICAgICAgZXZlbnQucm93SW5kZXggPSB0aGlzLmZvY3VzZWRDZWxsLnJvd0luZGV4O1xuICAgICAgICAgICAgZXZlbnQuY29sdW1uID0gdGhpcy5mb2N1c2VkQ2VsbC5jb2x1bW47XG4gICAgICAgICAgICBldmVudC5yb3dQaW5uZWQgPSB0aGlzLmZvY3VzZWRDZWxsLmZsb2F0aW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIEZvY3VzZWRDZWxsQ29udHJvbGxlci5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEZvY3VzZWRDZWxsQ29udHJvbGxlci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIEZvY3VzZWRDZWxsQ29udHJvbGxlci5wcm90b3R5cGUsIFwiY29sdW1uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5BcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5BcGkpXG4gICAgXSwgRm9jdXNlZENlbGxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJjb2x1bW5BcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZEFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZEFwaV8xLkdyaWRBcGkpXG4gICAgXSwgRm9jdXNlZENlbGxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEZvY3VzZWRDZWxsQ29udHJvbGxlci5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICBGb2N1c2VkQ2VsbENvbnRyb2xsZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2ZvY3VzZWRDZWxsQ29udHJvbGxlcicpXG4gICAgXSwgRm9jdXNlZENlbGxDb250cm9sbGVyKTtcbiAgICByZXR1cm4gRm9jdXNlZENlbGxDb250cm9sbGVyO1xufSgpKTtcbmV4cG9ydHMuRm9jdXNlZENlbGxDb250cm9sbGVyID0gRm9jdXNlZENlbGxDb250cm9sbGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZm9jdXNlZENlbGxDb250cm9sbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4vZW50aXRpZXMvY29sdW1uXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9ldmVudFNlcnZpY2VcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XG52YXIgY29udGV4dF8yID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi9ncmlkQXBpXCIpO1xudmFyIFNvcnRDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTb3J0Q29udHJvbGxlcigpIHtcbiAgICB9XG4gICAgU29ydENvbnRyb2xsZXJfMSA9IFNvcnRDb250cm9sbGVyO1xuICAgIFNvcnRDb250cm9sbGVyLnByb3RvdHlwZS5wcm9ncmVzc1NvcnQgPSBmdW5jdGlvbiAoY29sdW1uLCBtdWx0aVNvcnQpIHtcbiAgICAgICAgdmFyIG5leHREaXJlY3Rpb24gPSB0aGlzLmdldE5leHRTb3J0RGlyZWN0aW9uKGNvbHVtbik7XG4gICAgICAgIHRoaXMuc2V0U29ydEZvckNvbHVtbihjb2x1bW4sIG5leHREaXJlY3Rpb24sIG11bHRpU29ydCk7XG4gICAgfTtcbiAgICBTb3J0Q29udHJvbGxlci5wcm90b3R5cGUuc2V0U29ydEZvckNvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW4sIHNvcnQsIG11bHRpU29ydCkge1xuICAgICAgICAvLyBhdXRvIGNvcnJlY3QgLSBpZiBzb3J0IG5vdCBsZWdhbCB2YWx1ZSwgdGhlbiBzZXQgaXQgdG8gJ25vIHNvcnQnICh3aGljaCBpcyBudWxsKVxuICAgICAgICBpZiAoc29ydCAhPT0gY29sdW1uXzEuQ29sdW1uLlNPUlRfQVNDICYmIHNvcnQgIT09IGNvbHVtbl8xLkNvbHVtbi5TT1JUX0RFU0MpIHtcbiAgICAgICAgICAgIHNvcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBzb3J0IG9uIGN1cnJlbnQgY29sXG4gICAgICAgIGNvbHVtbi5zZXRTb3J0KHNvcnQpO1xuICAgICAgICAvLyBzb3J0ZWRBdCB1c2VkIGZvciBrbm93aW5nIG9yZGVyIG9mIGNvbHMgd2hlbiBtdWx0aS1jb2wgc29ydFxuICAgICAgICBpZiAoY29sdW1uLmdldFNvcnQoKSkge1xuICAgICAgICAgICAgdmFyIHNvcnRlZEF0ID0gTnVtYmVyKG5ldyBEYXRlKCkudmFsdWVPZigpKTtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRTb3J0ZWRBdChzb3J0ZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4uc2V0U29ydGVkQXQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvaW5nTXVsdGlTb3J0ID0gbXVsdGlTb3J0ICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzTXVsdGlTb3J0KCk7XG4gICAgICAgIC8vIGNsZWFyIHNvcnQgb24gYWxsIGNvbHVtbnMgZXhjZXB0IHRoaXMgb25lLCBhbmQgdXBkYXRlIHRoZSBpY29uc1xuICAgICAgICBpZiAoIWRvaW5nTXVsdGlTb3J0KSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU29ydEJhclRoaXNDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoU29ydENoYW5nZWRFdmVudHMoKTtcbiAgICB9O1xuICAgIC8vIGdldHMgY2FsbGVkIGJ5IEFQSSwgc28gaWYgZGF0YSBjaGFuZ2VzLCB1c2UgY2FuIGNhbGwgdGhpcywgd2hpY2ggd2lsbCBlbmQgdXBcbiAgICAvLyB3b3JraW5nIG91dCB0aGUgc29ydCBvcmRlciBhZ2FpbiBvZiB0aGUgcm93cy5cbiAgICBTb3J0Q29udHJvbGxlci5wcm90b3R5cGUub25Tb3J0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFNvcnRDaGFuZ2VkRXZlbnRzKCk7XG4gICAgfTtcbiAgICBTb3J0Q29udHJvbGxlci5wcm90b3R5cGUuZGlzcGF0Y2hTb3J0Q2hhbmdlZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1NPUlRfQ0hBTkdFRCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIFNvcnRDb250cm9sbGVyLnByb3RvdHlwZS5jbGVhclNvcnRCYXJUaGlzQ29sdW1uID0gZnVuY3Rpb24gKGNvbHVtblRvU2tpcCkge1xuICAgICAgICB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0UHJpbWFyeUFuZFNlY29uZGFyeUFuZEF1dG9Db2x1bW5zKCkuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uVG9DbGVhcikge1xuICAgICAgICAgICAgLy8gRG8gbm90IGNsZWFyIGlmIGVpdGhlciBob2xkaW5nIHNoaWZ0LCBvciBpZiBjb2x1bW4gaW4gcXVlc3Rpb24gd2FzIGNsaWNrZWRcbiAgICAgICAgICAgIGlmICghKGNvbHVtblRvQ2xlYXIgPT09IGNvbHVtblRvU2tpcCkpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5Ub0NsZWFyLnNldFNvcnQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU29ydENvbnRyb2xsZXIucHJvdG90eXBlLmdldE5leHRTb3J0RGlyZWN0aW9uID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgc29ydGluZ09yZGVyO1xuICAgICAgICBpZiAoY29sdW1uLmdldENvbERlZigpLnNvcnRpbmdPcmRlcikge1xuICAgICAgICAgICAgc29ydGluZ09yZGVyID0gY29sdW1uLmdldENvbERlZigpLnNvcnRpbmdPcmRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRTb3J0aW5nT3JkZXIoKSkge1xuICAgICAgICAgICAgc29ydGluZ09yZGVyID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0U29ydGluZ09yZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3J0aW5nT3JkZXIgPSBTb3J0Q29udHJvbGxlcl8xLkRFRkFVTFRfU09SVElOR19PUkRFUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc29ydGluZ09yZGVyKSB8fCBzb3J0aW5nT3JkZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogc29ydGluZ09yZGVyIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudCwgY3VycmVudGx5IGl0XFwncyAnICsgc29ydGluZ09yZGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gc29ydGluZ09yZGVyLmluZGV4T2YoY29sdW1uLmdldFNvcnQoKSk7XG4gICAgICAgIHZhciBub3RJbkFycmF5ID0gY3VycmVudEluZGV4IDwgMDtcbiAgICAgICAgdmFyIGxhc3RJdGVtSW5BcnJheSA9IGN1cnJlbnRJbmRleCA9PSBzb3J0aW5nT3JkZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKG5vdEluQXJyYXkgfHwgbGFzdEl0ZW1JbkFycmF5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzb3J0aW5nT3JkZXJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzb3J0aW5nT3JkZXJbY3VycmVudEluZGV4ICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmVyaWZ5IHRoZSBzb3J0IHR5cGUgZXhpc3RzLCBhcyB0aGUgdXNlciBjb3VsZCBwcm92aWRlIHRoZSBzb3J0T3JkZXIsIG5lZWQgdG8gbWFrZSBzdXJlIGl0J3MgdmFsaWRcbiAgICAgICAgaWYgKFNvcnRDb250cm9sbGVyXzEuREVGQVVMVF9TT1JUSU5HX09SREVSLmluZGV4T2YocmVzdWx0KSA8IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogaW52YWxpZCBzb3J0IHR5cGUgJyArIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLy8gdXNlZCBieSB0aGUgcHVibGljIGFwaSwgZm9yIHNhdmluZyB0aGUgc29ydCBtb2RlbFxuICAgIFNvcnRDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTb3J0TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2x1bW5zV2l0aFNvcnRpbmcgPSB0aGlzLmdldENvbHVtbnNXaXRoU29ydGluZ09yZGVyZWQoKTtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMubWFwKGNvbHVtbnNXaXRoU29ydGluZywgZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2xJZDogY29sdW1uLmdldENvbElkKCksXG4gICAgICAgICAgICAgICAgc29ydDogY29sdW1uLmdldFNvcnQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb3J0Q29udHJvbGxlci5wcm90b3R5cGUuc2V0U29ydE1vZGVsID0gZnVuY3Rpb24gKHNvcnRNb2RlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlU29ydGluZygpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IFlvdSBhcmUgc2V0dGluZyB0aGUgc29ydCBtb2RlbCBvbiBhIGdyaWQgdGhhdCBkb2VzIG5vdCBoYXZlIHNvcnRpbmcgZW5hYmxlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IHVwLCBjbGVhciBhbnkgcHJldmlvdXMgc29ydFxuICAgICAgICB2YXIgc29ydE1vZGVsUHJvdmlkZWQgPSBzb3J0TW9kZWwgJiYgc29ydE1vZGVsLmxlbmd0aCA+IDA7XG4gICAgICAgIHZhciBhbGxDb2x1bW5zSW5jbHVkaW5nQXV0byA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRQcmltYXJ5QW5kU2Vjb25kYXJ5QW5kQXV0b0NvbHVtbnMoKTtcbiAgICAgICAgYWxsQ29sdW1uc0luY2x1ZGluZ0F1dG8uZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgc29ydEZvckNvbCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgc29ydGVkQXQgPSAtMTtcbiAgICAgICAgICAgIGlmIChzb3J0TW9kZWxQcm92aWRlZCAmJiAhY29sdW1uLmdldENvbERlZigpLnN1cHByZXNzU29ydGluZykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc29ydE1vZGVsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3J0TW9kZWxFbnRyeSA9IHNvcnRNb2RlbFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3J0TW9kZWxFbnRyeS5jb2xJZCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHR5cGVvZiBjb2x1bW4uZ2V0Q29sSWQoKSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIF90aGlzLmNvbXBhcmVDb2xJZHMoc29ydE1vZGVsRW50cnksIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRGb3JDb2wgPSBzb3J0TW9kZWxFbnRyeS5zb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkQXQgPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvcnRGb3JDb2wpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4uc2V0U29ydChzb3J0Rm9yQ29sKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4uc2V0U29ydGVkQXQoc29ydGVkQXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLnNldFNvcnQobnVsbCk7XG4gICAgICAgICAgICAgICAgY29sdW1uLnNldFNvcnRlZEF0KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFNvcnRDaGFuZ2VkRXZlbnRzKCk7XG4gICAgfTtcbiAgICBTb3J0Q29udHJvbGxlci5wcm90b3R5cGUuY29tcGFyZUNvbElkcyA9IGZ1bmN0aW9uIChzb3J0TW9kZWxFbnRyeSwgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBzb3J0TW9kZWxFbnRyeS5jb2xJZCA9PT0gY29sdW1uLmdldENvbElkKCk7XG4gICAgfTtcbiAgICBTb3J0Q29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q29sdW1uc1dpdGhTb3J0aW5nT3JkZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcHVsbCBvdXQgYWxsIHRoZSBjb2x1bW5zIHRoYXQgaGF2ZSBzb3J0aW5nIHNldFxuICAgICAgICB2YXIgYWxsQ29sdW1uc0luY2x1ZGluZ0F1dG8gPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0UHJpbWFyeUFuZFNlY29uZGFyeUFuZEF1dG9Db2x1bW5zKCk7XG4gICAgICAgIHZhciBjb2x1bW5zV2l0aFNvcnRpbmcgPSB1dGlsc18xLlV0aWxzLmZpbHRlcihhbGxDb2x1bW5zSW5jbHVkaW5nQXV0bywgZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gISFjb2x1bW4uZ2V0U29ydCgpOyB9KTtcbiAgICAgICAgLy8gcHV0IHRoZSBjb2x1bW5zIGluIG9yZGVyIG9mIHdoaWNoIG9uZSBnb3Qgc29ydGVkIGZpcnN0XG4gICAgICAgIGNvbHVtbnNXaXRoU29ydGluZy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnNvcnRlZEF0IC0gYi5zb3J0ZWRBdDsgfSk7XG4gICAgICAgIHJldHVybiBjb2x1bW5zV2l0aFNvcnRpbmc7XG4gICAgfTtcbiAgICAvLyB1c2VkIGJ5IHJvdyBjb250cm9sbGVyLCB3aGVuIGRvaW5nIHRoZSBzb3J0aW5nXG4gICAgU29ydENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNvcnRGb3JSb3dDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sdW1uc1dpdGhTb3J0aW5nID0gdGhpcy5nZXRDb2x1bW5zV2l0aFNvcnRpbmdPcmRlcmVkKCk7XG4gICAgICAgIHJldHVybiB1dGlsc18xLlV0aWxzLm1hcChjb2x1bW5zV2l0aFNvcnRpbmcsIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBhc2NlbmRpbmcgPSBjb2x1bW4uZ2V0U29ydCgpID09PSBjb2x1bW5fMS5Db2x1bW4uU09SVF9BU0M7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludmVydGVyOiBhc2NlbmRpbmcgPyAxIDogLTEsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU29ydENvbnRyb2xsZXIuREVGQVVMVF9TT1JUSU5HX09SREVSID0gW2NvbHVtbl8xLkNvbHVtbi5TT1JUX0FTQywgY29sdW1uXzEuQ29sdW1uLlNPUlRfREVTQywgbnVsbF07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIFNvcnRDb250cm9sbGVyLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgU29ydENvbnRyb2xsZXIucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgU29ydENvbnRyb2xsZXIucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5BcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5BcGkpXG4gICAgXSwgU29ydENvbnRyb2xsZXIucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBTb3J0Q29udHJvbGxlci5wcm90b3R5cGUsIFwiZ3JpZEFwaVwiLCB2b2lkIDApO1xuICAgIFNvcnRDb250cm9sbGVyID0gU29ydENvbnRyb2xsZXJfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzIuQmVhbignc29ydENvbnRyb2xsZXInKVxuICAgIF0sIFNvcnRDb250cm9sbGVyKTtcbiAgICByZXR1cm4gU29ydENvbnRyb2xsZXI7XG4gICAgdmFyIFNvcnRDb250cm9sbGVyXzE7XG59KCkpO1xuZXhwb3J0cy5Tb3J0Q29udHJvbGxlciA9IFNvcnRDb250cm9sbGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvc29ydENvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMTQpKSg2KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGZpbHRlck1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWx0ZXIvZmlsdGVyTWFuYWdlclwiKTtcbnZhciBjb21wb25lbnRSZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50UmVzb2x2ZXJcIik7XG52YXIgQ29tcG9uZW50VHlwZTtcbihmdW5jdGlvbiAoQ29tcG9uZW50VHlwZSkge1xuICAgIENvbXBvbmVudFR5cGVbQ29tcG9uZW50VHlwZVtcIkFHX0dSSURcIl0gPSAwXSA9IFwiQUdfR1JJRFwiO1xuICAgIENvbXBvbmVudFR5cGVbQ29tcG9uZW50VHlwZVtcIkZSQU1FV09SS1wiXSA9IDFdID0gXCJGUkFNRVdPUktcIjtcbn0pKENvbXBvbmVudFR5cGUgfHwgKENvbXBvbmVudFR5cGUgPSB7fSkpO1xudmFyIENvbXBvbmVudFJlY2lwZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlY2lwZXMoKSB7XG4gICAgfVxuICAgIENvbXBvbmVudFJlY2lwZXMucHJvdG90eXBlLm5ld0RhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFJlc29sdmVyLmNyZWF0ZUFnR3JpZENvbXBvbmVudCh0aGlzLmdyaWRPcHRpb25zLCBwYXJhbXMsIFwiZGF0ZUNvbXBvbmVudFwiKTtcbiAgICB9O1xuICAgIENvbXBvbmVudFJlY2lwZXMucHJvdG90eXBlLm5ld0hlYWRlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50UmVzb2x2ZXIuY3JlYXRlQWdHcmlkQ29tcG9uZW50KHBhcmFtcy5jb2x1bW4uZ2V0Q29sRGVmKCksIHBhcmFtcywgXCJoZWFkZXJDb21wb25lbnRcIik7XG4gICAgfTtcbiAgICBDb21wb25lbnRSZWNpcGVzLnByb3RvdHlwZS5uZXdIZWFkZXJHcm91cENvbXBvbmVudCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50UmVzb2x2ZXIuY3JlYXRlQWdHcmlkQ29tcG9uZW50KHBhcmFtcy5jb2x1bW5Hcm91cC5nZXRDb2xHcm91cERlZigpLCBwYXJhbXMsIFwiaGVhZGVyR3JvdXBDb21wb25lbnRcIik7XG4gICAgfTtcbiAgICBDb21wb25lbnRSZWNpcGVzLnByb3RvdHlwZS5uZXdGbG9hdGluZ0ZpbHRlckNvbXBvbmVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb2xEZWYsIHBhcmFtcykge1xuICAgICAgICAvL3R5cGUgaWYgcG9wdWxhdGVkIG11c3QgYmUgb25lIG9mIFsnc2V0JywnbnVtYmVyJywndGV4dCcsJ2RhdGUnXVxuICAgICAgICB2YXIgZmxvYXRpbmdGaWx0ZXJOYW1lID0gdHlwZSArIFwiRmxvYXRpbmdGaWx0ZXJDb21wb25lbnRcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50UmVzb2x2ZXIuY3JlYXRlQWdHcmlkQ29tcG9uZW50KGNvbERlZiwgcGFyYW1zLCBcImZsb2F0aW5nRmlsdGVyQ29tcG9uZW50XCIsIGZsb2F0aW5nRmlsdGVyTmFtZSwgZmFsc2UpO1xuICAgIH07XG4gICAgQ29tcG9uZW50UmVjaXBlcy5wcm90b3R5cGUubmV3RmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbHVtbiwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xEZWYgPSBjb2x1bW4uZ2V0Q29sRGVmKCk7XG4gICAgICAgIGlmIChjb2xEZWYuc3VwcHJlc3NGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld0VtcHR5RmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcG9uZW50KGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsb2F0aW5nRmlsdGVyVHlwZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xEZWYuZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmxvYXRpbmdGaWx0ZXJUeXBlID0gY29sRGVmLmZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY29sRGVmLmZpbHRlcikge1xuICAgICAgICAgICAgZmxvYXRpbmdGaWx0ZXJUeXBlID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbnRlcnByaXNlKCkgPyAnc2V0JyA6ICd0ZXh0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZsb2F0aW5nRmlsdGVyVHlwZSA9ICdjdXN0b20nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbG9hdGluZ0ZpbHRlciA9IHRoaXMubmV3RmxvYXRpbmdGaWx0ZXJDb21wb25lbnQoZmxvYXRpbmdGaWx0ZXJUeXBlLCBjb2xEZWYsIHBhcmFtcyk7XG4gICAgICAgIHZhciBmbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wb25lbnRQYXJhbXMgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGZsb2F0aW5nRmlsdGVyQ29tcDogZmxvYXRpbmdGaWx0ZXIsXG4gICAgICAgICAgICBzdXBwcmVzc0ZpbHRlckJ1dHRvbjogdGhpcy5jb21wb25lbnRSZXNvbHZlci5tZXJnZVBhcmFtcyhjb2xEZWYsICdmbG9hdGluZ0ZpbHRlckNvbXBvbmVudCcsIHBhcmFtcykuc3VwcHJlc3NGaWx0ZXJCdXR0b25cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFmbG9hdGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlckNvbXBvbmVudCA9IHRoaXMuZ2V0RmlsdGVyQ29tcG9uZW50UHJvdG90eXBlKGNvbERlZik7XG4gICAgICAgICAgICBpZiAoZmlsdGVyQ29tcG9uZW50ICYmICFmaWx0ZXJDb21wb25lbnQuY29tcG9uZW50LnByb3RvdHlwZS5nZXRNb2RlbEFzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3RW1wdHlGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wb25lbnQoY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYXdNb2RlbEZuXzEgPSBwYXJhbXMuY3VycmVudFBhcmVudE1vZGVsO1xuICAgICAgICAgICAgcGFyYW1zLmN1cnJlbnRQYXJlbnRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UHJvbWlzZSA9IF90aGlzLmZpbHRlck1hbmFnZXIuZ2V0RmlsdGVyQ29tcG9uZW50KGNvbHVtbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFByb21pc2UucmVzb2x2ZU5vdyhudWxsLCBmdW5jdGlvbiAocGFyZW50KSB7IHJldHVybiBwYXJlbnQuZ2V0TW9kZWxBc1N0cmluZyA/IHBhcmVudC5nZXRNb2RlbEFzU3RyaW5nKHJhd01vZGVsRm5fMSgpKSA6IG51bGw7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXBvbmVudFBhcmFtcy5mbG9hdGluZ0ZpbHRlckNvbXAgPSB0aGlzLm5ld0Zsb2F0aW5nRmlsdGVyQ29tcG9uZW50KCdyZWFkTW9kZWxBc1N0cmluZycsIGNvbERlZiwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRSZXNvbHZlci5jcmVhdGVBZ0dyaWRDb21wb25lbnQoY29sRGVmLCBmbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wb25lbnRQYXJhbXMsIFwiZmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcG9uZW50XCIpO1xuICAgIH07XG4gICAgQ29tcG9uZW50UmVjaXBlcy5wcm90b3R5cGUubmV3RnVsbFdpZHRoR3JvdXBSb3dJbm5lckNlbGxSZW5kZXJlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50UmVzb2x2ZXIuY3JlYXRlQWdHcmlkQ29tcG9uZW50KHRoaXMuZ3JpZE9wdGlvbnMsIHBhcmFtcywgXCJncm91cFJvd0lubmVyUmVuZGVyZXJcIiwgXCJncm91cFJvd0lubmVyUmVuZGVyZXJcIiwgZmFsc2UpO1xuICAgIH07XG4gICAgQ29tcG9uZW50UmVjaXBlcy5wcm90b3R5cGUubmV3Q2VsbFJlbmRlcmVyID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFJlc29sdmVyLmNyZWF0ZUFnR3JpZENvbXBvbmVudCh0YXJnZXQsIHBhcmFtcywgXCJjZWxsUmVuZGVyZXJcIiwgXCJjZWxsUmVuZGVyZXJcIiwgZmFsc2UpO1xuICAgIH07XG4gICAgQ29tcG9uZW50UmVjaXBlcy5wcm90b3R5cGUubmV3SW5uZXJDZWxsUmVuZGVyZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50UmVzb2x2ZXIuY3JlYXRlQWdHcmlkQ29tcG9uZW50KHRhcmdldCwgcGFyYW1zLCBcImlubmVyUmVuZGVyZXJcIik7XG4gICAgfTtcbiAgICBDb21wb25lbnRSZWNpcGVzLnByb3RvdHlwZS5uZXdGdWxsUm93R3JvdXBSZW5kZXJlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50UmVzb2x2ZXIuY3JlYXRlQWdHcmlkQ29tcG9uZW50KHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBwYXJhbXMsIFwiZnVsbFdpZHRoQ2VsbFJlbmRlcmVyXCIpO1xuICAgIH07XG4gICAgQ29tcG9uZW50UmVjaXBlcy5wcm90b3R5cGUuZ2V0RmlsdGVyQ29tcG9uZW50UHJvdG90eXBlID0gZnVuY3Rpb24gKGNvbERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRSZXNvbHZlci5nZXRDb21wb25lbnRUb1VzZShjb2xEZWYsIFwiZmlsdGVyQ29tcG9uZW50XCIpO1xuICAgIH07XG4gICAgQ29tcG9uZW50UmVjaXBlcy5wcm90b3R5cGUubmV3RW1wdHlGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wb25lbnQgPSBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHZhciBmbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wb25lbnRQYXJhbXMgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGZsb2F0aW5nRmlsdGVyQ29tcDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRSZXNvbHZlci5jcmVhdGVBZ0dyaWRDb21wb25lbnQoY29sdW1uLmdldENvbERlZigpLCBmbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wb25lbnRQYXJhbXMsIFwiZmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcG9uZW50XCIsIFwiZW1wdHlGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wb25lbnRcIik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZChcImNvbXBvbmVudFJlc29sdmVyXCIpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29tcG9uZW50UmVzb2x2ZXJfMS5Db21wb25lbnRSZXNvbHZlcilcbiAgICBdLCBDb21wb25lbnRSZWNpcGVzLnByb3RvdHlwZSwgXCJjb21wb25lbnRSZXNvbHZlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKFwiZ3JpZE9wdGlvbnNcIiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ29tcG9uZW50UmVjaXBlcy5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZChcImdyaWRPcHRpb25zV3JhcHBlclwiKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBDb21wb25lbnRSZWNpcGVzLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZmlsdGVyTWFuYWdlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZmlsdGVyTWFuYWdlcl8xLkZpbHRlck1hbmFnZXIpXG4gICAgXSwgQ29tcG9uZW50UmVjaXBlcy5wcm90b3R5cGUsIFwiZmlsdGVyTWFuYWdlclwiLCB2b2lkIDApO1xuICAgIENvbXBvbmVudFJlY2lwZXMgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2NvbXBvbmVudFJlY2lwZXMnKVxuICAgIF0sIENvbXBvbmVudFJlY2lwZXMpO1xuICAgIHJldHVybiBDb21wb25lbnRSZWNpcGVzO1xufSgpKTtcbmV4cG9ydHMuQ29tcG9uZW50UmVjaXBlcyA9IENvbXBvbmVudFJlY2lwZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9jb21wb25lbnRzL2ZyYW1ld29yay9jb21wb25lbnRSZWNpcGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4vY29sdW1uXCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2V2ZW50U2VydmljZVwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi9ncmlkQXBpXCIpO1xudmFyIENvbHVtbkdyb3VwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2x1bW5Hcm91cChvcmlnaW5hbENvbHVtbkdyb3VwLCBncm91cElkLCBpbnN0YW5jZUlkKSB7XG4gICAgICAgIC8vIGRlcGVuZHMgb24gdGhlIG9wZW4vY2xvc2VkIHN0YXRlIG9mIHRoZSBncm91cCwgb25seSBkaXNwbGF5aW5nIGNvbHVtbnMgYXJlIHN0b3JlZCBoZXJlXG4gICAgICAgIHRoaXMuZGlzcGxheWVkQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5sb2NhbEV2ZW50U2VydmljZSA9IG5ldyBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UoKTtcbiAgICAgICAgdGhpcy5ncm91cElkID0gZ3JvdXBJZDtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENvbHVtbkdyb3VwID0gb3JpZ2luYWxDb2x1bW5Hcm91cDtcbiAgICB9XG4gICAgLy8gdGhpcyBpcyBzdGF0aWMsIGEgaXQgaXMgdXNlZCBvdXRzaWRlIG9mIHRoaXMgY2xhc3NcbiAgICBDb2x1bW5Hcm91cC5jcmVhdGVVbmlxdWVJZCA9IGZ1bmN0aW9uIChncm91cElkLCBpbnN0YW5jZUlkKSB7XG4gICAgICAgIHJldHVybiBncm91cElkICsgJ18nICsgaW5zdGFuY2VJZDtcbiAgICB9O1xuICAgIC8vIGFzIHRoZSB1c2VyIGlzIGFkZGluZyBhbmQgcmVtb3ZpbmcgY29sdW1ucywgdGhlIGdyb3VwcyBhcmUgcmVjYWxjdWxhdGVkLlxuICAgIC8vIHRoaXMgcmVzZXQgY2xlYXJzIG91dCBhbGwgY2hpbGRyZW4sIHJlYWR5IGZvciBjaGlsZHJlbiB0byBiZSBhZGRlZCBhZ2FpblxuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5nZXRVbmlxdWVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIENvbHVtbkdyb3VwLmNyZWF0ZVVuaXF1ZUlkKHRoaXMuZ3JvdXBJZCwgdGhpcy5pbnN0YW5jZUlkKTtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5pc0VtcHR5R3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXllZENoaWxkcmVuLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5jaGVja0xlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGZpcnN0IGdldCBhbGwgY2hpbGRyZW4gdG8gc2V0TGVmdCwgYXMgaXQgaW1wYWN0cyBvdXIgZGVjaXNpb24gYmVsb3dcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5jaGVja0xlZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldCBvdXIgbGVmdCBiYXNlZCBvbiBmaXJzdCBkaXNwbGF5ZWQgY29sdW1uXG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXllZENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVJ0bCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuZGlzcGxheWVkQ2hpbGRyZW5bdGhpcy5kaXNwbGF5ZWRDaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENoaWxkTGVmdCA9IGxhc3RDaGlsZC5nZXRMZWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMZWZ0KGxhc3RDaGlsZExlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2hpbGRMZWZ0ID0gdGhpcy5kaXNwbGF5ZWRDaGlsZHJlblswXS5nZXRMZWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMZWZ0KGZpcnN0Q2hpbGRMZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYXMgaWYgd2UgaGF2ZSBubyBkaXNwbGF5ZWQgY29sdW1ucywgdGhlblxuICAgICAgICAgICAgLy8gdGhpcyBncm91cHMgc2hvdWxkIG5vdCBldmVuIGV4aXN0LlxuICAgICAgICAgICAgdGhpcy5zZXRMZWZ0KG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdDtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5nZXRPbGRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbGRMZWZ0O1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLnNldExlZnQgPSBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICB0aGlzLm9sZExlZnQgPSBsZWZ0O1xuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBsZWZ0KSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5sb2NhbEV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlQWdFdmVudChDb2x1bW5Hcm91cC5FVkVOVF9MRUZUX0NIQU5HRUQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLmNyZWF0ZUFnRXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5sb2NhbEV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmxvY2FsRXZlbnRTZXJ2aWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuZ2V0R3JvdXBJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBJZDtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5nZXRJbnN0YW5jZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZUlkO1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLmlzQ2hpbGRJblRoaXNHcm91cERlZXBTZWFyY2ggPSBmdW5jdGlvbiAod2FudGVkQ2hpbGQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGZvdW5kQ2hpbGQpIHtcbiAgICAgICAgICAgIGlmICh3YW50ZWRDaGlsZCA9PT0gZm91bmRDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmRDaGlsZCBpbnN0YW5jZW9mIENvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kQ2hpbGQuaXNDaGlsZEluVGhpc0dyb3VwRGVlcFNlYXJjaCh3YW50ZWRDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLmdldEFjdHVhbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXBBY3R1YWxXaWR0aCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXllZENoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXllZENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBBY3R1YWxXaWR0aCArPSBjaGlsZC5nZXRBY3R1YWxXaWR0aCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwQWN0dWFsV2lkdGg7XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuaXNSZXNpemFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRDaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGF0IGxlYXN0IG9uZSBjaGlsZCBpcyByZXNpemFibGUsIHRoZW4gdGhlIGdyb3VwIGlzIHJlc2l6YWJsZVxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pc1Jlc2l6YWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuZ2V0TWluV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICB0aGlzLmRpc3BsYXllZENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwQ2hpbGQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBncm91cENoaWxkLmdldE1pbldpZHRoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuZ2V0RGlzcGxheWVkQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXllZENoaWxkcmVuO1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLmdldExlYWZDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuYWRkTGVhZkNvbHVtbnMocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5nZXREaXNwbGF5ZWRMZWFmQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmFkZERpc3BsYXllZExlYWZDb2x1bW5zKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyB3aHkgdHdvIG1ldGhvZHMgaGVyZSBkb2luZyB0aGUgc2FtZSB0aGluZz9cbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuZ2V0RGVmaW5pdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxDb2x1bW5Hcm91cC5nZXRDb2xHcm91cERlZigpO1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLmdldENvbEdyb3VwRGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbENvbHVtbkdyb3VwLmdldENvbEdyb3VwRGVmKCk7XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuaXNQYWRkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbENvbHVtbkdyb3VwLmlzUGFkZGluZygpO1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLmlzRXhwYW5kYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxDb2x1bW5Hcm91cC5pc0V4cGFuZGFibGUoKTtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5pc0V4cGFuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbENvbHVtbkdyb3VwLmlzRXhwYW5kZWQoKTtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5zZXRFeHBhbmRlZCA9IGZ1bmN0aW9uIChleHBhbmRlZCkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ29sdW1uR3JvdXAuc2V0RXhwYW5kZWQoZXhwYW5kZWQpO1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLmFkZERpc3BsYXllZExlYWZDb2x1bW5zID0gZnVuY3Rpb24gKGxlYWZDb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIGNvbHVtbl8xLkNvbHVtbikge1xuICAgICAgICAgICAgICAgIGxlYWZDb2x1bW5zLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmFkZERpc3BsYXllZExlYWZDb2x1bW5zKGxlYWZDb2x1bW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuYWRkTGVhZkNvbHVtbnMgPSBmdW5jdGlvbiAobGVhZkNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgY29sdW1uXzEuQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgbGVhZkNvbHVtbnMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYWRkTGVhZkNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLnByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuZ2V0Q29sdW1uR3JvdXBTaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbENvbHVtbkdyb3VwLmdldENvbHVtbkdyb3VwU2hvdygpO1xuICAgIH07XG4gICAgQ29sdW1uR3JvdXAucHJvdG90eXBlLmdldE9yaWdpbmFsQ29sdW1uR3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsQ29sdW1uR3JvdXA7XG4gICAgfTtcbiAgICBDb2x1bW5Hcm91cC5wcm90b3R5cGUuY2FsY3VsYXRlRGlzcGxheWVkQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gY2xlYXIgb3V0IGxhc3QgdGltZSB3ZSBjYWxjdWxhdGVkXG4gICAgICAgIHRoaXMuZGlzcGxheWVkQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gaXQgbm90IGV4cGFuZGFibGUsIGV2ZXJ5dGhpbmcgaXMgdmlzaWJsZVxuICAgICAgICBpZiAoIXRoaXMub3JpZ2luYWxDb2x1bW5Hcm91cC5pc0V4cGFuZGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhbmQgY2FsY3VsYXRlIGFnYWluXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFic3RyYWN0Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlckdyb3VwU2hvdyA9IGFic3RyYWN0Q29sdW1uLmdldENvbHVtbkdyb3VwU2hvdygpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaGVhZGVyR3JvdXBTaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ29sdW1uR3JvdXAuSEVBREVSX0dST1VQX1NIT1dfT1BFTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc2V0IHRvIG9wZW4sIG9ubHkgc2hvdyBjb2wgaWYgZ3JvdXAgaXMgb3BlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm9yaWdpbmFsQ29sdW1uR3JvdXAuaXNFeHBhbmRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGxheWVkQ2hpbGRyZW4ucHVzaChhYnN0cmFjdENvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2x1bW5Hcm91cC5IRUFERVJfR1JPVVBfU0hPV19DTE9TRUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHNldCB0byBvcGVuLCBvbmx5IHNob3cgY29sIGlmIGdyb3VwIGlzIG9wZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMub3JpZ2luYWxDb2x1bW5Hcm91cC5pc0V4cGFuZGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwbGF5ZWRDaGlsZHJlbi5wdXNoKGFic3RyYWN0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBpcyBhbHdheXMgc2hvdyB0aGUgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwbGF5ZWRDaGlsZHJlbi5wdXNoKGFic3RyYWN0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxFdmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUFnRXZlbnQoQ29sdW1uR3JvdXAuRVZFTlRfRElTUExBWUVEX0NISUxEUkVOX0NIQU5HRUQpKTtcbiAgICB9O1xuICAgIENvbHVtbkdyb3VwLkhFQURFUl9HUk9VUF9TSE9XX09QRU4gPSAnb3Blbic7XG4gICAgQ29sdW1uR3JvdXAuSEVBREVSX0dST1VQX1NIT1dfQ0xPU0VEID0gJ2Nsb3NlZCc7XG4gICAgQ29sdW1uR3JvdXAuRVZFTlRfTEVGVF9DSEFOR0VEID0gJ2xlZnRDaGFuZ2VkJztcbiAgICBDb2x1bW5Hcm91cC5FVkVOVF9ESVNQTEFZRURfQ0hJTERSRU5fQ0hBTkdFRCA9ICdsZWZ0Q2hhbmdlZCc7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIENvbHVtbkdyb3VwLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIENvbHVtbkdyb3VwLnByb3RvdHlwZSwgXCJjb2x1bW5BcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZEFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZEFwaV8xLkdyaWRBcGkpXG4gICAgXSwgQ29sdW1uR3JvdXAucHJvdG90eXBlLCBcImdyaWRBcGlcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQ29sdW1uR3JvdXA7XG59KCkpO1xuZXhwb3J0cy5Db2x1bW5Hcm91cCA9IENvbHVtbkdyb3VwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZW50aXRpZXMvY29sdW1uR3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiZWFuU3R1Yl8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvYmVhblN0dWJcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4uL2V2ZW50c1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGdyaWRQYW5lbF8xID0gcmVxdWlyZShcIi4uL2dyaWRQYW5lbC9ncmlkUGFuZWxcIik7XG52YXIgc2Nyb2xsVmlzaWJsZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ncmlkUGFuZWwvc2Nyb2xsVmlzaWJsZVNlcnZpY2VcIik7XG52YXIgc2VsZWN0aW9uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL3NlbGVjdGlvbkNvbnRyb2xsZXJcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi4vZ3JpZEFwaVwiKTtcbnZhciBQYWdpbmF0aW9uQXV0b1BhZ2VTaXplU2VydmljZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFBhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlLnByb3RvdHlwZS5ub3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNQYWdpbmF0aW9uQXV0b1BhZ2VTaXplKCk7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uQXV0b1BhZ2VTaXplU2VydmljZS5wcm90b3R5cGUucG9zdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9CT0RZX0hFSUdIVF9DSEFOR0VELCB0aGlzLm9uQm9keUhlaWdodENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfU0NST0xMX1ZJU0lCSUxJVFlfQ0hBTkdFRCwgdGhpcy5vblNjcm9sbFZpc2liaWxpdHlDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmNoZWNrUGFnZVNpemUoKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlLnByb3RvdHlwZS5vblNjcm9sbFZpc2liaWxpdHlDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoZWNrUGFnZVNpemUoKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlLnByb3RvdHlwZS5vbkJvZHlIZWlnaHRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoZWNrUGFnZVNpemUoKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlLnByb3RvdHlwZS5jaGVja1BhZ2VTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ub3RBY3RpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3dIZWlnaHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRSb3dIZWlnaHRBc051bWJlcigpO1xuICAgICAgICB2YXIgYm9keUhlaWdodCA9IHRoaXMuZ3JpZFBhbmVsLmdldEJvZHlIZWlnaHQoKTtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVmlzaWJsZVNlcnZpY2UuaXNIQm9keVNob3dpbmcoKSkge1xuICAgICAgICAgICAgYm9keUhlaWdodCA9IGJvZHlIZWlnaHQgLSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5SGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgdmFyIG5ld1BhZ2VTaXplID0gTWF0aC5mbG9vcihib2R5SGVpZ2h0IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLnNldFByb3BlcnR5KCdwYWdpbmF0aW9uUGFnZVNpemUnLCBuZXdQYWdlU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkUGFuZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRQYW5lbF8xLkdyaWRQYW5lbClcbiAgICBdLCBQYWdpbmF0aW9uQXV0b1BhZ2VTaXplU2VydmljZS5wcm90b3R5cGUsIFwiZ3JpZFBhbmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIFBhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlLnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgUGFnaW5hdGlvbkF1dG9QYWdlU2l6ZVNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdzY3JvbGxWaXNpYmxlU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgc2Nyb2xsVmlzaWJsZVNlcnZpY2VfMS5TY3JvbGxWaXNpYmxlU2VydmljZSlcbiAgICBdLCBQYWdpbmF0aW9uQXV0b1BhZ2VTaXplU2VydmljZS5wcm90b3R5cGUsIFwic2Nyb2xsVmlzaWJsZVNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgUGFnaW5hdGlvbkF1dG9QYWdlU2l6ZVNlcnZpY2UucHJvdG90eXBlLCBcInBvc3RDb25zdHJ1Y3RcIiwgbnVsbCk7XG4gICAgUGFnaW5hdGlvbkF1dG9QYWdlU2l6ZVNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ3BhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlJylcbiAgICBdLCBQYWdpbmF0aW9uQXV0b1BhZ2VTaXplU2VydmljZSk7XG4gICAgcmV0dXJuIFBhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlO1xufShiZWFuU3R1Yl8xLkJlYW5TdHViKSk7XG5leHBvcnRzLlBhZ2luYXRpb25BdXRvUGFnZVNpemVTZXJ2aWNlID0gUGFnaW5hdGlvbkF1dG9QYWdlU2l6ZVNlcnZpY2U7XG52YXIgUGFnaW5hdGlvblByb3h5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFnaW5hdGlvblByb3h5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhZ2luYXRpb25Qcm94eSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmN1cnJlbnRQYWdlID0gMDtcbiAgICAgICAgX3RoaXMudG9wUm93SW5kZXggPSAwO1xuICAgICAgICBfdGhpcy5ib3R0b21Sb3dJbmRleCA9IDA7XG4gICAgICAgIF90aGlzLnBpeGVsT2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLnBvc3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNQYWdpbmF0aW9uKCk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfTU9ERUxfVVBEQVRFRCwgdGhpcy5vbk1vZGVsVXBkYXRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsICdwYWdpbmF0aW9uUGFnZVNpemUnLCB0aGlzLm9uTW9kZWxVcGRhdGVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uTW9kZWxVcGRhdGVkKCk7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLmlzTGFzdFJvd0ZvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dNb2RlbC5pc0xhc3RSb3dGb3VuZCgpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZS5vbk1vZGVsVXBkYXRlZCA9IGZ1bmN0aW9uIChtb2RlbFVwZGF0ZWRFdmVudCkge1xuICAgICAgICB0aGlzLnNldEluZGV4ZXNBbmRCb3VuZHMoKTtcbiAgICAgICAgdmFyIHBhZ2luYXRpb25DaGFuZ2VkRXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfUEFHSU5BVElPTl9DSEFOR0VELFxuICAgICAgICAgICAgYW5pbWF0ZTogbW9kZWxVcGRhdGVkRXZlbnQgPyBtb2RlbFVwZGF0ZWRFdmVudC5hbmltYXRlIDogZmFsc2UsXG4gICAgICAgICAgICBuZXdEYXRhOiBtb2RlbFVwZGF0ZWRFdmVudCA/IG1vZGVsVXBkYXRlZEV2ZW50Lm5ld0RhdGEgOiBmYWxzZSxcbiAgICAgICAgICAgIG5ld1BhZ2U6IG1vZGVsVXBkYXRlZEV2ZW50ID8gbW9kZWxVcGRhdGVkRXZlbnQubmV3UGFnZSA6IGZhbHNlLFxuICAgICAgICAgICAga2VlcFJlbmRlcmVkUm93czogbW9kZWxVcGRhdGVkRXZlbnQgPyBtb2RlbFVwZGF0ZWRFdmVudC5rZWVwUmVuZGVyZWRSb3dzIDogZmFsc2UsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChwYWdpbmF0aW9uQ2hhbmdlZEV2ZW50KTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuZ29Ub1BhZ2UgPSBmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgPT09IHBhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gcGFnZTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX01PREVMX1VQREFURUQsXG4gICAgICAgICAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBSZW5kZXJlZFJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgbmV3RGF0YTogZmFsc2UsXG4gICAgICAgICAgICBuZXdQYWdlOiB0cnVlLFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Nb2RlbFVwZGF0ZWQoZXZlbnQpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZS5nZXRQaXhlbE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGl4ZWxPZmZzZXQ7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLmdldFJvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dNb2RlbC5nZXRSb3coaW5kZXgpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZS5nZXRSb3dJbmRleEF0UGl4ZWwgPSBmdW5jdGlvbiAocGl4ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93TW9kZWwuZ2V0Um93SW5kZXhBdFBpeGVsKHBpeGVsKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuZ2V0Q3VycmVudFBhZ2VIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh1dGlsc18xLl8ubWlzc2luZyh0aGlzLnRvcFJvd0JvdW5kcykgfHwgdXRpbHNfMS5fLm1pc3NpbmcodGhpcy5ib3R0b21Sb3dCb3VuZHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21Sb3dCb3VuZHMucm93VG9wICsgdGhpcy5ib3R0b21Sb3dCb3VuZHMucm93SGVpZ2h0IC0gdGhpcy50b3BSb3dCb3VuZHMucm93VG9wO1xuICAgIH07XG4gICAgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZS5pc1Jvd1ByZXNlbnQgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMucm93TW9kZWwuaXNSb3dQcmVzZW50KHJvd05vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGVJc0luUGFnZSA9IHJvd05vZGUucm93SW5kZXggPj0gdGhpcy50b3BSb3dJbmRleCAmJiByb3dOb2RlLnJvd0luZGV4IDw9IHRoaXMuYm90dG9tUm93SW5kZXg7XG4gICAgICAgIHJldHVybiBub2RlSXNJblBhZ2U7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd01vZGVsLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuaXNSb3dzVG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd01vZGVsLmlzUm93c1RvUmVuZGVyKCk7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLmdldE5vZGVzSW5SYW5nZUZvclNlbGVjdGlvbiA9IGZ1bmN0aW9uIChmaXJzdEluUmFuZ2UsIGxhc3RJblJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd01vZGVsLmdldE5vZGVzSW5SYW5nZUZvclNlbGVjdGlvbihmaXJzdEluUmFuZ2UsIGxhc3RJblJhbmdlKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuZm9yRWFjaE5vZGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93TW9kZWwuZm9yRWFjaE5vZGUoY2FsbGJhY2spO1xuICAgIH07XG4gICAgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dNb2RlbC5nZXRUeXBlKCk7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLmdldFJvd0JvdW5kcyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dNb2RlbC5nZXRSb3dCb3VuZHMoaW5kZXgpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZS5nZXRQYWdlRmlyc3RSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VTaXplICogdGhpcy5jdXJyZW50UGFnZTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuZ2V0UGFnZUxhc3RSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b3RhbExhc3RSb3cgPSAodGhpcy5wYWdlU2l6ZSAqICh0aGlzLmN1cnJlbnRQYWdlICsgMSkpIC0gMTtcbiAgICAgICAgdmFyIHBhZ2VMYXN0Um93ID0gdGhpcy5yb3dNb2RlbC5nZXRQYWdlTGFzdFJvdygpO1xuICAgICAgICBpZiAocGFnZUxhc3RSb3cgPiB0b3RhbExhc3RSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbExhc3RSb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFnZUxhc3RSb3c7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuZ2V0Um93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd01vZGVsLmdldFJvd0NvdW50KCk7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLmdvVG9QYWdlV2l0aEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFnZU51bWJlciA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnBhZ2VTaXplKTtcbiAgICAgICAgdGhpcy5nb1RvUGFnZShwYWdlTnVtYmVyKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuZ2V0VG90YWxSb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93TW9kZWwuZ2V0UGFnZUxhc3RSb3coKSArIDE7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLmlzTGFzdFBhZ2VGb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93TW9kZWwuaXNMYXN0Um93Rm91bmQoKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuZ2V0Q3VycmVudFBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYWdlO1xuICAgIH07XG4gICAgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZS5nb1RvTmV4dFBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ29Ub1BhZ2UodGhpcy5jdXJyZW50UGFnZSArIDEpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZS5nb1RvUHJldmlvdXNQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdvVG9QYWdlKHRoaXMuY3VycmVudFBhZ2UgLSAxKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuZ29Ub0ZpcnN0UGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nb1RvUGFnZSgwKTtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUuZ29Ub0xhc3RQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93Q291bnQgPSB0aGlzLnJvd01vZGVsLmdldFBhZ2VMYXN0Um93KCkgKyAxO1xuICAgICAgICB2YXIgbGFzdFBhZ2UgPSBNYXRoLmZsb29yKHJvd0NvdW50IC8gdGhpcy5wYWdlU2l6ZSk7XG4gICAgICAgIHRoaXMuZ29Ub1BhZ2UobGFzdFBhZ2UpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZS5nZXRQYWdlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZVNpemU7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLmdldFRvdGFsUGFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsUGFnZXM7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLnNldFBhZ2VTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBzaG93IHB1dCB0aGlzIGludG8gc3VwZXIgY2xhc3NcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldFBhZ2luYXRpb25QYWdlU2l6ZSgpO1xuICAgICAgICBpZiAoISh0aGlzLnBhZ2VTaXplID49IDEpKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2VTaXplID0gMTAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLnNldEluZGV4ZXNBbmRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRQYWdlU2l6ZSgpO1xuICAgICAgICAgICAgdmFyIHRvdGFsUm93Q291bnQgPSB0aGlzLmdldFRvdGFsUm93Q291bnQoKTtcbiAgICAgICAgICAgIHRoaXMudG90YWxQYWdlcyA9IE1hdGguZmxvb3IoKHRvdGFsUm93Q291bnQgLSAxKSAvIHRoaXMucGFnZVNpemUpICsgMTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlID49IHRoaXMudG90YWxQYWdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSB0aGlzLnRvdGFsUGFnZXMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1dGlsc18xLl8uaXNOdW1lcmljKHRoaXMuY3VycmVudFBhZ2UpIHx8IHRoaXMuY3VycmVudFBhZ2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRvcFJvd0luZGV4ID0gdGhpcy5wYWdlU2l6ZSAqIHRoaXMuY3VycmVudFBhZ2U7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbVJvd0luZGV4ID0gKHRoaXMucGFnZVNpemUgKiAodGhpcy5jdXJyZW50UGFnZSArIDEpKSAtIDE7XG4gICAgICAgICAgICB2YXIgbWF4Um93QWxsb3dlZCA9IHRoaXMucm93TW9kZWwuZ2V0UGFnZUxhc3RSb3coKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvdHRvbVJvd0luZGV4ID4gbWF4Um93QWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm90dG9tUm93SW5kZXggPSBtYXhSb3dBbGxvd2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHRoaXMucm93TW9kZWwuZ2V0UGFnZUxhc3RSb3coKSArIDE7XG4gICAgICAgICAgICB0aGlzLnRvdGFsUGFnZXMgPSAxO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IDA7XG4gICAgICAgICAgICB0aGlzLnRvcFJvd0luZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tUm93SW5kZXggPSB0aGlzLnJvd01vZGVsLmdldFBhZ2VMYXN0Um93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3BSb3dCb3VuZHMgPSB0aGlzLnJvd01vZGVsLmdldFJvd0JvdW5kcyh0aGlzLnRvcFJvd0luZGV4KTtcbiAgICAgICAgdGhpcy5ib3R0b21Sb3dCb3VuZHMgPSB0aGlzLnJvd01vZGVsLmdldFJvd0JvdW5kcyh0aGlzLmJvdHRvbVJvd0luZGV4KTtcbiAgICAgICAgdGhpcy5waXhlbE9mZnNldCA9IHV0aWxzXzEuXy5leGlzdHModGhpcy50b3BSb3dCb3VuZHMpID8gdGhpcy50b3BSb3dCb3VuZHMucm93VG9wIDogMDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdyb3dNb2RlbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBhZ2luYXRpb25Qcm94eS5wcm90b3R5cGUsIFwicm93TW9kZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZFBhbmVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkUGFuZWxfMS5HcmlkUGFuZWwpXG4gICAgXSwgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZSwgXCJncmlkUGFuZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnc2VsZWN0aW9uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgc2VsZWN0aW9uQ29udHJvbGxlcl8xLlNlbGVjdGlvbkNvbnRyb2xsZXIpXG4gICAgXSwgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZSwgXCJzZWxlY3Rpb25Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkFwaSlcbiAgICBdLCBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBQYWdpbmF0aW9uUHJveHkucHJvdG90eXBlLCBcImdyaWRBcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgUGFnaW5hdGlvblByb3h5LnByb3RvdHlwZSwgXCJwb3N0Q29uc3RydWN0XCIsIG51bGwpO1xuICAgIFBhZ2luYXRpb25Qcm94eSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbigncGFnaW5hdGlvblByb3h5JylcbiAgICBdLCBQYWdpbmF0aW9uUHJveHkpO1xuICAgIHJldHVybiBQYWdpbmF0aW9uUHJveHk7XG59KGJlYW5TdHViXzEuQmVhblN0dWIpKTtcbmV4cG9ydHMuUGFnaW5hdGlvblByb3h5ID0gUGFnaW5hdGlvblByb3h5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL3BhZ2luYXRpb25Qcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgcm93Tm9kZV8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL3Jvd05vZGVcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgY29udGV4dF8yID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi9ldmVudHNcIik7XG52YXIgY29udGV4dF8zID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi9ncmlkQXBpXCIpO1xudmFyIFBpbm5lZFJvd01vZGVsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQaW5uZWRSb3dNb2RlbCgpIHtcbiAgICB9XG4gICAgUGlubmVkUm93TW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0UGlubmVkVG9wUm93RGF0YSh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRQaW5uZWRUb3BSb3dEYXRhKCkpO1xuICAgICAgICB0aGlzLnNldFBpbm5lZEJvdHRvbVJvd0RhdGEodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0UGlubmVkQm90dG9tUm93RGF0YSgpKTtcbiAgICB9O1xuICAgIFBpbm5lZFJvd01vZGVsLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKGZsb2F0aW5nKSB7XG4gICAgICAgIHZhciByb3dzID0gZmxvYXRpbmcgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfVE9QID8gdGhpcy5waW5uZWRUb3BSb3dzIDogdGhpcy5waW5uZWRCb3R0b21Sb3dzO1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5VdGlscy5taXNzaW5nT3JFbXB0eShyb3dzKTtcbiAgICB9O1xuICAgIFBpbm5lZFJvd01vZGVsLnByb3RvdHlwZS5pc1Jvd3NUb1JlbmRlciA9IGZ1bmN0aW9uIChmbG9hdGluZykge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNFbXB0eShmbG9hdGluZyk7XG4gICAgfTtcbiAgICBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUuZ2V0Um93QXRQaXhlbCA9IGZ1bmN0aW9uIChwaXhlbCwgZmxvYXRpbmcpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBmbG9hdGluZyA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9UT1AgPyB0aGlzLnBpbm5lZFRvcFJvd3MgOiB0aGlzLnBpbm5lZEJvdHRvbVJvd3M7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmdPckVtcHR5KHJvd3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBqdXN0IGluIGNhc2UsIDAgaXMgZ3JhY2VmdWwgZmFpbHVyZVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJvd05vZGUgPSByb3dzW2ldO1xuICAgICAgICAgICAgdmFyIHJvd1RvcFBpeGVsID0gcm93Tm9kZS5yb3dUb3AgKyByb3dOb2RlLnJvd0hlaWdodCAtIDE7XG4gICAgICAgICAgICAvLyBvbmx5IG5lZWQgdG8gcmFuZ2UgY2hlY2sgYWdhaW5zdCB0aGUgdG9wIHBpeGVsLCBhcyB3ZSBhcmUgZ29pbmcgdGhyb3VnaCB0aGUgbGlzdFxuICAgICAgICAgICAgLy8gaW4gb3JkZXIsIGZpcnN0IHJvdyB0byBoaXQgdGhlIHBpeGVsIHdpbnNcbiAgICAgICAgICAgIGlmIChyb3dUb3BQaXhlbCA+PSBwaXhlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dzLmxlbmd0aCAtIDE7XG4gICAgfTtcbiAgICBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUuc2V0UGlubmVkVG9wUm93RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhKSB7XG4gICAgICAgIHRoaXMucGlubmVkVG9wUm93cyA9IHRoaXMuY3JlYXRlTm9kZXNGcm9tRGF0YShyb3dEYXRhLCB0cnVlKTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1BJTk5FRF9ST1dfREFUQV9DSEFOR0VELFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgUGlubmVkUm93TW9kZWwucHJvdG90eXBlLnNldFBpbm5lZEJvdHRvbVJvd0RhdGEgPSBmdW5jdGlvbiAocm93RGF0YSkge1xuICAgICAgICB0aGlzLnBpbm5lZEJvdHRvbVJvd3MgPSB0aGlzLmNyZWF0ZU5vZGVzRnJvbURhdGEocm93RGF0YSwgZmFsc2UpO1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfUElOTkVEX1JPV19EQVRBX0NIQU5HRUQsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcbiAgICBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUuY3JlYXRlTm9kZXNGcm9tRGF0YSA9IGZ1bmN0aW9uIChhbGxEYXRhLCBpc1RvcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcm93Tm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKGFsbERhdGEpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Um93VG9wXzEgPSAwO1xuICAgICAgICAgICAgYWxsRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93Tm9kZSA9IG5ldyByb3dOb2RlXzEuUm93Tm9kZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQud2lyZUJlYW4ocm93Tm9kZSk7XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5kYXRhID0gZGF0YUl0ZW07XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5yb3dQaW5uZWQgPSBpc1RvcCA/IGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfVE9QIDogY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9CT1RUT007XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5zZXRSb3dUb3AobmV4dFJvd1RvcF8xKTtcbiAgICAgICAgICAgICAgICByb3dOb2RlLnNldFJvd0hlaWdodChfdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Um93SGVpZ2h0Rm9yTm9kZShyb3dOb2RlKSk7XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5zZXRSb3dJbmRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgbmV4dFJvd1RvcF8xICs9IHJvd05vZGUucm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHJvd05vZGVzLnB1c2gocm93Tm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93Tm9kZXM7XG4gICAgfTtcbiAgICBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUuZ2V0UGlubmVkVG9wUm93RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlubmVkVG9wUm93cztcbiAgICB9O1xuICAgIFBpbm5lZFJvd01vZGVsLnByb3RvdHlwZS5nZXRQaW5uZWRCb3R0b21Sb3dEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waW5uZWRCb3R0b21Sb3dzO1xuICAgIH07XG4gICAgUGlubmVkUm93TW9kZWwucHJvdG90eXBlLmdldFBpbm5lZFRvcFRvdGFsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb3RhbEhlaWdodCh0aGlzLnBpbm5lZFRvcFJvd3MpO1xuICAgIH07XG4gICAgUGlubmVkUm93TW9kZWwucHJvdG90eXBlLmdldFBpbm5lZFRvcFJvd0NvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waW5uZWRUb3BSb3dzID8gdGhpcy5waW5uZWRUb3BSb3dzLmxlbmd0aCA6IDA7XG4gICAgfTtcbiAgICBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUuZ2V0UGlubmVkQm90dG9tUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbm5lZEJvdHRvbVJvd3MgPyB0aGlzLnBpbm5lZEJvdHRvbVJvd3MubGVuZ3RoIDogMDtcbiAgICB9O1xuICAgIFBpbm5lZFJvd01vZGVsLnByb3RvdHlwZS5nZXRQaW5uZWRUb3BSb3cgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlubmVkVG9wUm93c1tpbmRleF07XG4gICAgfTtcbiAgICBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUuZ2V0UGlubmVkQm90dG9tUm93ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbm5lZEJvdHRvbVJvd3NbaW5kZXhdO1xuICAgIH07XG4gICAgUGlubmVkUm93TW9kZWwucHJvdG90eXBlLmZvckVhY2hQaW5uZWRUb3BSb3cgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZ09yRW1wdHkodGhpcy5waW5uZWRUb3BSb3dzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGlubmVkVG9wUm93cy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFBpbm5lZFJvd01vZGVsLnByb3RvdHlwZS5mb3JFYWNoUGlubmVkQm90dG9tUm93ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmdPckVtcHR5KHRoaXMucGlubmVkQm90dG9tUm93cykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpbm5lZEJvdHRvbVJvd3MuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUuZ2V0UGlubmVkQm90dG9tVG90YWxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRvdGFsSGVpZ2h0KHRoaXMucGlubmVkQm90dG9tUm93cyk7XG4gICAgfTtcbiAgICBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUuZ2V0VG90YWxIZWlnaHQgPSBmdW5jdGlvbiAocm93Tm9kZXMpIHtcbiAgICAgICAgaWYgKCFyb3dOb2RlcyB8fCByb3dOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gcm93Tm9kZXNbcm93Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gbGFzdE5vZGUucm93VG9wICsgbGFzdE5vZGUucm93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8yLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgUGlubmVkUm93TW9kZWwucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzIuQXV0b3dpcmVkKCdldmVudFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSlcbiAgICBdLCBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMi5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIFBpbm5lZFJvd01vZGVsLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMi5BdXRvd2lyZWQoJ2NvbHVtbkFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkFwaSlcbiAgICBdLCBQaW5uZWRSb3dNb2RlbC5wcm90b3R5cGUsIFwiY29sdW1uQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMi5BdXRvd2lyZWQoJ2dyaWRBcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRBcGlfMS5HcmlkQXBpKVxuICAgIF0sIFBpbm5lZFJvd01vZGVsLnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMy5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIFBpbm5lZFJvd01vZGVsLnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIFBpbm5lZFJvd01vZGVsID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdwaW5uZWRSb3dNb2RlbCcpXG4gICAgXSwgUGlubmVkUm93TW9kZWwpO1xuICAgIHJldHVybiBQaW5uZWRSb3dNb2RlbDtcbn0oKSk7XG5leHBvcnRzLlBpbm5lZFJvd01vZGVsID0gUGlubmVkUm93TW9kZWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dNb2RlbHMvcGlubmVkUm93TW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGNvbHVtbkdyb3VwXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvY29sdW1uR3JvdXBcIik7XG52YXIgb3JpZ2luYWxDb2x1bW5Hcm91cF8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL29yaWdpbmFsQ29sdW1uR3JvdXBcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb250ZXh0XzIgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xuLy8gdGFrZXMgaW4gYSBsaXN0IG9mIGNvbHVtbnMsIGFzIHNwZWNpZmllZCBieSB0aGUgY29sdW1uIGRlZmluaXRpb25zLCBhbmQgcmV0dXJucyBjb2x1bW4gZ3JvdXBzXG52YXIgQ29sdW1uVXRpbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbHVtblV0aWxzKCkge1xuICAgIH1cbiAgICBDb2x1bW5VdGlscy5wcm90b3R5cGUuY2FsY3VsYXRlQ29sSW5pdGlhbFdpZHRoID0gZnVuY3Rpb24gKGNvbERlZikge1xuICAgICAgICBpZiAoIWNvbERlZi53aWR0aCkge1xuICAgICAgICAgICAgLy8gaWYgbm8gd2lkdGggZGVmaW5lZCBpbiBjb2xEZWYsIHVzZSBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29sV2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2xEZWYud2lkdGggPCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRNaW5Db2xXaWR0aCgpKSB7XG4gICAgICAgICAgICAvLyBpZiB3aWR0aCBpbiBjb2wgZGVmIHRvIHNtYWxsLCBzZXQgdG8gbWluIHdpZHRoXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TWluQ29sV2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIHByb3ZpZGVkIHdpZHRoXG4gICAgICAgICAgICByZXR1cm4gY29sRGVmLndpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5VdGlscy5wcm90b3R5cGUuZ2V0T3JpZ2luYWxQYXRoRm9yQ29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbiwgb3JpZ2luYWxCYWxhbmNlZFRyZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgcmVjdXJzZVBhdGgob3JpZ2luYWxCYWxhbmNlZFRyZWUsIDApO1xuICAgICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgdGhlIHBhdGgsIGJ1dCBpbiBjYXNlIHRoZXJlIGlzIGEgYnVnIHNvbWV3aGVyZSwgcmV0dXJuaW5nIG51bGxcbiAgICAgICAgLy8gd2lsbCBtYWtlIGl0IGZhaWwgcmF0aGVyIHRoYW4gcHJvdmlkZSBhICdoYXJkIHRvIHRyYWNrIGRvd24nIGJ1Z1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWN1cnNlUGF0aChiYWxhbmNlZENvbHVtblRyZWUsIGRlcHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFsYW5jZWRDb2x1bW5UcmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHF1aXQgdGhlIHNlYXJjaCwgc28gJ3Jlc3VsdCcgaXMga2VwdCB3aXRoIHRoZSBmb3VuZCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGJhbGFuY2VkQ29sdW1uVHJlZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG9yaWdpbmFsQ29sdW1uR3JvdXBfMS5PcmlnaW5hbENvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2VQYXRoKG5leHROb2RlLmdldENoaWxkcmVuKCksIGRlcHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2RlcHRdID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogICAgcHVibGljIGdldFBhdGhGb3JDb2x1bW4oY29sdW1uOiBDb2x1bW4sIGFsbERpc3BsYXllZENvbHVtbkdyb3VwczogQ29sdW1uR3JvdXBDaGlsZFtdKTogQ29sdW1uR3JvdXBbXSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0OiBDb2x1bW5Hcm91cFtdID0gW107XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBcbiAgICAgICAgICAgIHJlY3Vyc2VQYXRoKGFsbERpc3BsYXllZENvbHVtbkdyb3VwcywgMCk7XG4gICAgXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgdGhlIHBhdGgsIGJ1dCBpbiBjYXNlIHRoZXJlIGlzIGEgYnVnIHNvbWV3aGVyZSwgcmV0dXJuaW5nIG51bGxcbiAgICAgICAgICAgIC8vIHdpbGwgbWFrZSBpdCBmYWlsIHJhdGhlciB0aGFuIHByb3ZpZGUgYSAnaGFyZCB0byB0cmFjayBkb3duJyBidWdcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gcmVjdXJzZVBhdGgoYmFsYW5jZWRDb2x1bW5UcmVlOiBDb2x1bW5Hcm91cENoaWxkW10sIGRlcHQ6IG51bWJlcik6IHZvaWQge1xuICAgIFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpPGJhbGFuY2VkQ29sdW1uVHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHF1aXQgdGhlIHNlYXJjaCwgc28gJ3Jlc3VsdCcgaXMga2VwdCB3aXRoIHRoZSBmb3VuZCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGJhbGFuY2VkQ29sdW1uVHJlZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHROb2RlID0gPENvbHVtbkdyb3VwPiBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZVBhdGgobmV4dE5vZGUuZ2V0Q2hpbGRyZW4oKSwgZGVwdCsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtkZXB0XSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9Ki9cbiAgICBDb2x1bW5VdGlscy5wcm90b3R5cGUuZGVwdGhGaXJzdE9yaWdpbmFsVHJlZVNlYXJjaCA9IGZ1bmN0aW9uICh0cmVlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRyZWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmVlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBvcmlnaW5hbENvbHVtbkdyb3VwXzEuT3JpZ2luYWxDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRlcHRoRmlyc3RPcmlnaW5hbFRyZWVTZWFyY2goY2hpbGQuZ2V0Q2hpbGRyZW4oKSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbHVtblV0aWxzLnByb3RvdHlwZS5kZXB0aEZpcnN0QWxsQ29sdW1uVHJlZVNlYXJjaCA9IGZ1bmN0aW9uICh0cmVlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRyZWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmVlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBjb2x1bW5Hcm91cF8xLkNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVwdGhGaXJzdEFsbENvbHVtblRyZWVTZWFyY2goY2hpbGQuZ2V0Q2hpbGRyZW4oKSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbHVtblV0aWxzLnByb3RvdHlwZS5kZXB0aEZpcnN0RGlzcGxheWVkQ29sdW1uVHJlZVNlYXJjaCA9IGZ1bmN0aW9uICh0cmVlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRyZWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmVlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBjb2x1bW5Hcm91cF8xLkNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVwdGhGaXJzdERpc3BsYXllZENvbHVtblRyZWVTZWFyY2goY2hpbGQuZ2V0RGlzcGxheWVkQ2hpbGRyZW4oKSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzIuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBDb2x1bW5VdGlscy5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgQ29sdW1uVXRpbHMgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2NvbHVtblV0aWxzJylcbiAgICBdLCBDb2x1bW5VdGlscyk7XG4gICAgcmV0dXJuIENvbHVtblV0aWxzO1xufSgpKTtcbmV4cG9ydHMuQ29sdW1uVXRpbHMgPSBDb2x1bW5VdGlscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29sdW1uR3JvdXBfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbkdyb3VwXCIpO1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4vY29sdW1uXCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2V2ZW50U2VydmljZVwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgZ3JpZEFwaV8xID0gcmVxdWlyZShcIi4uL2dyaWRBcGlcIik7XG52YXIgT3JpZ2luYWxDb2x1bW5Hcm91cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3JpZ2luYWxDb2x1bW5Hcm91cChjb2xHcm91cERlZiwgZ3JvdXBJZCwgcGFkZGluZykge1xuICAgICAgICB0aGlzLmxvY2FsRXZlbnRTZXJ2aWNlID0gbmV3IGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSgpO1xuICAgICAgICB0aGlzLmV4cGFuZGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2xHcm91cERlZiA9IGNvbEdyb3VwRGVmO1xuICAgICAgICB0aGlzLmdyb3VwSWQgPSBncm91cElkO1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gY29sR3JvdXBEZWYgJiYgISFjb2xHcm91cERlZi5vcGVuQnlEZWZhdWx0O1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIH1cbiAgICBPcmlnaW5hbENvbHVtbkdyb3VwLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBjaGlsZCBpcyB2aXNpYmxlXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQuaXNWaXNpYmxlKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPcmlnaW5hbENvbHVtbkdyb3VwLnByb3RvdHlwZS5pc1BhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZGRpbmc7XG4gICAgfTtcbiAgICBPcmlnaW5hbENvbHVtbkdyb3VwLnByb3RvdHlwZS5zZXRFeHBhbmRlZCA9IGZ1bmN0aW9uIChleHBhbmRlZCkge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZXhwYW5kZWQ7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IE9yaWdpbmFsQ29sdW1uR3JvdXAuRVZFTlRfRVhQQU5ERURfQ0hBTkdFRFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvY2FsRXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgT3JpZ2luYWxDb2x1bW5Hcm91cC5wcm90b3R5cGUuaXNFeHBhbmRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlO1xuICAgIH07XG4gICAgT3JpZ2luYWxDb2x1bW5Hcm91cC5wcm90b3R5cGUuaXNFeHBhbmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kZWQ7XG4gICAgfTtcbiAgICBPcmlnaW5hbENvbHVtbkdyb3VwLnByb3RvdHlwZS5nZXRHcm91cElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cElkO1xuICAgIH07XG4gICAgT3JpZ2luYWxDb2x1bW5Hcm91cC5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyb3VwSWQoKTtcbiAgICB9O1xuICAgIE9yaWdpbmFsQ29sdW1uR3JvdXAucHJvdG90eXBlLnNldENoaWxkcmVuID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9O1xuICAgIE9yaWdpbmFsQ29sdW1uR3JvdXAucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICB9O1xuICAgIE9yaWdpbmFsQ29sdW1uR3JvdXAucHJvdG90eXBlLmdldENvbEdyb3VwRGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xHcm91cERlZjtcbiAgICB9O1xuICAgIE9yaWdpbmFsQ29sdW1uR3JvdXAucHJvdG90eXBlLmdldExlYWZDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuYWRkTGVhZkNvbHVtbnMocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE9yaWdpbmFsQ29sdW1uR3JvdXAucHJvdG90eXBlLmFkZExlYWZDb2x1bW5zID0gZnVuY3Rpb24gKGxlYWZDb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIGNvbHVtbl8xLkNvbHVtbikge1xuICAgICAgICAgICAgICAgIGxlYWZDb2x1bW5zLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBPcmlnaW5hbENvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYWRkTGVhZkNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9yaWdpbmFsQ29sdW1uR3JvdXAucHJvdG90eXBlLmdldENvbHVtbkdyb3VwU2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbEdyb3VwRGVmLmNvbHVtbkdyb3VwU2hvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgcGFkZGluZyB3ZSBoYXZlIGV4YWN0bHkgb25seSBjaGlsZC4gd2UgdGhlblxuICAgICAgICAgICAgLy8gdGFrZSB0aGUgdmFsdWUgZnJvbSB0aGUgY2hpbGQgYW5kIHB1c2ggaXQgdXAsIG1ha2luZ1xuICAgICAgICAgICAgLy8gdGhpcyBncm91cCAnaW52aXNpYmxlJy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdLmdldENvbHVtbkdyb3VwU2hvdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBuZWVkIHRvIGNoZWNrIHRoYXQgdGhpcyBncm91cCBoYXMgYXQgbGVhc3Qgb25lIGNvbCBzaG93aW5nIHdoZW4gYm90aCBleHBhbmRlZCBhbmQgY29udHJhY3RlZC5cbiAgICAvLyBpZiBub3QsIHRoZW4gd2UgZG9uJ3QgYWxsb3cgZXhwYW5kaW5nIGFuZCBjb250cmFjdGluZyBvbiB0aGlzIGdyb3VwXG4gICAgT3JpZ2luYWxDb2x1bW5Hcm91cC5wcm90b3R5cGUuc2V0dXBFeHBhbmRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNldEV4cGFuZGFibGUoKTtcbiAgICAgICAgLy8gbm90ZSAtIHdlIHNob3VsZCBiZSByZW1vdmluZyB0aGlzIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgIHRoaXMuZ2V0TGVhZkNvbHVtbnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHsgcmV0dXJuIGNvbC5hZGRFdmVudExpc3RlbmVyKGNvbHVtbl8xLkNvbHVtbi5FVkVOVF9WSVNJQkxFX0NIQU5HRUQsIF90aGlzLm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZWQuYmluZChfdGhpcykpOyB9KTtcbiAgICB9O1xuICAgIE9yaWdpbmFsQ29sdW1uR3JvdXAucHJvdG90eXBlLnNldEV4cGFuZGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdhbnQgdG8gbWFrZSBzdXJlIHRoZSBncm91cCBkb2Vzbid0IGRpc2FwcGVhciB3aGVuIGl0J3Mgb3BlblxuICAgICAgICB2YXIgYXRMZWFzdE9uZVNob3dpbmdXaGVuT3BlbiA9IGZhbHNlO1xuICAgICAgICAvLyB3YW50IHRvIG1ha2Ugc3VyZSB0aGUgZ3JvdXAgZG9lc24ndCBkaXNhcHBlYXIgd2hlbiBpdCdzIGNsb3NlZFxuICAgICAgICB2YXIgYXRMZWFzdE9uZVNob3dpbmdXaGVuQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIHdhbnQgdG8gbWFrZSBzdXJlIHRoZSBncm91cCBoYXMgc29tZXRoaW5nIHRvIHNob3cgLyBoaWRlXG4gICAgICAgIHZhciBhdExlYXN0T25lQ2hhbmdlYWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYWJzdHJhY3RDb2x1bW4gPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKCFhYnN0cmFjdENvbHVtbi5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIGFic3RyYWN0Q29sdW1uIGlzIGEgZ3JpZCBnZW5lcmF0ZWQgZ3JvdXAsIHRoZXJlIHdpbGwgYmUgbm8gY29sRGVmXG4gICAgICAgICAgICB2YXIgaGVhZGVyR3JvdXBTaG93ID0gYWJzdHJhY3RDb2x1bW4uZ2V0Q29sdW1uR3JvdXBTaG93KCk7XG4gICAgICAgICAgICBpZiAoaGVhZGVyR3JvdXBTaG93ID09PSBjb2x1bW5Hcm91cF8xLkNvbHVtbkdyb3VwLkhFQURFUl9HUk9VUF9TSE9XX09QRU4pIHtcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lU2hvd2luZ1doZW5PcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lQ2hhbmdlYWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZWFkZXJHcm91cFNob3cgPT09IGNvbHVtbkdyb3VwXzEuQ29sdW1uR3JvdXAuSEVBREVSX0dST1VQX1NIT1dfQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgYXRMZWFzdE9uZVNob3dpbmdXaGVuQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lQ2hhbmdlYWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lU2hvd2luZ1doZW5PcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lU2hvd2luZ1doZW5DbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBleHBhbmRhYmxlID0gYXRMZWFzdE9uZVNob3dpbmdXaGVuT3BlbiAmJiBhdExlYXN0T25lU2hvd2luZ1doZW5DbG9zZWQgJiYgYXRMZWFzdE9uZUNoYW5nZWFibGU7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGFibGUgIT09IGV4cGFuZGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kYWJsZSA9IGV4cGFuZGFibGU7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBPcmlnaW5hbENvbHVtbkdyb3VwLkVWRU5UX0VYUEFOREFCTEVfQ0hBTkdFRFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxFdmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudF8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3JpZ2luYWxDb2x1bW5Hcm91cC5wcm90b3R5cGUub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRFeHBhbmRhYmxlKCk7XG4gICAgfTtcbiAgICBPcmlnaW5hbENvbHVtbkdyb3VwLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5sb2NhbEV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgT3JpZ2luYWxDb2x1bW5Hcm91cC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubG9jYWxFdmVudFNlcnZpY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIE9yaWdpbmFsQ29sdW1uR3JvdXAuRVZFTlRfRVhQQU5ERURfQ0hBTkdFRCA9ICdleHBhbmRlZENoYW5nZWQnO1xuICAgIE9yaWdpbmFsQ29sdW1uR3JvdXAuRVZFTlRfRVhQQU5EQUJMRV9DSEFOR0VEID0gJ2V4cGFuZGFibGVDaGFuZ2VkJztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIE9yaWdpbmFsQ29sdW1uR3JvdXAucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBPcmlnaW5hbENvbHVtbkdyb3VwLnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIE9yaWdpbmFsQ29sdW1uR3JvdXA7XG59KCkpO1xuZXhwb3J0cy5PcmlnaW5hbENvbHVtbkdyb3VwID0gT3JpZ2luYWxDb2x1bW5Hcm91cDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2VudGl0aWVzL29yaWdpbmFsQ29sdW1uR3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgcm93UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmluZy9yb3dSZW5kZXJlclwiKTtcbnZhciBmaWx0ZXJNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXIvZmlsdGVyTWFuYWdlclwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2V2ZW50U2VydmljZVwiKTtcbnZhciBncmlkUGFuZWxfMSA9IHJlcXVpcmUoXCIuL2dyaWRQYW5lbC9ncmlkUGFuZWxcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgcG9wdXBTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi93aWRnZXRzL3BvcHVwU2VydmljZVwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgYm9yZGVyTGF5b3V0XzEgPSByZXF1aXJlKFwiLi9sYXlvdXQvYm9yZGVyTGF5b3V0XCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBmb2N1c2VkQ2VsbENvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL2ZvY3VzZWRDZWxsQ29udHJvbGxlclwiKTtcbnZhciBjb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuL3dpZGdldHMvY29tcG9uZW50XCIpO1xudmFyIHBhZ2luYXRpb25Db21wXzEgPSByZXF1aXJlKFwiLi9yb3dNb2RlbHMvcGFnaW5hdGlvbi9wYWdpbmF0aW9uQ29tcFwiKTtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi9ncmlkQXBpXCIpO1xudmFyIEdyaWRDb3JlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmlkQ29yZShsb2dnZXJGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlckZhY3RvcnkuY3JlYXRlKCdHcmlkQ29yZScpO1xuICAgIH1cbiAgICBHcmlkQ29yZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVTb3V0aFBhbmVsID0gdGhpcy5jcmVhdGVTb3V0aFBhbmVsKCk7XG4gICAgICAgIHZhciBlYXN0UGFuZWw7XG4gICAgICAgIHZhciB3ZXN0UGFuZWw7XG4gICAgICAgIGlmICh0aGlzLnRvb2xQYW5lbCAmJiAhdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNGb3JQcmludCgpKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgZG9pbmcgUlRMLCB0aGVuIHRoZSB0b29sIHBhbmVsIGFwcGVhcnMgb24gdGhlIGxlZnRcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVJ0bCgpKSB7XG4gICAgICAgICAgICAgICAgd2VzdFBhbmVsID0gdGhpcy50b29sUGFuZWwuZ2V0R3VpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlYXN0UGFuZWwgPSB0aGlzLnRvb2xQYW5lbC5nZXRHdWkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3JlYXRlVG9wUGFuZWxHdWkgPSB0aGlzLmNyZWF0ZU5vcnRoUGFuZWwoKTtcbiAgICAgICAgdGhpcy5lUm9vdFBhbmVsID0gbmV3IGJvcmRlckxheW91dF8xLkJvcmRlckxheW91dCh7XG4gICAgICAgICAgICBjZW50ZXI6IHRoaXMuZ3JpZFBhbmVsLmdldExheW91dCgpLFxuICAgICAgICAgICAgZWFzdDogZWFzdFBhbmVsLFxuICAgICAgICAgICAgd2VzdDogd2VzdFBhbmVsLFxuICAgICAgICAgICAgbm9ydGg6IGNyZWF0ZVRvcFBhbmVsR3VpLFxuICAgICAgICAgICAgc291dGg6IGVTb3V0aFBhbmVsLFxuICAgICAgICAgICAgZG9udEZpbGw6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKSxcbiAgICAgICAgICAgIGZpbGxIb3Jpem9udGFsT25seTogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNBdXRvSGVpZ2h0KCksXG4gICAgICAgICAgICBuYW1lOiAnZVJvb3RQYW5lbCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHBhcnRzIG9mIHRoZSBDU1MgbmVlZCB0byBrbm93IGlmIHdlIGFyZSBpbiAnZm9yIHByaW50JyBtb2RlIG9yIG5vdCxcbiAgICAgICAgLy8gc28gd2UgYWRkIGEgY2xhc3MgdG8gYWxsb3cgYXBwbHlpbmcgQ1NTIGJhc2VkIG9uIHRoaXMuXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0ZvclByaW50KCkpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkQ3NzQ2xhc3ModGhpcy5lUm9vdFBhbmVsLmdldEd1aSgpLCAnYWctbGF5b3V0LWZvci1wcmludCcpO1xuICAgICAgICAgICAgLy8ga2VwdCB0byBsaW1pdCBicmVha2luZyBjaGFuZ2VzLCBhZy1uby1zY3JvbGxzIHdhcyByZW5hbWVkIHRvIGFnLWxheW91dC1mb3ItcHJpbnRcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkQ3NzQ2xhc3ModGhpcy5lUm9vdFBhbmVsLmdldEd1aSgpLCAnYWctbm8tc2Nyb2xscycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzQXV0b0hlaWdodCgpKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZENzc0NsYXNzKHRoaXMuZVJvb3RQYW5lbC5nZXRHdWkoKSwgJ2FnLWxheW91dC1hdXRvLWhlaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRDc3NDbGFzcyh0aGlzLmVSb290UGFuZWwuZ2V0R3VpKCksICdhZy1sYXlvdXQtbm9ybWFsJyk7XG4gICAgICAgICAgICAvLyBrZXB0IHRvIGxpbWl0IGJyZWFraW5nIGNoYW5nZXMsIGFnLXNjcm9sbHMgd2FzIHJlbmFtZWQgdG8gYWctbGF5b3V0LW5vcm1hbFxuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRDc3NDbGFzcyh0aGlzLmVSb290UGFuZWwuZ2V0R3VpKCksICdhZy1zY3JvbGxzJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VlIHdoYXQgdGhlIGdyaWQgb3B0aW9ucyBhcmUgZm9yIGRlZmF1bHQgb2YgdG9vbGJhclxuICAgICAgICB0aGlzLnNob3dUb29sUGFuZWwodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTaG93VG9vbFBhbmVsKCkpO1xuICAgICAgICB0aGlzLmVHcmlkRGl2LmFwcGVuZENoaWxkKHRoaXMuZVJvb3RQYW5lbC5nZXRHdWkoKSk7XG4gICAgICAgIC8vIGlmIHVzaW5nIGFuZ3VsYXIsIHdhdGNoIGZvciBxdWlja0ZpbHRlciBjaGFuZ2VzXG4gICAgICAgIGlmICh0aGlzLiRzY29wZSkge1xuICAgICAgICAgICAgdGhpcy4kc2NvcGUuJHdhdGNoKHRoaXMucXVpY2tGaWx0ZXJPblNjb3BlLCBmdW5jdGlvbiAobmV3RmlsdGVyKSB7IHJldHVybiBfdGhpcy5maWx0ZXJNYW5hZ2VyLnNldFF1aWNrRmlsdGVyKG5ld0ZpbHRlcik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNGb3JQcmludCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvd1Jlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIHNldCBydGwgYmVmb3JlIGRvTGF5b3V0LCBhcyBzZXR0aW5nIHRoZSBSVEwgY2xhc3MgaW1wYWN0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uLFxuICAgICAgICAvLyB3aGljaCBkb0xheW91dCBpbmRpcmVjdGx5IGRlcGVuZHMgb25cbiAgICAgICAgdGhpcy5hZGRSdGxTdXBwb3J0KCk7XG4gICAgICAgIHRoaXMuZG9MYXlvdXQoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlcmlvZGljYWxseURvTGF5b3V0KCk7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9ST1dfR1JPVVBfQ0hBTkdFRCwgdGhpcy5vblJvd0dyb3VwQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX0VWRVJZVEhJTkdfQ0hBTkdFRCwgdGhpcy5vblJvd0dyb3VwQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vblJvd0dyb3VwQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3JlYWR5Jyk7XG4gICAgfTtcbiAgICBHcmlkQ29yZS5wcm90b3R5cGUuYWRkUnRsU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCkpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkQ3NzQ2xhc3ModGhpcy5lUm9vdFBhbmVsLmdldEd1aSgpLCAnYWctcnRsJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZENzc0NsYXNzKHRoaXMuZVJvb3RQYW5lbC5nZXRHdWkoKSwgJ2FnLWx0cicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkQ29yZS5wcm90b3R5cGUuY3JlYXRlTm9ydGhQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VudGVycHJpc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcFBhbmVsR3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBkcm9wUGFuZWxWaXNpYmxlTGlzdGVuZXIgPSB0aGlzLm9uRHJvcFBhbmVsVmlzaWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJvd0dyb3VwQ29tcCA9IHRoaXMucm93R3JvdXBDb21wRmFjdG9yeS5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5waXZvdENvbXAgPSB0aGlzLnBpdm90Q29tcEZhY3RvcnkuY3JlYXRlKCk7XG4gICAgICAgIHRvcFBhbmVsR3VpLmFwcGVuZENoaWxkKHRoaXMucm93R3JvdXBDb21wLmdldEd1aSgpKTtcbiAgICAgICAgdG9wUGFuZWxHdWkuYXBwZW5kQ2hpbGQodGhpcy5waXZvdENvbXAuZ2V0R3VpKCkpO1xuICAgICAgICB0aGlzLnJvd0dyb3VwQ29tcC5hZGRFdmVudExpc3RlbmVyKGNvbXBvbmVudF8xLkNvbXBvbmVudC5FVkVOVF9WSVNJQkxFX0NIQU5HRUQsIGRyb3BQYW5lbFZpc2libGVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMucGl2b3RDb21wLmFkZEV2ZW50TGlzdGVuZXIoY29tcG9uZW50XzEuQ29tcG9uZW50LkVWRU5UX1ZJU0lCTEVfQ0hBTkdFRCwgZHJvcFBhbmVsVmlzaWJsZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5kZXN0cm95RnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucm93R3JvdXBDb21wLnJlbW92ZUV2ZW50TGlzdGVuZXIoY29tcG9uZW50XzEuQ29tcG9uZW50LkVWRU5UX1ZJU0lCTEVfQ0hBTkdFRCwgZHJvcFBhbmVsVmlzaWJsZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIF90aGlzLnBpdm90Q29tcC5yZW1vdmVFdmVudExpc3RlbmVyKGNvbXBvbmVudF8xLkNvbXBvbmVudC5FVkVOVF9WSVNJQkxFX0NIQU5HRUQsIGRyb3BQYW5lbFZpc2libGVMaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uRHJvcFBhbmVsVmlzaWJsZSgpO1xuICAgICAgICByZXR1cm4gdG9wUGFuZWxHdWk7XG4gICAgfTtcbiAgICBHcmlkQ29yZS5wcm90b3R5cGUub25Ecm9wUGFuZWxWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm90aFZpc2libGUgPSB0aGlzLnJvd0dyb3VwQ29tcC5pc1Zpc2libGUoKSAmJiB0aGlzLnBpdm90Q29tcC5pc1Zpc2libGUoKTtcbiAgICAgICAgdGhpcy5yb3dHcm91cENvbXAuYWRkT3JSZW1vdmVDc3NDbGFzcygnYWctd2lkdGgtaGFsZicsIGJvdGhWaXNpYmxlKTtcbiAgICAgICAgdGhpcy5waXZvdENvbXAuYWRkT3JSZW1vdmVDc3NDbGFzcygnYWctd2lkdGgtaGFsZicsIGJvdGhWaXNpYmxlKTtcbiAgICB9O1xuICAgIEdyaWRDb3JlLnByb3RvdHlwZS5nZXRSb290R3VpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lUm9vdFBhbmVsLmdldEd1aSgpO1xuICAgIH07XG4gICAgR3JpZENvcmUucHJvdG90eXBlLmNyZWF0ZVNvdXRoUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0dXNCYXIgJiYgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVTdGF0dXNCYXIoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBzdGF0dXMgYmFyIGlzIG9ubHkgYXZhaWxhYmxlIGluIGFnLUdyaWQtRW50ZXJwcmlzZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0dXNCYXJFbmFibGVkID0gdGhpcy5zdGF0dXNCYXIgJiYgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVTdGF0dXNCYXIoKTtcbiAgICAgICAgdmFyIGlzUGFnaW5nID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNQYWdpbmF0aW9uKCk7XG4gICAgICAgIHZhciBwYWdpbmF0aW9uUGFuZWxFbmFibGVkID0gaXNQYWdpbmdcbiAgICAgICAgICAgICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0ZvclByaW50KClcbiAgICAgICAgICAgICYmICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzUGFnaW5hdGlvblBhbmVsKCk7XG4gICAgICAgIGlmICghc3RhdHVzQmFyRW5hYmxlZCAmJiAhcGFnaW5hdGlvblBhbmVsRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVTb3V0aFBhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGlmIChzdGF0dXNCYXJFbmFibGVkKSB7XG4gICAgICAgICAgICBlU291dGhQYW5lbC5hcHBlbmRDaGlsZCh0aGlzLnN0YXR1c0Jhci5nZXRHdWkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZ2luYXRpb25QYW5lbEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBwYWdpbmF0aW9uQ29tcCA9IG5ldyBwYWdpbmF0aW9uQ29tcF8xLlBhZ2luYXRpb25Db21wKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQud2lyZUJlYW4ocGFnaW5hdGlvbkNvbXApO1xuICAgICAgICAgICAgZVNvdXRoUGFuZWwuYXBwZW5kQ2hpbGQocGFnaW5hdGlvbkNvbXAuZ2V0R3VpKCkpO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95RnVuY3Rpb25zLnB1c2gocGFnaW5hdGlvbkNvbXAuZGVzdHJveS5iaW5kKHBhZ2luYXRpb25Db21wKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVTb3V0aFBhbmVsO1xuICAgIH07XG4gICAgR3JpZENvcmUucHJvdG90eXBlLm9uUm93R3JvdXBDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucm93R3JvdXBDb21wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvd0dyb3VwUGFuZWxTaG93ID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Um93R3JvdXBQYW5lbFNob3coKTtcbiAgICAgICAgaWYgKHJvd0dyb3VwUGFuZWxTaG93ID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuQUxXQVlTKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0dyb3VwQ29tcC5zZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvd0dyb3VwUGFuZWxTaG93ID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuT05MWV9XSEVOX0dST1VQSU5HKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBpbmcgPSAhdGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUm93R3JvdXBFbXB0eSgpO1xuICAgICAgICAgICAgdGhpcy5yb3dHcm91cENvbXAuc2V0VmlzaWJsZShncm91cGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvd0dyb3VwQ29tcC5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVSb290UGFuZWwuZG9MYXlvdXQoKTtcbiAgICB9O1xuICAgIEdyaWRDb3JlLnByb3RvdHlwZS5hZGRXaW5kb3dSZXNpemVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSB0aGlzLmRvTGF5b3V0LmJpbmQodGhpcyk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBldmVudExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5kZXN0cm95RnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGV2ZW50TGlzdGVuZXIpOyB9KTtcbiAgICB9O1xuICAgIEdyaWRDb3JlLnByb3RvdHlwZS5wZXJpb2RpY2FsbHlEb0xheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmZpbmlzaGVkKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxNaWxsaXMgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRMYXlvdXRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgLy8gaWYgaW50ZXJ2YWwgaXMgbmVnYXRpdmUsIHRoaXMgc3RvcHMgdGhlIGxheW91dCBmcm9tIGhhcHBlbmluZ1xuICAgICAgICAgICAgaWYgKGludGVydmFsTWlsbGlzID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWV3b3JrRmFjdG9yeS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9MYXlvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ3JpZFBhbmVsLnBlcmlvZGljYWxseUNoZWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBlcmlvZGljYWxseURvTGF5b3V0KCk7XG4gICAgICAgICAgICAgICAgfSwgaW50ZXJ2YWxNaWxsaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdXNlciBwcm92aWRlZCBuZWdhdGl2ZSBudW1iZXIsIHdlIHN0aWxsIGRvIHRoZSBjaGVjayBldmVyeSA1IHNlY29uZHMsXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgdXNlciB0dXJucyB0aGUgbnVtYmVyIHBvc2l0aXZlIGFnYWluXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXdvcmtGYWN0b3J5LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZXJpb2RpY2FsbHlEb0xheW91dCgpO1xuICAgICAgICAgICAgICAgIH0sIDUwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkQ29yZS5wcm90b3R5cGUuc2hvd1Rvb2xQYW5lbCA9IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgIGlmIChzaG93ICYmICF0aGlzLnRvb2xQYW5lbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiB0b29sUGFuZWwgaXMgb25seSBhdmFpbGFibGUgaW4gYWctR3JpZCBFbnRlcnByaXNlJyk7XG4gICAgICAgICAgICB0aGlzLnRvb2xQYW5lbFNob3dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvb2xQYW5lbFNob3dpbmcgPSBzaG93O1xuICAgICAgICBpZiAodGhpcy50b29sUGFuZWwpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbFBhbmVsLnNldFZpc2libGUoc2hvdyk7XG4gICAgICAgICAgICB0aGlzLmVSb290UGFuZWwuZG9MYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZENvcmUucHJvdG90eXBlLmlzVG9vbFBhbmVsU2hvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbFBhbmVsU2hvd2luZztcbiAgICB9O1xuICAgIEdyaWRDb3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lR3JpZERpdi5yZW1vdmVDaGlsZCh0aGlzLmVSb290UGFuZWwuZ2V0R3VpKCkpO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ0dyaWQgRE9NIHJlbW92ZWQnKTtcbiAgICAgICAgdGhpcy5kZXN0cm95RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIGZ1bmMoKTsgfSk7XG4gICAgfTtcbiAgICAvLyBWYWxpZCB2YWx1ZXMgZm9yIHBvc2l0aW9uIGFyZSBib3R0b20sIG1pZGRsZSBhbmQgdG9wXG4gICAgR3JpZENvcmUucHJvdG90eXBlLmVuc3VyZU5vZGVWaXNpYmxlID0gZnVuY3Rpb24gKGNvbXBhcmF0b3IsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7IHBvc2l0aW9uID0gJ3RvcCc7IH1cbiAgICAgICAgaWYgKHRoaXMuZG9pbmdWaXJ0dWFsUGFnaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyAnQ2Fubm90IHVzZSBlbnN1cmVOb2RlVmlzaWJsZSB3aGVuIGRvaW5nIHZpcnR1YWwgcGFnaW5nLCBhcyB3ZSBjYW5ub3QgY2hlY2sgcm93cyB0aGF0IGFyZSBub3QgaW4gbWVtb3J5JztcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIGZvciB0aGUgbm9kZSBpbmRleCB3ZSB3YW50IHRvIGRpc3BsYXlcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5yb3dNb2RlbC5nZXRQYWdlTGFzdFJvdygpICsgMTtcbiAgICAgICAgdmFyIGNvbXBhcmF0b3JJc0FGdW5jdGlvbiA9IHR5cGVvZiBjb21wYXJhdG9yID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB2YXIgaW5kZXhUb1NlbGVjdCA9IC0xO1xuICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCB0aGUgbm9kZXMsIGZpbmQgdGhlIG9uZSB3ZSB3YW50IHRvIHNob3dcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm93TW9kZWwuZ2V0Um93KGkpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3JJc0FGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VG9TZWxlY3QgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBvYmplY3QgZXF1YWxpdHkgYWdhaW5zdCBub2RlIGFuZCBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IgPT09IG5vZGUgfHwgY29tcGFyYXRvciA9PT0gbm9kZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VG9TZWxlY3QgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4VG9TZWxlY3QgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkUGFuZWwuZW5zdXJlSW5kZXhWaXNpYmxlKGluZGV4VG9TZWxlY3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZENvcmUucHJvdG90eXBlLmRvTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBuZWVkIHRvIGRvIGxheW91dCBmaXJzdCwgYXMgZHJhd1ZpcnR1YWxSb3dzIGFuZCBzZXRQaW5uZWRDb2xIZWlnaHRcbiAgICAgICAgLy8gbmVlZCB0byBrbm93IHRoZSByZXN1bHQgb2YgdGhlIHJlc2l6aW5nIG9mIHRoZSBwYW5lbHMuXG4gICAgICAgIHZhciBzaXplQ2hhbmdlZCA9IHRoaXMuZVJvb3RQYW5lbC5kb0xheW91dCgpO1xuICAgICAgICAvLyBub3Qgc3VyZSB3aHksIHRoaXMgaXMgYSBoYWNrLCBidXQgaWYgc2l6ZSBjaGFuZ2VkLCBpdCBtYXkgbmVlZCB0byBiZSBjYWxsZWRcbiAgICAgICAgLy8gYWdhaW4gLSBhcyB0aGUgc2l6ZSBjaGFuZ2UgY2FuIGNoYW5nZSB3aGV0aGVyIHNjcm9sbHMgYXJlIHZpc2libGUgb3Igbm90IChpIHRoaW5rKS5cbiAgICAgICAgLy8gdG8gc2VlIHdoeSwgdGFrZSB0aGlzIHNlY29uZCAnZG9MYXlvdXQnIGNhbGwgb3V0LCBhbmQgc2VlIGV4YW1wbGUgaW4gZG9jcyBmb3JcbiAgICAgICAgLy8gd2lkdGggJiBoZWlnaHQsIHRoZSBncmlkIHdpbGwgZmxpY2tlciBhcyBpdCBkb2Vzbid0IGdldCBsYWlkIG91dCBjb3JyZWN0bHkgd2l0aFxuICAgICAgICAvLyBvbmUgY2FsbCB0byBkb0xheW91dCgpXG4gICAgICAgIGlmIChzaXplQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5lUm9vdFBhbmVsLmRvTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYm90aCBvZiB0aGUgdHdvIGJlbG93IHNob3VsZCBiZSBkb25lIGluIGdyaWRQYW5lbCwgdGhlIGdyaWRQYW5lbCBzaG91bGQgcmVnaXN0ZXIgJ3Jlc2l6ZScgdG8gdGhlIHBhbmVsXG4gICAgICAgIGlmIChzaXplQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5yb3dSZW5kZXJlci5yZWRyYXdBZnRlclNjcm9sbCgpO1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0dSSURfU0laRV9DSEFOR0VELFxuICAgICAgICAgICAgICAgIGNsaWVudFdpZHRoOiB0aGlzLmVSb290UGFuZWwuZ2V0R3VpKCkuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiB0aGlzLmVSb290UGFuZWwuZ2V0R3VpKCkuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnMnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHcmlkQ29yZS5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdyb3dNb2RlbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRDb3JlLnByb3RvdHlwZSwgXCJyb3dNb2RlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdmcmFtZXdvcmtGYWN0b3J5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcImZyYW1ld29ya0ZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncm93UmVuZGVyZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHJvd1JlbmRlcmVyXzEuUm93UmVuZGVyZXIpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcInJvd1JlbmRlcmVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZpbHRlck1hbmFnZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGZpbHRlck1hbmFnZXJfMS5GaWx0ZXJNYW5hZ2VyKVxuICAgIF0sIEdyaWRDb3JlLnByb3RvdHlwZSwgXCJmaWx0ZXJNYW5hZ2VyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIEdyaWRDb3JlLnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZFBhbmVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkUGFuZWxfMS5HcmlkUGFuZWwpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcImdyaWRQYW5lbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdlR3JpZERpdicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcImVHcmlkRGl2XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJyRzY29wZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRDb3JlLnByb3RvdHlwZSwgXCIkc2NvcGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncXVpY2tGaWx0ZXJPblNjb3BlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcInF1aWNrRmlsdGVyT25TY29wZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdwb3B1cFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHBvcHVwU2VydmljZV8xLlBvcHVwU2VydmljZSlcbiAgICBdLCBHcmlkQ29yZS5wcm90b3R5cGUsIFwicG9wdXBTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZvY3VzZWRDZWxsQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZm9jdXNlZENlbGxDb250cm9sbGVyXzEuRm9jdXNlZENlbGxDb250cm9sbGVyKVxuICAgIF0sIEdyaWRDb3JlLnByb3RvdHlwZSwgXCJmb2N1c2VkQ2VsbENvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29udGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29udGV4dF8xLkNvbnRleHQpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIEdyaWRDb3JlLnByb3RvdHlwZSwgXCJjb2x1bW5BcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZEFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZEFwaV8xLkdyaWRBcGkpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcImdyaWRBcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLk9wdGlvbmFsKCdyb3dHcm91cENvbXBGYWN0b3J5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcInJvd0dyb3VwQ29tcEZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLk9wdGlvbmFsKCdwaXZvdENvbXBGYWN0b3J5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcInBpdm90Q29tcEZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLk9wdGlvbmFsKCd0b29sUGFuZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbXBvbmVudF8xLkNvbXBvbmVudClcbiAgICBdLCBHcmlkQ29yZS5wcm90b3R5cGUsIFwidG9vbFBhbmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5PcHRpb25hbCgnc3RhdHVzQmFyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb21wb25lbnRfMS5Db21wb25lbnQpXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcInN0YXR1c0JhclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBHcmlkQ29yZS5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlByZURlc3Ryb3ksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgR3JpZENvcmUucHJvdG90eXBlLCBcImRlc3Ryb3lcIiwgbnVsbCk7XG4gICAgR3JpZENvcmUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2dyaWRDb3JlJyksXG4gICAgICAgIF9fcGFyYW0oMCwgY29udGV4dF8xLlF1YWxpZmllcignbG9nZ2VyRmFjdG9yeScpKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtsb2dnZXJfMS5Mb2dnZXJGYWN0b3J5XSlcbiAgICBdLCBHcmlkQ29yZSk7XG4gICAgcmV0dXJuIEdyaWRDb3JlO1xufSgpKTtcbmV4cG9ydHMuR3JpZENvcmUgPSBHcmlkQ29yZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2dyaWRDb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgZ3JpZEFwaV8xID0gcmVxdWlyZShcIi4uL2dyaWRBcGlcIik7XG52YXIgU2Nyb2xsVmlzaWJsZVNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbFZpc2libGVTZXJ2aWNlKCkge1xuICAgIH1cbiAgICBTY3JvbGxWaXNpYmxlU2VydmljZS5wcm90b3R5cGUuc2V0U2Nyb2xsc1Zpc2libGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBhdExlYXN0T25lRGlmZmVyZW50ID0gdGhpcy52Qm9keSAhPT0gcGFyYW1zLnZCb2R5XG4gICAgICAgICAgICB8fCB0aGlzLmhCb2R5ICE9PSBwYXJhbXMuaEJvZHlcbiAgICAgICAgICAgIHx8IHRoaXMudlBpbm5lZExlZnQgIT09IHBhcmFtcy52UGlubmVkTGVmdFxuICAgICAgICAgICAgfHwgdGhpcy52UGlubmVkUmlnaHQgIT09IHBhcmFtcy52UGlubmVkUmlnaHQ7XG4gICAgICAgIGlmIChhdExlYXN0T25lRGlmZmVyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnZCb2R5ID0gcGFyYW1zLnZCb2R5O1xuICAgICAgICAgICAgdGhpcy5oQm9keSA9IHBhcmFtcy5oQm9keTtcbiAgICAgICAgICAgIHRoaXMudlBpbm5lZExlZnQgPSBwYXJhbXMudlBpbm5lZExlZnQ7XG4gICAgICAgICAgICB0aGlzLnZQaW5uZWRSaWdodCA9IHBhcmFtcy52UGlubmVkUmlnaHQ7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfU0NST0xMX1ZJU0lCSUxJVFlfQ0hBTkdFRCxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudF8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsVmlzaWJsZVNlcnZpY2UucHJvdG90eXBlLmlzVkJvZHlTaG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52Qm9keTtcbiAgICB9O1xuICAgIFNjcm9sbFZpc2libGVTZXJ2aWNlLnByb3RvdHlwZS5pc0hCb2R5U2hvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaEJvZHk7XG4gICAgfTtcbiAgICBTY3JvbGxWaXNpYmxlU2VydmljZS5wcm90b3R5cGUuaXNWUGlubmVkTGVmdFNob3dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZQaW5uZWRMZWZ0O1xuICAgIH07XG4gICAgU2Nyb2xsVmlzaWJsZVNlcnZpY2UucHJvdG90eXBlLmlzVlBpbm5lZFJpZ2h0U2hvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudlBpbm5lZFJpZ2h0O1xuICAgIH07XG4gICAgU2Nyb2xsVmlzaWJsZVNlcnZpY2UucHJvdG90eXBlLmdldFBpbm5lZExlZnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRQaW5uZWRMZWZ0Q29udGFpbmVyV2lkdGgoKTtcbiAgICB9O1xuICAgIFNjcm9sbFZpc2libGVTZXJ2aWNlLnByb3RvdHlwZS5nZXRQaW5uZWRMZWZ0V2l0aFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRQaW5uZWRMZWZ0V2lkdGgoKTtcbiAgICAgICAgaWYgKHRoaXMudlBpbm5lZExlZnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB1dGlsc18xLlV0aWxzLmdldFNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFNjcm9sbFZpc2libGVTZXJ2aWNlLnByb3RvdHlwZS5nZXRQaW5uZWRSaWdodFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldFBpbm5lZFJpZ2h0Q29udGFpbmVyV2lkdGgoKTtcbiAgICB9O1xuICAgIFNjcm9sbFZpc2libGVTZXJ2aWNlLnByb3RvdHlwZS5nZXRQaW5uZWRSaWdodFdpdGhTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0UGlubmVkUmlnaHRXaWR0aCgpO1xuICAgICAgICBpZiAodGhpcy52UGlubmVkUmlnaHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB1dGlsc18xLlV0aWxzLmdldFNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdldmVudFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSlcbiAgICBdLCBTY3JvbGxWaXNpYmxlU2VydmljZS5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIFNjcm9sbFZpc2libGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkFwaSlcbiAgICBdLCBTY3JvbGxWaXNpYmxlU2VydmljZS5wcm90b3R5cGUsIFwiY29sdW1uQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRBcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRBcGlfMS5HcmlkQXBpKVxuICAgIF0sIFNjcm9sbFZpc2libGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgU2Nyb2xsVmlzaWJsZVNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ3Njcm9sbFZpc2libGVTZXJ2aWNlJylcbiAgICBdLCBTY3JvbGxWaXNpYmxlU2VydmljZSk7XG4gICAgcmV0dXJuIFNjcm9sbFZpc2libGVTZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuU2Nyb2xsVmlzaWJsZVNlcnZpY2UgPSBTY3JvbGxWaXNpYmxlU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2dyaWRQYW5lbC9zY3JvbGxWaXNpYmxlU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgZ3JpZEFwaV8xID0gcmVxdWlyZShcIi4uL2dyaWRBcGlcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGV4cHJlc3Npb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVTZXJ2aWNlL2V4cHJlc3Npb25TZXJ2aWNlXCIpO1xudmFyIHJvd1JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9yb3dSZW5kZXJlclwiKTtcbnZhciB0ZW1wbGF0ZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi90ZW1wbGF0ZVNlcnZpY2VcIik7XG52YXIgdmFsdWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVTZXJ2aWNlL3ZhbHVlU2VydmljZVwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgY29sdW1uQW5pbWF0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vY29sdW1uQW5pbWF0aW9uU2VydmljZVwiKTtcbnZhciBmb2N1c2VkQ2VsbENvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9mb2N1c2VkQ2VsbENvbnRyb2xsZXJcIik7XG52YXIgY2VsbEVkaXRvckZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL2NlbGxFZGl0b3JGYWN0b3J5XCIpO1xudmFyIGNlbGxSZW5kZXJlckZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL2NlbGxSZW5kZXJlckZhY3RvcnlcIik7XG52YXIgcG9wdXBTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9wb3B1cFNlcnZpY2VcIik7XG52YXIgY2VsbFJlbmRlcmVyU2VydmljZV8xID0gcmVxdWlyZShcIi4vY2VsbFJlbmRlcmVyU2VydmljZVwiKTtcbnZhciB2YWx1ZUZvcm1hdHRlclNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3ZhbHVlRm9ybWF0dGVyU2VydmljZVwiKTtcbnZhciBzdHlsaW5nU2VydmljZV8xID0gcmVxdWlyZShcIi4uL3N0eWxpbmcvc3R5bGluZ1NlcnZpY2VcIik7XG52YXIgY29sdW1uSG92ZXJTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Ib3ZlclNlcnZpY2VcIik7XG52YXIgZ3JpZFBhbmVsXzEgPSByZXF1aXJlKFwiLi4vZ3JpZFBhbmVsL2dyaWRQYW5lbFwiKTtcbnZhciBwYWdpbmF0aW9uUHJveHlfMSA9IHJlcXVpcmUoXCIuLi9yb3dNb2RlbHMvcGFnaW5hdGlvblByb3h5XCIpO1xudmFyIGFuaW1hdGlvbkZyYW1lU2VydmljZV8xID0gcmVxdWlyZShcIi4uL21pc2MvYW5pbWF0aW9uRnJhbWVTZXJ2aWNlXCIpO1xudmFyIGNvbXBvbmVudFJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UmVzb2x2ZXJcIik7XG52YXIgQmVhbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJlYW5zKCkge1xuICAgIH1cbiAgICBCZWFucy5wcm90b3R5cGUucG9zdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3JQcmludCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdwYWdpbmF0aW9uUHJveHknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHBhZ2luYXRpb25Qcm94eV8xLlBhZ2luYXRpb25Qcm94eSlcbiAgICBdLCBCZWFucy5wcm90b3R5cGUsIFwicGFnaW5hdGlvblByb3h5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRQYW5lbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZFBhbmVsXzEuR3JpZFBhbmVsKVxuICAgIF0sIEJlYW5zLnByb3RvdHlwZSwgXCJncmlkUGFuZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29udGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29udGV4dF8xLkNvbnRleHQpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIEJlYW5zLnByb3RvdHlwZSwgXCJjb2x1bW5BcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZEFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZEFwaV8xLkdyaWRBcGkpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcImdyaWRBcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdleHByZXNzaW9uU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXhwcmVzc2lvblNlcnZpY2VfMS5FeHByZXNzaW9uU2VydmljZSlcbiAgICBdLCBCZWFucy5wcm90b3R5cGUsIFwiZXhwcmVzc2lvblNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncm93UmVuZGVyZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHJvd1JlbmRlcmVyXzEuUm93UmVuZGVyZXIpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcInJvd1JlbmRlcmVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJyRjb21waWxlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcIiRjb21waWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3RlbXBsYXRlU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdGVtcGxhdGVTZXJ2aWNlXzEuVGVtcGxhdGVTZXJ2aWNlKVxuICAgIF0sIEJlYW5zLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgndmFsdWVTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB2YWx1ZVNlcnZpY2VfMS5WYWx1ZVNlcnZpY2UpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcInZhbHVlU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdldmVudFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSlcbiAgICBdLCBCZWFucy5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIEJlYW5zLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkFuaW1hdGlvblNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkFuaW1hdGlvblNlcnZpY2VfMS5Db2x1bW5BbmltYXRpb25TZXJ2aWNlKVxuICAgIF0sIEJlYW5zLnByb3RvdHlwZSwgXCJjb2x1bW5BbmltYXRpb25TZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5PcHRpb25hbCgncmFuZ2VDb250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcInJhbmdlQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdmb2N1c2VkQ2VsbENvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGZvY3VzZWRDZWxsQ29udHJvbGxlcl8xLkZvY3VzZWRDZWxsQ29udHJvbGxlcilcbiAgICBdLCBCZWFucy5wcm90b3R5cGUsIFwiZm9jdXNlZENlbGxDb250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5PcHRpb25hbCgnY29udGV4dE1lbnVGYWN0b3J5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcImNvbnRleHRNZW51RmFjdG9yeVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjZWxsRWRpdG9yRmFjdG9yeScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY2VsbEVkaXRvckZhY3RvcnlfMS5DZWxsRWRpdG9yRmFjdG9yeSlcbiAgICBdLCBCZWFucy5wcm90b3R5cGUsIFwiY2VsbEVkaXRvckZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY2VsbFJlbmRlcmVyRmFjdG9yeScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY2VsbFJlbmRlcmVyRmFjdG9yeV8xLkNlbGxSZW5kZXJlckZhY3RvcnkpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcImNlbGxSZW5kZXJlckZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncG9wdXBTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBwb3B1cFNlcnZpY2VfMS5Qb3B1cFNlcnZpY2UpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcInBvcHVwU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjZWxsUmVuZGVyZXJTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjZWxsUmVuZGVyZXJTZXJ2aWNlXzEuQ2VsbFJlbmRlcmVyU2VydmljZSlcbiAgICBdLCBCZWFucy5wcm90b3R5cGUsIFwiY2VsbFJlbmRlcmVyU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCd2YWx1ZUZvcm1hdHRlclNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHZhbHVlRm9ybWF0dGVyU2VydmljZV8xLlZhbHVlRm9ybWF0dGVyU2VydmljZSlcbiAgICBdLCBCZWFucy5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0ZXJTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3N0eWxpbmdTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBzdHlsaW5nU2VydmljZV8xLlN0eWxpbmdTZXJ2aWNlKVxuICAgIF0sIEJlYW5zLnByb3RvdHlwZSwgXCJzdHlsaW5nU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5Ib3ZlclNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkhvdmVyU2VydmljZV8xLkNvbHVtbkhvdmVyU2VydmljZSlcbiAgICBdLCBCZWFucy5wcm90b3R5cGUsIFwiY29sdW1uSG92ZXJTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2VudGVycHJpc2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcImVudGVycHJpc2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29tcG9uZW50UmVzb2x2ZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbXBvbmVudFJlc29sdmVyXzEuQ29tcG9uZW50UmVzb2x2ZXIpXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcImNvbXBvbmVudFJlc29sdmVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2FuaW1hdGlvbkZyYW1lU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgYW5pbWF0aW9uRnJhbWVTZXJ2aWNlXzEuQW5pbWF0aW9uRnJhbWVTZXJ2aWNlKVxuICAgIF0sIEJlYW5zLnByb3RvdHlwZSwgXCJ0YXNrUXVldWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgQmVhbnMucHJvdG90eXBlLCBcInBvc3RDb25zdHJ1Y3RcIiwgbnVsbCk7XG4gICAgQmVhbnMgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2JlYW5zJylcbiAgICBdLCBCZWFucyk7XG4gICAgcmV0dXJuIEJlYW5zO1xufSgpKTtcbmV4cG9ydHMuQmVhbnMgPSBCZWFucztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9iZWFucy5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBWYWx1ZUNhY2hlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYWx1ZUNhY2hlKCkge1xuICAgICAgICB0aGlzLmNhY2hlVmVyc2lvbiA9IDA7XG4gICAgfVxuICAgIFZhbHVlQ2FjaGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNWYWx1ZUNhY2hlKCk7XG4gICAgICAgIHRoaXMubmV2ZXJFeHBpcmVzID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNWYWx1ZUNhY2hlTmV2ZXJFeHBpcmVzKCk7XG4gICAgfTtcbiAgICBWYWx1ZUNhY2hlLnByb3RvdHlwZS5vbkRhdGFDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5uZXZlckV4cGlyZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGlyZSgpO1xuICAgIH07XG4gICAgVmFsdWVDYWNoZS5wcm90b3R5cGUuZXhwaXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhY2hlVmVyc2lvbisrO1xuICAgIH07XG4gICAgVmFsdWVDYWNoZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAocm93Tm9kZSwgY29sSWQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKHJvd05vZGUuX19jYWNoZVZlcnNpb24gIT09IHRoaXMuY2FjaGVWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5fX2NhY2hlVmVyc2lvbiA9IHRoaXMuY2FjaGVWZXJzaW9uO1xuICAgICAgICAgICAgICAgIHJvd05vZGUuX19jYWNoZURhdGEgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd05vZGUuX19jYWNoZURhdGFbY29sSWRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZhbHVlQ2FjaGUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKHJvd05vZGUsIGNvbElkKSB7XG4gICAgICAgIHZhciB2YWx1ZUluQ2FjaGUgPSB0aGlzLmFjdGl2ZVxuICAgICAgICAgICAgJiYgcm93Tm9kZS5fX2NhY2hlVmVyc2lvbiA9PT0gdGhpcy5jYWNoZVZlcnNpb25cbiAgICAgICAgICAgICYmIHJvd05vZGUuX19jYWNoZURhdGFbY29sSWRdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh2YWx1ZUluQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiByb3dOb2RlLl9fY2FjaGVEYXRhW2NvbElkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBWYWx1ZUNhY2hlLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgVmFsdWVDYWNoZS5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICBWYWx1ZUNhY2hlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCd2YWx1ZUNhY2hlJylcbiAgICBdLCBWYWx1ZUNhY2hlKTtcbiAgICByZXR1cm4gVmFsdWVDYWNoZTtcbn0oKSk7XG5leHBvcnRzLlZhbHVlQ2FjaGUgPSBWYWx1ZUNhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvdmFsdWVTZXJ2aWNlL3ZhbHVlQ2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBncmlkQ29yZV8xID0gcmVxdWlyZShcIi4uL2dyaWRDb3JlXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBQb3B1cFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvcHVwU2VydmljZSgpIHtcbiAgICAgICAgLy8gdGhpcy5wb3B1cFNlcnZpY2Uuc2V0UG9wdXBQYXJlbnQodGhpcy5lUm9vdFBhbmVsLmdldEd1aSgpKTtcbiAgICAgICAgdGhpcy5hY3RpdmVQb3B1cEVsZW1lbnRzID0gW107XG4gICAgfVxuICAgIFBvcHVwU2VydmljZS5wcm90b3R5cGUuZ2V0UG9wdXBQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRDb3JlLmdldFJvb3RHdWkoKTtcbiAgICB9O1xuICAgIFBvcHVwU2VydmljZS5wcm90b3R5cGUucG9zaXRpb25Qb3B1cEZvck1lbnUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBzb3VyY2VSZWN0ID0gcGFyYW1zLmV2ZW50U291cmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHRoaXMuZ2V0UG9wdXBQYXJlbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHkgPSBzb3VyY2VSZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wO1xuICAgICAgICB5ID0gdGhpcy5rZWVwWVdpdGhpbkJvdW5kcyhwYXJhbXMsIHkpO1xuICAgICAgICB2YXIgbWluV2lkdGggPSAocGFyYW1zLmVQb3B1cC5jbGllbnRXaWR0aCA+IDApID8gcGFyYW1zLmVQb3B1cC5jbGllbnRXaWR0aCA6IDIwMDtcbiAgICAgICAgdmFyIHdpZHRoT2ZQYXJlbnQgPSBwYXJlbnRSZWN0LnJpZ2h0IC0gcGFyZW50UmVjdC5sZWZ0O1xuICAgICAgICB2YXIgbWF4WCA9IHdpZHRoT2ZQYXJlbnQgLSBtaW5XaWR0aDtcbiAgICAgICAgLy8gdGhlIHggcG9zaXRpb24gb2YgdGhlIHBvcHVwIGRlcGVuZHMgb24gUlRMIG9yIExUUi4gZm9yIG5vcm1hbCBjYXNlcywgTFRSLCB3ZSBwdXQgdGhlIGNoaWxkIHBvcHVwXG4gICAgICAgIC8vIHRvIHRoZSByaWdodCwgdW5sZXNzIGl0IGRvZXNuJ3QgZml0IGFuZCB3ZSB0aGVuIHB1dCBpdCB0byB0aGUgbGVmdC4gZm9yIFJUTCBpdCdzIHRoZSBvdGhlciB3YXkgYXJvdW5kLFxuICAgICAgICAvLyB3ZSB0cnkgcGxhY2UgaXQgZmlyc3QgdG8gdGhlIGxlZnQsIGFuZCB0aGVuIGlmIG5vdCB0byB0aGUgcmlnaHQuXG4gICAgICAgIHZhciB4O1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVSdGwoKSkge1xuICAgICAgICAgICAgLy8gZm9yIFJUTCwgdHJ5IGxlZnQgZmlyc3RcbiAgICAgICAgICAgIHggPSB4TGVmdFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgICAgICB4ID0geFJpZ2h0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZm9yIExUUiwgdHJ5IHJpZ2h0IGZpcnN0XG4gICAgICAgICAgICB4ID0geFJpZ2h0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgICAgICAgIHggPSB4TGVmdFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuZVBvcHVwLnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xuICAgICAgICBwYXJhbXMuZVBvcHVwLnN0eWxlLnRvcCA9IHkgKyBcInB4XCI7XG4gICAgICAgIGZ1bmN0aW9uIHhSaWdodFBvc2l0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVJlY3QucmlnaHQgLSBwYXJlbnRSZWN0LmxlZnQgLSAyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHhMZWZ0UG9zaXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gbWluV2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcHVwU2VydmljZS5wcm90b3R5cGUucG9zaXRpb25Qb3B1cFVuZGVyTW91c2VFdmVudCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmVudFJlY3QgPSB0aGlzLmdldFBvcHVwUGFyZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25Qb3B1cCh7XG4gICAgICAgICAgICBlUG9wdXA6IHBhcmFtcy5lUG9wdXAsXG4gICAgICAgICAgICB4OiBwYXJhbXMubW91c2VFdmVudC5jbGllbnRYIC0gcGFyZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgeTogcGFyYW1zLm1vdXNlRXZlbnQuY2xpZW50WSAtIHBhcmVudFJlY3QudG9wLFxuICAgICAgICAgICAga2VlcFdpdGhpbkJvdW5kczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsUG9zdFByb2Nlc3NQb3B1cChwYXJhbXMuZVBvcHVwLCBudWxsLCBwYXJhbXMubW91c2VFdmVudCwgcGFyYW1zLnR5cGUsIHBhcmFtcy5jb2x1bW4sIHBhcmFtcy5yb3dOb2RlKTtcbiAgICB9O1xuICAgIFBvcHVwU2VydmljZS5wcm90b3R5cGUucG9zaXRpb25Qb3B1cFVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgc291cmNlUmVjdCA9IHBhcmFtcy5ldmVudFNvdXJjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHBhcmVudFJlY3QgPSB0aGlzLmdldFBvcHVwUGFyZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25Qb3B1cCh7XG4gICAgICAgICAgICBlUG9wdXA6IHBhcmFtcy5lUG9wdXAsXG4gICAgICAgICAgICBtaW5XaWR0aDogcGFyYW1zLm1pbldpZHRoLFxuICAgICAgICAgICAgbnVkZ2VYOiBwYXJhbXMubnVkZ2VYLFxuICAgICAgICAgICAgbnVkZ2VZOiBwYXJhbXMubnVkZ2VZLFxuICAgICAgICAgICAgeDogc291cmNlUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgeTogc291cmNlUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCArIHNvdXJjZVJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAga2VlcFdpdGhpbkJvdW5kczogcGFyYW1zLmtlZXBXaXRoaW5Cb3VuZHNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbFBvc3RQcm9jZXNzUG9wdXAocGFyYW1zLmVQb3B1cCwgcGFyYW1zLmV2ZW50U291cmNlLCBudWxsLCBwYXJhbXMudHlwZSwgcGFyYW1zLmNvbHVtbiwgcGFyYW1zLnJvd05vZGUpO1xuICAgIH07XG4gICAgUG9wdXBTZXJ2aWNlLnByb3RvdHlwZS5jYWxsUG9zdFByb2Nlc3NQb3B1cCA9IGZ1bmN0aW9uIChlUG9wdXAsIGV2ZW50U291cmNlLCBtb3VzZUV2ZW50LCB0eXBlLCBjb2x1bW4sIHJvd05vZGUpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0UG9zdFByb2Nlc3NQb3B1cEZ1bmMoKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIHJvd05vZGU6IHJvd05vZGUsXG4gICAgICAgICAgICAgICAgZVBvcHVwOiBlUG9wdXAsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogZXZlbnRTb3VyY2UsXG4gICAgICAgICAgICAgICAgbW91c2VFdmVudDogbW91c2VFdmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcHVwU2VydmljZS5wcm90b3R5cGUucG9zaXRpb25Qb3B1cE92ZXJDb21wb25lbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBzb3VyY2VSZWN0ID0gcGFyYW1zLmV2ZW50U291cmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHRoaXMuZ2V0UG9wdXBQYXJlbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvblBvcHVwKHtcbiAgICAgICAgICAgIGVQb3B1cDogcGFyYW1zLmVQb3B1cCxcbiAgICAgICAgICAgIG1pbldpZHRoOiBwYXJhbXMubWluV2lkdGgsXG4gICAgICAgICAgICBudWRnZVg6IHBhcmFtcy5udWRnZVgsXG4gICAgICAgICAgICBudWRnZVk6IHBhcmFtcy5udWRnZVksXG4gICAgICAgICAgICB4OiBzb3VyY2VSZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICB5OiBzb3VyY2VSZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wLFxuICAgICAgICAgICAga2VlcFdpdGhpbkJvdW5kczogcGFyYW1zLmtlZXBXaXRoaW5Cb3VuZHNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbFBvc3RQcm9jZXNzUG9wdXAocGFyYW1zLmVQb3B1cCwgcGFyYW1zLmV2ZW50U291cmNlLCBudWxsLCBwYXJhbXMudHlwZSwgcGFyYW1zLmNvbHVtbiwgcGFyYW1zLnJvd05vZGUpO1xuICAgIH07XG4gICAgUG9wdXBTZXJ2aWNlLnByb3RvdHlwZS5wb3NpdGlvblBvcHVwID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgeCA9IHBhcmFtcy54O1xuICAgICAgICB2YXIgeSA9IHBhcmFtcy55O1xuICAgICAgICBpZiAocGFyYW1zLm51ZGdlWCkge1xuICAgICAgICAgICAgeCArPSBwYXJhbXMubnVkZ2VYO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubnVkZ2VZKSB7XG4gICAgICAgICAgICB5ICs9IHBhcmFtcy5udWRnZVk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgcG9wdXAgaXMgb3ZlcmZsb3dpbmcgdG8gdGhlIGJvdHRvbSwgbW92ZSBpdCB1cFxuICAgICAgICBpZiAocGFyYW1zLmtlZXBXaXRoaW5Cb3VuZHMpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmtlZXBYV2l0aGluQm91bmRzKHBhcmFtcywgeCk7XG4gICAgICAgICAgICB5ID0gdGhpcy5rZWVwWVdpdGhpbkJvdW5kcyhwYXJhbXMsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5lUG9wdXAuc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG4gICAgICAgIHBhcmFtcy5lUG9wdXAuc3R5bGUudG9wID0geSArIFwicHhcIjtcbiAgICB9O1xuICAgIFBvcHVwU2VydmljZS5wcm90b3R5cGUua2VlcFlXaXRoaW5Cb3VuZHMgPSBmdW5jdGlvbiAocGFyYW1zLCB5KSB7XG4gICAgICAgIHZhciBwYXJlbnRSZWN0ID0gdGhpcy5nZXRQb3B1cFBhcmVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgbWluSGVpZ2h0O1xuICAgICAgICBpZiAocGFyYW1zLmVQb3B1cC5jbGllbnRIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBwYXJhbXMuZVBvcHVwLmNsaWVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbkhlaWdodCA9IDIwMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVpZ2h0T2ZQYXJlbnQgPSBwYXJlbnRSZWN0LmJvdHRvbSAtIHBhcmVudFJlY3QudG9wO1xuICAgICAgICB2YXIgbWF4WSA9IGhlaWdodE9mUGFyZW50IC0gbWluSGVpZ2h0IC0gNTtcbiAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4WTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh5IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wdXBTZXJ2aWNlLnByb3RvdHlwZS5rZWVwWFdpdGhpbkJvdW5kcyA9IGZ1bmN0aW9uIChwYXJhbXMsIHgpIHtcbiAgICAgICAgdmFyIHBhcmVudFJlY3QgPSB0aGlzLmdldFBvcHVwUGFyZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBtaW5XaWR0aDtcbiAgICAgICAgaWYgKHBhcmFtcy5taW5XaWR0aCA+IDApIHtcbiAgICAgICAgICAgIG1pbldpZHRoID0gcGFyYW1zLm1pbldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5lUG9wdXAuY2xpZW50V2lkdGggPiAwKSB7XG4gICAgICAgICAgICBtaW5XaWR0aCA9IHBhcmFtcy5lUG9wdXAuY2xpZW50V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW5XaWR0aCA9IDIwMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGhPZlBhcmVudCA9IHBhcmVudFJlY3QucmlnaHQgLSBwYXJlbnRSZWN0LmxlZnQ7XG4gICAgICAgIHZhciBtYXhYID0gd2lkdGhPZlBhcmVudCAtIG1pbldpZHRoIC0gNTtcbiAgICAgICAgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4WDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy9hZGRzIGFuIGVsZW1lbnQgdG8gYSBkaXYsIGJ1dCBhbHNvIGxpc3RlbnMgdG8gYmFja2dyb3VuZCBjaGVja2luZyBmb3IgY2xpY2tzLFxuICAgIC8vc28gdGhhdCB3aGVuIHRoZSBiYWNrZ3JvdW5kIGlzIGNsaWNrZWQsIHRoZSBjaGlsZCBpcyByZW1vdmVkIGFnYWluLCBnaXZpbmdcbiAgICAvL2EgbW9kZWwgbG9vayB0byBwb3B1cHMuXG4gICAgUG9wdXBTZXJ2aWNlLnByb3RvdHlwZS5hZGRBc01vZGFsUG9wdXAgPSBmdW5jdGlvbiAoZUNoaWxkLCBjbG9zZU9uRXNjLCBjbG9zZWRDYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZUJvZHkgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXREb2N1bWVudCgpO1xuICAgICAgICBpZiAoIWVCb2R5KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IGNvdWxkIG5vdCBmaW5kIHRoZSBib2R5IG9mIHRoZSBkb2N1bWVudCwgZG9jdW1lbnQuYm9keSBpcyBlbXB0eScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVDaGlsZC5zdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgZUNoaWxkLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgdmFyIHBvcHVwQWxyZWFkeVNob3duID0gdXRpbHNfMS5VdGlscy5pc1Zpc2libGUoZUNoaWxkKTtcbiAgICAgICAgaWYgKHBvcHVwQWxyZWFkeVNob3duKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVQb3B1cFBhcmVudCA9IHRoaXMuZ2V0UG9wdXBQYXJlbnQoKTtcbiAgICAgICAgZVBvcHVwUGFyZW50LmFwcGVuZENoaWxkKGVDaGlsZCk7XG4gICAgICAgIHRoaXMuYWN0aXZlUG9wdXBFbGVtZW50cy5wdXNoKGVDaGlsZCk7XG4gICAgICAgIHZhciBwb3B1cEhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAvLyBsZXQgdGltZU9mTW91c2VFdmVudE9uQ2hpbGQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgLy8gbGV0IGNoaWxkTW91c2VDbGljazogTW91c2VFdmVudCA9IG51bGw7XG4gICAgICAgIC8vIGxldCBjaGlsZFRvdWNoOiBUb3VjaEV2ZW50ID0gbnVsbDtcbiAgICAgICAgdmFyIGhpZGVQb3B1cE9uRXNjID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfRVNDQVBFKSB7XG4gICAgICAgICAgICAgICAgaGlkZVBvcHVwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaGlkZVBvcHVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBoaWRlIHBvcHVwIGlmIHRoZSBldmVudCB3YXMgb24gdGhlIGNoaWxkLCBvciBhbnlcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoaXMgY2hpbGRcbiAgICAgICAgICAgIHZhciBpbmRleE9mVGhpc0NoaWxkID0gX3RoaXMuYWN0aXZlUG9wdXBFbGVtZW50cy5pbmRleE9mKGVDaGlsZCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXhPZlRoaXNDaGlsZDsgaSA8IF90aGlzLmFjdGl2ZVBvcHVwRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IF90aGlzLmFjdGl2ZVBvcHVwRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuaXNFbGVtZW50SW5FdmVudFBhdGgoZWxlbWVudCwgZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZS4gdGhlIGNsaWVudCBjYW4gaGF2ZSBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vIHBhdGhzLCBlYWNoIG9uZSB3YW50aW5nIHRvIGNsb3NlLCBzbyB0aGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG11bHRpcGxlXG4gICAgICAgICAgICAvLyB0aW1lcy5cbiAgICAgICAgICAgIGlmIChwb3B1cEhpZGRlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcHVwSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGVQb3B1cFBhcmVudC5yZW1vdmVDaGlsZChlQ2hpbGQpO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVGcm9tQXJyYXkoX3RoaXMuYWN0aXZlUG9wdXBFbGVtZW50cywgZUNoaWxkKTtcbiAgICAgICAgICAgIGVCb2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoaWRlUG9wdXBPbkVzYyk7XG4gICAgICAgICAgICBlQm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhpZGVQb3B1cCk7XG4gICAgICAgICAgICBlQm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGlkZVBvcHVwKTtcbiAgICAgICAgICAgIGVCb2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgaGlkZVBvcHVwKTtcbiAgICAgICAgICAgIC8vIGVDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNvbnN1bWVNb3VzZUNsaWNrKTtcbiAgICAgICAgICAgIC8vIGVDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY29uc3VtZVRvdWNoQ2xpY2spO1xuICAgICAgICAgICAgaWYgKGNsb3NlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgd2UgYWRkIHRoZXNlIGxpc3RlbmVycyBub3csIHRoZW4gdGhlIGN1cnJlbnQgbW91c2VcbiAgICAgICAgLy8gY2xpY2sgd2lsbCBiZSBpbmNsdWRlZCwgd2hpY2ggd2UgZG9uJ3Qgd2FudFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjbG9zZU9uRXNjKSB7XG4gICAgICAgICAgICAgICAgZUJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhpZGVQb3B1cE9uRXNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVCb2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGlkZVBvcHVwKTtcbiAgICAgICAgICAgIGVCb2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoaWRlUG9wdXApO1xuICAgICAgICAgICAgZUJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBoaWRlUG9wdXApO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIGhpZGVQb3B1cDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQ29yZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZENvcmVfMS5HcmlkQ29yZSlcbiAgICBdLCBQb3B1cFNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRDb3JlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIFBvcHVwU2VydmljZS5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgUG9wdXBTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdwb3B1cFNlcnZpY2UnKVxuICAgIF0sIFBvcHVwU2VydmljZSk7XG4gICAgcmV0dXJuIFBvcHVwU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlBvcHVwU2VydmljZSA9IFBvcHVwU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3dpZGdldHMvcG9wdXBTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29udGV4dF8yID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjZWxsQ29tcF8xID0gcmVxdWlyZShcIi4uL3JlbmRlcmluZy9jZWxsQ29tcFwiKTtcbnZhciBNb3VzZUV2ZW50U2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW91c2VFdmVudFNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuZ3JpZEluc3RhbmNlSWQgPSBNb3VzZUV2ZW50U2VydmljZV8xLmdyaWRJbnN0YW5jZVNlcXVlbmNlLm5leHQoKTtcbiAgICB9XG4gICAgTW91c2VFdmVudFNlcnZpY2VfMSA9IE1vdXNlRXZlbnRTZXJ2aWNlO1xuICAgIE1vdXNlRXZlbnRTZXJ2aWNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YW1wRG9tRWxlbWVudFdpdGhHcmlkSW5zdGFuY2UoKTtcbiAgICB9O1xuICAgIC8vIHdlIHB1dCB0aGUgaW5zdGFuY2UgaWQgb250byB0aGUgbWFpbiBET00gZWxlbWVudC4gdGhpcyBpcyB1c2VkIGZvciBldmVudHMsIHdoZW4gZ3JpZHMgYXJlIGluc2lkZSBncmlkcyxcbiAgICAvLyBzbyB0aGUgZ3JpZCBjYW4gd29yayBvdXQgaWYgdGhlIGV2ZW4gY2FtZSBmcm9tIHRoaXMgZ3JpZCBvciBhIGdyaWQgaW5zaWRlIHRoaXMgb25lLiBzZWUgdGhlIGN0cmwrdiBsb2dpY1xuICAgIC8vIGZvciB3aGVyZSB0aGlzIGlzIHVzZWQuXG4gICAgTW91c2VFdmVudFNlcnZpY2UucHJvdG90eXBlLnN0YW1wRG9tRWxlbWVudFdpdGhHcmlkSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZUdyaWREaXZbTW91c2VFdmVudFNlcnZpY2VfMS5HUklEX0RPTV9LRVldID0gdGhpcy5ncmlkSW5zdGFuY2VJZDtcbiAgICB9O1xuICAgIE1vdXNlRXZlbnRTZXJ2aWNlLnByb3RvdHlwZS5nZXRSZW5kZXJlZENlbGxGb3JFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgc291cmNlRWxlbWVudCA9IHV0aWxzXzEuVXRpbHMuZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgd2hpbGUgKHNvdXJjZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZENlbGwgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXREb21EYXRhKHNvdXJjZUVsZW1lbnQsIGNlbGxDb21wXzEuQ2VsbENvbXAuRE9NX0RBVEFfS0VZX0NFTExfQ09NUCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWRDZWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVkQ2VsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBzb3VyY2VFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyB3YWxrcyB0aGUgcGF0aCBvZiB0aGUgZXZlbnQsIGFuZCByZXR1cm5zIHRydWUgaWYgdGhpcyBncmlkIGlzIHRoZSBmaXJzdCBvbmUgdGhhdCBpdCBmaW5kcy4gaWYgZG9pbmdcbiAgICAvLyBtYXN0ZXIgLyBkZXRhaWwgZ3JpZHMsIGFuZCBhIGNoaWxkIGdyaWQgaXMgZm91bmQsIHRoZW4gaXQgcmV0dXJucyBmYWxzZS4gdGhpcyBzdG9wcyB0aGluZ3MgbGlrZSBjb3B5L3Bhc3RlXG4gICAgLy8gZ2V0dGluZyBleGVjdXRlZCBvbiBtYW55IGdyaWRzIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgTW91c2VFdmVudFNlcnZpY2UucHJvdG90eXBlLmlzRXZlbnRGcm9tVGhpc0dyaWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBhdGggPSB1dGlsc18xLlV0aWxzLmdldEV2ZW50UGF0aChldmVudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBwYXRoW2ldO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBlbGVtZW50W01vdXNlRXZlbnRTZXJ2aWNlXzEuR1JJRF9ET01fS0VZXTtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhpbnN0YW5jZUlkKSkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudEZyb21UaGlzR3JpZCA9IGluc3RhbmNlSWQgPT09IHRoaXMuZ3JpZEluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50RnJvbVRoaXNHcmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE1vdXNlRXZlbnRTZXJ2aWNlLnByb3RvdHlwZS5nZXRHcmlkQ2VsbEZvckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsQ29tcCA9IHRoaXMuZ2V0UmVuZGVyZWRDZWxsRm9yRXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gY2VsbENvbXAgPyBjZWxsQ29tcC5nZXRHcmlkQ2VsbCgpIDogbnVsbDtcbiAgICB9O1xuICAgIE1vdXNlRXZlbnRTZXJ2aWNlLmdyaWRJbnN0YW5jZVNlcXVlbmNlID0gbmV3IHV0aWxzXzEuTnVtYmVyU2VxdWVuY2UoKTtcbiAgICBNb3VzZUV2ZW50U2VydmljZS5HUklEX0RPTV9LRVkgPSAnX19hZ19ncmlkX2luc3RhbmNlJztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8yLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgTW91c2VFdmVudFNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzIuQXV0b3dpcmVkKCdlR3JpZERpdicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgTW91c2VFdmVudFNlcnZpY2UucHJvdG90eXBlLCBcImVHcmlkRGl2XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIE1vdXNlRXZlbnRTZXJ2aWNlLnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIE1vdXNlRXZlbnRTZXJ2aWNlID0gTW91c2VFdmVudFNlcnZpY2VfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignbW91c2VFdmVudFNlcnZpY2UnKVxuICAgIF0sIE1vdXNlRXZlbnRTZXJ2aWNlKTtcbiAgICByZXR1cm4gTW91c2VFdmVudFNlcnZpY2U7XG4gICAgdmFyIE1vdXNlRXZlbnRTZXJ2aWNlXzE7XG59KCkpO1xuZXhwb3J0cy5Nb3VzZUV2ZW50U2VydmljZSA9IE1vdXNlRXZlbnRTZXJ2aWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZ3JpZFBhbmVsL21vdXNlRXZlbnRTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIEhvcml6b250YWxEcmFnU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSG9yaXpvbnRhbERyYWdTZXJ2aWNlKCkge1xuICAgIH1cbiAgICBIb3Jpem9udGFsRHJhZ1NlcnZpY2UucHJvdG90eXBlLmFkZERyYWdIYW5kbGluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcGFyYW1zLmVEcmFnZ2FibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uIChzdGFydEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbXlEb2N1bWVudCA9IF90aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXREb2N1bWVudCgpO1xuICAgICAgICAgICAgdmFyIGVCb2R5ID0gbXlEb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gICAgICAgICAgICBuZXcgRHJhZ0luc3RhbmNlKHBhcmFtcywgc3RhcnRFdmVudCwgZUJvZHkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBIb3Jpem9udGFsRHJhZ1NlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIEhvcml6b250YWxEcmFnU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignaG9yaXpvbnRhbERyYWdTZXJ2aWNlJylcbiAgICBdLCBIb3Jpem9udGFsRHJhZ1NlcnZpY2UpO1xuICAgIHJldHVybiBIb3Jpem9udGFsRHJhZ1NlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5Ib3Jpem9udGFsRHJhZ1NlcnZpY2UgPSBIb3Jpem9udGFsRHJhZ1NlcnZpY2U7XG52YXIgRHJhZ0luc3RhbmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcmFnSW5zdGFuY2UocGFyYW1zLCBzdGFydEV2ZW50LCBlQm9keSkge1xuICAgICAgICB0aGlzLm1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3VzZUxlYXZlID0gdGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5sYXN0RGVsdGEgPSAwO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5lRHJhZ1BhcmVudCA9IGVCb2R5O1xuICAgICAgICB0aGlzLmRyYWdTdGFydFggPSBzdGFydEV2ZW50LmNsaWVudFg7XG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuZURyYWdQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmUpO1xuICAgICAgICB0aGlzLmVEcmFnUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApO1xuICAgICAgICB0aGlzLmVEcmFnUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm1vdXNlTGVhdmUpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RhcnRBZnRlclBpeGVsc0V4aXN0ID0gdHlwZW9mIHBhcmFtcy5zdGFydEFmdGVyUGl4ZWxzID09PSAnbnVtYmVyJyAmJiBwYXJhbXMuc3RhcnRBZnRlclBpeGVscyA+IDA7XG4gICAgICAgIGlmICghc3RhcnRBZnRlclBpeGVsc0V4aXN0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZ2dpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEcmFnSW5zdGFuY2UucHJvdG90eXBlLnN0YXJ0RHJhZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbGRCb2R5Q3Vyc29yID0gdGhpcy5wYXJhbXMuZUJvZHkuc3R5bGUuY3Vyc29yO1xuICAgICAgICB0aGlzLm9sZFBhcmVudEN1cnNvciA9IHRoaXMuZURyYWdQYXJlbnQuc3R5bGUuY3Vyc29yO1xuICAgICAgICB0aGlzLm9sZE1zVXNlclNlbGVjdCA9IHRoaXMuZURyYWdQYXJlbnQuc3R5bGUubXNVc2VyU2VsZWN0O1xuICAgICAgICB0aGlzLm9sZFdlYmtpdFVzZXJTZWxlY3QgPSB0aGlzLmVEcmFnUGFyZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3Q7XG4gICAgICAgIC8vIGNoYW5nZSB0aGUgYm9keSBjdXJzb3IsIHNvIHdoZW4gZHJhZyBtb3ZlcyBvdXQgb2YgdGhlIGRyYWcgYmFyLCB0aGUgY3Vyc29yIGlzIHN0aWxsICdyZXNpemUnIChvciAnbW92ZSdcbiAgICAgICAgdGhpcy5wYXJhbXMuZUJvZHkuc3R5bGUuY3Vyc29yID0gdGhpcy5wYXJhbXMuY3Vyc29yO1xuICAgICAgICAvLyBzYW1lIGZvciBvdXRzaWRlIHRoZSBncmlkLCB3ZSB3YW50IHRvIGtlZXAgdGhlIHJlc2l6ZSAob3IgbW92ZSkgY3Vyc29yXG4gICAgICAgIHRoaXMuZURyYWdQYXJlbnQuc3R5bGUuY3Vyc29yID0gdGhpcy5wYXJhbXMuY3Vyc29yO1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRleHQgc2VsZWN0aW9uIG91dHNpZGUgdGhlIGdyaWQgKG90aGVyd2lzZSBpdCBsb29rcyB3ZWlyZCBhcyB0ZXh0IGhpZ2hsaWdodHMgd2hlbiB3ZSBtb3ZlKVxuICAgICAgICB0aGlzLmVEcmFnUGFyZW50LnN0eWxlLm1zVXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgdGhpcy5lRHJhZ1BhcmVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnBhcmFtcy5vbkRyYWdTdGFydCh0aGlzLnN0YXJ0RXZlbnQpO1xuICAgIH07XG4gICAgRHJhZ0luc3RhbmNlLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChtb3ZlRXZlbnQpIHtcbiAgICAgICAgdmFyIG5ld1ggPSBtb3ZlRXZlbnQuY2xpZW50WDtcbiAgICAgICAgdGhpcy5sYXN0RGVsdGEgPSBuZXdYIC0gdGhpcy5kcmFnU3RhcnRYO1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmdTdGFydGVkKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ0V4Y2VlZGVkU3RhcnRBZnRlclBpeGVscyA9IE1hdGguYWJzKHRoaXMubGFzdERlbHRhKSA+PSB0aGlzLnBhcmFtcy5zdGFydEFmdGVyUGl4ZWxzO1xuICAgICAgICAgICAgaWYgKGRyYWdFeGNlZWRlZFN0YXJ0QWZ0ZXJQaXhlbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZ2dpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLm9uRHJhZ2dpbmcodGhpcy5sYXN0RGVsdGEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhZ0luc3RhbmNlLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcERyYWdnaW5nKCk7XG4gICAgfTtcbiAgICBEcmFnSW5zdGFuY2UucHJvdG90eXBlLm9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wRHJhZ2dpbmcoKTtcbiAgICB9O1xuICAgIERyYWdJbnN0YW5jZS5wcm90b3R5cGUuc3RvcERyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXNldCBjdXJzb3IgYmFjayB0byBvcmlnaW5hbCBjdXJzb3IsIGlmIHRoZXkgd2VyZSBjaGFuZ2VkIGluIHRoZSBmaXJzdCBwbGFjZVxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmVCb2R5LnN0eWxlLmN1cnNvciA9IHRoaXMub2xkQm9keUN1cnNvcjtcbiAgICAgICAgICAgIHRoaXMuZURyYWdQYXJlbnQuc3R5bGUuY3Vyc29yID0gdGhpcy5vbGRQYXJlbnRDdXJzb3I7XG4gICAgICAgICAgICB0aGlzLmVEcmFnUGFyZW50LnN0eWxlLm1zVXNlclNlbGVjdCA9IHRoaXMub2xkTXNVc2VyU2VsZWN0O1xuICAgICAgICAgICAgdGhpcy5lRHJhZ1BhcmVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gdGhpcy5vbGRXZWJraXRVc2VyU2VsZWN0O1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMub25EcmFnZ2luZyh0aGlzLmxhc3REZWx0YSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWx3YXlzIHJlbW92ZSB0aGUgbGlzdGVuZXJzLCBhcyB0aGVzZSBhcmUgYWx3YXlzIGFkZGVkXG4gICAgICAgIHRoaXMuZURyYWdQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmUpO1xuICAgICAgICB0aGlzLmVEcmFnUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApO1xuICAgICAgICB0aGlzLmVEcmFnUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm1vdXNlTGVhdmUpO1xuICAgIH07XG4gICAgcmV0dXJuIERyYWdJbnN0YW5jZTtcbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaG9yaXpvbnRhbERyYWdTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZFBhbmVsXzEgPSByZXF1aXJlKFwiLi4vZ3JpZFBhbmVsL2dyaWRQYW5lbFwiKTtcbnZhciBsaW5rZWRMaXN0XzEgPSByZXF1aXJlKFwiLi9saW5rZWRMaXN0XCIpO1xudmFyIEFuaW1hdGlvbkZyYW1lU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uRnJhbWVTZXJ2aWNlKCkge1xuICAgICAgICB0aGlzLnAxVGFza3MgPSBuZXcgbGlua2VkTGlzdF8xLkxpbmtlZExpc3QoKTtcbiAgICAgICAgdGhpcy5wMlRhc2tzID0gbmV3IGxpbmtlZExpc3RfMS5MaW5rZWRMaXN0KCk7XG4gICAgICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICBBbmltYXRpb25GcmFtZVNlcnZpY2UucHJvdG90eXBlLmFkZFAxVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHRoaXMucDFUYXNrcy5hZGQodGFzayk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICB9O1xuICAgIEFuaW1hdGlvbkZyYW1lU2VydmljZS5wcm90b3R5cGUuYWRkUDJUYXNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGhpcy5wMlRhc2tzLmFkZCh0YXNrKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgIH07XG4gICAgQW5pbWF0aW9uRnJhbWVTZXJ2aWNlLnByb3RvdHlwZS5leGVjdXRlRnJhbWUgPSBmdW5jdGlvbiAobWlsbGlzKSB7XG4gICAgICAgIHZhciBmcmFtZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSBmcmFtZVN0YXJ0O1xuICAgICAgICB2YXIgZ3JpZFBhbmVsTmVlZHNBRnJhbWUgPSB0cnVlO1xuICAgICAgICAvLyAxNm1zIGlzIDYwIGZwc1xuICAgICAgICB2YXIgbm9NYXhNaWxsaXMgPSBtaWxsaXMgPD0gMDtcbiAgICAgICAgd2hpbGUgKG5vTWF4TWlsbGlzIHx8IGR1cmF0aW9uIDwgbWlsbGlzKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZFBhbmVsTmVlZHNBRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBncmlkUGFuZWxOZWVkc0FGcmFtZSA9IHRoaXMuZ3JpZFBhbmVsLmV4ZWN1dGVGcmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMucDFUYXNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHRoaXMucDFUYXNrcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5wMlRhc2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXNrID0gdGhpcy5wMlRhc2tzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVyYXRpb24gPSAobmV3IERhdGUoKS5nZXRUaW1lKCkpIC0gZnJhbWVTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZFBhbmVsTmVlZHNBRnJhbWUgfHwgIXRoaXMucDFUYXNrcy5pc0VtcHR5KCkgfHwgIXRoaXMucDJUYXNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5pbWF0aW9uRnJhbWVTZXJ2aWNlLnByb3RvdHlwZS5mbHVzaEFsbEZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5leGVjdXRlRnJhbWUoLTEpO1xuICAgIH07XG4gICAgQW5pbWF0aW9uRnJhbWVTZXJ2aWNlLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRpY2tpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudGlja2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RGcmFtZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbmltYXRpb25GcmFtZVNlcnZpY2UucHJvdG90eXBlLnJlcXVlc3RGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBhbmQgaWZcbiAgICAgICAgLy8gaXQncyBtaXNzaW5nLCB0aGVuIHdlIHBvbHlmaWxsIGl0IHdpdGggc2V0VGltZW91dCgpXG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXhlY3V0ZUZyYW1lLmJpbmQodGhpcywgNjApO1xuICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRQYW5lbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZFBhbmVsXzEuR3JpZFBhbmVsKVxuICAgIF0sIEFuaW1hdGlvbkZyYW1lU2VydmljZS5wcm90b3R5cGUsIFwiZ3JpZFBhbmVsXCIsIHZvaWQgMCk7XG4gICAgQW5pbWF0aW9uRnJhbWVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdhbmltYXRpb25GcmFtZVNlcnZpY2UnKVxuICAgIF0sIEFuaW1hdGlvbkZyYW1lU2VydmljZSk7XG4gICAgcmV0dXJuIEFuaW1hdGlvbkZyYW1lU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkFuaW1hdGlvbkZyYW1lU2VydmljZSA9IEFuaW1hdGlvbkZyYW1lU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL21pc2MvYW5pbWF0aW9uRnJhbWVTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2NvbHVtblwiKTtcbnZhciByb3dOb2RlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvcm93Tm9kZVwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xudmFyIGdyaWRDZWxsXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvZ3JpZENlbGxcIik7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgY2hlY2tib3hTZWxlY3Rpb25Db21wb25lbnRfMSA9IHJlcXVpcmUoXCIuL2NoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50XCIpO1xudmFyIENlbGxDb21wID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2VsbENvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2VsbENvbXAoc2NvcGUsIGJlYW5zLCBjb2x1bW4sIHJvd05vZGUsIHJvd0NvbXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWRpdGluZ0NlbGwgPSBmYWxzZTtcbiAgICAgICAgLy8gZXZlcnkgdGltZSB3ZSBnbyBpbnRvIGVkaXQgbW9kZSwgb3IgYmFjayBhZ2FpbiwgdGhpcyBnZXRzIGluY3JlbWVudGVkLlxuICAgICAgICAvLyBpdCdzIHRoZSBjb21wb25lbnRzIHdheSBvZiBkZWFsaW5nIHdpdGggdGhlIGFzeW5jIG5hdHVyZSBvZiBmcmFtZXdvcmsgY29tcG9uZW50cyxcbiAgICAgICAgLy8gc28gaWYgYSBmcmFtZXdvcmsgY29tcG9uZW50IHRha2VzIGEgd2hpbGUgdG8gYmUgY3JlYXRlZCwgd2Uga25vdyBpZiB0aGUgb2JqZWN0XG4gICAgICAgIC8vIGlzIHN0aWxsIHJlbGV2YW50IHdoZW4gY3JlYXRpbmcgaXMgZmluaXNoZWQuIGVnIHdlIGNvdWxkIGNsaWNrIGVkaXQgLyB1bmVkaXQgMjBcbiAgICAgICAgLy8gdGltZXMgYmVmb3JlIHRoZSBmaXJzdCBSZWFjdCBlZGl0IGNvbXBvbmVudCBjb21lcyBiYWNrIC0gd2Ugc2hvdWxkIGRpc2NhcmRcbiAgICAgICAgLy8gdGhlIGZpcnN0IDE5LlxuICAgICAgICBfdGhpcy5jZWxsRWRpdG9yVmVyc2lvbiA9IDA7XG4gICAgICAgIF90aGlzLmNlbGxSZW5kZXJlclZlcnNpb24gPSAwO1xuICAgICAgICBfdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICBfdGhpcy5iZWFucyA9IGJlYW5zO1xuICAgICAgICBfdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIF90aGlzLnJvd05vZGUgPSByb3dOb2RlO1xuICAgICAgICBfdGhpcy5yb3dDb21wID0gcm93Q29tcDtcbiAgICAgICAgX3RoaXMuY3JlYXRlR3JpZENlbGxWbygpO1xuICAgICAgICBfdGhpcy5yYW5nZVNlbGVjdGlvbkVuYWJsZWQgPSBiZWFucy5lbnRlcnByaXNlICYmIGJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgICAgIF90aGlzLmNlbGxGb2N1c2VkID0gX3RoaXMuYmVhbnMuZm9jdXNlZENlbGxDb250cm9sbGVyLmlzQ2VsbEZvY3VzZWQoX3RoaXMuZ3JpZENlbGwpO1xuICAgICAgICBfdGhpcy5maXJzdFJpZ2h0UGlubmVkID0gX3RoaXMuY29sdW1uLmlzRmlyc3RSaWdodFBpbm5lZCgpO1xuICAgICAgICBfdGhpcy5sYXN0TGVmdFBpbm5lZCA9IF90aGlzLmNvbHVtbi5pc0xhc3RMZWZ0UGlubmVkKCk7XG4gICAgICAgIGlmIChfdGhpcy5yYW5nZVNlbGVjdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIF90aGlzLnJhbmdlQ291bnQgPSBfdGhpcy5iZWFucy5yYW5nZUNvbnRyb2xsZXIuZ2V0Q2VsbFJhbmdlQ291bnQoX3RoaXMuZ3JpZENlbGwpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnZhbHVlID0gX3RoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgX3RoaXMuc2V0VXNpbmdXcmFwcGVyKCk7XG4gICAgICAgIF90aGlzLmNob29zZUNlbGxSZW5kZXJlcigpO1xuICAgICAgICBfdGhpcy5zZXR1cENvbFNwYW4oKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZ2V0Q3JlYXRlVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZVBhcnRzID0gW107XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRDZWxsV2lkdGgoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBjb2wuZ2V0TGVmdCgpO1xuICAgICAgICB2YXIgdmFsdWVUb1JlbmRlciA9IHRoaXMuZ2V0SW5pdGlhbFZhbHVlVG9SZW5kZXIoKTtcbiAgICAgICAgdmFyIHZhbHVlU2FuaXRpc2VkID0gdXRpbHNfMS5fLmdldCh0aGlzLmNvbHVtbiwgJ2NvbERlZi50ZW1wbGF0ZScsIG51bGwpID8gdmFsdWVUb1JlbmRlciA6IHV0aWxzXzEuXy5lc2NhcGUodmFsdWVUb1JlbmRlcik7XG4gICAgICAgIHZhciB0b29sdGlwID0gdGhpcy5nZXRUb29sVGlwKCk7XG4gICAgICAgIHZhciB0b29sdGlwU2FuaXRpc2VkID0gdXRpbHNfMS5fLmVzY2FwZSh0b29sdGlwKTtcbiAgICAgICAgdmFyIHdyYXBwZXJTdGFydFRlbXBsYXRlO1xuICAgICAgICB2YXIgd3JhcHBlckVuZFRlbXBsYXRlO1xuICAgICAgICB2YXIgc3R5bGVzRnJvbUNvbERlZiA9IHRoaXMucHJlUHJvY2Vzc1N0eWxlc0Zyb21Db2xEZWYoKTtcbiAgICAgICAgdmFyIGNzc0NsYXNzZXMgPSB0aGlzLmdldEluaXRpYWxDc3NDbGFzc2VzKCk7XG4gICAgICAgIGlmICh0aGlzLnVzaW5nV3JhcHBlcikge1xuICAgICAgICAgICAgd3JhcHBlclN0YXJ0VGVtcGxhdGUgPSAnPHNwYW4gcmVmPVwiZUNlbGxXcmFwcGVyXCIgY2xhc3M9XCJhZy1jZWxsLXdyYXBwZXJcIj48c3BhbiByZWY9XCJlQ2VsbFZhbHVlXCIgY2xhc3M9XCJhZy1jZWxsLXZhbHVlXCI+JztcbiAgICAgICAgICAgIHdyYXBwZXJFbmRUZW1wbGF0ZSA9ICc8L3NwYW4+PC9zcGFuPic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGV5LCB0aGlzIGxvb2tzIGxpa2UgUmVhY3QhISFcbiAgICAgICAgdGVtcGxhdGVQYXJ0cy5wdXNoKFwiPGRpdlwiKTtcbiAgICAgICAgdGVtcGxhdGVQYXJ0cy5wdXNoKFwiIHRhYmluZGV4PVxcXCItMVxcXCJcIik7XG4gICAgICAgIHRlbXBsYXRlUGFydHMucHVzaChcIiByb2xlPVxcXCJncmlkY2VsbFxcXCJcIik7XG4gICAgICAgIHRlbXBsYXRlUGFydHMucHVzaChcIiBjb21wLWlkPVxcXCJcIiArIHRoaXMuZ2V0Q29tcElkKCkgKyBcIlxcXCIgXCIpO1xuICAgICAgICB0ZW1wbGF0ZVBhcnRzLnB1c2goXCIgY29sLWlkPVxcXCJcIiArIGNvbC5nZXRJZCgpICsgXCJcXFwiXCIpO1xuICAgICAgICB0ZW1wbGF0ZVBhcnRzLnB1c2goXCIgY2xhc3M9XFxcIlwiICsgY3NzQ2xhc3Nlcy5qb2luKCcgJykgKyBcIlxcXCJcIik7XG4gICAgICAgIHRlbXBsYXRlUGFydHMucHVzaCh0b29sdGlwU2FuaXRpc2VkID8gXCIgdGl0bGU9XFxcIlwiICsgdG9vbHRpcFNhbml0aXNlZCArIFwiXFxcIlwiIDogXCJcIik7XG4gICAgICAgIHRlbXBsYXRlUGFydHMucHVzaChcIiBzdHlsZT1cXFwid2lkdGg6IFwiICsgd2lkdGggKyBcInB4OyBsZWZ0OiBcIiArIGxlZnQgKyBcInB4OyBcIiArIHN0eWxlc0Zyb21Db2xEZWYgKyBcIlxcXCIgPlwiKTtcbiAgICAgICAgdGVtcGxhdGVQYXJ0cy5wdXNoKHdyYXBwZXJTdGFydFRlbXBsYXRlKTtcbiAgICAgICAgdGVtcGxhdGVQYXJ0cy5wdXNoKHZhbHVlU2FuaXRpc2VkKTtcbiAgICAgICAgdGVtcGxhdGVQYXJ0cy5wdXNoKHdyYXBwZXJFbmRUZW1wbGF0ZSk7XG4gICAgICAgIHRlbXBsYXRlUGFydHMucHVzaChcIjwvZGl2PlwiKTtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlUGFydHMuam9pbignJyk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuYWZ0ZXJBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHF1ZXJ5U2VsZWN0b3IgPSBcIltjb21wLWlkPVxcXCJcIiArIHRoaXMuZ2V0Q29tcElkKCkgKyBcIlxcXCJdXCI7XG4gICAgICAgIHZhciBlR3VpID0gdGhpcy5lUGFyZW50Um93LnF1ZXJ5U2VsZWN0b3IocXVlcnlTZWxlY3Rvcik7XG4gICAgICAgIHRoaXMuc2V0R3VpKGVHdWkpO1xuICAgICAgICAvLyBhbGwgb2YgdGhlc2UgaGF2ZSBkZXBlbmRlbmNpZXMgb24gdGhlIGVHdWksIHNvIG9ubHkgZG8gdGhlbSBhZnRlciBlR3VpIGlzIHNldFxuICAgICAgICB0aGlzLmFkZERvbURhdGEoKTtcbiAgICAgICAgdGhpcy5hZGRTZWxlY3Rpb25DaGVja2JveCgpO1xuICAgICAgICB0aGlzLmF0dGFjaENlbGxSZW5kZXJlcigpO1xuICAgICAgICB0aGlzLmFuZ3VsYXIxQ29tcGlsZSgpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmJlYW5zLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NFTExfRk9DVVNFRCwgdGhpcy5vbkNlbGxGb2N1c2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmJlYW5zLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0ZMQVNIX0NFTExTLCB0aGlzLm9uRmxhc2hDZWxscy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5iZWFucy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fSE9WRVJfQ0hBTkdFRCwgdGhpcy5vbkNvbHVtbkhvdmVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLnJvd05vZGUsIHJvd05vZGVfMS5Sb3dOb2RlLkVWRU5UX1JPV19JTkRFWF9DSEFOR0VELCB0aGlzLm9uUm93SW5kZXhDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLnJvd05vZGUsIHJvd05vZGVfMS5Sb3dOb2RlLkVWRU5UX0NFTExfQ0hBTkdFRCwgdGhpcy5vbkNlbGxDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmNvbHVtbiwgY29sdW1uXzEuQ29sdW1uLkVWRU5UX0xFRlRfQ0hBTkdFRCwgdGhpcy5vbkxlZnRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmNvbHVtbiwgY29sdW1uXzEuQ29sdW1uLkVWRU5UX1dJRFRIX0NIQU5HRUQsIHRoaXMub25XaWR0aENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuY29sdW1uLCBjb2x1bW5fMS5Db2x1bW4uRVZFTlRfRklSU1RfUklHSFRfUElOTkVEX0NIQU5HRUQsIHRoaXMub25GaXJzdFJpZ2h0UGlubmVkQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5jb2x1bW4sIGNvbHVtbl8xLkNvbHVtbi5FVkVOVF9MQVNUX0xFRlRfUElOTkVEX0NIQU5HRUQsIHRoaXMub25MYXN0TGVmdFBpbm5lZENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIGlmIG5vdCBkb2luZyBlbnRlcnByaXNlLCB0aGVuIHJhbmdlIHNlbGVjdGlvbiBzZXJ2aWNlIHdvdWxkIGJlIG1pc3NpbmdcbiAgICAgICAgLy8gc28gbmVlZCB0byBjaGVjayBiZWZvcmUgdHJ5aW5nIHRvIHVzZSBpdFxuICAgICAgICBpZiAodGhpcy5yYW5nZVNlbGVjdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuYmVhbnMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfUkFOR0VfU0VMRUNUSU9OX0NIQU5HRUQsIHRoaXMub25SYW5nZVNlbGVjdGlvbkNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5vbkNvbHVtbkhvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNIb3ZlcmVkID0gdGhpcy5iZWFucy5jb2x1bW5Ib3ZlclNlcnZpY2UuaXNIb3ZlcmVkKHRoaXMuY29sdW1uKTtcbiAgICAgICAgdXRpbHNfMS5fLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5nZXRHdWkoKSwgJ2FnLWNvbHVtbi1ob3ZlcicsIGlzSG92ZXJlZCk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25DZWxsQ2hhbmdlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnRJbXBhY3RzVGhpc0NlbGwgPSBldmVudC5jb2x1bW4gPT09IHRoaXMuY29sdW1uO1xuICAgICAgICBpZiAoZXZlbnRJbXBhY3RzVGhpc0NlbGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENlbGwoe30pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZ2V0Q2VsbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb3N0TGVmdENvbDtcbiAgICAgICAgaWYgKHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCkgJiYgdGhpcy5jb2xzU3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIG1vc3RMZWZ0Q29sID0gdGhpcy5jb2xzU3Bhbm5pbmdbdGhpcy5jb2xzU3Bhbm5pbmcubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb3N0TGVmdENvbCA9IHRoaXMuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3N0TGVmdENvbC5nZXRMZWZ0KCk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZ2V0Q2VsbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb2xzU3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvbHNTcGFubmluZy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHsgcmV0dXJuIHJlc3VsdF8xICs9IGNvbC5nZXRBY3R1YWxXaWR0aCgpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRfMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbi5nZXRBY3R1YWxXaWR0aCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25GbGFzaENlbGxzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsSWQgPSB0aGlzLmdyaWRDZWxsLmNyZWF0ZUlkKCk7XG4gICAgICAgIHZhciBzaG91bGRGbGFzaCA9IGV2ZW50LmNlbGxzW2NlbGxJZF07XG4gICAgICAgIGlmIChzaG91bGRGbGFzaCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlQ2VsbCgnaGlnaGxpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5zZXR1cENvbFNwYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIG5vIGNvbCBzcGFuIGlzIGFjdGl2ZSwgdGhlbiB3ZSBkb24ndCBzZXQgaXQgdXAsIGFzIGl0IHdvdWxkIGJlIHdhc3RlZnVsIG9mIENQVVxuICAgICAgICBpZiAodXRpbHNfMS5fLm1pc3NpbmcodGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCkuY29sU3BhbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFyZSBjb2wgc3Bhbm5pbmcsIGEgcmVvcmRlciBvZiB0aGUgY29scyBjYW4gY2hhbmdlIHdoYXQgY29scyB3ZSBhcmUgc3Bhbm5pbmcgb3ZlclxuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmJlYW5zLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0RJU1BMQVlFRF9DT0xVTU5TX0NIQU5HRUQsIHRoaXMub25EaXNwbGF5Q29sdW1uc0NoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgYXJlIHNwYW5uaW5nIG92ZXIgbXVsdGlwbGUgY29scywgd2UgY2hlY2sgZm9yIHdpZHRoIGFueSB0aW1lIGFueSBjb2xzIHdpZHRoIGNoYW5nZXMuXG4gICAgICAgIC8vIHRoaXMgaXMgZXhwZW5zaXZlIC0gcmVhbGx5IHdlIHNob3VsZCBiZSBleHBsaWNpdGx5IGNoZWNraW5nIG9ubHkgdGhlIGNvbHMgd2UgYXJlIHNwYW5uaW5nIG92ZXJcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBldmVyeSBjb2wsIGhvd2V2ZXIgaXQgd291bGQgYmUgdHJpY2t5IGNvZGUgdG8gdHJhY2sgdGhlIGNvbHMgd2UgYXJlIHNwYW5uaW5nIG92ZXIsIHNvXG4gICAgICAgIC8vIGJlY2F1c2UgaGFyZGx5IGFueW9uZSB3aWxsIGJlIHVzaW5nIGNvbFNwYW4sIGFtIGZhdm9yaW5nIHRoaXMgZWFzaWVyIHdheSBmb3IgbW9yZSBtYWludGFpbmFibGUgY29kZS5cbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5iZWFucy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9ESVNQTEFZRURfQ09MVU1OU19XSURUSF9DSEFOR0VELCB0aGlzLm9uV2lkdGhDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmNvbHNTcGFubmluZyA9IHRoaXMuZ2V0Q29sU3Bhbm5pbmdMaXN0KCk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZ2V0Q29sU3Bhbm5pbmdMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sU3BhbiA9IHRoaXMuY29sdW1uLmdldENvbFNwYW4odGhpcy5yb3dOb2RlKTtcbiAgICAgICAgdmFyIGNvbHNTcGFubmluZyA9IFtdO1xuICAgICAgICAvLyBpZiBqdXN0IG9uZSBjb2wsIHRoZSBjb2wgc3BhbiBpcyBqdXN0IHRoZSBjb2x1bW4gd2UgYXJlIGluXG4gICAgICAgIGlmIChjb2xTcGFuID09PSAxKSB7XG4gICAgICAgICAgICBjb2xzU3Bhbm5pbmcucHVzaCh0aGlzLmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuY29sdW1uO1xuICAgICAgICAgICAgdmFyIHBpbm5lZCA9IHRoaXMuY29sdW1uLmdldFBpbm5lZCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xTcGFuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2xzU3Bhbm5pbmcucHVzaChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyID0gdGhpcy5iZWFucy5jb2x1bW5Db250cm9sbGVyLmdldERpc3BsYXllZENvbEFmdGVyKHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLl8ubWlzc2luZyhwb2ludGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2UgZG8gbm90IGFsbG93IGNvbCBzcGFubmluZyB0byBzcGFuIG91dHNpZGUgb2YgcGlubmVkIGFyZWFzXG4gICAgICAgICAgICAgICAgaWYgKHBpbm5lZCAhPT0gcG9pbnRlci5nZXRQaW5uZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHNTcGFubmluZztcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5vbkRpc3BsYXlDb2x1bW5zQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbHNTcGFubmluZyA9IHRoaXMuZ2V0Q29sU3Bhbm5pbmdMaXN0KCk7XG4gICAgICAgIGlmICghdXRpbHNfMS5fLmNvbXBhcmVBcnJheXModGhpcy5jb2xzU3Bhbm5pbmcsIGNvbHNTcGFubmluZykpIHtcbiAgICAgICAgICAgIHRoaXMuY29sc1NwYW5uaW5nID0gY29sc1NwYW5uaW5nO1xuICAgICAgICAgICAgdGhpcy5vbldpZHRoQ2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy5vbkxlZnRDaGFuZ2VkKCk7IC8vIGxlZnQgY2hhbmdlcyB3aGVuIGRvaW5nIFJUTFxuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZ2V0SW5pdGlhbENzc0NsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzc2VzID0gW1wiYWctY2VsbFwiLCBcImFnLWNlbGwtbm90LWlubGluZS1lZGl0aW5nXCJdO1xuICAgICAgICBjc3NDbGFzc2VzLnB1c2godGhpcy5jZWxsRm9jdXNlZCA/ICdhZy1jZWxsLWZvY3VzJyA6ICdhZy1jZWxsLW5vLWZvY3VzJyk7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0UmlnaHRQaW5uZWQpIHtcbiAgICAgICAgICAgIGNzc0NsYXNzZXMucHVzaCgnYWctY2VsbC1maXJzdC1yaWdodC1waW5uZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0TGVmdFBpbm5lZCkge1xuICAgICAgICAgICAgY3NzQ2xhc3Nlcy5wdXNoKCdhZy1jZWxsLWxhc3QtbGVmdC1waW5uZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iZWFucy5jb2x1bW5Ib3ZlclNlcnZpY2UuaXNIb3ZlcmVkKHRoaXMuY29sdW1uKSkge1xuICAgICAgICAgICAgY3NzQ2xhc3Nlcy5wdXNoKCdhZy1jb2x1bW4taG92ZXInKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsc18xLl8ucHVzaEFsbChjc3NDbGFzc2VzLCB0aGlzLnByZVByb2Nlc3NDbGFzc2VzRnJvbUNvbERlZigpKTtcbiAgICAgICAgdXRpbHNfMS5fLnB1c2hBbGwoY3NzQ2xhc3NlcywgdGhpcy5wcmVQcm9jZXNzQ2VsbENsYXNzUnVsZXMoKSk7XG4gICAgICAgIHV0aWxzXzEuXy5wdXNoQWxsKGNzc0NsYXNzZXMsIHRoaXMuZ2V0UmFuZ2VDbGFzc2VzKCkpO1xuICAgICAgICAvLyBpZiB1c2luZyB0aGUgd3JhcHBlciwgdGhpcyBjbGFzcyBnb2VzIG9uIHRoZSB3cmFwcGVyIGluc3RlYWRcbiAgICAgICAgaWYgKCF0aGlzLnVzaW5nV3JhcHBlcikge1xuICAgICAgICAgICAgY3NzQ2xhc3Nlcy5wdXNoKCdhZy1jZWxsLXZhbHVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZ2V0SW5pdGlhbFZhbHVlVG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIHVzaW5nIGEgY2VsbFJlbmRlcmVyLCB0aGVuIHJlbmRlciB0aGUgaHRtbCBmcm9tIHRoZSBjZWxsIHJlbmRlcmVyIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAodGhpcy51c2luZ0NlbGxSZW5kZXJlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNlbGxSZW5kZXJlckd1aSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsUmVuZGVyZXJHdWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbERlZiA9IHRoaXMuY29sdW1uLmdldENvbERlZigpO1xuICAgICAgICBpZiAoY29sRGVmLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyB0ZW1wbGF0ZSBpcyByZWFsbHkgb25seSB1c2VkIGZvciBhbmd1bGFyIDEgLSBhcyBwZW9wbGUgdXNpbmcgbmcxIGFyZSB1c2VkIHRvIHByb3ZpZGluZyB0ZW1wbGF0ZXMgd2l0aFxuICAgICAgICAgICAgLy8gYmluZGluZ3MgaW4gaXQuIGluIG5nMiwgcGVvcGxlIHdpbGwgaG9wZWZ1bGx5IHdhbnQgdG8gcHJvdmlkZSBjb21wb25lbnRzLCBub3QgdGVtcGxhdGVzLlxuICAgICAgICAgICAgcmV0dXJuIGNvbERlZi50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2xEZWYudGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICAgIC8vIGxpa2V3aXNlIGZvciB0ZW1wbGF0ZVVybCAtIGl0J3MgZm9yIG5nMSByZWFsbHkgLSB3aGVuIHdlIG1vdmUgYXdheSBmcm9tIG5nMSwgd2UgY2FuIHRha2UgdGhlc2Ugb3V0LlxuICAgICAgICAgICAgLy8gbmlhbGwgd2FzIHBybyBhbmd1bGFyIDEgd2hlbiB3cml0aW5nIHRlbXBsYXRlIGFuZCB0ZW1wbGF0ZVVybCwgaWYgd3JpdGluZyBmcm9tIHNjcmF0Y2ggbm93LCB3b3VsZFxuICAgICAgICAgICAgLy8gbm90IGRvIHRoZXNlLCBidXQgd291bGQgZm9sbG93IGEgcGF0dGVybiB0aGF0IHdhcyBmcmllbmRseSB0b3dhcmRzIGNvbXBvbmVudHMsIG5vdCB0ZW1wbGF0ZXMuXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLmJlYW5zLnRlbXBsYXRlU2VydmljZS5nZXRUZW1wbGF0ZShjb2xEZWYudGVtcGxhdGVVcmwsIHRoaXMucmVmcmVzaENlbGwuYmluZCh0aGlzLCB0cnVlKSk7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVGb3JtYXR0ZWQgPSB0aGlzLmJlYW5zLnZhbHVlRm9ybWF0dGVyU2VydmljZS5mb3JtYXRWYWx1ZSh0aGlzLmNvbHVtbiwgdGhpcy5yb3dOb2RlLCBudWxsLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlZEV4aXRzID0gdmFsdWVGb3JtYXR0ZWQgIT09IG51bGwgJiYgdmFsdWVGb3JtYXR0ZWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZUZvcm1hdHRlZEV4aXRzID8gdmFsdWVGb3JtYXR0ZWQgOiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZ2V0UmVuZGVyZWRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0NvbXA7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuaXNTdXBwcmVzc05hdmlnYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uLmlzU3VwcHJlc3NOYXZpZ2FibGUodGhpcy5yb3dOb2RlKTtcbiAgICB9O1xuICAgIC8vICsgc3RvcCBlZGl0aW5nIHtmb3JjZVJlZnJlc2g6IHRydWUsIHN1cHByZXNzRmxhc2g6IHRydWV9XG4gICAgLy8gKyBldmVudCBjZWxsQ2hhbmdlZCB7fVxuICAgIC8vICsgY2VsbFJlbmRlcmVyLnBhcmFtcy5yZWZyZXNoKCkge30gLT4gbWV0aG9kIHBhc3NlcyAnYXMgaXMnIHRvIHRoZSBjZWxsUmVuZGVyZXIsIHNvIHBhcmFtcyBjb3VsZCBiZSBhbnl0aGluZ1xuICAgIC8vICsgcm93Q29tcDogZXZlbnQgZGF0YUNoYW5nZWQge2FuaW1hdGU6IHVwZGF0ZSwgbmV3RGF0YTogIXVwZGF0ZX1cbiAgICAvLyArIHJvd0NvbXA6IGFwaSByZWZyZXNoQ2VsbHMoKSB7YW5pbWF0ZTogdHJ1ZS9mYWxzZX1cbiAgICAvLyArIHJvd1JlbmRlcmVyOiBhcGkgc29mdFJlZnJlc2hWaWV3KCkge31cbiAgICBDZWxsQ29tcC5wcm90b3R5cGUucmVmcmVzaENlbGwgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRpbmdDZWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0RhdGEgPSBwYXJhbXMgJiYgcGFyYW1zLm5ld0RhdGE7XG4gICAgICAgIHZhciBzdXBwcmVzc0ZsYXNoID0gcGFyYW1zICYmIHBhcmFtcy5zdXBwcmVzc0ZsYXNoO1xuICAgICAgICB2YXIgdm9sYXRpbGUgPSBwYXJhbXMgJiYgcGFyYW1zLnZvbGF0aWxlO1xuICAgICAgICB2YXIgZm9yY2VSZWZyZXNoID0gcGFyYW1zICYmIHBhcmFtcy5mb3JjZVJlZnJlc2g7XG4gICAgICAgIC8vIGlmIG9ubHkgcmVmcmVzaGluZyB2b2xhdGlsZSBjZWxscywgdGhlbiBza2lwIHRoZSByZWZyZXNoIGlmIHdlIGFyZSBub3Qgdm9sYXRpbGVcbiAgICAgICAgaWYgKHZvbGF0aWxlICYmICF0aGlzLmlzVm9sYXRpbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIC8vIGZvciBzaW1wbGUgdmFsdWVzIG9ubHkgKG5vdCBwb2pvJ3MpLCBzZWUgaWYgdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBhbmQgaWYgaXQgaXMsIHNraXAgdGhlIHJlZnJlc2guXG4gICAgICAgIC8vIHdoZW4gbmV2ZXIgYWxsb3cgc2tpcHBpbmcgYWZ0ZXIgYW4gZWRpdCwgYXMgYWZ0ZXIgZWRpdGluZywgd2UgbmVlZCB0byBwdXQgdGhlIEdVSSBiYWNrIHRvIHRoZSB3YXlcbiAgICAgICAgLy8gaWYgd2FzIGJlZm9yZSB0aGUgZWRpdC5cbiAgICAgICAgdmFyIHNraXBSZWZyZXNoID0gIWZvcmNlUmVmcmVzaCAmJiB0aGlzLnZhbHVlc0FyZUVxdWFsKG9sZFZhbHVlLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgaWYgKHNraXBSZWZyZXNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlbGxSZW5kZXJlclJlZnJlc2hlZDtcbiAgICAgICAgLy8gaWYgaXQncyAnbmV3IGRhdGEnLCB0aGVuIHdlIGRvbid0IHJlZnJlc2ggdGhlIGNlbGxSZW5kZXJlciwgZXZlbiBpZiByZWZyZXNoIG1ldGhvZCBpcyBhdmFpbGFibGUuXG4gICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBpZiB0aGUgd2hvbGUgZGF0YSBpcyBuZXcgKGllIHdlIGFyZSBzaG93aW5nIHN0b2NrIHByaWNlICdCQkEnIG5vdyBhbmQgbm90ICdTU0QnKVxuICAgICAgICAvLyB0aGVuIHdlIGFyZSBub3Qgc2hvd2luZyBhIG1vdmVtZW50IGluIHRoZSBzdG9jayBwcmljZSwgcmF0aGVyIHdlIGFyZSBzaG93aW5nIGRpZmZlcmVudCBzdG9jay5cbiAgICAgICAgaWYgKG5ld0RhdGEgfHwgc3VwcHJlc3NGbGFzaCkge1xuICAgICAgICAgICAgY2VsbFJlbmRlcmVyUmVmcmVzaGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZWxsUmVuZGVyZXJSZWZyZXNoZWQgPSB0aGlzLmF0dGVtcHRDZWxsUmVuZGVyZXJSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZG8gdGhlIHJlcGxhY2UgaWYgbm90IGRvaW5nIHJlZnJlc2gsIG9yIGlmIHJlZnJlc2ggd2FzIHVuc3VjY2Vzc2Z1bC5cbiAgICAgICAgLy8gdGhlIHJlZnJlc2ggY2FuIGJlIHVuc3VjY2Vzc2Z1bCBpZiB3ZSBhcmUgdXNpbmcgYSBmcmFtZXdvcmsgKGVnIG5nMiBvciByZWFjdCkgYW5kIHRoZSBmcmFtZXdvcmtcbiAgICAgICAgLy8gd3JhcHBlciBoYXMgdGhlIHJlZnJlc2ggbWV0aG9kLCBidXQgdGhlIHVuZGVybHlpbmcgY29tcG9uZW50IGRvZXNuJ3RcbiAgICAgICAgaWYgKCFjZWxsUmVuZGVyZXJSZWZyZXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUNvbnRlbnRzQWZ0ZXJSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdXBwcmVzc0ZsYXNoKSB7XG4gICAgICAgICAgICB0aGlzLmZsYXNoQ2VsbCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgcnVsZXMuIG5vdGUsIHdlIGlnbm9yZSBjb2xEZWYgY2xhc3NlcyBhbmQgc3R5bGVzLCB0aGVzZSBhcmUgYXNzdW1lZCB0byBiZSBzdGF0aWNcbiAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc1N0eWxlc0Zyb21Db2xEZWYoKTtcbiAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc0NsYXNzZXNGcm9tQ29sRGVmKCk7XG4gICAgICAgIHRoaXMucG9zdFByb2Nlc3NDZWxsQ2xhc3NSdWxlcygpO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmZsYXNoQ2VsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlQ2VsbENoYW5nZUZsYXNoKCkgfHwgdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCkuZW5hYmxlQ2VsbENoYW5nZUZsYXNoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVDZWxsKCdkYXRhLWNoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmFuaW1hdGVDZWxsID0gZnVuY3Rpb24gKGNzc05hbWUpIHtcbiAgICAgICAgdmFyIGZ1bGxOYW1lID0gJ2FnLWNlbGwtJyArIGNzc05hbWU7XG4gICAgICAgIHZhciBhbmltYXRpb25GdWxsTmFtZSA9ICdhZy1jZWxsLScgKyBjc3NOYW1lICsgJy1hbmltYXRpb24nO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0R3VpKCk7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gaGlnaGxpZ2h0IHRoZSBjZWxscywgd2l0aG91dCBhbnkgYW5pbWF0aW9uXG4gICAgICAgIHV0aWxzXzEuXy5hZGRDc3NDbGFzcyhlbGVtZW50LCBmdWxsTmFtZSk7XG4gICAgICAgIHV0aWxzXzEuXy5yZW1vdmVDc3NDbGFzcyhlbGVtZW50LCBhbmltYXRpb25GdWxsTmFtZSk7XG4gICAgICAgIC8vIHRoZW4gb25jZSB0aGF0IGlzIGFwcGxpZWQsIHdlIHJlbW92ZSB0aGUgaGlnaGxpZ2h0IHdpdGggYW5pbWF0aW9uXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXRpbHNfMS5fLnJlbW92ZUNzc0NsYXNzKGVsZW1lbnQsIGZ1bGxOYW1lKTtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5hZGRDc3NDbGFzcyhlbGVtZW50LCBhbmltYXRpb25GdWxsTmFtZSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiB0byBsZWF2ZSB0aGluZ3MgYXMgd2UgZ290IHRoZW0sIHdlIHJlbW92ZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgdXRpbHNfMS5fLnJlbW92ZUNzc0NsYXNzKGVsZW1lbnQsIGFuaW1hdGlvbkZ1bGxOYW1lKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9LCA1MDApO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLnJlcGxhY2VDb250ZW50c0FmdGVyUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHJpcCBvdXQgdGhlIGNlbGwgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgdXRpbHNfMS5fLnJlbW92ZUFsbENoaWxkcmVuKHRoaXMuZVBhcmVudE9mVmFsdWUpO1xuICAgICAgICAvLyByZW1vdmUgb2xkIHJlbmRlcmVyIGNvbXBvbmVudCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuY2VsbFJlbmRlcmVyICYmIHRoaXMuY2VsbFJlbmRlcmVyLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNlbGxSZW5kZXJlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyR3VpID0gbnVsbDtcbiAgICAgICAgLy8gcG9wdWxhdGVcbiAgICAgICAgdGhpcy5wdXREYXRhSW50b0NlbGxBZnRlclJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5hbmd1bGFyMUNvbXBpbGUoKTtcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5hbmd1bGFyMUNvbXBpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIGFuZ3VsYXIgY29tcGlsaW5nLCB0aGVuIG5lZWQgdG8gYWxzbyBjb21waWxlIHRoZSBjZWxsIGFnYWluIChhbmd1bGFyIGNvbXBpbGluZyBzdWNrcywgcGxlYXNlIHdhaXQuLi4pXG4gICAgICAgIGlmICh0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5pc0FuZ3VsYXJDb21waWxlUm93cygpKSB7XG4gICAgICAgICAgICB2YXIgZUd1aSA9IHRoaXMuZ2V0R3VpKCk7XG4gICAgICAgICAgICB0aGlzLmJlYW5zLiRjb21waWxlKGVHdWkpKHRoaXMuc2NvcGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUucG9zdFByb2Nlc3NTdHlsZXNGcm9tQ29sRGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGVzVG9Vc2UgPSB0aGlzLnByb2Nlc3NTdHlsZXNGcm9tQ29sRGVmKCk7XG4gICAgICAgIGlmIChzdHlsZXNUb1VzZSkge1xuICAgICAgICAgICAgdXRpbHNfMS5fLmFkZFN0eWxlc1RvRWxlbWVudCh0aGlzLmdldEd1aSgpLCBzdHlsZXNUb1VzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5wcmVQcm9jZXNzU3R5bGVzRnJvbUNvbERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlc1RvVXNlID0gdGhpcy5wcm9jZXNzU3R5bGVzRnJvbUNvbERlZigpO1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5fLmNzc1N0eWxlT2JqZWN0VG9NYXJrdXAoc3R5bGVzVG9Vc2UpO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLnByb2Nlc3NTdHlsZXNGcm9tQ29sRGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sRGVmID0gdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCk7XG4gICAgICAgIGlmIChjb2xEZWYuY2VsbFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgY3NzVG9Vc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbERlZi5jZWxsU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbFN0eWxlUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5yb3dOb2RlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHRoaXMucm93Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgY29sRGVmOiBjb2xEZWYsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICRzY29wZTogdGhpcy5zY29wZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgICAgICBhcGk6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbFN0eWxlRnVuYyA9IGNvbERlZi5jZWxsU3R5bGU7XG4gICAgICAgICAgICAgICAgY3NzVG9Vc2UgPSBjZWxsU3R5bGVGdW5jKGNlbGxTdHlsZVBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjc3NUb1VzZSA9IGNvbERlZi5jZWxsU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3NzVG9Vc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5wb3N0UHJvY2Vzc0NsYXNzZXNGcm9tQ29sRGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb2Nlc3NDbGFzc2VzRnJvbUNvbERlZihmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiB1dGlsc18xLl8uYWRkQ3NzQ2xhc3MoX3RoaXMuZ2V0R3VpKCksIGNsYXNzTmFtZSk7IH0pO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLnByZVByb2Nlc3NDbGFzc2VzRnJvbUNvbERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB0aGlzLnByb2Nlc3NDbGFzc2VzRnJvbUNvbERlZihmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiByZXMucHVzaChjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5wcm9jZXNzQ2xhc3Nlc0Zyb21Db2xEZWYgPSBmdW5jdGlvbiAob25BcHBsaWNhYmxlQ2xhc3MpIHtcbiAgICAgICAgdGhpcy5iZWFucy5zdHlsaW5nU2VydmljZS5wcm9jZXNzU3RhdGljQ2VsbENsYXNzZXModGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCksIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5yb3dOb2RlLmRhdGEsXG4gICAgICAgICAgICBub2RlOiB0aGlzLnJvd05vZGUsXG4gICAgICAgICAgICBjb2xEZWY6IHRoaXMuY29sdW1uLmdldENvbERlZigpLFxuICAgICAgICAgICAgcm93SW5kZXg6IHRoaXMucm93Tm9kZS5yb3dJbmRleCxcbiAgICAgICAgICAgICRzY29wZTogdGhpcy5zY29wZSxcbiAgICAgICAgICAgIGFwaTogdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCksXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb250ZXh0KClcbiAgICAgICAgfSwgb25BcHBsaWNhYmxlQ2xhc3MpO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLnB1dERhdGFJbnRvQ2VsbEFmdGVyUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGVtcGxhdGUgZ2V0cyBwcmVmZXJlbmNlLCB0aGVuIGNlbGxSZW5kZXJlciwgdGhlbiBkbyBpdCBvdXJzZWx2ZXNcbiAgICAgICAgdmFyIGNvbERlZiA9IHRoaXMuY29sdW1uLmdldENvbERlZigpO1xuICAgICAgICBpZiAoY29sRGVmLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyB0ZW1wbGF0ZSBpcyByZWFsbHkgb25seSB1c2VkIGZvciBhbmd1bGFyIDEgLSBhcyBwZW9wbGUgdXNpbmcgbmcxIGFyZSB1c2VkIHRvIHByb3ZpZGluZyB0ZW1wbGF0ZXMgd2l0aFxuICAgICAgICAgICAgLy8gYmluZGluZ3MgaW4gaXQuIGluIG5nMiwgcGVvcGxlIHdpbGwgaG9wZWZ1bGx5IHdhbnQgdG8gcHJvdmlkZSBjb21wb25lbnRzLCBub3QgdGVtcGxhdGVzLlxuICAgICAgICAgICAgdGhpcy5lUGFyZW50T2ZWYWx1ZS5pbm5lckhUTUwgPSBjb2xEZWYudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sRGVmLnRlbXBsYXRlVXJsKSB7XG4gICAgICAgICAgICAvLyBsaWtld2lzZSBmb3IgdGVtcGxhdGVVcmwgLSBpdCdzIGZvciBuZzEgcmVhbGx5IC0gd2hlbiB3ZSBtb3ZlIGF3YXkgZnJvbSBuZzEsIHdlIGNhbiB0YWtlIHRoZXNlIG91dC5cbiAgICAgICAgICAgIC8vIG5pYWxsIHdhcyBwcm8gYW5ndWxhciAxIHdoZW4gd3JpdGluZyB0ZW1wbGF0ZSBhbmQgdGVtcGxhdGVVcmwsIGlmIHdyaXRpbmcgZnJvbSBzY3JhdGNoIG5vdywgd291bGRcbiAgICAgICAgICAgIC8vIG5vdCBkbyB0aGVzZSwgYnV0IHdvdWxkIGZvbGxvdyBhIHBhdHRlcm4gdGhhdCB3YXMgZnJpZW5kbHkgdG93YXJkcyBjb21wb25lbnRzLCBub3QgdGVtcGxhdGVzLlxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5iZWFucy50ZW1wbGF0ZVNlcnZpY2UuZ2V0VGVtcGxhdGUoY29sRGVmLnRlbXBsYXRlVXJsLCB0aGlzLnJlZnJlc2hDZWxsLmJpbmQodGhpcywgdHJ1ZSkpO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lUGFyZW50T2ZWYWx1ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZSBjZWxsIHJlbmRlcmVyIGlmIGl0IGV4aXN0c1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudXNpbmdDZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2VsbFJlbmRlcmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVGb3JtYXR0ZWQgPSB0aGlzLmJlYW5zLnZhbHVlRm9ybWF0dGVyU2VydmljZS5mb3JtYXRWYWx1ZSh0aGlzLmNvbHVtbiwgdGhpcy5yb3dOb2RlLCB0aGlzLnNjb3BlLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlZEV4aXRzID0gdmFsdWVGb3JtYXR0ZWQgIT09IG51bGwgJiYgdmFsdWVGb3JtYXR0ZWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciB2YWx1ZVRvUmVuZGVyID0gdmFsdWVGb3JtYXR0ZWRFeGl0cyA/IHZhbHVlRm9ybWF0dGVkIDogdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVRvUmVuZGVyICE9PSBudWxsICYmIHZhbHVlVG9SZW5kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZVBhcmVudE9mVmFsdWUuaW5uZXJUZXh0ID0gdmFsdWVUb1JlbmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sRGVmLnRvb2x0aXBGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnJvd05vZGUuZGF0YTtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLl8uZXhpc3RzKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXAgPSB1dGlsc18xLl8uZ2V0VmFsdWVVc2luZ0ZpZWxkKGRhdGEsIGNvbERlZi50b29sdGlwRmllbGQsIHRoaXMuY29sdW1uLmlzVG9vbHRpcEZpZWxkQ29udGFpbnNEb3RzKCkpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLl8uZXhpc3RzKHRvb2x0aXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZVBhcmVudE9mVmFsdWUuc2V0QXR0cmlidXRlKCd0aXRsZScsIHRvb2x0aXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lUGFyZW50T2ZWYWx1ZS5yZW1vdmVBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuYXR0ZW1wdENlbGxSZW5kZXJlclJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh1dGlsc18xLl8ubWlzc2luZyh0aGlzLmNlbGxSZW5kZXJlcikgfHwgdXRpbHNfMS5fLm1pc3NpbmcodGhpcy5jZWxsUmVuZGVyZXIucmVmcmVzaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgY2VsbCByZW5kZXJlciBoYXMgYSByZWZyZXNoIG1ldGhvZCwgd2UgY2FsbCB0aGlzIGluc3RlYWQgb2YgZG9pbmcgYSByZWZyZXNoXG4gICAgICAgIC8vIG5vdGU6IHNob3VsZCBwYXNzIGluIHBhcmFtcyBoZXJlIGluc3RlYWQgb2YgdmFsdWU/PyBzbyB0aGF0IGNsaWVudCBoYXMgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgdmFyIHZhbHVlRm9ybWF0dGVkID0gdGhpcy5mb3JtYXRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuY3JlYXRlQ2VsbFJlbmRlcmVyUGFyYW1zKHZhbHVlRm9ybWF0dGVkKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2VsbFJlbmRlcmVyLnJlZnJlc2gocGFyYW1zKTtcbiAgICAgICAgLy8gTk9URSBvbiB1bmRlZmluZWQ6IHByZXZpb3VzIHZlcnNpb24gb2YgdGhlIGNlbGxSZW5kZXJlci5yZWZyZXNoKCkgaW50ZXJmYWNlXG4gICAgICAgIC8vIHJldHVybmVkIG5vdGhpbmcsIGlmIHRoZSBtZXRob2QgZXhpc3RlZCwgd2UgYXNzdW1lZCBpdCByZWZyZXNoZWQuIHNvIGZvclxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2UgYXNzdW1lIGlmIG1ldGhvZCBleGlzdHMgYW5kIHJldHVybnMgbm90aGluZyxcbiAgICAgICAgLy8gdGhhdCBpdCB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZSB8fCByZXN1bHQgPT09IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5pc1ZvbGF0aWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCkudm9sYXRpbGU7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUudmFsdWVzQXJlRXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMikge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBwcm92aWRlZCBhbiBlcXVhbHMgbWV0aG9kLCB1c2UgdGhhdCwgb3RoZXJ3aXNlIGRvIHNpbXBsZSBjb21wYXJpc29uXG4gICAgICAgIHZhciBjb2xEZWYgPSB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKTtcbiAgICAgICAgdmFyIGVxdWFsc01ldGhvZCA9IGNvbERlZiA/IGNvbERlZi5lcXVhbHMgOiBudWxsO1xuICAgICAgICBpZiAoZXF1YWxzTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxzTWV0aG9kKHZhbDEsIHZhbDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDEgPT09IHZhbDI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5nZXRUb29sVGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sRGVmID0gdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5yb3dOb2RlLmRhdGE7XG4gICAgICAgIGlmIChjb2xEZWYudG9vbHRpcEZpZWxkICYmIHV0aWxzXzEuXy5leGlzdHMoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLl8uZ2V0VmFsdWVVc2luZ0ZpZWxkKGRhdGEsIGNvbERlZi50b29sdGlwRmllbGQsIHRoaXMuY29sdW1uLmlzVG9vbHRpcEZpZWxkQ29udGFpbnNEb3RzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5wcm9jZXNzQ2VsbENsYXNzUnVsZXMgPSBmdW5jdGlvbiAob25BcHBsaWNhYmxlQ2xhc3MsIG9uTm90QXBwbGljYWJsZUNsYXNzKSB7XG4gICAgICAgIHRoaXMuYmVhbnMuc3R5bGluZ1NlcnZpY2UucHJvY2Vzc0NsYXNzUnVsZXModGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCkuY2VsbENsYXNzUnVsZXMsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5yb3dOb2RlLmRhdGEsXG4gICAgICAgICAgICBub2RlOiB0aGlzLnJvd05vZGUsXG4gICAgICAgICAgICBjb2xEZWY6IHRoaXMuY29sdW1uLmdldENvbERlZigpLFxuICAgICAgICAgICAgcm93SW5kZXg6IHRoaXMuZ3JpZENlbGwucm93SW5kZXgsXG4gICAgICAgICAgICBhcGk6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpXG4gICAgICAgIH0sIG9uQXBwbGljYWJsZUNsYXNzLCBvbk5vdEFwcGxpY2FibGVDbGFzcyk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUucG9zdFByb2Nlc3NDZWxsQ2xhc3NSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm9jZXNzQ2VsbENsYXNzUnVsZXMoZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdXRpbHNfMS5fLmFkZENzc0NsYXNzKF90aGlzLmdldEd1aSgpLCBjbGFzc05hbWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB1dGlsc18xLl8ucmVtb3ZlQ3NzQ2xhc3MoX3RoaXMuZ2V0R3VpKCksIGNsYXNzTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLnByZVByb2Nlc3NDZWxsQ2xhc3NSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB0aGlzLnByb2Nlc3NDZWxsQ2xhc3NSdWxlcyhmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXMucHVzaChjbGFzc05hbWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAvLyBub3QgY2F0ZXJlZCBmb3IsIGlmIGNyZWF0aW5nLCBubyBuZWVkXG4gICAgICAgICAgICAvLyB0byByZW1vdmUgY2xhc3MgYXMgaXQgd2FzIG5ldmVyIHRoZXJlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgLy8gYSB3cmFwcGVyIGlzIHVzZWQgd2hlbiB3ZSBhcmUgcHV0dGluZyBhIHNlbGVjdGlvbiBjaGVja2JveCBpbiB0aGUgY2VsbCB3aXRoIHRoZSB2YWx1ZVxuICAgIENlbGxDb21wLnByb3RvdHlwZS5zZXRVc2luZ1dyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2xEZWYgPSB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKTtcbiAgICAgICAgLy8gbmV2ZXIgYWxsb3cgc2VsZWN0aW9uIG9uIHBpbm5lZCByb3dzXG4gICAgICAgIGlmICh0aGlzLnJvd05vZGUucm93UGlubmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVzaW5nV3JhcHBlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb2xEZWYuY2hlY2tib3hTZWxlY3Rpb24gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy51c2luZ1dyYXBwZXIgPSBjb2xEZWYuY2hlY2tib3hTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbERlZi5jaGVja2JveFNlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWYgY2hlY2tib3hTZWxlY3Rpb24gaXMgYSBmdW5jdGlvbiwgdGhlbiB0aGUgY2hlY2tib3ggbWF5IG9yIG1heSBub3QgYmUgcHJlc2VudCxcbiAgICAgICAgICAgIC8vIHNvIHdlIGluY2x1ZGUgdGhlIEhUTUwgd3JhcHBlciB0byBjYXRlciBmb3IgZWl0aGVyIGNhc2VcbiAgICAgICAgICAgIHRoaXMudXNpbmdXcmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXNpbmdXcmFwcGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5jaG9vc2VDZWxsUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRlbXBsYXRlIGdldHMgcHJlZmVyZW5jZSwgdGhlbiBjZWxsUmVuZGVyZXIsIHRoZW4gZG8gaXQgb3Vyc2VsdmVzXG4gICAgICAgIHZhciBjb2xEZWYgPSB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKTtcbiAgICAgICAgLy8gdGVtcGxhdGVzIGFyZSBmb3IgbmcxLCBpZGVhbGx5IHdlIHdvdWxkbid0IGhhdmUgdGhlc2UsIHRoZXkgYXJlIG5nMSBzdXBwb3J0XG4gICAgICAgIC8vIGluc2lkZSB0aGUgY29yZSB3aGljaCBpcyBiYWRcbiAgICAgICAgaWYgKGNvbERlZi50ZW1wbGF0ZSB8fCBjb2xEZWYudGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICAgIHRoaXMudXNpbmdDZWxsUmVuZGVyZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2VsbFJlbmRlcmVyID0gdGhpcy5iZWFucy5jb21wb25lbnRSZXNvbHZlci5nZXRDb21wb25lbnRUb1VzZShjb2xEZWYsICdjZWxsUmVuZGVyZXInKTtcbiAgICAgICAgdmFyIHBpbm5lZFJvd0NlbGxSZW5kZXJlciA9IHRoaXMuYmVhbnMuY29tcG9uZW50UmVzb2x2ZXIuZ2V0Q29tcG9uZW50VG9Vc2UoY29sRGVmLCAncGlubmVkUm93Q2VsbFJlbmRlcmVyJyk7XG4gICAgICAgIGlmIChwaW5uZWRSb3dDZWxsUmVuZGVyZXIgJiYgdGhpcy5yb3dOb2RlLnJvd1Bpbm5lZCkge1xuICAgICAgICAgICAgdGhpcy5jZWxsUmVuZGVyZXJUeXBlID0gJ3Bpbm5lZFJvd0NlbGxSZW5kZXJlcic7XG4gICAgICAgICAgICB0aGlzLnVzaW5nQ2VsbFJlbmRlcmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyVHlwZSA9ICdjZWxsUmVuZGVyZXInO1xuICAgICAgICAgICAgdGhpcy51c2luZ0NlbGxSZW5kZXJlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVzaW5nQ2VsbFJlbmRlcmVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5jcmVhdGVDZWxsUmVuZGVyZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlVG9SZW5kZXIgPSB0aGlzLmZvcm1hdFZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5jcmVhdGVDZWxsUmVuZGVyZXJQYXJhbXModmFsdWVUb1JlbmRlcik7XG4gICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyVmVyc2lvbisrO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmFmdGVyQ2VsbFJlbmRlcmVyQ3JlYXRlZC5iaW5kKHRoaXMsIHRoaXMuY2VsbFJlbmRlcmVyVmVyc2lvbik7XG4gICAgICAgIHRoaXMuYmVhbnMuY29tcG9uZW50UmVzb2x2ZXIuY3JlYXRlQWdHcmlkQ29tcG9uZW50KHRoaXMuY29sdW1uLmdldENvbERlZigpLCBwYXJhbXMsIHRoaXMuY2VsbFJlbmRlcmVyVHlwZSkudGhlbihjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuYWZ0ZXJDZWxsUmVuZGVyZXJDcmVhdGVkID0gZnVuY3Rpb24gKGNlbGxSZW5kZXJlclZlcnNpb24sIGNlbGxSZW5kZXJlcikge1xuICAgICAgICAvLyBzZWUgaWYgZGFlbW9uXG4gICAgICAgIGlmIChjZWxsUmVuZGVyZXJWZXJzaW9uICE9PSB0aGlzLmNlbGxSZW5kZXJlclZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmIChjZWxsUmVuZGVyZXIuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGNlbGxSZW5kZXJlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZWxsUmVuZGVyZXIgPSBjZWxsUmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyR3VpID0gdGhpcy5jZWxsUmVuZGVyZXIuZ2V0R3VpKCk7XG4gICAgICAgIGlmICh1dGlsc18xLl8ubWlzc2luZyh0aGlzLmNlbGxSZW5kZXJlckd1aSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhc3luYyBjb21wb25lbnRzLCB0aGVuIGl0J3MgcG9zc2libGUgdGhlIHVzZXIgc3RhcnRlZCBlZGl0aW5nIHNpbmNlXG4gICAgICAgIC8vIHRoaXMgY2FsbCB3YXMgbWFkZVxuICAgICAgICBpZiAoIXRoaXMuZWRpdGluZ0NlbGwpIHtcbiAgICAgICAgICAgIHRoaXMuZVBhcmVudE9mVmFsdWUuYXBwZW5kQ2hpbGQodGhpcy5jZWxsUmVuZGVyZXJHdWkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuYXR0YWNoQ2VsbFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudXNpbmdDZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0ZUNlbGxSZW5kZXJlckluc3RhbmNlKCk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuY3JlYXRlQ2VsbFJlbmRlcmVyUGFyYW1zID0gZnVuY3Rpb24gKHZhbHVlRm9ybWF0dGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0dGVkOiB2YWx1ZUZvcm1hdHRlZCxcbiAgICAgICAgICAgIGdldFZhbHVlOiB0aGlzLmdldFZhbHVlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7IF90aGlzLmJlYW5zLnZhbHVlU2VydmljZS5zZXRWYWx1ZShfdGhpcy5yb3dOb2RlLCBfdGhpcy5jb2x1bW4sIHZhbHVlKTsgfSxcbiAgICAgICAgICAgIGZvcm1hdFZhbHVlOiB0aGlzLmZvcm1hdFZhbHVlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkYXRhOiB0aGlzLnJvd05vZGUuZGF0YSxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMucm93Tm9kZSxcbiAgICAgICAgICAgIGNvbERlZjogdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCksXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgJHNjb3BlOiB0aGlzLnNjb3BlLFxuICAgICAgICAgICAgcm93SW5kZXg6IHRoaXMuZ3JpZENlbGwucm93SW5kZXgsXG4gICAgICAgICAgICBhcGk6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb2x1bW5BcGkoKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgIHJlZnJlc2hDZWxsOiB0aGlzLnJlZnJlc2hDZWxsLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyB0b2RvIGRhbmdlciAtIGluIHRoZSBuZXcgd29ybGQsIHRoZXNlIGFyZSBub3QgcHJlc2VudCA6KFxuICAgICAgICAgICAgZUdyaWRDZWxsOiB0aGlzLmdldEd1aSgpLFxuICAgICAgICAgICAgZVBhcmVudE9mVmFsdWU6IHRoaXMuZVBhcmVudE9mVmFsdWUsXG4gICAgICAgICAgICAvLyB0aGVzZSBiaXRzIGFyZSBub3QgZG9jdW1lbnRlZCBhbnl3aGVyZSwgc28gd2UgY291bGQgZHJvcCB0aGVtP1xuICAgICAgICAgICAgLy8gaXQgd2FzIGluIHRoZSBvbGRlbiBkYXlzIHRvIGFsbG93IHVzZXIgdG8gcmVnaXN0ZXIgZm9yIHdoZW4gcmVuZGVyZWRcbiAgICAgICAgICAgIC8vIHJvdyB3YXMgcmVtb3ZlZCAodGhlIHJvdyBjb21wIHdhcyByZW1vdmVkKSwgaG93ZXZlciBub3cgdGhhdCB0aGUgdXNlclxuICAgICAgICAgICAgLy8gY2FuIHByb3ZpZGUgY29tcG9uZW50cyBmb3IgY2VsbHMsIHRoZSBkZXN0cm95IG1ldGhvZCBnZXRzIGNhbGwgd2hlbiB0aGlzXG4gICAgICAgICAgICAvLyBoYXBwZW5zIHNvIG5vIGxvbmdlciBuZWVkIHRvIGZpcmUgZXZlbnQuXG4gICAgICAgICAgICBhZGRSb3dDb21wTGlzdGVuZXI6IHRoaXMucm93Q29tcC5hZGRFdmVudExpc3RlbmVyLmJpbmQodGhpcy5yb3dDb21wKSxcbiAgICAgICAgICAgIGFkZFJlbmRlcmVkUm93TGlzdGVuZXI6IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBzaW5jZSBhZy1HcmlkIC52MTEsIHBhcmFtcy5hZGRSZW5kZXJlZFJvd0xpc3RlbmVyKCkgaXMgbm93IHBhcmFtcy5hZGRSb3dDb21wTGlzdGVuZXIoKScpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJvd0NvbXAuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5mb3JtYXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVGb3JtYXR0ZWQgPSB0aGlzLmJlYW5zLnZhbHVlRm9ybWF0dGVyU2VydmljZS5mb3JtYXRWYWx1ZSh0aGlzLmNvbHVtbiwgdGhpcy5yb3dOb2RlLCB0aGlzLnNjb3BlLCB2YWx1ZSk7XG4gICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlZEV4aXN0cyA9IHZhbHVlRm9ybWF0dGVkICE9PSBudWxsICYmIHZhbHVlRm9ybWF0dGVkICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB2YWx1ZUZvcm1hdHRlZEV4aXN0cyA/IHZhbHVlRm9ybWF0dGVkIDogdmFsdWU7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGNoZWNrIHRoaXMsIHRoZW4gdGhlIGdyaWQgd2lsbCByZW5kZXIgbGVhZiBncm91cHMgYXMgb3BlbiBldmVuIGlmIHdlIGFyZSBub3RcbiAgICAgICAgLy8gYWxsb3dpbmcgdGhlIHVzZXIgdG8gb3BlbiBsZWFmIGdyb3Vwcy4gY29uZnVzZWQ/IHJlbWVtYmVyIGZvciBwaXZvdCBtb2RlIHdlIGRvbid0IGFsbG93XG4gICAgICAgIC8vIG9wZW5pbmcgbGVhZiBncm91cHMsIHNvIHdlIGhhdmUgdG8gZm9yY2UgbGVhZkdyb3VwcyB0byBiZSBjbG9zZWQgaW4gY2FzZSB0aGUgdXNlciBleHBhbmRlZFxuICAgICAgICAvLyB0aGVtIHZpYSB0aGUgQVBJLCBvciB1c2VyIHVzZXIgZXhwYW5kZWQgdGhlbSBpbiB0aGUgVUkgYmVmb3JlIHR1cm5pbmcgb24gcGl2b3QgbW9kZVxuICAgICAgICB2YXIgbG9ja2VkQ2xvc2VkR3JvdXAgPSB0aGlzLnJvd05vZGUubGVhZkdyb3VwICYmIHRoaXMuYmVhbnMuY29sdW1uQ29udHJvbGxlci5pc1Bpdm90TW9kZSgpO1xuICAgICAgICB2YXIgaXNPcGVuR3JvdXAgPSB0aGlzLnJvd05vZGUuZ3JvdXAgJiYgdGhpcy5yb3dOb2RlLmV4cGFuZGVkICYmICF0aGlzLnJvd05vZGUuZm9vdGVyICYmICFsb2NrZWRDbG9zZWRHcm91cDtcbiAgICAgICAgaWYgKGlzT3Blbkdyb3VwICYmIHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzR3JvdXBJbmNsdWRlRm9vdGVyKCkpIHtcbiAgICAgICAgICAgIC8vIGlmIGRvaW5nIGdyb3VwaW5nIGFuZCBmb290ZXJzLCB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGUgdGhlIGFnZyB2YWx1ZVxuICAgICAgICAgICAgLy8gaW4gdGhlIGhlYWRlciB3aGVuIHRoZSBncm91cCBpcyBvcGVuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWFucy52YWx1ZVNlcnZpY2UuZ2V0VmFsdWUodGhpcy5jb2x1bW4sIHRoaXMucm93Tm9kZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWFucy52YWx1ZVNlcnZpY2UuZ2V0VmFsdWUodGhpcy5jb2x1bW4sIHRoaXMucm93Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5vbk1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBtb3VzZUV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNlbGxDbGlja2VkKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VEb3duKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYmxjbGljayc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNlbGxEb3VibGVDbGlja2VkKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25Db250ZXh0TWVudShtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VPdXQobW91c2VFdmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU92ZXIobW91c2VFdmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5jcmVhdGVFdmVudCA9IGZ1bmN0aW9uIChkb21FdmVudCwgZXZlbnRUeXBlKSB7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMucm93Tm9kZSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMucm93Tm9kZS5kYXRhLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgY29sRGVmOiB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgIGFwaTogdGhpcy5iZWFucy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmJlYW5zLmNvbHVtbkFwaSxcbiAgICAgICAgICAgIHJvd1Bpbm5lZDogdGhpcy5yb3dOb2RlLnJvd1Bpbm5lZCxcbiAgICAgICAgICAgIGV2ZW50OiBkb21FdmVudCxcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgICAgIHJvd0luZGV4OiB0aGlzLnJvd05vZGUucm93SW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhcmUgaGFja2luZyBpbiAkc2NvcGUgZm9yIGFuZ3VsYXIgMSwgd2UgaGF2ZSB0byBkZS1yZWZlcmVuY2VcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgICAgICAgIGV2ZW50LiRzY29wZSA9IHRoaXMuc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uTW91c2VPdXQgPSBmdW5jdGlvbiAobW91c2VFdmVudCkge1xuICAgICAgICB2YXIgY2VsbE1vdXNlT3V0RXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KG1vdXNlRXZlbnQsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DRUxMX01PVVNFX09VVCk7XG4gICAgICAgIHRoaXMuYmVhbnMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoY2VsbE1vdXNlT3V0RXZlbnQpO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uTW91c2VPdmVyID0gZnVuY3Rpb24gKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIGNlbGxNb3VzZU92ZXJFdmVudCA9IHRoaXMuY3JlYXRlRXZlbnQobW91c2VFdmVudCwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NFTExfTU9VU0VfT1ZFUik7XG4gICAgICAgIHRoaXMuYmVhbnMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoY2VsbE1vdXNlT3ZlckV2ZW50KTtcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgLy8gdG8gYWxsb3cgdXMgdG8gZGVidWcgaW4gY2hyb21lLCB3ZSBpZ25vcmUgdGhlIGV2ZW50IGlmIGN0cmwgaXMgcHJlc3NlZC5cbiAgICAgICAgLy8gbm90IGV2ZXJ5b25lIHdhbnRzIHRoaXMsIHNvIGZpcnN0ICdpZicgYmVsb3cgYWxsb3dzIHRvIHR1cm4gdGhpcyBoYWNrIG9mZi5cbiAgICAgICAgaWYgKCF0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5pc0FsbG93Q29udGV4dE1lbnVXaXRoQ29udHJvbEtleSgpKSB7XG4gICAgICAgICAgICAvLyB0aGVuIGRvIHRoZSBjaGVja1xuICAgICAgICAgICAgaWYgKG1vdXNlRXZlbnQuY3RybEtleSB8fCBtb3VzZUV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbERlZiA9IHRoaXMuY29sdW1uLmdldENvbERlZigpO1xuICAgICAgICB2YXIgY2VsbENvbnRleHRNZW51RXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KG1vdXNlRXZlbnQsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DRUxMX0NPTlRFWFRfTUVOVSk7XG4gICAgICAgIHRoaXMuYmVhbnMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoY2VsbENvbnRleHRNZW51RXZlbnQpO1xuICAgICAgICBpZiAoY29sRGVmLm9uQ2VsbENvbnRleHRNZW51KSB7XG4gICAgICAgICAgICBjb2xEZWYub25DZWxsQ29udGV4dE1lbnUoY2VsbENvbnRleHRNZW51RXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJlYW5zLmNvbnRleHRNZW51RmFjdG9yeSAmJiAhdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc0NvbnRleHRNZW51KCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmVhbnMuY29udGV4dE1lbnVGYWN0b3J5LnNob3dNZW51KHRoaXMucm93Tm9kZSwgdGhpcy5jb2x1bW4sIHRoaXMudmFsdWUsIG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25DZWxsRG91YmxlQ2xpY2tlZCA9IGZ1bmN0aW9uIChtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBjb2xEZWYgPSB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKTtcbiAgICAgICAgLy8gYWx3YXlzIGRpc3BhdGNoIGV2ZW50IHRvIGV2ZW50U2VydmljZVxuICAgICAgICB2YXIgY2VsbERvdWJsZUNsaWNrZWRFdmVudCA9IHRoaXMuY3JlYXRlRXZlbnQobW91c2VFdmVudCwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NFTExfRE9VQkxFX0NMSUNLRUQpO1xuICAgICAgICB0aGlzLmJlYW5zLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGNlbGxEb3VibGVDbGlja2VkRXZlbnQpO1xuICAgICAgICAvLyBjaGVjayBpZiBjb2xEZWYgYWxzbyB3YW50cyB0byBoYW5kbGUgZXZlbnRcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xEZWYub25DZWxsRG91YmxlQ2xpY2tlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29sRGVmLm9uQ2VsbERvdWJsZUNsaWNrZWQoY2VsbERvdWJsZUNsaWNrZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkaXRPbkRvdWJsZUNsaWNrID0gIXRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU2luZ2xlQ2xpY2tFZGl0KClcbiAgICAgICAgICAgICYmICF0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzQ2xpY2tFZGl0KCk7XG4gICAgICAgIGlmIChlZGl0T25Eb3VibGVDbGljaykge1xuICAgICAgICAgICAgdGhpcy5zdGFydFJvd09yQ2VsbEVkaXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gY2FsbGVkIGJ5IHJvd1JlbmRlcmVyIHdoZW4gdXNlciBuYXZpZ2F0ZXMgdmlhIHRhYiBrZXlcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuc3RhcnRSb3dPckNlbGxFZGl0ID0gZnVuY3Rpb24gKGtleVByZXNzLCBjaGFyUHJlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRnVsbFJvd0VkaXQoKSkge1xuICAgICAgICAgICAgdGhpcy5yb3dDb21wLnN0YXJ0Um93RWRpdGluZyhrZXlQcmVzcywgY2hhclByZXNzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRFZGl0aW5nSWZFbmFibGVkKGtleVByZXNzLCBjaGFyUHJlc3MsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuaXNDZWxsRWRpdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbi5pc0NlbGxFZGl0YWJsZSh0aGlzLnJvd05vZGUpO1xuICAgIH07XG4gICAgLy8gZWl0aGVyIGNhbGxlZCBpbnRlcm5hbGx5IGlmIHNpbmdsZSBjZWxsIGVkaXRpbmcsIG9yIGNhbGxlZCBieSByb3dSZW5kZXJlciBpZiByb3cgZWRpdGluZ1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5zdGFydEVkaXRpbmdJZkVuYWJsZWQgPSBmdW5jdGlvbiAoa2V5UHJlc3MsIGNoYXJQcmVzcywgY2VsbFN0YXJ0ZWRFZGl0KSB7XG4gICAgICAgIGlmIChrZXlQcmVzcyA9PT0gdm9pZCAwKSB7IGtleVByZXNzID0gbnVsbDsgfVxuICAgICAgICBpZiAoY2hhclByZXNzID09PSB2b2lkIDApIHsgY2hhclByZXNzID0gbnVsbDsgfVxuICAgICAgICBpZiAoY2VsbFN0YXJ0ZWRFZGl0ID09PSB2b2lkIDApIHsgY2VsbFN0YXJ0ZWRFZGl0ID0gZmFsc2U7IH1cbiAgICAgICAgLy8gZG9uJ3QgZG8gaXQgaWYgbm90IGVkaXRhYmxlXG4gICAgICAgIGlmICghdGhpcy5pc0NlbGxFZGl0YWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgZG8gaXQgaWYgYWxyZWFkeSBlZGl0aW5nXG4gICAgICAgIGlmICh0aGlzLmVkaXRpbmdDZWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0aW5nQ2VsbCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2VsbEVkaXRvclZlcnNpb24rKztcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5hZnRlckNlbGxFZGl0b3JDcmVhdGVkLmJpbmQodGhpcywgdGhpcy5jZWxsRWRpdG9yVmVyc2lvbik7XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmNyZWF0ZUNlbGxFZGl0b3JQYXJhbXMoa2V5UHJlc3MsIGNoYXJQcmVzcywgY2VsbFN0YXJ0ZWRFZGl0KTtcbiAgICAgICAgdGhpcy5iZWFucy5jZWxsRWRpdG9yRmFjdG9yeS5jcmVhdGVDZWxsRWRpdG9yKHRoaXMuY29sdW1uLmdldENvbERlZigpLCBwYXJhbXMpLnRoZW4oY2FsbGJhY2spO1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCBkbyB0aGlzLCBhbmQgZWRpdG9yIGNvbXBvbmVudCBpcyBhc3luYywgdGhlbiB0aGVyZSB3aWxsIGJlIGEgcGVyaW9kXG4gICAgICAgIC8vIHdoZW4gdGhlIGNvbXBvbmVudCBpc24ndCBwcmVzZW50IGFuZCBrZXlib2FyZCBuYXZpZ2F0aW9uIHdvbid0IHdvcmsgLSBzbyBleGFtcGxlXG4gICAgICAgIC8vIG9mIHVzZXIgaGl0dGluZyB0YWIgcXVpY2tseSAobW9yZSBxdWlja2x5IHRoYW4gcmVuZGVyZXJzIGdldHRpbmcgY3JlYXRlZCkgd29uJ3Qgd29ya1xuICAgICAgICB2YXIgY2VsbEVkaXRvckFzeW5jID0gdXRpbHNfMS5fLm1pc3NpbmcodGhpcy5jZWxsRWRpdG9yKTtcbiAgICAgICAgaWYgKGNlbGxFZGl0b3JBc3luYyAmJiBjZWxsU3RhcnRlZEVkaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNDZWxsKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuYWZ0ZXJDZWxsRWRpdG9yQ3JlYXRlZCA9IGZ1bmN0aW9uIChjZWxsRWRpdG9yVmVyc2lvbiwgY2VsbEVkaXRvcikge1xuICAgICAgICAvLyBpZiBlZGl0aW5nQ2VsbD1mYWxzZSwgbWVhbnMgdXNlciBjYW5jZWxsZWQgdGhlIGVkaXRvciBiZWZvcmUgY29tcG9uZW50IHdhcyByZWFkeS5cbiAgICAgICAgLy8gaWYgdmVyc2lvbk1pc21hdGNoLCB0aGVuIHVzZXIgY2FuY2VsbGVkIHRoZSBlZGl0LCB0aGVuIHN0YXJ0ZWQgdGhlIGVkaXQgYWdhaW4sIGFuZCB0aGlzXG4gICAgICAgIC8vICAgaXMgdGhlIGZpcnN0IGVkaXRvciB3aGljaCBpcyBub3cgc3RhbGUuXG4gICAgICAgIHZhciB2ZXJzaW9uTWlzbWF0Y2ggPSBjZWxsRWRpdG9yVmVyc2lvbiAhPT0gdGhpcy5jZWxsRWRpdG9yVmVyc2lvbjtcbiAgICAgICAgaWYgKHZlcnNpb25NaXNtYXRjaCB8fCAhdGhpcy5lZGl0aW5nQ2VsbCkge1xuICAgICAgICAgICAgaWYgKGNlbGxFZGl0b3IuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGNlbGxFZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsRWRpdG9yLmlzQ2FuY2VsQmVmb3JlU3RhcnQgJiYgY2VsbEVkaXRvci5pc0NhbmNlbEJlZm9yZVN0YXJ0KCkpIHtcbiAgICAgICAgICAgIGlmIChjZWxsRWRpdG9yLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWRpdGluZ0NlbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNlbGxFZGl0b3IuZ2V0R3VpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1HcmlkOiBjZWxsRWRpdG9yIGZvciBjb2x1bW4gXCIgKyB0aGlzLmNvbHVtbi5nZXRJZCgpICsgXCIgaXMgbWlzc2luZyBnZXRHdWkoKSBtZXRob2RcIik7XG4gICAgICAgICAgICAvLyBubyBnZXRHdWksIGZvciBSZWFjdCBndXlzLCBzZWUgaWYgdGhleSBhdHRhY2hlZCBhIHJlYWN0IGNvbXBvbmVudCBkaXJlY3RseVxuICAgICAgICAgICAgaWYgKGNlbGxFZGl0b3IucmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYWctR3JpZDogd2UgZm91bmQgJ3JlbmRlcicgb24gdGhlIGNvbXBvbmVudCwgYXJlIHlvdSB0cnlpbmcgdG8gc2V0IGEgUmVhY3QgcmVuZGVyZXIgYnV0IGFkZGVkIGl0IGFzIGNvbERlZi5jZWxsRWRpdG9yIGluc3RlYWQgb2YgY29sRGVmLmNlbGxFZGl0b3JGbWs/XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbGxFZGl0b3IuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGNlbGxFZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lZGl0aW5nQ2VsbCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2VsbEVkaXRvciA9IGNlbGxFZGl0b3I7XG4gICAgICAgIHRoaXMuY2VsbEVkaXRvckluUG9wdXAgPSBjZWxsRWRpdG9yLmlzUG9wdXAgJiYgY2VsbEVkaXRvci5pc1BvcHVwKCk7XG4gICAgICAgIHRoaXMuc2V0SW5saW5lRWRpdGluZ0NsYXNzKCk7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3JJblBvcHVwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFBvcHVwQ2VsbEVkaXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRJbkNlbGxFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbEVkaXRvci5hZnRlckd1aUF0dGFjaGVkKSB7XG4gICAgICAgICAgICBjZWxsRWRpdG9yLmFmdGVyR3VpQXR0YWNoZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KG51bGwsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DRUxMX0VESVRJTkdfU1RBUlRFRCk7XG4gICAgICAgIHRoaXMuYmVhbnMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmFkZEluQ2VsbEVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHNfMS5fLnJlbW92ZUFsbENoaWxkcmVuKHRoaXMuZ2V0R3VpKCkpO1xuICAgICAgICB0aGlzLmdldEd1aSgpLmFwcGVuZENoaWxkKHRoaXMuY2VsbEVkaXRvci5nZXRHdWkoKSk7XG4gICAgICAgIHRoaXMuYW5ndWxhcjFDb21waWxlKCk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuYWRkUG9wdXBDZWxsRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZVBvcHVwR3VpID0gdGhpcy5jZWxsRWRpdG9yLmdldEd1aSgpO1xuICAgICAgICB0aGlzLmhpZGVFZGl0b3JQb3B1cCA9IHRoaXMuYmVhbnMucG9wdXBTZXJ2aWNlLmFkZEFzTW9kYWxQb3B1cChlUG9wdXBHdWksIHRydWUsIFxuICAgICAgICAvLyBjYWxsYmFjayBmb3Igd2hlbiBwb3B1cCBkaXNhcHBlYXJzXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm9uUG9wdXBFZGl0b3JDbG9zZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmVhbnMucG9wdXBTZXJ2aWNlLnBvc2l0aW9uUG9wdXBPdmVyQ29tcG9uZW50KHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICByb3dOb2RlOiB0aGlzLnJvd05vZGUsXG4gICAgICAgICAgICB0eXBlOiAncG9wdXBDZWxsRWRpdG9yJyxcbiAgICAgICAgICAgIGV2ZW50U291cmNlOiB0aGlzLmdldEd1aSgpLFxuICAgICAgICAgICAgZVBvcHVwOiBlUG9wdXBHdWksXG4gICAgICAgICAgICBrZWVwV2l0aGluQm91bmRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFuZ3VsYXIxQ29tcGlsZSgpO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uUG9wdXBFZGl0b3JDbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdlIG9ubHkgY2FsbCBzdG9wRWRpdGluZyBpZiB3ZSBhcmUgZWRpdGluZywgYXNcbiAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgcG9wdXAgY2FsbGVkICdzdG9wIGVkaXRpbmcnXG4gICAgICAgIC8vIGJlZm9yZSB0aGlzLCBlZyBpZiAnZW50ZXIga2V5JyB3YXMgcHJlc3NlZCBvblxuICAgICAgICAvLyB0aGUgZWRpdG9yLlxuICAgICAgICBpZiAodGhpcy5lZGl0aW5nQ2VsbCkge1xuICAgICAgICAgICAgLy8gbm90ZTogdGhpcyBvbmx5IGhhcHBlbnMgd2hlbiB1c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGdyaWQuIGlmIHVzZSBjbGlja3Mgb24gYW5vdGhlclxuICAgICAgICAgICAgLy8gY2VsbCwgdGhlbiB0aGUgZWRpdGluZyB3aWxsIGhhdmUgYWxyZWFkeSBzdG9wcGVkIG9uIHRoaXMgY2VsbFxuICAgICAgICAgICAgdGhpcy5zdG9wUm93T3JDZWxsRWRpdCgpO1xuICAgICAgICAgICAgLy8gd2Ugb25seSBmb2N1cyBjZWxsIGFnYWluIGlmIHRoaXMgY2VsbCBpcyBzdGlsbCBmb2N1c2VkLiBpdCBpcyBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gaXQgaXMgbm90IGZvY3VzZWQgaWYgdGhlIHVzZXIgY2FuY2VsbGVkIHRoZSBlZGl0IGJ5IGNsaWNraW5nIG9uIGFub3RoZXJcbiAgICAgICAgICAgIC8vIGNlbGwgb3V0c2lkZSBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgaWYgKHRoaXMuYmVhbnMuZm9jdXNlZENlbGxDb250cm9sbGVyLmlzQ2VsbEZvY3VzZWQodGhpcy5ncmlkQ2VsbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzQ2VsbCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gaWYgd2UgYXJlIGVkaXRpbmcgaW5saW5lLCB0aGVuIHdlIGRvbid0IGhhdmUgdGhlIHBhZGRpbmcgaW4gdGhlIGNlbGwgKHNldCBpbiB0aGUgdGhlbWVzKVxuICAgIC8vIHRvIGFsbG93IHRoZSB0ZXh0IGVkaXRvciBmdWxsIGFjY2VzcyB0byB0aGUgZW50aXJlIGNlbGxcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuc2V0SW5saW5lRWRpdGluZ0NsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWRpdGluZ0lubGluZSA9IHRoaXMuZWRpdGluZ0NlbGwgJiYgIXRoaXMuY2VsbEVkaXRvckluUG9wdXA7XG4gICAgICAgIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZ2V0R3VpKCksICdhZy1jZWxsLWlubGluZS1lZGl0aW5nJywgZWRpdGluZ0lubGluZSk7XG4gICAgICAgIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZ2V0R3VpKCksICdhZy1jZWxsLW5vdC1pbmxpbmUtZWRpdGluZycsICFlZGl0aW5nSW5saW5lKTtcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5jcmVhdGVDZWxsRWRpdG9yUGFyYW1zID0gZnVuY3Rpb24gKGtleVByZXNzLCBjaGFyUHJlc3MsIGNlbGxTdGFydGVkRWRpdCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgIGtleVByZXNzOiBrZXlQcmVzcyxcbiAgICAgICAgICAgIGNoYXJQcmVzczogY2hhclByZXNzLFxuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIHJvd0luZGV4OiB0aGlzLmdyaWRDZWxsLnJvd0luZGV4LFxuICAgICAgICAgICAgbm9kZTogdGhpcy5yb3dOb2RlLFxuICAgICAgICAgICAgYXBpOiB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBcGkoKSxcbiAgICAgICAgICAgIGNlbGxTdGFydGVkRWRpdDogY2VsbFN0YXJ0ZWRFZGl0LFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb2x1bW5BcGkoKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICRzY29wZTogdGhpcy5zY29wZSxcbiAgICAgICAgICAgIG9uS2V5RG93bjogdGhpcy5vbktleURvd24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHN0b3BFZGl0aW5nOiB0aGlzLnN0b3BFZGl0aW5nQW5kRm9jdXMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVHcmlkQ2VsbDogdGhpcy5nZXRHdWkoKSxcbiAgICAgICAgICAgIHBhcnNlVmFsdWU6IHRoaXMucGFyc2VWYWx1ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZm9ybWF0VmFsdWU6IHRoaXMuZm9ybWF0VmFsdWUuYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgLy8gY2VsbCBlZGl0b3JzIGNhbGwgdGhpcywgd2hlbiB0aGV5IHdhbnQgdG8gc3RvcCBmb3IgcmVhc29ucyBvdGhlclxuICAgIC8vIHRoYW4gd2hhdCB3ZSBwaWNrIHVwIG9uLiBlZyBzZWxlY3RpbmcgZnJvbSBhIGRyb3Bkb3duIGVuZHMgZWRpdGluZy5cbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuc3RvcEVkaXRpbmdBbmRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wUm93T3JDZWxsRWRpdCgpO1xuICAgICAgICB0aGlzLmZvY3VzQ2VsbCh0cnVlKTtcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5wYXJzZVZhbHVlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBub2RlOiB0aGlzLnJvd05vZGUsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLnJvd05vZGUuZGF0YSxcbiAgICAgICAgICAgIG9sZFZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgY29sRGVmOiB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKSxcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICBhcGk6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb2x1bW5BcGkoKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdmFsdWVQYXJzZXIgPSB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKS52YWx1ZVBhcnNlcjtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuXy5leGlzdHModmFsdWVQYXJzZXIpID8gdGhpcy5iZWFucy5leHByZXNzaW9uU2VydmljZS5ldmFsdWF0ZSh2YWx1ZVBhcnNlciwgcGFyYW1zKSA6IG5ld1ZhbHVlO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmZvY3VzQ2VsbCA9IGZ1bmN0aW9uIChmb3JjZUJyb3dzZXJGb2N1cykge1xuICAgICAgICBpZiAoZm9yY2VCcm93c2VyRm9jdXMgPT09IHZvaWQgMCkgeyBmb3JjZUJyb3dzZXJGb2N1cyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuYmVhbnMuZm9jdXNlZENlbGxDb250cm9sbGVyLnNldEZvY3VzZWRDZWxsKHRoaXMuZ3JpZENlbGwucm93SW5kZXgsIHRoaXMuY29sdW1uLCB0aGlzLnJvd05vZGUucm93UGlubmVkLCBmb3JjZUJyb3dzZXJGb2N1cyk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuc2V0Rm9jdXNJbk9uRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0aW5nQ2VsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvciAmJiB0aGlzLmNlbGxFZGl0b3IuZm9jdXNJbikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBlZGl0b3IgaXMgcHJlc2VudCwgdGhlbiB3ZSBqdXN0IGZvY3VzIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLmZvY3VzSW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBlZGl0b3IgaXMgbm90IHByZXNlbnQsIGl0IG1lYW5zIGFzeW5jIGNlbGwgZWRpdG9yIChlZyBSZWFjdCBmaWJyZSlcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2UgYXJlIHRyeWluZyB0byBzZXQgZm9jdXMgYmVmb3JlIHRoZSBjZWxsIGVkaXRvciBpcyBwcmVzZW50LCBzbyB3ZVxuICAgICAgICAgICAgICAgIC8vIGZvY3VzIHRoZSBjZWxsIGluc3RlYWRcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzQ2VsbCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmlzRWRpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGluZ0NlbGw7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25LZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlO1xuICAgICAgICAvLyBnaXZlIHVzZXIgYSBjaGFuY2UgdG8gY2FuY2VsIGV2ZW50IHByb2Nlc3NpbmdcbiAgICAgICAgaWYgKHRoaXMuZG9lc1VzZXJXYW50VG9DYW5jZWxLZXlib2FyZEV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfRU5URVI6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVudGVyS2V5RG93bigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX0YyOlxuICAgICAgICAgICAgICAgIHRoaXMub25GMktleURvd24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9FU0NBUEU6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVzY2FwZUtleURvd24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9UQUI6XG4gICAgICAgICAgICAgICAgdGhpcy5vblRhYktleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX0JBQ0tTUEFDRTpcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9ERUxFVEU6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkJhY2tzcGFjZU9yRGVsZXRlS2V5UHJlc3NlZChrZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX0RPV046XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfVVA6XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfUklHSFQ6XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfTEVGVDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uTmF2aWdhdGlvbktleVByZXNzZWQoZXZlbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5kb2VzVXNlcldhbnRUb0NhbmNlbEtleWJvYXJkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCkuc3VwcHJlc3NLZXlib2FyZEV2ZW50O1xuICAgICAgICBpZiAodXRpbHNfMS5fLm1pc3NpbmcoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBlZGl0aW5nIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB0aGlzIHNldHMgaXQgdG8gZmFsc2VcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGVkaXRpbmc6IHRoaXMuZWRpdGluZ0NlbGwsXG4gICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgICAgIG5vZGU6IHRoaXMucm93Tm9kZSxcbiAgICAgICAgICAgICAgICBjb2xEZWY6IHRoaXMuY29sdW1uLmdldENvbERlZigpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbHVtbkFwaSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5zZXRGb2N1c091dE9uRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0aW5nQ2VsbCAmJiB0aGlzLmNlbGxFZGl0b3IgJiYgdGhpcy5jZWxsRWRpdG9yLmZvY3VzT3V0KSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3IuZm9jdXNPdXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uTmF2aWdhdGlvbktleVByZXNzZWQgPSBmdW5jdGlvbiAoZXZlbnQsIGtleSkge1xuICAgICAgICBpZiAodGhpcy5lZGl0aW5nQ2VsbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUm93T3JDZWxsRWRpdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVhbnMucm93UmVuZGVyZXIubmF2aWdhdGVUb05leHRDZWxsKGV2ZW50LCBrZXksIHRoaXMuZ3JpZENlbGwucm93SW5kZXgsIHRoaXMuY29sdW1uLCB0aGlzLnJvd05vZGUucm93UGlubmVkKTtcbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgcHJldmVudCBkZWZhdWx0LCB0aGUgZ3JpZCB3aWxsIHNjcm9sbCB3aXRoIHRoZSBuYXZpZ2F0aW9uIGtleXNcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5vblRhYktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NUYWJiaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlYW5zLnJvd1JlbmRlcmVyLm9uVGFiS2V5RG93bih0aGlzLCBldmVudCk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25CYWNrc3BhY2VPckRlbGV0ZUtleVByZXNzZWQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0aW5nQ2VsbCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFJvd09yQ2VsbEVkaXQoa2V5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uRW50ZXJLZXlEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0aW5nQ2VsbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUm93T3JDZWxsRWRpdCgpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c0NlbGwodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Um93T3JDZWxsRWRpdChjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX0VOVEVSKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uRjJLZXlEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWRpdGluZ0NlbGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSb3dPckNlbGxFZGl0KGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfRjIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25Fc2NhcGVLZXlEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0aW5nQ2VsbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUm93T3JDZWxsRWRpdCh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNDZWxsKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBjaGVjayB0aGlzLCBpbiBjYXNlIGZvY3VzIGlzIG9uIGEgKGZvciBleGFtcGxlKSBhIHRleHQgZmllbGQgaW5zaWRlIHRoZSBjZWxsLFxuICAgICAgICAvLyBpbiB3aGljaCBjc2Ugd2Ugc2hvdWxkIG5vdCBiZSBsaXN0ZW5pbmcgZm9yIHRoZXNlIGtleSBwcmVzc2VkXG4gICAgICAgIHZhciBldmVudFRhcmdldCA9IHV0aWxzXzEuXy5nZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgICB2YXIgZXZlbnRPbkNoaWxkQ29tcG9uZW50ID0gZXZlbnRUYXJnZXQgIT09IHRoaXMuZ2V0R3VpKCk7XG4gICAgICAgIGlmIChldmVudE9uQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZWRpdGluZ0NlbGwpIHtcbiAgICAgICAgICAgIHZhciBwcmVzc2VkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgICAgICAgICAgaWYgKHByZXNzZWRDaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3BhY2VLZXlQcmVzc2VkKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLl8uaXNFdmVudEZyb21QcmludGFibGVDaGFyYWN0ZXIoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSb3dPckNlbGxFZGl0KG51bGwsIHByZXNzZWRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgcHJldmVudCBkZWZhdWx0LCB0aGVuIHRoZSBrZXlwcmVzcyBhbHNvIGdldHMgYXBwbGllZCB0byB0aGUgdGV4dCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAvLyAoYXQgbGVhc3Qgd2hlbiBkb2luZyB0aGUgZGVmYXVsdCBlZGl0b3IpLCBidXQgd2UgbmVlZCB0byBhbGxvdyB0aGUgZWRpdG9yIHRvIGRlY2lkZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGF0IGl0IHdhbnRzIHRvIGRvLiB3ZSBvbmx5IGRvIHRoaXMgSUYgZWRpdGluZyB3YXMgc3RhcnRlZCAtIG90aGVyd2lzZSBpdCBtZXNzZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdXAgd2hlbiB0aGUgdXNlIGlzIG5vdCBkb2luZyBlZGl0aW5nLCBidXQgdXNpbmcgcmVuZGVyaW5nIHdpdGggdGV4dCBmaWVsZHMgaW4gY2VsbFJlbmRlcmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIChhcyBpdCB3b3VsZCBibG9jayB0aGUgdGhlIHVzZXIgZnJvbSB0eXBpbmcgaW50byB0ZXh0IGZpZWxkcykuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25TcGFjZUtleVByZXNzZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRpbmdDZWxsICYmIHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzUm93U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMucm93Tm9kZS5pc1NlbGVjdGVkKCk7XG4gICAgICAgICAgICB0aGlzLnJvd05vZGUuc2V0U2VsZWN0ZWQoIXNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50IGRlZmF1bHQgYXMgc3BhY2Uga2V5LCBieSBkZWZhdWx0LCBtb3ZlcyBicm93c2VyIHNjcm9sbCBkb3duXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdlIHBhc3MgZmFsc2UgdG8gZm9jdXNDZWxsLCBhcyB3ZSBkb24ndCB3YW50IHRoZSBjZWxsIHRvIGZvY3VzXG4gICAgICAgIC8vIGFsc28gZ2V0IHRoZSBicm93c2VyIGZvY3VzLiBpZiB3ZSBkaWQsIHRoZW4gdGhlIGNlbGxSZW5kZXJlciBjb3VsZFxuICAgICAgICAvLyBoYXZlIGEgdGV4dCBmaWVsZCBpbiBpdCwgZm9yIGV4YW1wbGUsIGFuZCBhcyB0aGUgdXNlciBjbGlja3Mgb24gdGhlXG4gICAgICAgIC8vIHRleHQgZmllbGQsIHRoZSB0ZXh0IGZpZWxkLCB0aGUgZm9jdXMgZG9lc24ndCBnZXQgdG8gdGhlIHRleHRcbiAgICAgICAgLy8gZmllbGQsIGluc3RlYWQgdG8gZ29lcyB0byB0aGUgZGl2IGJlaGluZCwgbWFraW5nIGl0IGltcG9zc2libGUgdG9cbiAgICAgICAgLy8gc2VsZWN0IHRoZSB0ZXh0IGZpZWxkLlxuICAgICAgICB0aGlzLmZvY3VzQ2VsbChmYWxzZSk7XG4gICAgICAgIC8vIGlmIGl0J3MgYSByaWdodCBjbGljaywgdGhlbiBpZiB0aGUgY2VsbCBpcyBhbHJlYWR5IGluIHJhbmdlLFxuICAgICAgICAvLyBkb24ndCBjaGFuZ2UgdGhlIHJhbmdlLCBob3dldmVyIGlmIHRoZSBjZWxsIGlzIG5vdCBpbiBhIHJhbmdlLFxuICAgICAgICAvLyB3ZSBzZXQgYSBuZXcgcmFuZ2VcbiAgICAgICAgaWYgKHRoaXMuYmVhbnMucmFuZ2VDb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgdGhpc0NlbGwgPSB0aGlzLmdyaWRDZWxsO1xuICAgICAgICAgICAgdmFyIGNlbGxBbHJlYWR5SW5SYW5nZSA9IHRoaXMuYmVhbnMucmFuZ2VDb250cm9sbGVyLmlzQ2VsbEluQW55UmFuZ2UodGhpc0NlbGwpO1xuICAgICAgICAgICAgaWYgKCFjZWxsQWxyZWFkeUluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJlYW5zLnJhbmdlQ29udHJvbGxlci5zZXRSYW5nZVRvQ2VsbCh0aGlzQ2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5vbkNlbGxDbGlja2VkID0gZnVuY3Rpb24gKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIGNlbGxDbGlja2VkRXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KG1vdXNlRXZlbnQsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DRUxMX0NMSUNLRUQpO1xuICAgICAgICB0aGlzLmJlYW5zLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGNlbGxDbGlja2VkRXZlbnQpO1xuICAgICAgICB2YXIgY29sRGVmID0gdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCk7XG4gICAgICAgIGlmIChjb2xEZWYub25DZWxsQ2xpY2tlZCkge1xuICAgICAgICAgICAgY29sRGVmLm9uQ2VsbENsaWNrZWQoY2VsbENsaWNrZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkaXRPblNpbmdsZUNsaWNrID0gdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTaW5nbGVDbGlja0VkaXQoKVxuICAgICAgICAgICAgJiYgIXRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NDbGlja0VkaXQoKTtcbiAgICAgICAgaWYgKGVkaXRPblNpbmdsZUNsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Um93T3JDZWxsRWRpdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9JZUZvY3VzSGFjaygpO1xuICAgIH07XG4gICAgLy8gaHR0cHM6Ly9hZy1ncmlkLmNvbS9mb3J1bS9zaG93dGhyZWFkLnBocD90aWQ9NDM2MlxuICAgIC8vIHdoZW4gaW4gSUUgb3IgRWRnZSwgd2hlbiB5b3UgYXJlIGVkaXRpbmcgYSBjZWxsLCB0aGVuIGNsaWNrIG9uIGFub3RoZXIgY2VsbCxcbiAgICAvLyB0aGUgb3RoZXIgY2VsbCBkb2Vzbid0IGtlZXAgZm9jdXMsIHNvIG5hdmlnYXRpb24ga2V5cywgdHlwZSB0byBzdGFydCBlZGl0IGV0Y1xuICAgIC8vIGRvbid0IHdvcmsuIGFwcGVhcnMgdGhhdCB3aGVuIHlvdSB1cGRhdGUgdGhlIGRvbSBpbiBJRSBpdCBsb29zZXMgZm9jdXNcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZG9JZUZvY3VzSGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuXy5pc0Jyb3dzZXJJRSgpIHx8IHV0aWxzXzEuXy5pc0Jyb3dzZXJFZGdlKCkpIHtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLl8ubWlzc2luZyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ21pc3NpbmcgZm9jdXMnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEd1aSgpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5jcmVhdGVHcmlkQ2VsbFZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JpZENlbGxEZWYgPSB7XG4gICAgICAgICAgICByb3dJbmRleDogdGhpcy5yb3dOb2RlLnJvd0luZGV4LFxuICAgICAgICAgICAgZmxvYXRpbmc6IHRoaXMucm93Tm9kZS5yb3dQaW5uZWQsXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ3JpZENlbGwgPSBuZXcgZ3JpZENlbGxfMS5HcmlkQ2VsbChncmlkQ2VsbERlZik7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUuZ2V0R3JpZENlbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRDZWxsO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmdldFBhcmVudFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZVBhcmVudFJvdztcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5zZXRQYXJlbnRSb3cgPSBmdW5jdGlvbiAoZVBhcmVudFJvdykge1xuICAgICAgICB0aGlzLmVQYXJlbnRSb3cgPSBlUGFyZW50Um93O1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmdldENvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lUGFyZW50Um93LnJlbW92ZUNoaWxkKHRoaXMuZ2V0R3VpKCkpO1xuICAgIH07XG4gICAgLy8gaWYgdGhlIHJvdyBpcyBhbHNvIGdldHRpbmcgZGVzdHJveWVkLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gcmVtb3ZlIGZyb20gZG9tLFxuICAgIC8vIGFzIHRoZSByb3cgd2lsbCBhbHNvIGdldCByZW1vdmVkLCBzbyBubyBuZWVkIHRvIHRha2Ugb3V0IHRoZSBjZWxscyBmcm9tIHRoZSByb3dcbiAgICAvLyBpZiB0aGUgcm93IGlzIGdvaW5nIChyZW1vdmluZyBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG8gcmVtb3ZlXG4gICAgLy8gdGhlIHRvcCBwYXJ0KVxuICAgIENlbGxDb21wLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvciAmJiB0aGlzLmNlbGxFZGl0b3IuZGVzdHJveSkge1xuICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2VsbFJlbmRlcmVyICYmIHRoaXMuY2VsbFJlbmRlcmVyLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uTGVmdENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5nZXRDZWxsTGVmdCgpO1xuICAgICAgICB0aGlzLmdldEd1aSgpLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5vbldpZHRoQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRDZWxsV2lkdGgoKTtcbiAgICAgICAgdGhpcy5nZXRHdWkoKS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5nZXRSYW5nZUNsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlU2VsZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICByZXMucHVzaCgnYWctY2VsbC1yYW5nZS1zZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKCdhZy1jZWxsLXJhbmdlLXNlbGVjdGVkLTEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09PSAyKSB7XG4gICAgICAgICAgICByZXMucHVzaCgnYWctY2VsbC1yYW5nZS1zZWxlY3RlZC0yJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCA9PT0gMykge1xuICAgICAgICAgICAgcmVzLnB1c2goJ2FnLWNlbGwtcmFuZ2Utc2VsZWN0ZWQtMycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQgPj0gNCkge1xuICAgICAgICAgICAgcmVzLnB1c2goJ2FnLWNlbGwtcmFuZ2Utc2VsZWN0ZWQtNCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBDZWxsQ29tcC5wcm90b3R5cGUub25Sb3dJbmRleENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdoZW4gaW5kZXggY2hhbmdlcywgdGhpcyBpbmZsdWVuY2VzIGl0ZW1zIHRoYXQgbmVlZCB0aGUgaW5kZXgsIHNvIHdlIHVwZGF0ZSB0aGVcbiAgICAgICAgLy8gZ3JpZCBjZWxsIHNvIHRoZXkgYXJlIHdvcmtpbmcgb2ZmIHRoZSBuZXcgaW5kZXguXG4gICAgICAgIHRoaXMuY3JlYXRlR3JpZENlbGxWbygpO1xuICAgICAgICAvLyB3aGVuIHRoZSBpbmRleCBvZiB0aGUgcm93IGNoYW5nZXMsIGllIG1lYW5zIHRoZSBjZWxsIG1heSBoYXZlIGxvc3Qgb3IgZ2FpbmVkIGZvY3VzXG4gICAgICAgIHRoaXMub25DZWxsRm9jdXNlZCgpO1xuICAgICAgICAvLyBjaGVjayByYW5nZSBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5vblJhbmdlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uUmFuZ2VTZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYmVhbnMuZW50ZXJwcmlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdSYW5nZUNvdW50ID0gdGhpcy5iZWFucy5yYW5nZUNvbnRyb2xsZXIuZ2V0Q2VsbFJhbmdlQ291bnQodGhpcy5ncmlkQ2VsbCk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRHdWkoKTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCAhPT0gbmV3UmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgdXRpbHNfMS5fLmFkZE9yUmVtb3ZlQ3NzQ2xhc3MoZWxlbWVudCwgJ2FnLWNlbGwtcmFuZ2Utc2VsZWN0ZWQnLCBuZXdSYW5nZUNvdW50ICE9PSAwKTtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKGVsZW1lbnQsICdhZy1jZWxsLXJhbmdlLXNlbGVjdGVkLTEnLCBuZXdSYW5nZUNvdW50ID09PSAxKTtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKGVsZW1lbnQsICdhZy1jZWxsLXJhbmdlLXNlbGVjdGVkLTInLCBuZXdSYW5nZUNvdW50ID09PSAyKTtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKGVsZW1lbnQsICdhZy1jZWxsLXJhbmdlLXNlbGVjdGVkLTMnLCBuZXdSYW5nZUNvdW50ID09PSAzKTtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKGVsZW1lbnQsICdhZy1jZWxsLXJhbmdlLXNlbGVjdGVkLTQnLCBuZXdSYW5nZUNvdW50ID49IDQpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUNvdW50ID0gbmV3UmFuZ2VDb3VudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uRmlyc3RSaWdodFBpbm5lZENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJzdFJpZ2h0UGlubmVkID0gdGhpcy5jb2x1bW4uaXNGaXJzdFJpZ2h0UGlubmVkKCk7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0UmlnaHRQaW5uZWQgIT09IGZpcnN0UmlnaHRQaW5uZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RSaWdodFBpbm5lZCA9IGZpcnN0UmlnaHRQaW5uZWQ7XG4gICAgICAgICAgICB1dGlsc18xLl8uYWRkT3JSZW1vdmVDc3NDbGFzcyh0aGlzLmdldEd1aSgpLCAnYWctY2VsbC1maXJzdC1yaWdodC1waW5uZWQnLCBmaXJzdFJpZ2h0UGlubmVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uTGFzdExlZnRQaW5uZWRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFzdExlZnRQaW5uZWQgPSB0aGlzLmNvbHVtbi5pc0xhc3RMZWZ0UGlubmVkKCk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RMZWZ0UGlubmVkICE9PSBsYXN0TGVmdFBpbm5lZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0TGVmdFBpbm5lZCA9IGxhc3RMZWZ0UGlubmVkO1xuICAgICAgICAgICAgdXRpbHNfMS5fLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5nZXRHdWkoKSwgJ2FnLWNlbGwtbGFzdC1sZWZ0LXBpbm5lZCcsIGxhc3RMZWZ0UGlubmVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmFkZFNlbGVjdGlvbkNoZWNrYm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy51c2luZ1dyYXBwZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZVBhcmVudE9mVmFsdWUgPSB0aGlzLmdldFJlZkVsZW1lbnQoJ2VDZWxsVmFsdWUnKTtcbiAgICAgICAgICAgIHRoaXMuZUNlbGxXcmFwcGVyID0gdGhpcy5nZXRSZWZFbGVtZW50KCdlQ2VsbFdyYXBwZXInKTtcbiAgICAgICAgICAgIHZhciBjYlNlbGVjdGlvbkNvbXBvbmVudF8xID0gbmV3IGNoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50XzEuQ2hlY2tib3hTZWxlY3Rpb25Db21wb25lbnQoKTtcbiAgICAgICAgICAgIHRoaXMuYmVhbnMuY29udGV4dC53aXJlQmVhbihjYlNlbGVjdGlvbkNvbXBvbmVudF8xKTtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlRnVuYyA9IHRoaXMuY29sdW1uLmdldENvbERlZigpLmNoZWNrYm94U2VsZWN0aW9uO1xuICAgICAgICAgICAgdmlzaWJsZUZ1bmMgPSB0eXBlb2YgdmlzaWJsZUZ1bmMgPT09ICdmdW5jdGlvbicgPyB2aXNpYmxlRnVuYyA6IG51bGw7XG4gICAgICAgICAgICBjYlNlbGVjdGlvbkNvbXBvbmVudF8xLmluaXQoeyByb3dOb2RlOiB0aGlzLnJvd05vZGUsIGNvbHVtbjogdGhpcy5jb2x1bW4sIHZpc2libGVGdW5jOiB2aXNpYmxlRnVuYyB9KTtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveUZ1bmMoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2JTZWxlY3Rpb25Db21wb25lbnRfMS5kZXN0cm95KCk7IH0pO1xuICAgICAgICAgICAgLy8gcHV0IHRoZSBjaGVja2JveCBpbiBiZWZvcmUgdGhlIHZhbHVlXG4gICAgICAgICAgICB0aGlzLmVDZWxsV3JhcHBlci5pbnNlcnRCZWZvcmUoY2JTZWxlY3Rpb25Db21wb25lbnRfMS5nZXRHdWkoKSwgdGhpcy5lUGFyZW50T2ZWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVQYXJlbnRPZlZhbHVlID0gdGhpcy5nZXRHdWkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLmFkZERvbURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRHdWkoKTtcbiAgICAgICAgdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuc2V0RG9tRGF0YShlbGVtZW50LCBDZWxsQ29tcC5ET01fREFUQV9LRVlfQ0VMTF9DT01QLCB0aGlzKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95RnVuYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLnNldERvbURhdGEoZWxlbWVudCwgQ2VsbENvbXAuRE9NX0RBVEFfS0VZX0NFTExfQ09NUCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2VsbENvbXAucHJvdG90eXBlLm9uQ2VsbEZvY3VzZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGNlbGxGb2N1c2VkID0gdGhpcy5iZWFucy5mb2N1c2VkQ2VsbENvbnRyb2xsZXIuaXNDZWxsRm9jdXNlZCh0aGlzLmdyaWRDZWxsKTtcbiAgICAgICAgLy8gc2VlIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBjbGFzc2VzIG9uIHRoaXMgY2VsbFxuICAgICAgICBpZiAoY2VsbEZvY3VzZWQgIT09IHRoaXMuY2VsbEZvY3VzZWQpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZ2V0R3VpKCksICdhZy1jZWxsLWZvY3VzJywgY2VsbEZvY3VzZWQpO1xuICAgICAgICAgICAgdXRpbHNfMS5fLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5nZXRHdWkoKSwgJ2FnLWNlbGwtbm8tZm9jdXMnLCAhY2VsbEZvY3VzZWQpO1xuICAgICAgICAgICAgdGhpcy5jZWxsRm9jdXNlZCA9IGNlbGxGb2N1c2VkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoaXMgY2VsbCB3YXMganVzdCBmb2N1c2VkLCBzZWUgaWYgd2UgbmVlZCB0byBmb3JjZSBicm93c2VyIGZvY3VzLCBoaXMgY2FuXG4gICAgICAgIC8vIGhhcHBlbiBpZiBmb2N1cyBpcyBwcm9ncmFtbWF0aWNhbGx5IHNldC5cbiAgICAgICAgaWYgKGNlbGxGb2N1c2VkICYmIGV2ZW50ICYmIGV2ZW50LmZvcmNlQnJvd3NlckZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmdldEd1aSgpLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYW5vdGhlciBjZWxsIHdhcyBmb2N1c2VkLCBhbmQgd2UgYXJlIGVkaXRpbmcsIHRoZW4gc3RvcCBlZGl0aW5nXG4gICAgICAgIHZhciBmdWxsUm93RWRpdCA9IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRnVsbFJvd0VkaXQoKTtcbiAgICAgICAgaWYgKCFjZWxsRm9jdXNlZCAmJiAhZnVsbFJvd0VkaXQgJiYgdGhpcy5lZGl0aW5nQ2VsbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUm93T3JDZWxsRWRpdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBwYXNzIGluICd0cnVlJyB0byBjYW5jZWwgdGhlIGVkaXRpbmcuXG4gICAgQ2VsbENvbXAucHJvdG90eXBlLnN0b3BSb3dPckNlbGxFZGl0ID0gZnVuY3Rpb24gKGNhbmNlbCkge1xuICAgICAgICBpZiAoY2FuY2VsID09PSB2b2lkIDApIHsgY2FuY2VsID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRnVsbFJvd0VkaXQoKSkge1xuICAgICAgICAgICAgdGhpcy5yb3dDb21wLnN0b3BSb3dFZGl0aW5nKGNhbmNlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKGNhbmNlbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxDb21wLnByb3RvdHlwZS5zdG9wRWRpdGluZyA9IGZ1bmN0aW9uIChjYW5jZWwpIHtcbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gdm9pZCAwKSB7IGNhbmNlbCA9IGZhbHNlOyB9XG4gICAgICAgIGlmICghdGhpcy5lZGl0aW5nQ2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vIGNlbGwgZWRpdG9yLCB0aGlzIG1lYW5zIGR1ZSB0byBhc3luYywgdGhhdCB0aGUgY2VsbCBlZGl0b3IgbmV2ZXIgZ290IGluaXRpYWxpc2VkLFxuICAgICAgICAvLyBzbyB3ZSBqdXN0IGNhcnJ5IG9uIHJlZ2FyZGxlc3MgYXMgaWYgdGhlIGVkaXRpbmcgd2FzIG5ldmVyIHN0YXJ0ZWQuXG4gICAgICAgIGlmICghdGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRpbmdDZWxsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgICAgICAgIC8vIGFsc28gaGF2ZSBhbm90aGVyIG9wdGlvbiBoZXJlIHRvIGNhbmNlbCBhZnRlciBlZGl0aW5nLCBzbyBmb3IgZXhhbXBsZSB1c2VyIGNvdWxkIGhhdmUgYSBwb3B1cCBlZGl0b3IgYW5kXG4gICAgICAgICAgICAvLyBpdCBpcyBjbG9zZWQgYnkgdXNlciBjbGlja2luZyBvdXRzaWRlIHRoZSBlZGl0b3IuIHRoZW4gdGhlIGVkaXRvciB3aWxsIGNsb3NlIGF1dG9tYXRpY2FsbHkgKHdpdGggZmFsc2VcbiAgICAgICAgICAgIC8vIHBhc3NlZCBhYm92ZSkgYW5kIHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBlZGl0b3Igd2FudHMgdG8gYWNjZXB0IHRoZSBuZXcgdmFsdWUuXG4gICAgICAgICAgICB2YXIgdXNlcldhbnRzVG9DYW5jZWwgPSB0aGlzLmNlbGxFZGl0b3IuaXNDYW5jZWxBZnRlckVuZCAmJiB0aGlzLmNlbGxFZGl0b3IuaXNDYW5jZWxBZnRlckVuZCgpO1xuICAgICAgICAgICAgaWYgKCF1c2VyV2FudHNUb0NhbmNlbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY2VsbEVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucm93Tm9kZS5zZXREYXRhVmFsdWUodGhpcy5jb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGl0IGlzIGltcG9ydGFudCB3ZSBzZXQgdGhpcyBhZnRlciBzZXRWYWx1ZSgpIGFib3ZlLCBhcyBvdGhlcndpc2UgdGhlIGNlbGwgd2lsbCBmbGFzaFxuICAgICAgICAvLyB3aGVuIGVkaXRpbmcgc3RvcHMuIHRoZSAncmVmcmVzaCcgbWV0aG9kIGNoZWNrcyBlZGl0aW5nLCBhbmQgZG9lc24ndCByZWZyZXNoIGVkaXRpbmcgY2VsbHMuXG4gICAgICAgIC8vIHRodXMgaXQgd2lsbCBza2lwIHRoZSByZWZyZXNoIG9uIHRoaXMgY2VsbCB1bnRpbCB0aGUgZW5kIG9mIHRoaXMgbWV0aG9kIHdoZXJlIHdlIGNhbGxcbiAgICAgICAgLy8gcmVmcmVzaCBkaXJlY3RseSBhbmQgd2Ugc3VwcHJlc3MgdGhlIGZsYXNoLlxuICAgICAgICB0aGlzLmVkaXRpbmdDZWxsID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IuZGVzdHJveSkge1xuICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gY2xlYXIgdGhpcyBvdXQgLSBhcyBwYXJ0cyBvZiB0aGUgY29kZSB3aWxsIGNoZWNrIGZvclxuICAgICAgICAvLyB0aGlzIHRvIHNlZSBpZiBhbiBhc3luYyBjZWxsRWRpdG9yIGhhcyB5ZXQgdG8gYmUgY3JlYXRlZFxuICAgICAgICB0aGlzLmNlbGxFZGl0b3IgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9ySW5Qb3B1cCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlRWRpdG9yUG9wdXAoKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZUVkaXRvclBvcHVwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5yZW1vdmVBbGxDaGlsZHJlbih0aGlzLmdldEd1aSgpKTtcbiAgICAgICAgICAgIC8vIHB1dCB0aGUgY2VsbCBiYWNrIHRoZSB3YXkgaXQgd2FzIGJlZm9yZSBlZGl0aW5nXG4gICAgICAgICAgICBpZiAodGhpcy51c2luZ1dyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3cmFwcGVyLCB0aGVuIHB1dCB0aGUgd3JhcHBlciBiYWNrXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRHdWkoKS5hcHBlbmRDaGlsZCh0aGlzLmVDZWxsV3JhcHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBjZWxsUmVuZGVyZXIsIHRoZW4gcHV0IHRoZSBndWkgYmFjayBpbi4gaWYgdGhlIHJlbmRlcmVyIGhhc1xuICAgICAgICAgICAgICAgIC8vIGEgcmVmcmVzaCwgaXQgd2lsbCBiZSBjYWxsZWQuIGhvd2V2ZXIgaWYgaXQgZG9lc24ndCwgdGhlbiBsYXRlclxuICAgICAgICAgICAgICAgIC8vIHRoZSByZW5kZXJlciB3aWxsIGJlIGRlc3Ryb3llZCBhbmQgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Uga25vdyBpdCdzIGEgZG9tIGVsZW1lbnQgKG5vdCBhIHN0cmluZykgYmVjYXVzZSB3ZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgYWZ0ZXIgdGhlIGd1aSB3YXMgYXR0YWNoZWQgaWYgaXQgd2FzIGEgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZUNlbGwgPSB0aGlzLmNlbGxSZW5kZXJlckd1aTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGJlIG51bGwgaWYgY2VsbCB3YXMgcHJldmlvdXNseSBudWxsIC8gY29udGFpbmVkIGVtcHR5IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlc3VsdCBpbiBuZXcgdmFsdWUgbm90IGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZUNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0R3VpKCkuYXBwZW5kQ2hpbGQoZUNlbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SW5saW5lRWRpdGluZ0NsYXNzKCk7XG4gICAgICAgIC8vIHdlIHN1cHByZXNzIHRoZSBmbGFzaCwgYXMgaXQgaXMgbm90IGNvcnJlY3QgdG8gZmxhc2ggdGhlIGNlbGwgdGhlIHVzZXIgaGFzIGZpbmlzaGVkIGVkaXRpbmcsXG4gICAgICAgIC8vIHRoZSB1c2VyIGRvZXNuJ3QgbmVlZCB0byBmbGFzaCBhcyB0aGV5IHdlcmUgdGhlIG9uZSB3aG8gZGlkIHRoZSBlZGl0LCB0aGUgZmxhc2ggaXMgcG9pbnRsZXNzXG4gICAgICAgIC8vIChhcyB0aGUgZmxhc2ggaXMgbWVhbnQgdG8gZHJhdyB0aGUgdXNlciB0byBhIGNoYW5nZSB0aGF0IHRoZXkgZGlkbid0IG1hbnVhbGx5IGRvIHRoZW1zZWx2ZXMpLlxuICAgICAgICB0aGlzLnJlZnJlc2hDZWxsKHsgZm9yY2VSZWZyZXNoOiB0cnVlLCBzdXBwcmVzc0ZsYXNoOiB0cnVlIH0pO1xuICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KG51bGwsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DRUxMX0VESVRJTkdfU1RPUFBFRCk7XG4gICAgICAgIHRoaXMuYmVhbnMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgQ2VsbENvbXAuRE9NX0RBVEFfS0VZX0NFTExfQ09NUCA9ICdjZWxsQ29tcCc7XG4gICAgcmV0dXJuIENlbGxDb21wO1xufShjb21wb25lbnRfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQ2VsbENvbXAgPSBDZWxsQ29tcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsQ29tcC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBjb2x1bW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnRpdGllcy9jb2x1bW5cIik7XG52YXIgYmVhblN0dWJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L2JlYW5TdHViXCIpO1xudmFyIFNldExlZnRGZWF0dXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2V0TGVmdEZlYXR1cmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2V0TGVmdEZlYXR1cmUoY29sdW1uT3JHcm91cCwgZUNlbGwsIGJlYW5zLCBjb2xzU3Bhbm5pbmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29sdW1uT3JHcm91cCA9IGNvbHVtbk9yR3JvdXA7XG4gICAgICAgIF90aGlzLmVDZWxsID0gZUNlbGw7XG4gICAgICAgIF90aGlzLmNvbHNTcGFubmluZyA9IGNvbHNTcGFubmluZztcbiAgICAgICAgX3RoaXMuYmVhbnMgPSBiZWFucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTZXRMZWZ0RmVhdHVyZS5wcm90b3R5cGUuc2V0Q29sc1NwYW5uaW5nID0gZnVuY3Rpb24gKGNvbHNTcGFubmluZykge1xuICAgICAgICB0aGlzLmNvbHNTcGFubmluZyA9IGNvbHNTcGFubmluZztcbiAgICAgICAgdGhpcy5vbkxlZnRDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBTZXRMZWZ0RmVhdHVyZS5wcm90b3R5cGUuZ2V0Q29sdW1uT3JHcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCkgJiYgdGhpcy5jb2xzU3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHNTcGFubmluZ1t0aGlzLmNvbHNTcGFubmluZy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbk9yR3JvdXA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNldExlZnRGZWF0dXJlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmNvbHVtbk9yR3JvdXAsIGNvbHVtbl8xLkNvbHVtbi5FVkVOVF9MRUZUX0NIQU5HRUQsIHRoaXMub25MZWZ0Q2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zZXRMZWZ0Rmlyc3RUaW1lKCk7XG4gICAgfTtcbiAgICBTZXRMZWZ0RmVhdHVyZS5wcm90b3R5cGUuc2V0TGVmdEZpcnN0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1cHByZXNzTW92ZUFuaW1hdGlvbiA9IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NDb2x1bW5Nb3ZlQW5pbWF0aW9uKCk7XG4gICAgICAgIHZhciBvbGRMZWZ0RXhpc3RzID0gdXRpbHNfMS5VdGlscy5leGlzdHModGhpcy5jb2x1bW5Pckdyb3VwLmdldE9sZExlZnQoKSk7XG4gICAgICAgIHZhciBhbmltYXRlQ29sdW1uTW92ZSA9IHRoaXMuYmVhbnMuY29sdW1uQW5pbWF0aW9uU2VydmljZS5pc0FjdGl2ZSgpICYmIG9sZExlZnRFeGlzdHMgJiYgIXN1cHByZXNzTW92ZUFuaW1hdGlvbjtcbiAgICAgICAgaWYgKGFuaW1hdGVDb2x1bW5Nb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVJbkxlZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25MZWZ0Q2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXRMZWZ0RmVhdHVyZS5wcm90b3R5cGUuYW5pbWF0ZUluTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmdldENvbHVtbk9yR3JvdXAoKS5nZXRMZWZ0KCk7XG4gICAgICAgIHZhciBvbGRMZWZ0ID0gdGhpcy5nZXRDb2x1bW5Pckdyb3VwKCkuZ2V0T2xkTGVmdCgpO1xuICAgICAgICB0aGlzLnNldExlZnQob2xkTGVmdCk7XG4gICAgICAgIC8vIHdlIG11c3Qga2VlcCB0cmFjayBvZiB0aGUgbGVmdCB3ZSB3YW50IHRvIHNldCB0bywgYXMgdGhpcyB3b3VsZCBvdGhlcndpc2UgbGVhZCB0byBhIHJhY2VcbiAgICAgICAgLy8gY29uZGl0aW9uLCBpZiB0aGUgdXNlciBjaGFuZ2VkIHRoZSBsZWZ0IHZhbHVlIG1hbnkgdGltZXMgaW4gb25lIFZNIHR1cm4sIHRoZW4gd2Ugd2FudCB0byBtYWtlXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYWN0dWFsTGVmdCB3ZSBzZXQgaW4gdGhlIHRpbWVvdXQgYmVsb3cgKGluIHRoZSBuZXh0IFZNIHR1cm4pIGlzIHRoZSBjb3JyZWN0IGxlZnRcbiAgICAgICAgLy8gcG9zaXRpb24uIGVnIGlmIHVzZXIgY2hhbmdlcyBjb2x1bW4gcG9zaXRpb24gdHdpY2UsIHRoZW4gc2V0TGVmdCgpIGJlbG93IGV4ZWN1dGVzIHR3aWNlIGluIG5leHRcbiAgICAgICAgLy8gVk0gdHVybiwgYnV0IG9ubHkgb25lICh0aGUgY29ycmVjdCBvbmUpIHNob3VsZCBnZXQgYXBwbGllZC5cbiAgICAgICAgdGhpcy5hY3R1YWxMZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5iZWFucy5jb2x1bW5BbmltYXRpb25TZXJ2aWNlLmV4ZWN1dGVOZXh0Vk1UdXJuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHRlc3QgdGhpcyBsZWZ0IHZhbHVlIGlzIHRoZSBsYXRlc3Qgb25lIHRvIGJlIGFwcGxpZWQsIGFuZCBpZiBub3QsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3R1YWxMZWZ0ID09PSBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0TGVmdChsZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZXRMZWZ0RmVhdHVyZS5wcm90b3R5cGUub25MZWZ0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3R1YWxMZWZ0ID0gdGhpcy5nZXRDb2x1bW5Pckdyb3VwKCkuZ2V0TGVmdCgpO1xuICAgICAgICB0aGlzLnNldExlZnQodGhpcy5hY3R1YWxMZWZ0KTtcbiAgICB9O1xuICAgIFNldExlZnRGZWF0dXJlLnByb3RvdHlwZS5zZXRMZWZ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBudWxsLCB0aGVuIHRoYXQgbWVhbnMgdGhlIGNvbHVtbiBpcyBubyBsb25nZXJcbiAgICAgICAgLy8gZGlzcGxheWVkLiB0aGVyZSBpcyBsb2dpYyBpbiB0aGUgcmVuZGVyaW5nIHRvIGZhZGUgdGhlc2UgY29sdW1uc1xuICAgICAgICAvLyBvdXQsIHNvIHdlIGRvbid0IHRyeSBhbmQgY2hhbmdlIHRoZWlyIGxlZnQgcG9zaXRpb25zLlxuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHModmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmVDZWxsLnN0eWxlLmxlZnQgPSB2YWx1ZSArICdweCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTZXRMZWZ0RmVhdHVyZTtcbn0oYmVhblN0dWJfMS5CZWFuU3R1YikpO1xuZXhwb3J0cy5TZXRMZWZ0RmVhdHVyZSA9IFNldExlZnRGZWF0dXJlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2ZlYXR1cmVzL3NldExlZnRGZWF0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGV4cHJlc3Npb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVTZXJ2aWNlL2V4cHJlc3Npb25TZXJ2aWNlXCIpO1xudmFyIFZhbHVlRm9ybWF0dGVyU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFsdWVGb3JtYXR0ZXJTZXJ2aWNlKCkge1xuICAgIH1cbiAgICBWYWx1ZUZvcm1hdHRlclNlcnZpY2UucHJvdG90eXBlLmZvcm1hdFZhbHVlID0gZnVuY3Rpb24gKGNvbHVtbiwgcm93Tm9kZSwgJHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVyO1xuICAgICAgICB2YXIgY29sRGVmID0gY29sdW1uLmdldENvbERlZigpO1xuICAgICAgICAvLyBpZiBmbG9hdGluZywgZ2l2ZSBwcmVmZXJlbmNlIHRvIHRoZSBmbG9hdGluZyBmb3JtYXR0ZXJcbiAgICAgICAgaWYgKHJvd05vZGUgJiYgcm93Tm9kZS5yb3dQaW5uZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlciA9IGNvbERlZi5waW5uZWRSb3dWYWx1ZUZvcm1hdHRlciA/IGNvbERlZi5waW5uZWRSb3dWYWx1ZUZvcm1hdHRlciA6IGNvbERlZi52YWx1ZUZvcm1hdHRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdHRlciA9IGNvbERlZi52YWx1ZUZvcm1hdHRlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgbm9kZTogcm93Tm9kZSxcbiAgICAgICAgICAgICAgICBkYXRhOiByb3dOb2RlID8gcm93Tm9kZS5kYXRhIDogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2xEZWY6IGNvbHVtbi5nZXRDb2xEZWYoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29sdW1uQXBpKCksXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gb3JpZ2luYWxseSB3ZSBwdXQgdGhlIGFuZ3VsYXIgMSBzY29wZSBoZXJlLCBidXQgd2UgZG9uJ3Qgd2FudCB0aGUgc2NvcGVcbiAgICAgICAgICAgIC8vIGluIHRoZSBwYXJhbXMgaW50ZXJmYWNlLCBhcyBvdGhlciBmcmFtZXdvcmtzIHdpbGwgc2VlIHRoZSBpbnRlcmZhY2UsIGFuZFxuICAgICAgICAgICAgLy8gYW5ndWxhciAxIGlzIG5vdCBjb29sIGFueSBtb3JlLiBzbyB3ZSBoYWNrIHRoZSBzY29wZSBpbiBoZXJlICh3ZSBjYW5ub3RcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgaXQgYWJvdmUsIGFzIGl0J3Mgbm90IGluIHRoZSBpbnRlcmZhY2UsIHNvIHdvdWxkIGNhdXNlIGEgY29tcGlsZSBlcnJvcikuXG4gICAgICAgICAgICAvLyBpbiB0aGUgZnV0dXJlLCB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBhbmd1bGFyIDEsIHdlIGNhbiB0YWtlIHRoaXMgb3V0LlxuICAgICAgICAgICAgcGFyYW1zLiRzY29wZSA9ICRzY29wZTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZXhwcmVzc2lvblNlcnZpY2UuZXZhbHVhdGUoZm9ybWF0dGVyLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbERlZi5yZWZEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sRGVmLnJlZkRhdGFbdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGRvIHRoaXMsIHRoZW4gYXJyYXlzIGdldCBkaXNwbGF5ZWQgYXMgMSwyLDMsIGJ1dCB3ZSB3YW50IDEsIDIsIDMgKGllIHdpdGggc3BhY2VzKVxuICAgICAgICBpZiAoKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLmpvaW4oJywgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBWYWx1ZUZvcm1hdHRlclNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdleHByZXNzaW9uU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXhwcmVzc2lvblNlcnZpY2VfMS5FeHByZXNzaW9uU2VydmljZSlcbiAgICBdLCBWYWx1ZUZvcm1hdHRlclNlcnZpY2UucHJvdG90eXBlLCBcImV4cHJlc3Npb25TZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgVmFsdWVGb3JtYXR0ZXJTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCd2YWx1ZUZvcm1hdHRlclNlcnZpY2UnKVxuICAgIF0sIFZhbHVlRm9ybWF0dGVyU2VydmljZSk7XG4gICAgcmV0dXJuIFZhbHVlRm9ybWF0dGVyU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlZhbHVlRm9ybWF0dGVyU2VydmljZSA9IFZhbHVlRm9ybWF0dGVyU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy92YWx1ZUZvcm1hdHRlclNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMTQpKSgxNTApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGdyaWRQYW5lbF8xID0gcmVxdWlyZShcIi4vZ3JpZFBhbmVsL2dyaWRQYW5lbFwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2V2ZW50U2VydmljZVwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29udGV4dF8yID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbnRleHRfMyA9IHJlcXVpcmUoXCIuL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb250ZXh0XzQgPSByZXF1aXJlKFwiLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY291bnRlciA9IDA7XG52YXIgQWxpZ25lZEdyaWRzU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWxpZ25lZEdyaWRzU2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlkID0gY291bnRlcisrO1xuICAgICAgICAvLyBmbGFnIHRvIG1hcmsgaWYgd2UgYXJlIGNvbnN1bWluZy4gdG8gYXZvaWQgY3ljbGljIGV2ZW50cyAoaWUgb3RoZXIgZ3JpZCBmaXJpbmcgYmFjayB0byBtYXN0ZXJcbiAgICAgICAgLy8gd2hpbGUgcHJvY2Vzc2luZyBhIG1hc3RlciBldmVudCkgd2UgbWFyayB0aGlzIGlmIGNvbnN1bWluZyBhbiBldmVudCwgYW5kIGlmIHdlIGFyZSwgdGhlblxuICAgICAgICAvLyB3ZSBkb24ndCBmaXJlIGJhY2sgYW55IGV2ZW50cy5cbiAgICAgICAgdGhpcy5jb25zdW1pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUuc2V0QmVhbnMgPSBmdW5jdGlvbiAobG9nZ2VyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlckZhY3RvcnkuY3JlYXRlKCdBbGlnbmVkR3JpZHNTZXJ2aWNlJyk7XG4gICAgfTtcbiAgICBBbGlnbmVkR3JpZHNTZXJ2aWNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fTU9WRUQsIHRoaXMuZmlyZUNvbHVtbkV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fVklTSUJMRSwgdGhpcy5maXJlQ29sdW1uRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9QSU5ORUQsIHRoaXMuZmlyZUNvbHVtbkV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fR1JPVVBfT1BFTkVELCB0aGlzLmZpcmVDb2x1bW5FdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1JFU0laRUQsIHRoaXMuZmlyZUNvbHVtbkV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9CT0RZX1NDUk9MTCwgdGhpcy5maXJlU2Nyb2xsRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICAvLyBjb21tb24gbG9naWMgYWNyb3NzIGFsbCB0aGUgZmlyZSBtZXRob2RzXG4gICAgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUuZmlyZUV2ZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBhbHJlYWR5IGNvbnN1bWluZywgdGhlbiB3ZSBhcmUgYWN0aW5nIG9uIGFuIGV2ZW50IGZyb20gYSBtYXN0ZXIsXG4gICAgICAgIC8vIHNvIHdlIGRvbid0IGNhdXNlIGEgY3ljbGljIGZpcmluZyBvZiBldmVudHNcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBhbGlnbmVkIGdyaWRzLCBhbmQgcGFzcyBlYWNoIGFsaWduZWQgZ3JpZCBzZXJ2aWNlIHRvIHRoZSBjYWxsYmFja1xuICAgICAgICB2YXIgb3RoZXJHcmlkcyA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFsaWduZWRHcmlkcygpO1xuICAgICAgICBpZiAob3RoZXJHcmlkcykge1xuICAgICAgICAgICAgb3RoZXJHcmlkcy5mb3JFYWNoKGZ1bmN0aW9uIChvdGhlckdyaWRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyR3JpZE9wdGlvbnMuYXBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGlnbmVkR3JpZFNlcnZpY2UgPSBvdGhlckdyaWRPcHRpb25zLmFwaS5fX2dldEFsaWduZWRHcmlkU2VydmljZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhhbGlnbmVkR3JpZFNlcnZpY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBjb21tb24gbG9naWMgYWNyb3NzIGFsbCBjb25zdW1lIG1ldGhvZHMuIHZlcnkgbGl0dGxlIGNvbW1vbiBsb2dpYywgaG93ZXZlciBleHRyYWN0aW5nXG4gICAgLy8gZ3VhcmFudGVlcyBjb25zaXN0ZW5jeSBhY3Jvc3MgdGhlIG1ldGhvZHMuXG4gICAgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUub25FdmVudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNvbnN1bWluZyA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuY29uc3VtaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICBBbGlnbmVkR3JpZHNTZXJ2aWNlLnByb3RvdHlwZS5maXJlQ29sdW1uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoZnVuY3Rpb24gKGFsaWduZWRHcmlkc1NlcnZpY2UpIHtcbiAgICAgICAgICAgIGFsaWduZWRHcmlkc1NlcnZpY2Uub25Db2x1bW5FdmVudChldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUuZmlyZVNjcm9sbEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kaXJlY3Rpb24gIT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KGZ1bmN0aW9uIChhbGlnbmVkR3JpZHNTZXJ2aWNlKSB7XG4gICAgICAgICAgICBhbGlnbmVkR3JpZHNTZXJ2aWNlLm9uU2Nyb2xsRXZlbnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFsaWduZWRHcmlkc1NlcnZpY2UucHJvdG90eXBlLm9uU2Nyb2xsRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vbkV2ZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmdyaWRQYW5lbC5zZXRIb3Jpem9udGFsU2Nyb2xsUG9zaXRpb24oZXZlbnQubGVmdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUuZ2V0TWFzdGVyQ29sdW1ucyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChldmVudC5jb2x1bW5zKSB7XG4gICAgICAgICAgICBldmVudC5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5jb2x1bW4pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV2ZW50LmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEFsaWduZWRHcmlkc1NlcnZpY2UucHJvdG90eXBlLmdldENvbHVtbklkcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChldmVudC5jb2x1bW5zKSB7XG4gICAgICAgICAgICBldmVudC5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbHVtbi5nZXRDb2xJZCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV2ZW50LmNvbHVtbi5nZXRDb2xJZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUub25Db2x1bW5FdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uRXZlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX01PVkVEOlxuICAgICAgICAgICAgICAgIGNhc2UgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9WSVNJQkxFOlxuICAgICAgICAgICAgICAgIGNhc2UgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9QSU5ORUQ6XG4gICAgICAgICAgICAgICAgY2FzZSBldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1JFU0laRUQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzQ29sdW1uRXZlbnQoY29sRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fR1JPVVBfT1BFTkVEOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBPcGVuZWRFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzR3JvdXBPcGVuZWRFdmVudChncm91cE9wZW5lZEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1BJVk9UX0NIQU5HRUQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCBzdXBwb3J0IHBpdm90aW5nIHdpdGggYWxpZ25lZCBncmlkcyBhcyB0aGUgY29sdW1ucyB3aWxsIGJlIG91dCBvZiBzeW5jIGFzIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBncmlkcyB3aWxsIGhhdmUgY29sdW1ucyBjcmVhdGVkIGJhc2VkIG9uIHRoZSByb3cgZGF0YSBvZiB0aGUgZ3JpZC5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBwaXZvdGluZyBpcyBub3Qgc3VwcG9ydGVkIHdpdGggYWxpZ25lZCBncmlkcy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnWW91IGNhbiBvbmx5IHVzZSBvbmUgb2YgdGhlc2UgZmVhdHVyZXMgYXQgYSB0aW1lIGluIGEgZ3JpZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUucHJvY2Vzc0dyb3VwT3BlbmVkRXZlbnQgPSBmdW5jdGlvbiAoZ3JvdXBPcGVuZWRFdmVudCkge1xuICAgICAgICAvLyBsaWtld2lzZSBmb3IgY29sdW1uIGdyb3VwXG4gICAgICAgIHZhciBtYXN0ZXJDb2x1bW5Hcm91cCA9IGdyb3VwT3BlbmVkRXZlbnQuY29sdW1uR3JvdXA7XG4gICAgICAgIHZhciBvdGhlckNvbHVtbkdyb3VwO1xuICAgICAgICBpZiAobWFzdGVyQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBncm91cElkID0gbWFzdGVyQ29sdW1uR3JvdXAuZ2V0R3JvdXBJZCgpO1xuICAgICAgICAgICAgb3RoZXJDb2x1bW5Hcm91cCA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRPcmlnaW5hbENvbHVtbkdyb3VwKGdyb3VwSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXN0ZXJDb2x1bW5Hcm91cCAmJiAhb3RoZXJDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnb25Db2x1bW5FdmVudC0+IHByb2Nlc3NpbmcgJyArIGV2ZW50ICsgJyBleHBhbmRlZCA9ICcgKyBtYXN0ZXJDb2x1bW5Hcm91cC5pc0V4cGFuZGVkKCkpO1xuICAgICAgICB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuc2V0Q29sdW1uR3JvdXBPcGVuZWQob3RoZXJDb2x1bW5Hcm91cCwgbWFzdGVyQ29sdW1uR3JvdXAuaXNFeHBhbmRlZCgpKTtcbiAgICB9O1xuICAgIEFsaWduZWRHcmlkc1NlcnZpY2UucHJvdG90eXBlLnByb2Nlc3NDb2x1bW5FdmVudCA9IGZ1bmN0aW9uIChjb2xFdmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyB0aGUgY29sdW1uIGluIHRoZSBldmVudCBpcyBmcm9tIHRoZSBtYXN0ZXIgZ3JpZC4gbmVlZCB0b1xuICAgICAgICAvLyBsb29rIHVwIHRoZSBlcXVpdmFsZW50IGZyb20gdGhpcyAob3RoZXIpIGdyaWRcbiAgICAgICAgdmFyIG1hc3RlckNvbHVtbiA9IGNvbEV2ZW50LmNvbHVtbjtcbiAgICAgICAgdmFyIG90aGVyQ29sdW1uO1xuICAgICAgICBpZiAobWFzdGVyQ29sdW1uKSB7XG4gICAgICAgICAgICBvdGhlckNvbHVtbiA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRQcmltYXJ5Q29sdW1uKG1hc3RlckNvbHVtbi5nZXRDb2xJZCgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBldmVudCB3YXMgd2l0aCByZXNwZWN0IHRvIGEgbWFzdGVyIGNvbHVtbiwgdGhhdCBpcyBub3QgcHJlc2VudCBpbiB0aGlzXG4gICAgICAgIC8vIGdyaWQsIHRoZW4gd2UgaWdub3JlIHRoZSBldmVudFxuICAgICAgICBpZiAobWFzdGVyQ29sdW1uICYmICFvdGhlckNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIHRpbWUsIGFsbCB0aGUgbWV0aG9kcyBiZWxvdyBzaG91bGQgdXNlIHRoZSBjb2x1bW4gaWRzLCBpdCdzIGEgbW9yZSBnZW5lcmljIHdheVxuICAgICAgICAvLyBvZiBoYW5kbGluZyBjb2x1bW5zLCBhbmQgYWxzbyBhbGxvd3MgZm9yIHNpbmdsZSBvciBtdWx0aSBjb2x1bW4gZXZlbnRzXG4gICAgICAgIHZhciBjb2x1bW5JZHMgPSB0aGlzLmdldENvbHVtbklkcyhjb2xFdmVudCk7XG4gICAgICAgIHZhciBtYXN0ZXJDb2x1bW5zID0gdGhpcy5nZXRNYXN0ZXJDb2x1bW5zKGNvbEV2ZW50KTtcbiAgICAgICAgc3dpdGNoIChjb2xFdmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fTU9WRUQ6XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVkRXZlbnQgPSBjb2xFdmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ29uQ29sdW1uRXZlbnQtPiBwcm9jZXNzaW5nICcgKyBjb2xFdmVudC50eXBlICsgJyB0b0luZGV4ID0gJyArIG1vdmVkRXZlbnQudG9JbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5Db250cm9sbGVyLm1vdmVDb2x1bW5zKGNvbHVtbklkcywgbW92ZWRFdmVudC50b0luZGV4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9WSVNJQkxFOlxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlRXZlbnQgPSBjb2xFdmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ29uQ29sdW1uRXZlbnQtPiBwcm9jZXNzaW5nICcgKyBjb2xFdmVudC50eXBlICsgJyB2aXNpYmxlID0gJyArIHZpc2libGVFdmVudC52aXNpYmxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuc2V0Q29sdW1uc1Zpc2libGUoY29sdW1uSWRzLCB2aXNpYmxlRXZlbnQudmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUElOTkVEOlxuICAgICAgICAgICAgICAgIHZhciBwaW5uZWRFdmVudCA9IGNvbEV2ZW50O1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygnb25Db2x1bW5FdmVudC0+IHByb2Nlc3NpbmcgJyArIGNvbEV2ZW50LnR5cGUgKyAnIHBpbm5lZCA9ICcgKyBwaW5uZWRFdmVudC5waW5uZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5zUGlubmVkKGNvbHVtbklkcywgcGlubmVkRXZlbnQucGlubmVkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9SRVNJWkVEOlxuICAgICAgICAgICAgICAgIHZhciByZXNpemVkRXZlbnRfMSA9IGNvbEV2ZW50O1xuICAgICAgICAgICAgICAgIG1hc3RlckNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAobWFzdGVyQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coJ29uQ29sdW1uRXZlbnQtPiBwcm9jZXNzaW5nICcgKyBjb2xFdmVudC50eXBlICsgJyBhY3R1YWxXaWR0aCA9ICcgKyBtYXN0ZXJDb2x1bW4uZ2V0QWN0dWFsV2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbHVtbkNvbnRyb2xsZXIuc2V0Q29sdW1uV2lkdGgobWFzdGVyQ29sdW1uLmdldENvbElkKCksIG1hc3RlckNvbHVtbi5nZXRBY3R1YWxXaWR0aCgpLCByZXNpemVkRXZlbnRfMS5maW5pc2hlZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzMuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBBbGlnbmVkR3JpZHNTZXJ2aWNlLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8zLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUsIFwiY29sdW1uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzMuQXV0b3dpcmVkKCdncmlkUGFuZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRQYW5lbF8xLkdyaWRQYW5lbClcbiAgICBdLCBBbGlnbmVkR3JpZHNTZXJ2aWNlLnByb3RvdHlwZSwgXCJncmlkUGFuZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8zLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIF9fcGFyYW0oMCwgY29udGV4dF8yLlF1YWxpZmllcignbG9nZ2VyRmFjdG9yeScpKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtsb2dnZXJfMS5Mb2dnZXJGYWN0b3J5XSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgQWxpZ25lZEdyaWRzU2VydmljZS5wcm90b3R5cGUsIFwic2V0QmVhbnNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfNC5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEFsaWduZWRHcmlkc1NlcnZpY2UucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgQWxpZ25lZEdyaWRzU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignYWxpZ25lZEdyaWRzU2VydmljZScpXG4gICAgXSwgQWxpZ25lZEdyaWRzU2VydmljZSk7XG4gICAgcmV0dXJuIEFsaWduZWRHcmlkc1NlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5BbGlnbmVkR3JpZHNTZXJ2aWNlID0gQWxpZ25lZEdyaWRzU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2FsaWduZWRHcmlkc1NlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xudmFyIGNvbHVtblV0aWxzXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5VdGlsc1wiKTtcbnZhciBjb2x1bW5LZXlDcmVhdG9yXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5LZXlDcmVhdG9yXCIpO1xudmFyIG9yaWdpbmFsQ29sdW1uR3JvdXBfMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9vcmlnaW5hbENvbHVtbkdyb3VwXCIpO1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2NvbHVtblwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgZGVmYXVsdENvbHVtblR5cGVzXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvZGVmYXVsdENvbHVtblR5cGVzXCIpO1xuLy8gdGFrZXMgaW4gYSBsaXN0IG9mIGNvbHVtbnMsIGFzIHNwZWNpZmllZCBieSB0aGUgY29sdW1uIGRlZmluaXRpb25zLCBhbmQgcmV0dXJucyBjb2x1bW4gZ3JvdXBzXG52YXIgQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlcigpIHtcbiAgICB9XG4gICAgQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlci5wcm90b3R5cGUuc2V0QmVhbnMgPSBmdW5jdGlvbiAobG9nZ2VyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlckZhY3RvcnkuY3JlYXRlKCdCYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyJyk7XG4gICAgfTtcbiAgICBCYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVCYWxhbmNlZENvbHVtbkdyb3VwcyA9IGZ1bmN0aW9uIChhYnN0cmFjdENvbERlZnMsIHByaW1hcnlDb2x1bW5zKSB7XG4gICAgICAgIC8vIGNvbHVtbiBrZXkgY3JlYXRvciBkaXNoZXMgb3V0IHVuaXF1ZSBjb2x1bW4gaWQncyBpbiBhIGRldGVybWluaXN0aWMgd2F5LFxuICAgICAgICAvLyBzbyBpZiB3ZSBoYXZlIHR3byBncmlkcyAodGhhdCBjb2xkIGJlIG1hc3Rlci9zbGF2ZSkgd2l0aCBzYW1lIGNvbHVtbiBkZWZpbml0aW9ucyxcbiAgICAgICAgLy8gdGhlbiB0aGlzIGVuc3VyZXMgdGhlIHR3byBncmlkcyB1c2UgaWRlbnRpY2FsIGlkJ3MuXG4gICAgICAgIHZhciBjb2x1bW5LZXlDcmVhdG9yID0gbmV3IGNvbHVtbktleUNyZWF0b3JfMS5Db2x1bW5LZXlDcmVhdG9yKCk7XG4gICAgICAgIC8vIGNyZWF0ZSBhbSB1bmJhbGFuY2VkIHRyZWUgdGhhdCBtYXBzIHRoZSBwcm92aWRlZCBkZWZpbml0aW9uc1xuICAgICAgICB2YXIgdW5iYWxhbmNlZFRyZWUgPSB0aGlzLnJlY3Vyc2l2ZWx5Q3JlYXRlQ29sdW1ucyhhYnN0cmFjdENvbERlZnMsIDAsIGNvbHVtbktleUNyZWF0b3IsIHByaW1hcnlDb2x1bW5zKTtcbiAgICAgICAgdmFyIHRyZWVEZXB0ID0gdGhpcy5maW5kTWF4RGVwdCh1bmJhbGFuY2VkVHJlZSwgMCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnTnVtYmVyIG9mIGxldmVscyBmb3IgZ3JvdXBlZCBjb2x1bW5zIGlzICcgKyB0cmVlRGVwdCk7XG4gICAgICAgIHZhciBiYWxhbmNlZFRyZWUgPSB0aGlzLmJhbGFuY2VDb2x1bW5UcmVlKHVuYmFsYW5jZWRUcmVlLCAwLCB0cmVlRGVwdCwgY29sdW1uS2V5Q3JlYXRvcik7XG4gICAgICAgIHRoaXMuY29sdW1uVXRpbHMuZGVwdGhGaXJzdE9yaWdpbmFsVHJlZVNlYXJjaChiYWxhbmNlZFRyZWUsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2Ygb3JpZ2luYWxDb2x1bW5Hcm91cF8xLk9yaWdpbmFsQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5zZXR1cEV4cGFuZGFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYWxhbmNlZFRyZWU6IGJhbGFuY2VkVHJlZSxcbiAgICAgICAgICAgIHRyZWVEZXB0OiB0cmVlRGVwdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlci5wcm90b3R5cGUuYmFsYW5jZUNvbHVtblRyZWUgPSBmdW5jdGlvbiAodW5iYWxhbmNlZFRyZWUsIGN1cnJlbnREZXB0LCBjb2x1bW5EZXB0LCBjb2x1bW5LZXlDcmVhdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCBlYWNoIGNoaWxkLCBmb3IgZ3JvdXBzLCByZWN1cnNlIGEgbGV2ZWwgZGVlcGVyLFxuICAgICAgICAvLyBmb3IgY29sdW1ucyB3ZSBuZWVkIHRvIHBhZFxuICAgICAgICB1bmJhbGFuY2VkVHJlZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2Ygb3JpZ2luYWxDb2x1bW5Hcm91cF8xLk9yaWdpbmFsQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxHcm91cCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IF90aGlzLmJhbGFuY2VDb2x1bW5UcmVlKG9yaWdpbmFsR3JvdXAuZ2V0Q2hpbGRyZW4oKSwgY3VycmVudERlcHQgKyAxLCBjb2x1bW5EZXB0LCBjb2x1bW5LZXlDcmVhdG9yKTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEdyb3VwLnNldENoaWxkcmVuKG5ld0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvcmlnaW5hbEdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBjb2x1bW5EZXB0IC0gMTsgaSA+PSBjdXJyZW50RGVwdDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDb2xJZCA9IGNvbHVtbktleUNyZWF0b3IuZ2V0VW5pcXVlS2V5KG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sR3JvdXBEZWZNZXJnZWQgPSBfdGhpcy5jcmVhdGVNZXJnZWRDb2xHcm91cERlZihudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRlZEdyb3VwID0gbmV3IG9yaWdpbmFsQ29sdW1uR3JvdXBfMS5PcmlnaW5hbENvbHVtbkdyb3VwKGNvbEdyb3VwRGVmTWVyZ2VkLCBuZXdDb2xJZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQud2lyZUJlYW4ocGFkZGVkR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICBwYWRkZWRHcm91cC5zZXRDaGlsZHJlbihbbmV3Q2hpbGRdKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBwYWRkZWRHcm91cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEJhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmZpbmRNYXhEZXB0ID0gZnVuY3Rpb24gKHRyZWVDaGlsZHJlbiwgZGVwdCkge1xuICAgICAgICB2YXIgbWF4RGVwdFRoaXNMZXZlbCA9IGRlcHQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYWJzdHJhY3RDb2x1bW4gPSB0cmVlQ2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoYWJzdHJhY3RDb2x1bW4gaW5zdGFuY2VvZiBvcmlnaW5hbENvbHVtbkdyb3VwXzEuT3JpZ2luYWxDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEdyb3VwID0gYWJzdHJhY3RDb2x1bW47XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RlcHQgPSB0aGlzLmZpbmRNYXhEZXB0KG9yaWdpbmFsR3JvdXAuZ2V0Q2hpbGRyZW4oKSwgZGVwdCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChtYXhEZXB0VGhpc0xldmVsIDwgbmV3RGVwdCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhEZXB0VGhpc0xldmVsID0gbmV3RGVwdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heERlcHRUaGlzTGV2ZWw7XG4gICAgfTtcbiAgICBCYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyLnByb3RvdHlwZS5yZWN1cnNpdmVseUNyZWF0ZUNvbHVtbnMgPSBmdW5jdGlvbiAoYWJzdHJhY3RDb2xEZWZzLCBsZXZlbCwgY29sdW1uS2V5Q3JlYXRvciwgcHJpbWFyeUNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoIWFic3RyYWN0Q29sRGVmcykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhYnN0cmFjdENvbERlZnMuZm9yRWFjaChmdW5jdGlvbiAoYWJzdHJhY3RDb2xEZWYpIHtcbiAgICAgICAgICAgIHZhciBuZXdHcm91cE9yQ29sdW1uO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzQ29sdW1uR3JvdXAoYWJzdHJhY3RDb2xEZWYpKSB7XG4gICAgICAgICAgICAgICAgbmV3R3JvdXBPckNvbHVtbiA9IF90aGlzLmNyZWF0ZUNvbHVtbkdyb3VwKGNvbHVtbktleUNyZWF0b3IsIHByaW1hcnlDb2x1bW5zLCBhYnN0cmFjdENvbERlZiwgbGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3R3JvdXBPckNvbHVtbiA9IF90aGlzLmNyZWF0ZUNvbHVtbihjb2x1bW5LZXlDcmVhdG9yLCBwcmltYXJ5Q29sdW1ucywgYWJzdHJhY3RDb2xEZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3R3JvdXBPckNvbHVtbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlQ29sdW1uR3JvdXAgPSBmdW5jdGlvbiAoY29sdW1uS2V5Q3JlYXRvciwgcHJpbWFyeUNvbHVtbnMsIGNvbEdyb3VwRGVmLCBsZXZlbCkge1xuICAgICAgICB2YXIgY29sR3JvdXBEZWZNZXJnZWQgPSB0aGlzLmNyZWF0ZU1lcmdlZENvbEdyb3VwRGVmKGNvbEdyb3VwRGVmKTtcbiAgICAgICAgdmFyIGdyb3VwSWQgPSBjb2x1bW5LZXlDcmVhdG9yLmdldFVuaXF1ZUtleShjb2xHcm91cERlZk1lcmdlZC5ncm91cElkLCBudWxsKTtcbiAgICAgICAgdmFyIG9yaWdpbmFsR3JvdXAgPSBuZXcgb3JpZ2luYWxDb2x1bW5Hcm91cF8xLk9yaWdpbmFsQ29sdW1uR3JvdXAoY29sR3JvdXBEZWZNZXJnZWQsIGdyb3VwSWQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LndpcmVCZWFuKG9yaWdpbmFsR3JvdXApO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJlY3Vyc2l2ZWx5Q3JlYXRlQ29sdW1ucyhjb2xHcm91cERlZk1lcmdlZC5jaGlsZHJlbiwgbGV2ZWwgKyAxLCBjb2x1bW5LZXlDcmVhdG9yLCBwcmltYXJ5Q29sdW1ucyk7XG4gICAgICAgIG9yaWdpbmFsR3JvdXAuc2V0Q2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxHcm91cDtcbiAgICB9O1xuICAgIEJhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZU1lcmdlZENvbEdyb3VwRGVmID0gZnVuY3Rpb24gKGNvbEdyb3VwRGVmKSB7XG4gICAgICAgIHZhciBjb2xHcm91cERlZk1lcmdlZCA9IHt9O1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFzc2lnbihjb2xHcm91cERlZk1lcmdlZCwgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RGVmYXVsdENvbEdyb3VwRGVmKCkpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFzc2lnbihjb2xHcm91cERlZk1lcmdlZCwgY29sR3JvdXBEZWYpO1xuICAgICAgICB0aGlzLmNoZWNrRm9yRGVwcmVjYXRlZEl0ZW1zKGNvbEdyb3VwRGVmTWVyZ2VkKTtcbiAgICAgICAgcmV0dXJuIGNvbEdyb3VwRGVmTWVyZ2VkO1xuICAgIH07XG4gICAgQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlQ29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbktleUNyZWF0b3IsIHByaW1hcnlDb2x1bW5zLCBjb2xEZWYpIHtcbiAgICAgICAgdmFyIGNvbERlZk1lcmdlZCA9IHRoaXMubWVyZ2VDb2xEZWZzKGNvbERlZik7XG4gICAgICAgIHRoaXMuY2hlY2tGb3JEZXByZWNhdGVkSXRlbXMoY29sRGVmTWVyZ2VkKTtcbiAgICAgICAgdmFyIGNvbElkID0gY29sdW1uS2V5Q3JlYXRvci5nZXRVbmlxdWVLZXkoY29sRGVmTWVyZ2VkLmNvbElkLCBjb2xEZWZNZXJnZWQuZmllbGQpO1xuICAgICAgICB2YXIgY29sdW1uID0gbmV3IGNvbHVtbl8xLkNvbHVtbihjb2xEZWZNZXJnZWQsIGNvbElkLCBwcmltYXJ5Q29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29udGV4dC53aXJlQmVhbihjb2x1bW4pO1xuICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgIH07XG4gICAgQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlci5wcm90b3R5cGUubWVyZ2VDb2xEZWZzID0gZnVuY3Rpb24gKGNvbERlZikge1xuICAgICAgICAvLyBzdGFydCB3aXRoIGVtcHR5IG1lcmdlZCBkZWZpbml0aW9uXG4gICAgICAgIHZhciBjb2xEZWZNZXJnZWQgPSB7fTtcbiAgICAgICAgLy8gbWVyZ2UgcHJvcGVydGllcyBmcm9tIGRlZmF1bHQgY29sdW1uIGRlZmluaXRpb25zXG4gICAgICAgIHV0aWxzXzEuVXRpbHMuYXNzaWduKGNvbERlZk1lcmdlZCwgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RGVmYXVsdENvbERlZigpKTtcbiAgICAgICAgLy8gbWVyZ2UgcHJvcGVydGllcyBmcm9tIGNvbHVtbiB0eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKGNvbERlZi50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2lnbkNvbHVtblR5cGVzKGNvbERlZiwgY29sRGVmTWVyZ2VkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBwcm9wZXJ0aWVzIGZyb20gY29sdW1uIGRlZmluaXRpb25zXG4gICAgICAgIHV0aWxzXzEuVXRpbHMuYXNzaWduKGNvbERlZk1lcmdlZCwgY29sRGVmKTtcbiAgICAgICAgcmV0dXJuIGNvbERlZk1lcmdlZDtcbiAgICB9O1xuICAgIEJhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmFzc2lnbkNvbHVtblR5cGVzID0gZnVuY3Rpb24gKGNvbERlZiwgY29sRGVmTWVyZ2VkKSB7XG4gICAgICAgIHZhciB0eXBlS2V5cztcbiAgICAgICAgaWYgKGNvbERlZi50eXBlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBpbnZhbGlkQXJyYXkgPSBjb2xEZWYudHlwZS5zb21lKGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSAhPT0gJ3N0cmluZyc7IH0pO1xuICAgICAgICAgICAgaWYgKGludmFsaWRBcnJheSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLWdyaWQ6IGlmIGNvbERlZi50eXBlIGlzIHN1cHBsaWVkIGFuIGFycmF5IGl0IHNob3VsZCBiZSBvZiB0eXBlICdzdHJpbmdbXSdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlS2V5cyA9IGNvbERlZi50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb2xEZWYudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHR5cGVLZXlzID0gY29sRGVmLnR5cGUuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLWdyaWQ6IGNvbERlZi50eXBlIHNob3VsZCBiZSBvZiB0eXBlICdzdHJpbmcnIHwgJ3N0cmluZ1tdJ1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSB1c2VyIGRlZmluZWQgd2l0aCBkZWZhdWx0IGNvbHVtbiB0eXBlc1xuICAgICAgICB2YXIgYWxsQ29sdW1uVHlwZXMgPSB1dGlsc18xLlV0aWxzLmFzc2lnbih7fSwgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29sdW1uVHlwZXMoKSwgZGVmYXVsdENvbHVtblR5cGVzXzEuRGVmYXVsdENvbHVtblR5cGVzKTtcbiAgICAgICAgdHlwZUtleXMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIHR5cGVDb2xEZWYgPSBhbGxDb2x1bW5UeXBlc1t0LnRyaW0oKV07XG4gICAgICAgICAgICBpZiAodHlwZUNvbERlZikge1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuYXNzaWduKGNvbERlZk1lcmdlZCwgdHlwZUNvbERlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1ncmlkOiBjb2xEZWYudHlwZSAnXCIgKyB0ICsgXCInIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gZGVmaW5lZCBncmlkT3B0aW9ucy5jb2x1bW5UeXBlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyLnByb3RvdHlwZS5jaGVja0ZvckRlcHJlY2F0ZWRJdGVtcyA9IGZ1bmN0aW9uIChjb2xEZWYpIHtcbiAgICAgICAgaWYgKGNvbERlZikge1xuICAgICAgICAgICAgdmFyIGNvbERlZk5vVHlwZSA9IGNvbERlZjsgLy8gdGFrZSBvdXQgdGhlIHR5cGUsIHNvIHdlIGNhbiBhY2Nlc3MgYXR0cmlidXRlcyBub3QgZGVmaW5lZCBpbiB0aGUgdHlwZVxuICAgICAgICAgICAgaWYgKGNvbERlZk5vVHlwZS5ncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1ncmlkOiBjb2xEZWYuZ3JvdXAgaXMgaW52YWxpZCwgcGxlYXNlIGNoZWNrIGRvY3VtZW50YXRpb24gb24gaG93IHRvIGRvIGdyb3VwaW5nIGFzIGl0IGNoYW5nZWQgaW4gdmVyc2lvbiAzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sRGVmTm9UeXBlLmhlYWRlckdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IGNvbERlZi5oZWFkZXJHcm91cCBpcyBpbnZhbGlkLCBwbGVhc2UgY2hlY2sgZG9jdW1lbnRhdGlvbiBvbiBob3cgdG8gZG8gZ3JvdXBpbmcgYXMgaXQgY2hhbmdlZCBpbiB2ZXJzaW9uIDMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2xEZWZOb1R5cGUuaGVhZGVyR3JvdXBTaG93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IGNvbERlZi5oZWFkZXJHcm91cFNob3cgaXMgaW52YWxpZCwgc2hvdWxkIGJlIGNvbHVtbkdyb3VwU2hvdywgcGxlYXNlIGNoZWNrIGRvY3VtZW50YXRpb24gb24gaG93IHRvIGRvIGdyb3VwaW5nIGFzIGl0IGNoYW5nZWQgaW4gdmVyc2lvbiAzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sRGVmTm9UeXBlLnN1cHByZXNzUm93R3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogY29sRGVmLnN1cHByZXNzUm93R3JvdXAgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBjb2xEZWYudHlwZSBpbnN0ZWFkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sRGVmTm9UeXBlLnN1cHByZXNzQWdncmVnYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogY29sRGVmLnN1cHByZXNzQWdncmVnYXRpb24gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBjb2xEZWYudHlwZSBpbnN0ZWFkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sRGVmTm9UeXBlLnN1cHByZXNzUm93R3JvdXAgfHwgY29sRGVmTm9UeXBlLnN1cHByZXNzQWdncmVnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IGNvbERlZi5zdXBwcmVzc0FnZ3JlZ2F0aW9uIGFuZCBjb2xEZWYuc3VwcHJlc3NSb3dHcm91cCBhcmUgZGVwcmVjYXRlZCwgdXNlIGFsbG93Um93R3JvdXAsIGFsbG93UGl2b3QgYW5kIGFsbG93VmFsdWUgaW5zdGVhZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbERlZk5vVHlwZS5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImFnLWdyaWQ6IEZvdW5kIGRpc3BsYXlOYW1lIFwiICsgY29sRGVmTm9UeXBlLmRpc3BsYXlOYW1lICsgXCIsIHBsZWFzZSB1c2UgaGVhZGVyTmFtZSBpbnN0ZWFkLCBkaXNwbGF5TmFtZSBpcyBkZXByZWNhdGVkLlwiKTtcbiAgICAgICAgICAgICAgICBjb2xEZWZOb1R5cGUuaGVhZGVyTmFtZSA9IGNvbERlZk5vVHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gaWYgb2JqZWN0IGhhcyBjaGlsZHJlbiwgd2UgYXNzdW1lIGl0J3MgYSBncm91cFxuICAgIEJhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmlzQ29sdW1uR3JvdXAgPSBmdW5jdGlvbiAoYWJzdHJhY3RDb2xEZWYpIHtcbiAgICAgICAgcmV0dXJuIGFic3RyYWN0Q29sRGVmLmNoaWxkcmVuICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtblV0aWxzJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5VdGlsc18xLkNvbHVtblV0aWxzKVxuICAgIF0sIEJhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXIucHJvdG90eXBlLCBcImNvbHVtblV0aWxzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIEJhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXIucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgX19wYXJhbSgwLCBjb250ZXh0XzEuUXVhbGlmaWVyKCdsb2dnZXJGYWN0b3J5JykpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2xvZ2dlcl8xLkxvZ2dlckZhY3RvcnldKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBCYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyLnByb3RvdHlwZSwgXCJzZXRCZWFuc1wiLCBudWxsKTtcbiAgICBCYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyJylcbiAgICBdLCBCYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyKTtcbiAgICByZXR1cm4gQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLkJhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXIgPSBCYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9iYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbHVtblV0aWxzXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5VdGlsc1wiKTtcbnZhciBjb2x1bW5Hcm91cF8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2NvbHVtbkdyb3VwXCIpO1xudmFyIG9yaWdpbmFsQ29sdW1uR3JvdXBfMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9vcmlnaW5hbENvbHVtbkdyb3VwXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBjb250ZXh0XzIgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xuLy8gdGFrZXMgaW4gYSBsaXN0IG9mIGNvbHVtbnMsIGFzIHNwZWNpZmllZCBieSB0aGUgY29sdW1uIGRlZmluaXRpb25zLCBhbmQgcmV0dXJucyBjb2x1bW4gZ3JvdXBzXG52YXIgRGlzcGxheWVkR3JvdXBDcmVhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXNwbGF5ZWRHcm91cENyZWF0b3IoKSB7XG4gICAgfVxuICAgIERpc3BsYXllZEdyb3VwQ3JlYXRvci5wcm90b3R5cGUuY3JlYXRlRGlzcGxheWVkR3JvdXBzID0gZnVuY3Rpb24gKFxuICAgICAgICAvLyBhbGwgZGlzcGxheWVkIGNvbHVtbnMgc29ydGVkIC0gdGhpcyBpcyB0aGUgY29sdW1ucyB0aGUgZ3JpZCBzaG91bGQgc2hvd1xuICAgICAgICBzb3J0ZWRWaXNpYmxlQ29sdW1ucywgXG4gICAgICAgIC8vIHRoZSB0cmVlIG9mIGNvbHVtbnMsIGFzIHByb3ZpZGVkIGJ5IHRoZSB1c2VycywgdXNlZCB0byBrbm93IHdoYXQgZ3JvdXBzIGNvbHVtbnMgcm9sbCB1cCBpbnRvXG4gICAgICAgIGJhbGFuY2VkQ29sdW1uVHJlZSwgXG4gICAgICAgIC8vIGNyZWF0ZSdzIHVuaXF1ZSBpZCdzIGZvciB0aGUgZ3JvdXBcbiAgICAgICAgZ3JvdXBJbnN0YW5jZUlkQ3JlYXRvciwgXG4gICAgICAgIC8vIHdlIHRyeSB0byByZXVzZSBvbGQgZ3JvdXBzIGlmIHdlIGNhbiwgdG8gYWxsb3cgZ3VpIHRvIGRvIGFuaW1hdGlvblxuICAgICAgICBvbGREaXNwbGF5ZWRHcm91cHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgcHJldmlvdXNSZWFsUGF0aDtcbiAgICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxQYXRoO1xuICAgICAgICB2YXIgb2xkQ29sdW1uc01hcHBlZCA9IHRoaXMubWFwT2xkR3JvdXBzQnlJZChvbGREaXNwbGF5ZWRHcm91cHMpO1xuICAgICAgICAvLyBnbyB0aHJvdWdoIGVhY2ggY29sdW1uLCB0aGVuIGRvIGEgYm90dG9tIHVwIGNvbXBhcmlzb24gdG8gdGhlIHByZXZpb3VzIGNvbHVtbiwgYW5kIHN0YXJ0XG4gICAgICAgIC8vIHRvIHNoYXJlIGdyb3VwcyBpZiB0aGV5IGNvbnZlcmdlIGF0IGFueSBwb2ludC5cbiAgICAgICAgc29ydGVkVmlzaWJsZUNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudENvbHVtbikge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRPcmlnaW5hbFBhdGggPSBfdGhpcy5nZXRPcmlnaW5hbFBhdGhGb3JDb2x1bW4oYmFsYW5jZWRDb2x1bW5UcmVlLCBjdXJyZW50Q29sdW1uKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UmVhbFBhdGggPSBbXTtcbiAgICAgICAgICAgIHZhciBmaXJzdENvbHVtbiA9ICFwcmV2aW91c09yaWdpbmFsUGF0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudE9yaWdpbmFsUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENvbHVtbiB8fCBjdXJyZW50T3JpZ2luYWxQYXRoW2ldICE9PSBwcmV2aW91c09yaWdpbmFsUGF0aFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXcgZ3JvdXAgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdHcm91cCA9IF90aGlzLmNyZWF0ZUNvbHVtbkdyb3VwKGN1cnJlbnRPcmlnaW5hbFBhdGhbaV0sIGdyb3VwSW5zdGFuY2VJZENyZWF0b3IsIG9sZENvbHVtbnNNYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVhbFBhdGhbaV0gPSBuZXdHcm91cDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdG9wIGxldmVsLCBhZGQgdG8gcmVzdWx0LCBvdGhlcndpc2UgYWRkIHRvIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVhbFBhdGhbaSAtIDFdLmFkZENoaWxkKG5ld0dyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV1c2Ugb2xkIGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWFsUGF0aFtpXSA9IHByZXZpb3VzUmVhbFBhdGhbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vQ29sdW1uR3JvdXBzID0gY3VycmVudFJlYWxQYXRoLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIGlmIChub0NvbHVtbkdyb3Vwcykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBub3QgZ3JvdXBpbmcsIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYWJvdmUgaXMgYW4gZW1wdHlcbiAgICAgICAgICAgICAgICAvLyBwYXRoIChubyBncm91cHMpLCBhbmQgd2UganVzdCBhZGQgdGhlIGNvbHVtbiB0byB0aGUgcm9vdCBsaXN0LlxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRDb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlYWZHcm91cCA9IGN1cnJlbnRSZWFsUGF0aFtjdXJyZW50UmVhbFBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbGVhZkdyb3VwLmFkZENoaWxkKGN1cnJlbnRDb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXNSZWFsUGF0aCA9IGN1cnJlbnRSZWFsUGF0aDtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxQYXRoID0gY3VycmVudE9yaWdpbmFsUGF0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0dXBQYXJlbnRzSW50b0NvbHVtbnMocmVzdWx0LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIERpc3BsYXllZEdyb3VwQ3JlYXRvci5wcm90b3R5cGUuY3JlYXRlQ29sdW1uR3JvdXAgPSBmdW5jdGlvbiAob3JpZ2luYWxHcm91cCwgZ3JvdXBJbnN0YW5jZUlkQ3JlYXRvciwgb2xkQ29sdW1uc01hcHBlZCkge1xuICAgICAgICB2YXIgZ3JvdXBJZCA9IG9yaWdpbmFsR3JvdXAuZ2V0R3JvdXBJZCgpO1xuICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IGdyb3VwSW5zdGFuY2VJZENyZWF0b3IuZ2V0SW5zdGFuY2VJZEZvcktleShncm91cElkKTtcbiAgICAgICAgdmFyIHVuaXF1ZUlkID0gY29sdW1uR3JvdXBfMS5Db2x1bW5Hcm91cC5jcmVhdGVVbmlxdWVJZChncm91cElkLCBpbnN0YW5jZUlkKTtcbiAgICAgICAgdmFyIGNvbHVtbkdyb3VwID0gb2xkQ29sdW1uc01hcHBlZFt1bmlxdWVJZF07XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGlzIHNldHRpbmcgbmV3IGNvbERlZnMsIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIGlkJ3Mgb3ZlcmxhcCwgYW5kIHdlXG4gICAgICAgIC8vIHdvdWxkIGhhdmUgYSBmYWxzZSBtYXRjaCBmcm9tIGFib3ZlLiBzbyB3ZSBkb3VibGUgY2hlY2sgd2UgYXJlIHRhbGtpbmcgYWJvdXQgdGhlXG4gICAgICAgIC8vIHNhbWUgb3JpZ2luYWwgY29sdW1uIGdyb3VwLlxuICAgICAgICBpZiAoY29sdW1uR3JvdXAgJiYgY29sdW1uR3JvdXAuZ2V0T3JpZ2luYWxDb2x1bW5Hcm91cCgpICE9PSBvcmlnaW5hbEdyb3VwKSB7XG4gICAgICAgICAgICBjb2x1bW5Hcm91cCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKGNvbHVtbkdyb3VwKSkge1xuICAgICAgICAgICAgLy8gY2xlYW4gb3V0IHRoZSBvbGQgY29sdW1uIGdyb3VwIGhlcmUsIGFzIHdlIHdpbGwgYmUgYWRkaW5nIGNoaWxkcmVuIGludG8gaXQgYWdhaW5cbiAgICAgICAgICAgIGNvbHVtbkdyb3VwLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW5Hcm91cCA9IG5ldyBjb2x1bW5Hcm91cF8xLkNvbHVtbkdyb3VwKG9yaWdpbmFsR3JvdXAsIGdyb3VwSWQsIGluc3RhbmNlSWQpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LndpcmVCZWFuKGNvbHVtbkdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uR3JvdXA7XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIGJhY2sgYSAyZCBtYXAgb2YgQ29sdW1uR3JvdXAgYXMgZm9sbG93czogZ3JvdXBJZCAtPiBpbnN0YW5jZUlkIC0+IENvbHVtbkdyb3VwXG4gICAgRGlzcGxheWVkR3JvdXBDcmVhdG9yLnByb3RvdHlwZS5tYXBPbGRHcm91cHNCeUlkID0gZnVuY3Rpb24gKGRpc3BsYXllZEdyb3Vwcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciByZWN1cnNpdmUgPSBmdW5jdGlvbiAoY29sdW1uc09yR3JvdXBzKSB7XG4gICAgICAgICAgICBjb2x1bW5zT3JHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uT3JHcm91cCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5Pckdyb3VwIGluc3RhbmNlb2YgY29sdW1uR3JvdXBfMS5Db2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uR3JvdXAgPSBjb2x1bW5Pckdyb3VwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY29sdW1uT3JHcm91cC5nZXRVbmlxdWVJZCgpXSA9IGNvbHVtbkdyb3VwO1xuICAgICAgICAgICAgICAgICAgICByZWN1cnNpdmUoY29sdW1uR3JvdXAuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkaXNwbGF5ZWRHcm91cHMpIHtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZShkaXNwbGF5ZWRHcm91cHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBEaXNwbGF5ZWRHcm91cENyZWF0b3IucHJvdG90eXBlLnNldHVwUGFyZW50c0ludG9Db2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbnNPckdyb3VwcywgcGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbHVtbnNPckdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW5zT3JHcm91cCkge1xuICAgICAgICAgICAgY29sdW1uc09yR3JvdXAuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgICAgICAgICBpZiAoY29sdW1uc09yR3JvdXAgaW5zdGFuY2VvZiBjb2x1bW5Hcm91cF8xLkNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkdyb3VwID0gY29sdW1uc09yR3JvdXA7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0dXBQYXJlbnRzSW50b0NvbHVtbnMoY29sdW1uR3JvdXAuZ2V0Q2hpbGRyZW4oKSwgY29sdW1uR3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERpc3BsYXllZEdyb3VwQ3JlYXRvci5wcm90b3R5cGUuY3JlYXRlRmFrZVBhdGggPSBmdW5jdGlvbiAoYmFsYW5jZWRDb2x1bW5UcmVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnRDaGlsZHJlbiA9IGJhbGFuY2VkQ29sdW1uVHJlZTtcbiAgICAgICAgLy8gdGhpcyB3aGlsZSBsb29rIGRvZXMgc2VhcmNoIG9uIHRoZSBiYWxhbmNlZCB0cmVlLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSByaWdodCBsZW5ndGhcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRDaGlsZHJlbiAmJiBjdXJyZW50Q2hpbGRyZW5bMF0gJiYgY3VycmVudENoaWxkcmVuWzBdIGluc3RhbmNlb2Ygb3JpZ2luYWxDb2x1bW5Hcm91cF8xLk9yaWdpbmFsQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIC8vIHB1dHRpbmcgaW4gYSBkZXRlcm1pbmlzdGljIGZha2UgaWQsIGluIGNhc2UgdGhlIEFQSSBpbiB0aGUgZnV0dXJlIG5lZWRzIHRvIHJlZmVyZW5jZSB0aGUgY29sXG4gICAgICAgICAgICB2YXIgZmFrZVBhdGggPSBuZXcgb3JpZ2luYWxDb2x1bW5Hcm91cF8xLk9yaWdpbmFsQ29sdW1uR3JvdXAobnVsbCwgJ0ZBS0VfUEFUSF8nICsgaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LndpcmVCZWFuKGZha2VQYXRoKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZha2VQYXRoKTtcbiAgICAgICAgICAgIGN1cnJlbnRDaGlsZHJlbiA9IGN1cnJlbnRDaGlsZHJlblswXS5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgRGlzcGxheWVkR3JvdXBDcmVhdG9yLnByb3RvdHlwZS5nZXRPcmlnaW5hbFBhdGhGb3JDb2x1bW4gPSBmdW5jdGlvbiAoYmFsYW5jZWRDb2x1bW5UcmVlLCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgcmVjdXJzZVBhdGgoYmFsYW5jZWRDb2x1bW5UcmVlLCAwKTtcbiAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB3ZSBkaWRuJ3QgZmluZCBhIHBhdGguIHRoaXMgaGFwcGVucyBpZiB0aGUgY29sdW1uIGlzIGdlbmVyYXRlZFxuICAgICAgICAvLyBieSB0aGUgZ3JpZCwgaW4gdGhhdCB0aGUgZGVmaW5pdGlvbiBkaWRuJ3QgY29tZSBmcm9tIHRoZSBjbGllbnQuIGluIHRoaXMgY2FzZSxcbiAgICAgICAgLy8gd2UgY3JlYXRlIGEgZmFrZSBvcmlnaW5hbCBwYXRoLlxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWtlUGF0aChiYWxhbmNlZENvbHVtblRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2VQYXRoKGJhbGFuY2VkQ29sdW1uVHJlZSwgZGVwdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYWxhbmNlZENvbHVtblRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcXVpdCB0aGUgc2VhcmNoLCBzbyAncmVzdWx0JyBpcyBrZXB0IHdpdGggdGhlIGZvdW5kIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gYmFsYW5jZWRDb2x1bW5UcmVlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygb3JpZ2luYWxDb2x1bW5Hcm91cF8xLk9yaWdpbmFsQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZVBhdGgobmV4dE5vZGUuZ2V0Q2hpbGRyZW4oKSwgZGVwdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZGVwdF0gPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8yLkF1dG93aXJlZCgnY29sdW1uVXRpbHMnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtblV0aWxzXzEuQ29sdW1uVXRpbHMpXG4gICAgXSwgRGlzcGxheWVkR3JvdXBDcmVhdG9yLnByb3RvdHlwZSwgXCJjb2x1bW5VdGlsc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzIuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBEaXNwbGF5ZWRHcm91cENyZWF0b3IucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBEaXNwbGF5ZWRHcm91cENyZWF0b3IgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2Rpc3BsYXllZEdyb3VwQ3JlYXRvcicpXG4gICAgXSwgRGlzcGxheWVkR3JvdXBDcmVhdG9yKTtcbiAgICByZXR1cm4gRGlzcGxheWVkR3JvdXBDcmVhdG9yO1xufSgpKTtcbmV4cG9ydHMuRGlzcGxheWVkR3JvdXBDcmVhdG9yID0gRGlzcGxheWVkR3JvdXBDcmVhdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9kaXNwbGF5ZWRHcm91cENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG52YXIgQWdDb21wb25lbnRVdGlscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWdDb21wb25lbnRVdGlscygpIHtcbiAgICB9XG4gICAgQWdDb21wb25lbnRVdGlscy5wcm90b3R5cGUuYWRhcHRGdW5jdGlvbiA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGhhcmRjb2RlZEpzRnVuY3Rpb24sIHR5cGUsIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFyZGNvZGVkSnNGdW5jdGlvbiA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gdGhpcy5jb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyLnJldHJpZXZlKHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5mdW5jdGlvbkFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IG1ldGFkYXRhLmZ1bmN0aW9uQWRhcHRlcihoYXJkY29kZWRKc0Z1bmN0aW9uKSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiSXQgc2VlbXMgbGlrZSB5b3UgYXJlIHByb3ZpZGluZyBhIGZ1bmN0aW9uIGFzIGEgY29tcG9uZW50OiBcIiArIGhhcmRjb2RlZEpzRnVuY3Rpb24gKyBcIiwgYnV0IHRoaXMgY29tcG9uZW50OiBbXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIl0gZG9lc250IGFjY2VwdCBmdW5jdGlvbnNcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWdDb21wb25lbnRVdGlscy5wcm90b3R5cGUuYWRhcHRDZWxsUmVuZGVyZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgQWRhcHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBBZGFwdGVyKCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQWRhcHRlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQWRhcHRlci5wcm90b3R5cGUuZ2V0R3VpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja1Jlc3VsdCA9IGNhbGxiYWNrKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrUmVzdWx0ICE9ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tSZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuXy5sb2FkVGVtcGxhdGUoJzxzcGFuPicgKyBjYWxsYmFja1Jlc3VsdCArICc8L3NwYW4+Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gQWRhcHRlcjtcbiAgICAgICAgfSgpKTtcbiAgICAgICAgcmV0dXJuIEFkYXB0ZXI7XG4gICAgfTtcbiAgICBBZ0NvbXBvbmVudFV0aWxzLnByb3RvdHlwZS5kb2VzSW1wbGVtZW50SUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgICAgaWYgKCFjYW5kaWRhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUucHJvdG90eXBlICYmICdnZXRHdWknIGluIGNhbmRpZGF0ZS5wcm90b3R5cGU7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZChcImNvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXJcIiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXzEuQ29tcG9uZW50TWV0YWRhdGFQcm92aWRlcilcbiAgICBdLCBBZ0NvbXBvbmVudFV0aWxzLnByb3RvdHlwZSwgXCJjb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXCIsIHZvaWQgMCk7XG4gICAgQWdDb21wb25lbnRVdGlscyA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbihcImFnQ29tcG9uZW50VXRpbHNcIilcbiAgICBdLCBBZ0NvbXBvbmVudFV0aWxzKTtcbiAgICByZXR1cm4gQWdDb21wb25lbnRVdGlscztcbn0oKSk7XG5leHBvcnRzLkFnQ29tcG9uZW50VXRpbHMgPSBBZ0NvbXBvbmVudFV0aWxzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29tcG9uZW50cy9mcmFtZXdvcmsvYWdDb21wb25lbnRVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBncmlkU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vZ3JpZFNlcmlhbGl6ZXJcIik7XG52YXIgZG93bmxvYWRlcl8xID0gcmVxdWlyZShcIi4vZG93bmxvYWRlclwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgdmFsdWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi92YWx1ZVNlcnZpY2UvdmFsdWVTZXJ2aWNlXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBMSU5FX1NFUEFSQVRPUiA9ICdcXHJcXG4nO1xudmFyIENzdlNlcmlhbGl6aW5nU2Vzc2lvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENzdlNlcmlhbGl6aW5nU2Vzc2lvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDc3ZTZXJpYWxpemluZ1Nlc3Npb24oY29sdW1uQ29udHJvbGxlciwgdmFsdWVTZXJ2aWNlLCBncmlkT3B0aW9uc1dyYXBwZXIsIHByb2Nlc3NDZWxsQ2FsbGJhY2ssIHByb2Nlc3NIZWFkZXJDYWxsYmFjaywgc3VwcHJlc3NRdW90ZXMsIGNvbHVtblNlcGFyYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb2x1bW5Db250cm9sbGVyLCB2YWx1ZVNlcnZpY2UsIGdyaWRPcHRpb25zV3JhcHBlciwgcHJvY2Vzc0NlbGxDYWxsYmFjaywgcHJvY2Vzc0hlYWRlckNhbGxiYWNrKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdXBwcmVzc1F1b3RlcyA9IHN1cHByZXNzUXVvdGVzO1xuICAgICAgICBfdGhpcy5jb2x1bW5TZXBhcmF0b3IgPSBjb2x1bW5TZXBhcmF0b3I7XG4gICAgICAgIF90aGlzLnJlc3VsdCA9ICcnO1xuICAgICAgICBfdGhpcy5saW5lT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ3N2U2VyaWFsaXppbmdTZXNzaW9uLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKGNvbHVtbnNUb0V4cG9ydCkge1xuICAgIH07XG4gICAgQ3N2U2VyaWFsaXppbmdTZXNzaW9uLnByb3RvdHlwZS5hZGRDdXN0b21IZWFkZXIgPSBmdW5jdGlvbiAoY3VzdG9tSGVhZGVyKSB7XG4gICAgICAgIGlmICghY3VzdG9tSGVhZGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlc3VsdCArPSBjdXN0b21IZWFkZXIgKyBMSU5FX1NFUEFSQVRPUjtcbiAgICB9O1xuICAgIENzdlNlcmlhbGl6aW5nU2Vzc2lvbi5wcm90b3R5cGUuYWRkQ3VzdG9tRm9vdGVyID0gZnVuY3Rpb24gKGN1c3RvbUZvb3Rlcikge1xuICAgICAgICBpZiAoIWN1c3RvbUZvb3RlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXN1bHQgKz0gY3VzdG9tRm9vdGVyICsgTElORV9TRVBBUkFUT1I7XG4gICAgfTtcbiAgICBDc3ZTZXJpYWxpemluZ1Nlc3Npb24ucHJvdG90eXBlLm9uTmV3SGVhZGVyR3JvdXBpbmdSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVPcGVuZWQpXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBMSU5FX1NFUEFSQVRPUjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uQ29sdW1uOiB0aGlzLm9uTmV3SGVhZGVyR3JvdXBpbmdSb3dDb2x1bW4uYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ3N2U2VyaWFsaXppbmdTZXNzaW9uLnByb3RvdHlwZS5vbk5ld0hlYWRlckdyb3VwaW5nUm93Q29sdW1uID0gZnVuY3Rpb24gKGhlYWRlciwgaW5kZXgsIHNwYW4pIHtcbiAgICAgICAgaWYgKGluZGV4ICE9IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9IHRoaXMuY29sdW1uU2VwYXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdWx0ICs9IGhlYWRlcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3BhbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSB0aGlzLmNvbHVtblNlcGFyYXRvciArIHRoaXMucHV0SW5RdW90ZXMoXCJcIiwgdGhpcy5zdXBwcmVzc1F1b3Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5lT3BlbmVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIENzdlNlcmlhbGl6aW5nU2Vzc2lvbi5wcm90b3R5cGUub25OZXdIZWFkZXJSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVPcGVuZWQpXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBMSU5FX1NFUEFSQVRPUjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uQ29sdW1uOiB0aGlzLm9uTmV3SGVhZGVyUm93Q29sdW1uLmJpbmQodGhpcylcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENzdlNlcmlhbGl6aW5nU2Vzc2lvbi5wcm90b3R5cGUub25OZXdIZWFkZXJSb3dDb2x1bW4gPSBmdW5jdGlvbiAoY29sdW1uLCBpbmRleCwgbm9kZSkge1xuICAgICAgICBpZiAoaW5kZXggIT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gdGhpcy5jb2x1bW5TZXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN1bHQgKz0gdGhpcy5wdXRJblF1b3Rlcyh0aGlzLmV4dHJhY3RIZWFkZXJWYWx1ZShjb2x1bW4pLCB0aGlzLnN1cHByZXNzUXVvdGVzKTtcbiAgICAgICAgdGhpcy5saW5lT3BlbmVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIENzdlNlcmlhbGl6aW5nU2Vzc2lvbi5wcm90b3R5cGUub25OZXdCb2R5Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lT3BlbmVkKVxuICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gTElORV9TRVBBUkFUT1I7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbkNvbHVtbjogdGhpcy5vbk5ld0JvZHlSb3dDb2x1bW4uYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ3N2U2VyaWFsaXppbmdTZXNzaW9uLnByb3RvdHlwZS5vbk5ld0JvZHlSb3dDb2x1bW4gPSBmdW5jdGlvbiAoY29sdW1uLCBpbmRleCwgbm9kZSkge1xuICAgICAgICBpZiAoaW5kZXggIT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gdGhpcy5jb2x1bW5TZXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN1bHQgKz0gdGhpcy5wdXRJblF1b3Rlcyh0aGlzLmV4dHJhY3RSb3dDZWxsVmFsdWUoY29sdW1uLCBpbmRleCwgY29uc3RhbnRzXzEuQ29uc3RhbnRzLkVYUE9SVF9UWVBFX0NTViwgbm9kZSksIHRoaXMuc3VwcHJlc3NRdW90ZXMpO1xuICAgICAgICB0aGlzLmxpbmVPcGVuZWQgPSB0cnVlO1xuICAgIH07XG4gICAgQ3N2U2VyaWFsaXppbmdTZXNzaW9uLnByb3RvdHlwZS5wdXRJblF1b3RlcyA9IGZ1bmN0aW9uICh2YWx1ZSwgc3VwcHJlc3NRdW90ZXMpIHtcbiAgICAgICAgaWYgKHN1cHByZXNzUXVvdGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCJcIic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndW5rbm93biB2YWx1ZSB0eXBlIGR1cmluZyBjc3YgY29udmVyc2lvbicpO1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNlIGVhY2ggXCIgd2l0aCBcIlwiIChpZSB0d28gc2V0cyBvZiBkb3VibGUgcXVvdGVzIGlzIGhvdyB0byBkbyBkb3VibGUgcXVvdGVzIGluIGNzdilcbiAgICAgICAgdmFyIHZhbHVlRXNjYXBlZCA9IHN0cmluZ1ZhbHVlLnJlcGxhY2UoL1wiL2csIFwiXFxcIlxcXCJcIik7XG4gICAgICAgIHJldHVybiAnXCInICsgdmFsdWVFc2NhcGVkICsgJ1wiJztcbiAgICB9O1xuICAgIENzdlNlcmlhbGl6aW5nU2Vzc2lvbi5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBDc3ZTZXJpYWxpemluZ1Nlc3Npb247XG59KGdyaWRTZXJpYWxpemVyXzEuQmFzZUdyaWRTZXJpYWxpemluZ1Nlc3Npb24pKTtcbmV4cG9ydHMuQ3N2U2VyaWFsaXppbmdTZXNzaW9uID0gQ3N2U2VyaWFsaXppbmdTZXNzaW9uO1xudmFyIEJhc2VDcmVhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlQ3JlYXRvcigpIHtcbiAgICB9XG4gICAgQmFzZUNyZWF0b3IucHJvdG90eXBlLmV4cG9ydCA9IGZ1bmN0aW9uICh1c2VyUGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXhwb3J0U3VwcHJlc3NlZCgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1ncmlkOiBFeHBvcnQgY2FuY2VsZWQuIEV4cG9ydCBpcyBub3QgYWxsb3dlZCBhcyBwZXIgeW91ciBjb25maWd1cmF0aW9uLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0TWVyZ2VkUGFyYW1zQW5kRGF0YSh1c2VyUGFyYW1zKSwgbWVyZ2VkUGFyYW1zID0gX2EubWVyZ2VkUGFyYW1zLCBkYXRhID0gX2EuZGF0YTtcbiAgICAgICAgdmFyIGZpbGVOYW1lUHJlc2VudCA9IG1lcmdlZFBhcmFtcyAmJiBtZXJnZWRQYXJhbXMuZmlsZU5hbWUgJiYgbWVyZ2VkUGFyYW1zLmZpbGVOYW1lLmxlbmd0aCAhPT0gMDtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVQcmVzZW50ID8gbWVyZ2VkUGFyYW1zLmZpbGVOYW1lIDogdGhpcy5nZXREZWZhdWx0RmlsZU5hbWUoKTtcbiAgICAgICAgaWYgKGZpbGVOYW1lLmluZGV4T2YoXCIuXCIpID09PSAtMSkge1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZSArIFwiLlwiICsgdGhpcy5nZXREZWZhdWx0RmlsZUV4dGVuc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG93bmxvYWRlci5kb3dubG9hZChmaWxlTmFtZSwgZGF0YSwgdGhpcy5nZXRNaW1lVHlwZSgpKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBCYXNlQ3JlYXRvci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWVyZ2VkUGFyYW1zQW5kRGF0YShwYXJhbXMpLmRhdGE7XG4gICAgfTtcbiAgICBCYXNlQ3JlYXRvci5wcm90b3R5cGUuZ2V0TWVyZ2VkUGFyYW1zQW5kRGF0YSA9IGZ1bmN0aW9uICh1c2VyUGFyYW1zKSB7XG4gICAgICAgIHZhciBtZXJnZWRQYXJhbXMgPSB0aGlzLm1lcmdlRGVmYXVsdFBhcmFtcyh1c2VyUGFyYW1zKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdyaWRTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLmNyZWF0ZVNlcmlhbGl6aW5nU2Vzc2lvbihtZXJnZWRQYXJhbXMpLCBtZXJnZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4geyBtZXJnZWRQYXJhbXM6IG1lcmdlZFBhcmFtcywgZGF0YTogZGF0YSB9O1xuICAgIH07XG4gICAgQmFzZUNyZWF0b3IucHJvdG90eXBlLm1lcmdlRGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uICh1c2VyUGFyYW1zKSB7XG4gICAgICAgIHZhciBiYXNlUGFyYW1zID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RGVmYXVsdEV4cG9ydFBhcmFtcygpO1xuICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgIHV0aWxzXzEuXy5hc3NpZ24ocGFyYW1zLCBiYXNlUGFyYW1zKTtcbiAgICAgICAgdXRpbHNfMS5fLmFzc2lnbihwYXJhbXMsIHVzZXJQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2Rvd25sb2FkZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGRvd25sb2FkZXJfMS5Eb3dubG9hZGVyKVxuICAgIF0sIEJhc2VDcmVhdG9yLnByb3RvdHlwZSwgXCJkb3dubG9hZGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRTZXJpYWxpemVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkU2VyaWFsaXplcl8xLkdyaWRTZXJpYWxpemVyKVxuICAgIF0sIEJhc2VDcmVhdG9yLnByb3RvdHlwZSwgXCJncmlkU2VyaWFsaXplclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBCYXNlQ3JlYXRvci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEJhc2VDcmVhdG9yO1xufSgpKTtcbmV4cG9ydHMuQmFzZUNyZWF0b3IgPSBCYXNlQ3JlYXRvcjtcbnZhciBDc3ZDcmVhdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3N2Q3JlYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDc3ZDcmVhdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENzdkNyZWF0b3IucHJvdG90eXBlLmV4cG9ydERhdGFBc0NzdiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0KHBhcmFtcyk7XG4gICAgfTtcbiAgICBDc3ZDcmVhdG9yLnByb3RvdHlwZS5nZXREYXRhQXNDc3YgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGEocGFyYW1zKTtcbiAgICB9O1xuICAgIENzdkNyZWF0b3IucHJvdG90eXBlLmdldE1pbWVUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04O1wiO1xuICAgIH07XG4gICAgQ3N2Q3JlYXRvci5wcm90b3R5cGUuZ2V0RGVmYXVsdEZpbGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ2V4cG9ydC5jc3YnO1xuICAgIH07XG4gICAgQ3N2Q3JlYXRvci5wcm90b3R5cGUuZ2V0RGVmYXVsdEZpbGVFeHRlbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnY3N2JztcbiAgICB9O1xuICAgIENzdkNyZWF0b3IucHJvdG90eXBlLmNyZWF0ZVNlcmlhbGl6aW5nU2Vzc2lvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDc3ZTZXJpYWxpemluZ1Nlc3Npb24odGhpcy5jb2x1bW5Db250cm9sbGVyLCB0aGlzLnZhbHVlU2VydmljZSwgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIHBhcmFtcyA/IHBhcmFtcy5wcm9jZXNzQ2VsbENhbGxiYWNrIDogbnVsbCwgcGFyYW1zID8gcGFyYW1zLnByb2Nlc3NIZWFkZXJDYWxsYmFjayA6IG51bGwsIHBhcmFtcyAmJiBwYXJhbXMuc3VwcHJlc3NRdW90ZXMsIChwYXJhbXMgJiYgcGFyYW1zLmNvbHVtblNlcGFyYXRvcikgfHwgJywnKTtcbiAgICB9O1xuICAgIENzdkNyZWF0b3IucHJvdG90eXBlLmlzRXhwb3J0U3VwcHJlc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NDc3ZFeHBvcnQoKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5Db250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQ29udHJvbGxlcilcbiAgICBdLCBDc3ZDcmVhdG9yLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3ZhbHVlU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdmFsdWVTZXJ2aWNlXzEuVmFsdWVTZXJ2aWNlKVxuICAgIF0sIENzdkNyZWF0b3IucHJvdG90eXBlLCBcInZhbHVlU2VydmljZVwiLCB2b2lkIDApO1xuICAgIENzdkNyZWF0b3IgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2NzdkNyZWF0b3InKVxuICAgIF0sIENzdkNyZWF0b3IpO1xuICAgIHJldHVybiBDc3ZDcmVhdG9yO1xufShCYXNlQ3JlYXRvcikpO1xuZXhwb3J0cy5Dc3ZDcmVhdG9yID0gQ3N2Q3JlYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2NzdkNyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi9ncmlkQXBpXCIpO1xuLyoqIEFkZHMgZHJhZyBsaXN0ZW5pbmcgb250byBhbiBlbGVtZW50LiBJbiBhZy1HcmlkIHRoaXMgaXMgdXNlZCB0d2ljZSwgZmlyc3QgaXMgcmVzaXppbmcgY29sdW1ucyxcbiAqIHNlY29uZCBpcyBtb3ZpbmcgdGhlIGNvbHVtbnMgYW5kIGNvbHVtbiBncm91cHMgYXJvdW5kIChpZSB0aGUgJ2RyYWcnIHBhcnQgb2YgRHJhZyBhbmQgRHJvcC4gKi9cbnZhciBEcmFnU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJhZ1NlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlTGlzdGVuZXIgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Ub3VjaEVuZExpc3RlbmVyID0gdGhpcy5vblRvdWNoVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblRvdWNoTW92ZUxpc3RlbmVyID0gdGhpcy5vblRvdWNoTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRyYWdFbmRGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5kcmFnU291cmNlcyA9IFtdO1xuICAgIH1cbiAgICBEcmFnU2VydmljZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSB0aGlzLmxvZ2dlckZhY3RvcnkuY3JlYXRlKCdEcmFnU2VydmljZScpO1xuICAgIH07XG4gICAgRHJhZ1NlcnZpY2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZXMuZm9yRWFjaCh0aGlzLnJlbW92ZUxpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmRyYWdTb3VyY2VzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBEcmFnU2VydmljZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZHJhZ1NvdXJjZUFuZExpc3RlbmVyKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZHJhZ1NvdXJjZUFuZExpc3RlbmVyLmRyYWdTb3VyY2UuZUVsZW1lbnQ7XG4gICAgICAgIHZhciBtb3VzZURvd25MaXN0ZW5lciA9IGRyYWdTb3VyY2VBbmRMaXN0ZW5lci5tb3VzZURvd25MaXN0ZW5lcjtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZURvd25MaXN0ZW5lcik7XG4gICAgICAgIC8vIHJlbW92ZSB0b3VjaCBsaXN0ZW5lciBvbmx5IGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAoZHJhZ1NvdXJjZUFuZExpc3RlbmVyLnRvdWNoRW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoU3RhcnRMaXN0ZW5lciA9IGRyYWdTb3VyY2VBbmRMaXN0ZW5lci50b3VjaFN0YXJ0TGlzdGVuZXI7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaFN0YXJ0TGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhZ1NlcnZpY2UucHJvdG90eXBlLnJlbW92ZURyYWdTb3VyY2UgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBkcmFnU291cmNlQW5kTGlzdGVuZXIgPSB1dGlsc18xLlV0aWxzLmZpbmQodGhpcy5kcmFnU291cmNlcywgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uZHJhZ1NvdXJjZSA9PT0gcGFyYW1zOyB9KTtcbiAgICAgICAgaWYgKCFkcmFnU291cmNlQW5kTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGRyYWdTb3VyY2VBbmRMaXN0ZW5lcik7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbUFycmF5KHRoaXMuZHJhZ1NvdXJjZXMsIGRyYWdTb3VyY2VBbmRMaXN0ZW5lcik7XG4gICAgfTtcbiAgICBEcmFnU2VydmljZS5wcm90b3R5cGUuc2V0Tm9TZWxlY3RUb0JvZHkgPSBmdW5jdGlvbiAobm9TZWxlY3QpIHtcbiAgICAgICAgdmFyIHVzckRvY3VtZW50ID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgdmFyIGVCb2R5ID0gdXNyRG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMoZUJvZHkpKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3MoZUJvZHksICdhZy1ib2R5LW5vLXNlbGVjdCcsIG5vU2VsZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhZ1NlcnZpY2UucHJvdG90eXBlLmFkZERyYWdTb3VyY2UgPSBmdW5jdGlvbiAocGFyYW1zLCBpbmNsdWRlVG91Y2gpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVUb3VjaCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVUb3VjaCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBtb3VzZUxpc3RlbmVyID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIHBhcmFtcy5lRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZUxpc3RlbmVyKTtcbiAgICAgICAgdmFyIHRvdWNoTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB2YXIgc3VwcHJlc3NUb3VjaCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NUb3VjaCgpO1xuICAgICAgICB2YXIgcmVhbGx5SW5jbHVkZVRvdWNoID0gaW5jbHVkZVRvdWNoICYmICFzdXBwcmVzc1RvdWNoO1xuICAgICAgICBpZiAocmVhbGx5SW5jbHVkZVRvdWNoKSB7XG4gICAgICAgICAgICB0b3VjaExpc3RlbmVyID0gdGhpcy5vblRvdWNoU3RhcnQuYmluZCh0aGlzLCBwYXJhbXMpO1xuICAgICAgICAgICAgcGFyYW1zLmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaExpc3RlbmVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZXMucHVzaCh7XG4gICAgICAgICAgICBkcmFnU291cmNlOiBwYXJhbXMsXG4gICAgICAgICAgICBtb3VzZURvd25MaXN0ZW5lcjogbW91c2VMaXN0ZW5lcixcbiAgICAgICAgICAgIHRvdWNoU3RhcnRMaXN0ZW5lcjogdG91Y2hMaXN0ZW5lcixcbiAgICAgICAgICAgIHRvdWNoRW5hYmxlZDogaW5jbHVkZVRvdWNoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgbW91c2UgZG93biBvbiBhbnkgZHJhZyBzb3VyY2VcbiAgICBEcmFnU2VydmljZS5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gKHBhcmFtcywgdG91Y2hFdmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmN1cnJlbnREcmFnUGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciB0b3VjaCA9IHRvdWNoRXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgdGhpcy50b3VjaExhc3RUaW1lID0gdG91Y2g7XG4gICAgICAgIHRoaXMudG91Y2hTdGFydCA9IHRvdWNoO1xuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIHdlIHRlbXBvcmFsbHkgYWRkIHRoZXNlIGxpc3RlbmVycywgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZywgdGhleVxuICAgICAgICAvLyBhcmUgcmVtb3ZlZCBpbiB0b3VjaCBlbmQgaGFuZGxpbmcuXG4gICAgICAgIHBhcmFtcy5lRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgcGFyYW1zLmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kTGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgcGFyYW1zLmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5vblRvdWNoRW5kTGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5kcmFnRW5kRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGFyYW1zLmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF90aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHBhcmFtcy5lRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLm9uVG91Y2hFbmRMaXN0ZW5lciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgcGFyYW1zLmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX3RoaXMub25Ub3VjaEVuZExpc3RlbmVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzZWUgaWYgd2Ugd2FudCB0byBzdGFydCBkcmFnZ2luZyBzdHJhaWdodCBhd2F5XG4gICAgICAgIGlmIChwYXJhbXMuZHJhZ1N0YXJ0UGl4ZWxzID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29tbW9uTW92ZSh0b3VjaCwgdGhpcy50b3VjaFN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgbW91c2UgZG93biBvbiBhbnkgZHJhZyBzb3VyY2VcbiAgICBEcmFnU2VydmljZS5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbiAocGFyYW1zLCBtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiBsZWZ0IGJ1dHRvbiBjbGlja3NcbiAgICAgICAgaWYgKG1vdXNlRXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50RHJhZ1BhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlRXZlbnRMYXN0VGltZSA9IG1vdXNlRXZlbnQ7XG4gICAgICAgIHRoaXMubW91c2VTdGFydEV2ZW50ID0gbW91c2VFdmVudDtcbiAgICAgICAgdmFyIHVzckRvY3VtZW50ID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgLy8gd2UgdGVtcG9yYWxseSBhZGQgdGhlc2UgbGlzdGVuZXJzLCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLCB0aGV5XG4gICAgICAgIC8vIGFyZSByZW1vdmVkIGluIG1vdXNldXAgaGFuZGxpbmcuXG4gICAgICAgIHVzckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgICAgIHVzckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5kcmFnRW5kRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXNyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMub25Nb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB1c3JEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMub25Nb3VzZVVwTGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2VlIGlmIHdlIHdhbnQgdG8gc3RhcnQgZHJhZ2dpbmcgc3RyYWlnaHQgYXdheVxuICAgICAgICBpZiAocGFyYW1zLmRyYWdTdGFydFBpeGVscyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShtb3VzZUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gcmV0dXJucyB0cnVlIGlmIHRoZSBldmVudCBpcyBjbG9zZSB0byB0aGUgb3JpZ2luYWwgZXZlbnQgYnkgWCBwaXhlbHMgZWl0aGVyIHZlcnRpY2FsbHkgb3IgaG9yaXpvbnRhbGx5LlxuICAgIC8vIHdlIG9ubHkgc3RhcnQgZHJhZ2dpbmcgYWZ0ZXIgWCBwaXhlbHMgc28gdGhpcyBhbGxvd3MgdXMgdG8ga25vdyBpZiB3ZSBzaG91bGQgc3RhcnQgZHJhZ2dpbmcgeWV0LlxuICAgIERyYWdTZXJ2aWNlLnByb3RvdHlwZS5pc0V2ZW50TmVhclN0YXJ0RXZlbnQgPSBmdW5jdGlvbiAoY3VycmVudEV2ZW50LCBzdGFydEV2ZW50KSB7XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQsIHdlIHdhaXQgNCBwaXhlbHMgYmVmb3JlIHN0YXJ0aW5nIHRoZSBkcmFnXG4gICAgICAgIHZhciByZXF1aXJlZFBpeGVsRGlmZiA9IHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMuY3VycmVudERyYWdQYXJhbXMuZHJhZ1N0YXJ0UGl4ZWxzKSA/IHRoaXMuY3VycmVudERyYWdQYXJhbXMuZHJhZ1N0YXJ0UGl4ZWxzIDogNDtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMuYXJlRXZlbnRzTmVhcihjdXJyZW50RXZlbnQsIHN0YXJ0RXZlbnQsIHJlcXVpcmVkUGl4ZWxEaWZmKTtcbiAgICB9O1xuICAgIERyYWdTZXJ2aWNlLnByb3RvdHlwZS5nZXRGaXJzdEFjdGl2ZVRvdWNoID0gZnVuY3Rpb24gKHRvdWNoTGlzdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB0b3VjaExpc3RbaV0uaWRlbnRpZmllciA9PT0gdGhpcy50b3VjaFN0YXJ0LmlkZW50aWZpZXI7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3VjaExpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBEcmFnU2VydmljZS5wcm90b3R5cGUub25Db21tb25Nb3ZlID0gZnVuY3Rpb24gKGN1cnJlbnRFdmVudCwgc3RhcnRFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIC8vIGlmIG1vdXNlIGhhc24ndCB0cmF2ZWxsZWQgZnJvbSB0aGUgc3RhcnQgcG9zaXRpb24gZW5vdWdoLCBkbyBub3RoaW5nXG4gICAgICAgICAgICB2YXIgdG9FYXJseVRvRHJhZyA9ICF0aGlzLmRyYWdnaW5nICYmIHRoaXMuaXNFdmVudE5lYXJTdGFydEV2ZW50KGN1cnJlbnRFdmVudCwgc3RhcnRFdmVudCk7XG4gICAgICAgICAgICBpZiAodG9FYXJseVRvRHJhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFsZXJ0KGBzdGFydGVkYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9EUkFHX1NUQVJURUQsXG4gICAgICAgICAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWdQYXJhbXMub25EcmFnU3RhcnQoc3RhcnRFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROb1NlbGVjdFRvQm9keSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnREcmFnUGFyYW1zLm9uRHJhZ2dpbmcoY3VycmVudEV2ZW50KTtcbiAgICB9O1xuICAgIERyYWdTZXJ2aWNlLnByb3RvdHlwZS5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uICh0b3VjaEV2ZW50KSB7XG4gICAgICAgIHZhciB0b3VjaCA9IHRoaXMuZ2V0Rmlyc3RBY3RpdmVUb3VjaCh0b3VjaEV2ZW50LnRvdWNoZXMpO1xuICAgICAgICBpZiAoIXRvdWNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5fX19zdGF0dXNCYXIuc2V0SW5mb1RleHQoTWF0aC5yYW5kb20oKSArICcgb25Ub3VjaE1vdmUgcHJldmVudERlZmF1bHQgc3RvcFByb3BhZ2F0aW9uJyk7XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IHByZXZpZXcgZGVmYXVsdCwgdGhlbiB0aGUgYnJvd3NlciB3aWxsIHRyeSBhbmQgZG8gaXQncyBvd24gdG91Y2ggc3R1ZmYsXG4gICAgICAgIC8vIGxpa2UgZG8gJ2JhY2sgYnV0dG9uJyAoY2hyb21lIGRvZXMgdGhpcykgb3Igc2Nyb2xsIHRoZSBwYWdlIChlZyBkcmFnIGNvbHVtbiBjb3VsZCAgYmUgY29uZnVzZWRcbiAgICAgICAgLy8gd2l0aCBzY3JvbGwgcGFnZSBpbiB0aGUgYXBwKVxuICAgICAgICAvLyB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub25Db21tb25Nb3ZlKHRvdWNoLCB0aGlzLnRvdWNoU3RhcnQpO1xuICAgIH07XG4gICAgLy8gb25seSBnZXRzIGNhbGxlZCBhZnRlciBhIG1vdXNlIGRvd24gLSBhcyB0aGlzIGlzIG9ubHkgYWRkZWQgYWZ0ZXIgbW91c2VEb3duXG4gICAgLy8gYW5kIGlzIHJlbW92ZWQgd2hlbiBtb3VzZVVwIGhhcHBlbnNcbiAgICBEcmFnU2VydmljZS5wcm90b3R5cGUub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAobW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLm9uQ29tbW9uTW92ZShtb3VzZUV2ZW50LCB0aGlzLm1vdXNlU3RhcnRFdmVudCk7XG4gICAgfTtcbiAgICBEcmFnU2VydmljZS5wcm90b3R5cGUub25Ub3VjaFVwID0gZnVuY3Rpb24gKHRvdWNoRXZlbnQpIHtcbiAgICAgICAgdmFyIHRvdWNoID0gdGhpcy5nZXRGaXJzdEFjdGl2ZVRvdWNoKHRvdWNoRXZlbnQudGFyZ2V0VG91Y2hlcyk7XG4gICAgICAgIC8vIGkgaGF2ZW4ndCB3b3JrZWQgdGhpcyBvdXQgeWV0LCBidXQgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgdG91Y2hcbiAgICAgICAgLy8gd2hlbiB3ZSBnZXQgdGhlIHRvdWNoIHVwIGV2ZW50LiB0byBnZXQgYXJvdW5kIHRoaXMsIHdlIHN3YXAgaW5cbiAgICAgICAgLy8gdGhlIGxhc3QgdG91Y2guIHRoaXMgaXMgYSBoYWNrIHRvICdnZXQgaXQgd29ya2luZycgd2hpbGUgd2VcbiAgICAgICAgLy8gZmlndXJlIG91dCB3aGF0J3MgZ29pbmcgb24sIHdoeSB3ZSBhcmUgbm90IGdldHRpbmcgYSB0b3VjaCBpblxuICAgICAgICAvLyBjdXJyZW50IGV2ZW50LlxuICAgICAgICBpZiAoIXRvdWNoKSB7XG4gICAgICAgICAgICB0b3VjaCA9IHRoaXMudG91Y2hMYXN0VGltZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBtb3VzZSB3YXMgbGVmdCB1cCBiZWZvcmUgd2Ugc3RhcnRlZCB0byBtb3ZlLCB0aGVuIHRoaXMgaXMgYSB0YXAuXG4gICAgICAgIC8vIHdlIGNoZWNrIHRoaXMgYmVmb3JlIG9uVXBDb21tb24gYXMgb25VcENvbW1vbiByZXNldHMgdGhlIGRyYWdnaW5nXG4gICAgICAgIC8vIGxldCB0YXAgPSAhdGhpcy5kcmFnZ2luZztcbiAgICAgICAgLy8gbGV0IHRhcFRhcmdldCA9IHRoaXMuY3VycmVudERyYWdQYXJhbXMuZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMub25VcENvbW1vbih0b3VjaCk7XG4gICAgICAgIC8vIGlmIHRhcCwgdGVsbCB1c2VyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAke01hdGgucmFuZG9tKCl9IHRhcCA9ICR7dGFwfWApO1xuICAgICAgICAvLyBpZiAodGFwKSB7XG4gICAgICAgIC8vICAgICB0YXBUYXJnZXQuY2xpY2soKTtcbiAgICAgICAgLy8gfVxuICAgIH07XG4gICAgRHJhZ1NlcnZpY2UucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uIChtb3VzZUV2ZW50KSB7XG4gICAgICAgIHRoaXMub25VcENvbW1vbihtb3VzZUV2ZW50KTtcbiAgICB9O1xuICAgIERyYWdTZXJ2aWNlLnByb3RvdHlwZS5vblVwQ29tbW9uID0gZnVuY3Rpb24gKGV2ZW50T3JUb3VjaCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZ1BhcmFtcy5vbkRyYWdTdG9wKGV2ZW50T3JUb3VjaCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfRFJBR19TVE9QUEVELFxuICAgICAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Tm9TZWxlY3RUb0JvZHkoZmFsc2UpO1xuICAgICAgICB0aGlzLm1vdXNlU3RhcnRFdmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMubW91c2VFdmVudExhc3RUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50b3VjaExhc3RUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50RHJhZ1BhcmFtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhZ0VuZEZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7IHJldHVybiBmdW5jKCk7IH0pO1xuICAgICAgICB0aGlzLmRyYWdFbmRGdW5jdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdsb2dnZXJGYWN0b3J5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBsb2dnZXJfMS5Mb2dnZXJGYWN0b3J5KVxuICAgIF0sIERyYWdTZXJ2aWNlLnByb3RvdHlwZSwgXCJsb2dnZXJGYWN0b3J5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIERyYWdTZXJ2aWNlLnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgRHJhZ1NlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5BcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5BcGkpXG4gICAgXSwgRHJhZ1NlcnZpY2UucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBEcmFnU2VydmljZS5wcm90b3R5cGUsIFwiZ3JpZEFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBEcmFnU2VydmljZS5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlByZURlc3Ryb3ksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgRHJhZ1NlcnZpY2UucHJvdG90eXBlLCBcImRlc3Ryb3lcIiwgbnVsbCk7XG4gICAgRHJhZ1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2RyYWdTZXJ2aWNlJylcbiAgICBdLCBEcmFnU2VydmljZSk7XG4gICAgcmV0dXJuIERyYWdTZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuRHJhZ1NlcnZpY2UgPSBEcmFnU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2RyYWdBbmREcm9wL2RyYWdTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciB0aGVtZXMgPSBbJ2ZyZXNoJywgJ2RhcmsnLCAnYmx1ZScsICdib290c3RyYXAnLCAnbWF0ZXJpYWwnLCAndGhlbWUtbWF0ZXJpYWwnXTtcbnZhciB0aGVtZUNMYXNzID0gbmV3IFJlZ0V4cChcImFnLShcIiArIHRoZW1lcy5qb2luKCd8JykgKyBcIilcIik7XG52YXIgRW52aXJvbm1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVudmlyb25tZW50KCkge1xuICAgIH1cbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0VGhlbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGVtZU1hdGNoO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZUdyaWREaXY7XG4gICAgICAgIHdoaWxlIChlbGVtZW50ICE9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiB0aGVtZU1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoZW1lTWF0Y2ggPSBlbGVtZW50LmNsYXNzTmFtZS5tYXRjaCh0aGVtZUNMYXNzKTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoZW1lTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGVtZU1hdGNoWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdhZy1mcmVzaCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdlR3JpZERpdicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgRW52aXJvbm1lbnQucHJvdG90eXBlLCBcImVHcmlkRGl2XCIsIHZvaWQgMCk7XG4gICAgRW52aXJvbm1lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2Vudmlyb25tZW50JylcbiAgICBdLCBFbnZpcm9ubWVudCk7XG4gICAgcmV0dXJuIEVudmlyb25tZW50O1xufSgpKTtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBFbnZpcm9ubWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2Vudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgY29tcG9uZW50QW5ub3RhdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi93aWRnZXRzL2NvbXBvbmVudEFubm90YXRpb25zXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgREVGQVVMVF9UUkFOU0xBVElPTlMgPSB7XG4gICAgbG9hZGluZ09vbzogJ0xvYWRpbmcuLi4nLFxuICAgIGVxdWFsczogJ0VxdWFscycsXG4gICAgbm90RXF1YWw6ICdOb3QgZXF1YWwnLFxuICAgIGxlc3NUaGFuOiAnTGVzcyB0aGFuJyxcbiAgICBncmVhdGVyVGhhbjogJ0dyZWF0ZXIgdGhhbicsXG4gICAgaW5SYW5nZTogJ0luIHJhbmdlJyxcbiAgICBsZXNzVGhhbk9yRXF1YWw6ICdMZXNzIHRoYW4gb3IgZXF1YWxzJyxcbiAgICBncmVhdGVyVGhhbk9yRXF1YWw6ICdHcmVhdGVyIHRoYW4gb3IgZXF1YWxzJyxcbiAgICBmaWx0ZXJPb286ICdGaWx0ZXIuLi4nLFxuICAgIGNvbnRhaW5zOiAnQ29udGFpbnMnLFxuICAgIG5vdENvbnRhaW5zOiAnTm90IGNvbnRhaW5zJyxcbiAgICBzdGFydHNXaXRoOiAnU3RhcnRzIHdpdGgnLFxuICAgIGVuZHNXaXRoOiAnRW5kcyB3aXRoJyxcbiAgICBzZWFyY2hPb286ICdTZWFyY2guLi4nLFxuICAgIHNlbGVjdEFsbDogJ1NlbGVjdCBBbGwnLFxuICAgIGFwcGx5RmlsdGVyOiAnQXBwbHkgRmlsdGVyJyxcbiAgICBjbGVhckZpbHRlcjogJ0NsZWFyIEZpbHRlcidcbn07XG4vKipcbiAqIFQoeXBlKSBUaGUgdHlwZSBvZiB0aGlzIGZpbHRlci4gaWUgaW4gRGF0ZUZpbHRlciBUPURhdGVcbiAqIFAoYXJhbXMpIFRoZSBwYXJhbXMgdGhhdCB0aGlzIGZpbHRlciBjYW4gdGFrZVxuICogTShtb2RlbCBnZXRNb2RlbC9zZXRNb2RlbCkgVGhlIG9iamVjdCB0aGF0IHRoaXMgZmlsdGVyIHNlcmlhbGl6ZXMgdG9cbiAqIEYgRmxvYXRpbmcgZmlsdGVyIHBhcmFtc1xuICpcbiAqIENvbnRhaW5zIGNvbW1vbiBsb2dpYyB0byBBTEwgZmlsdGVycy4uIFRyYW5zbGF0aW9uLCBhcHBseSBhbmQgY2xlYXIgYnV0dG9uXG4gKiBnZXQvc2V0TW9kZWwgY29udGV4dCB3aXJpbmcuLi4uXG4gKi9cbnZhciBCYXNlRmlsdGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFzZUZpbHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNlRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEJhc2VGaWx0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyUGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLmRlZmF1bHRGaWx0ZXIgPSB0aGlzLmZpbHRlclBhcmFtcy5kZWZhdWx0T3B0aW9uO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJQYXJhbXMuZmlsdGVyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyUGFyYW1zLmZpbHRlck9wdGlvbnMubGFzdEluZGV4T2YoQmFzZUZpbHRlci5FUVVBTFMpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdEZpbHRlciA9IHRoaXMuZmlsdGVyUGFyYW1zLmZpbHRlck9wdGlvbnNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXN0b21Jbml0KCk7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gdGhpcy5kZWZhdWx0RmlsdGVyO1xuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlID0gcGFyYW1zLmNsZWFyQnV0dG9uID09PSB0cnVlO1xuICAgICAgICAvL0FsbG93aW5nIGZvciBvbGQgcGFyYW0gcHJvcGVydHkgYXBwbHksIGV2ZW4gdGhvdWdoIGlzIG5vdCBhZHZlcnRpc2VkIHRocm91Z2ggdGhlIGludGVyZmFjZVxuICAgICAgICB0aGlzLmFwcGx5QWN0aXZlID0gKChwYXJhbXMuYXBwbHlCdXR0b24gPT09IHRydWUpIHx8IChwYXJhbXMuYXBwbHkgPT09IHRydWUpKTtcbiAgICAgICAgdGhpcy5uZXdSb3dzQWN0aW9uS2VlcCA9IHBhcmFtcy5uZXdSb3dzQWN0aW9uID09PSAna2VlcCc7XG4gICAgICAgIHRoaXMuc2V0VGVtcGxhdGUodGhpcy5nZW5lcmF0ZVRlbXBsYXRlKCkpO1xuICAgICAgICB1dGlsc18xLl8uc2V0VmlzaWJsZSh0aGlzLmVBcHBseUJ1dHRvbiwgdGhpcy5hcHBseUFjdGl2ZSk7XG4gICAgICAgIGlmICh0aGlzLmFwcGx5QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVBcHBseUJ1dHRvbiwgXCJjbGlja1wiLCB0aGlzLmZpbHRlclBhcmFtcy5maWx0ZXJDaGFuZ2VkQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxzXzEuXy5zZXRWaXNpYmxlKHRoaXMuZUNsZWFyQnV0dG9uLCB0aGlzLmNsZWFyQWN0aXZlKTtcbiAgICAgICAgaWYgKHRoaXMuY2xlYXJBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZUNsZWFyQnV0dG9uLCBcImNsaWNrXCIsIHRoaXMub25DbGVhckJ1dHRvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW55QnV0dG9uVmlzaWJsZSA9IHRoaXMuYXBwbHlBY3RpdmUgfHwgdGhpcy5jbGVhckFjdGl2ZTtcbiAgICAgICAgdXRpbHNfMS5fLnNldFZpc2libGUodGhpcy5lQnV0dG9uc1BhbmVsLCBhbnlCdXR0b25WaXNpYmxlKTtcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0ZSh0aGlzLmNvbnRleHQpO1xuICAgICAgICB0aGlzLmluaXRpYWxpc2VGaWx0ZXJCb2R5VWkoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoRmlsdGVyQm9keVVpKCk7XG4gICAgfTtcbiAgICBCYXNlRmlsdGVyLnByb3RvdHlwZS5vbkNsZWFyQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldE1vZGVsKG51bGwpO1xuICAgICAgICB0aGlzLm9uRmlsdGVyQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgQmFzZUZpbHRlci5wcm90b3R5cGUuZmxvYXRpbmdGaWx0ZXIgPSBmdW5jdGlvbiAoZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSAhPT0gJycpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWxGcm9tRmxvYXRpbmdGaWx0ZXIoZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGVsKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25GaWx0ZXJDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBCYXNlRmlsdGVyLnByb3RvdHlwZS5vbk5ld1Jvd3NMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5uZXdSb3dzQWN0aW9uS2VlcCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhc2VGaWx0ZXIucHJvdG90eXBlLmdldE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZpbHRlckFjdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlRmlsdGVyLnByb3RvdHlwZS5nZXROdWxsYWJsZU1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICB9O1xuICAgIEJhc2VGaWx0ZXIucHJvdG90eXBlLnNldE1vZGVsID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZShtb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2hGaWx0ZXJCb2R5VWkoKTtcbiAgICB9O1xuICAgIEJhc2VGaWx0ZXIucHJvdG90eXBlLmRvT25GaWx0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKGFwcGx5Tm93KSB7XG4gICAgICAgIGlmIChhcHBseU5vdyA9PT0gdm9pZCAwKSB7IGFwcGx5Tm93ID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5maWx0ZXJQYXJhbXMuZmlsdGVyTW9kaWZpZWRDYWxsYmFjaygpO1xuICAgICAgICB2YXIgcmVxdWlyZXNBcHBseUFuZElzQXBwbHlpbmcgPSB0aGlzLmFwcGx5QWN0aXZlICYmIGFwcGx5Tm93O1xuICAgICAgICB2YXIgbm90UmVxdWlyZXNBcHBseSA9ICF0aGlzLmFwcGx5QWN0aXZlO1xuICAgICAgICB2YXIgc2hvdWxkRmlsdGVyID0gbm90UmVxdWlyZXNBcHBseSB8fCByZXF1aXJlc0FwcGx5QW5kSXNBcHBseWluZztcbiAgICAgICAgaWYgKHNob3VsZEZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJQYXJhbXMuZmlsdGVyQ2hhbmdlZENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZyZXNoRmlsdGVyQm9keVVpKCk7XG4gICAgICAgIHJldHVybiBzaG91bGRGaWx0ZXI7XG4gICAgfTtcbiAgICBCYXNlRmlsdGVyLnByb3RvdHlwZS5vbkZpbHRlckNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZG9PbkZpbHRlckNoYW5nZWQoKTtcbiAgICB9O1xuICAgIEJhc2VGaWx0ZXIucHJvdG90eXBlLm9uRmxvYXRpbmdGaWx0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAvL0l0IGhhcyB0byBiZSBvZiB0aGUgdHlwZSBGbG9hdGluZ0ZpbHRlcldpdGhBcHBseUNoYW5nZSBpZiBpdCBnZXRzIGhlcmVcbiAgICAgICAgdmFyIGNhc3RlZCA9IGNoYW5nZTtcbiAgICAgICAgdGhpcy5zZXRNb2RlbChjYXN0ZWQgPyBjYXN0ZWQubW9kZWwgOiBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9PbkZpbHRlckNoYW5nZWQoY2FzdGVkID8gY2FzdGVkLmFwcGx5IDogZmFsc2UpO1xuICAgIH07XG4gICAgQmFzZUZpbHRlci5wcm90b3R5cGUuZ2VuZXJhdGVGaWx0ZXJIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIEJhc2VGaWx0ZXIucHJvdG90eXBlLmdlbmVyYXRlVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMuYm9keVRlbXBsYXRlKCk7XG4gICAgICAgIHJldHVybiBcIjxkaXY+XFxuICAgICAgICAgICAgICAgICAgICBcIiArIHRoaXMuZ2VuZXJhdGVGaWx0ZXJIZWFkZXIoKSArIFwiXFxuICAgICAgICAgICAgICAgICAgICBcIiArIGJvZHkgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYWctZmlsdGVyLWFwcGx5LXBhbmVsXFxcIiBpZD1cXFwiYXBwbHlQYW5lbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJjbGVhckJ1dHRvblxcXCI+XCIgKyB0cmFuc2xhdGUoJ2NsZWFyRmlsdGVyJykgKyBcIjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBpZD1cXFwiYXBwbHlCdXR0b25cXFwiPlwiICsgdHJhbnNsYXRlKCdhcHBseUZpbHRlcicpICsgXCI8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cIjtcbiAgICB9O1xuICAgIEJhc2VGaWx0ZXIucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh0b1RyYW5zbGF0ZSkge1xuICAgICAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TG9jYWxlVGV4dEZ1bmMoKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZSh0b1RyYW5zbGF0ZSwgREVGQVVMVF9UUkFOU0xBVElPTlNbdG9UcmFuc2xhdGVdKTtcbiAgICB9O1xuICAgIEJhc2VGaWx0ZXIuRVFVQUxTID0gJ2VxdWFscyc7XG4gICAgQmFzZUZpbHRlci5OT1RfRVFVQUwgPSAnbm90RXF1YWwnO1xuICAgIEJhc2VGaWx0ZXIuTEVTU19USEFOID0gJ2xlc3NUaGFuJztcbiAgICBCYXNlRmlsdGVyLkxFU1NfVEhBTl9PUl9FUVVBTCA9ICdsZXNzVGhhbk9yRXF1YWwnO1xuICAgIEJhc2VGaWx0ZXIuR1JFQVRFUl9USEFOID0gJ2dyZWF0ZXJUaGFuJztcbiAgICBCYXNlRmlsdGVyLkdSRUFURVJfVEhBTl9PUl9FUVVBTCA9ICdncmVhdGVyVGhhbk9yRXF1YWwnO1xuICAgIEJhc2VGaWx0ZXIuSU5fUkFOR0UgPSAnaW5SYW5nZSc7XG4gICAgQmFzZUZpbHRlci5DT05UQUlOUyA9ICdjb250YWlucyc7IC8vMTtcbiAgICBCYXNlRmlsdGVyLk5PVF9DT05UQUlOUyA9ICdub3RDb250YWlucyc7IC8vMTtcbiAgICBCYXNlRmlsdGVyLlNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnOyAvLzQ7XG4gICAgQmFzZUZpbHRlci5FTkRTX1dJVEggPSAnZW5kc1dpdGgnOyAvLzU7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUXVlcnlTZWxlY3RvcignI2FwcGx5UGFuZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEJhc2VGaWx0ZXIucHJvdG90eXBlLCBcImVCdXR0b25zUGFuZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5RdWVyeVNlbGVjdG9yKCcjYXBwbHlCdXR0b24nKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEJhc2VGaWx0ZXIucHJvdG90eXBlLCBcImVBcHBseUJ1dHRvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlF1ZXJ5U2VsZWN0b3IoJyNjbGVhckJ1dHRvbicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgQmFzZUZpbHRlci5wcm90b3R5cGUsIFwiZUNsZWFyQnV0dG9uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIEJhc2VGaWx0ZXIucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgQmFzZUZpbHRlci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEJhc2VGaWx0ZXI7XG59KGNvbXBvbmVudF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5CYXNlRmlsdGVyID0gQmFzZUZpbHRlcjtcbi8qKlxuICogRXZlcnkgZmlsdGVyIHdpdGggYSBkcm9wZG93biB3aGVyZSB0aGUgdXNlciBjYW4gc3BlY2lmeSBhIGNvbXBhcmluZyB0eXBlIGFnYWluc3QgdGhlIGZpbHRlciB2YWx1ZXNcbiAqL1xudmFyIENvbXBhcmFibGVCYXNlRmlsdGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcGFyYWJsZUJhc2VGaWx0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tcGFyYWJsZUJhc2VGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29tcGFyYWJsZUJhc2VGaWx0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZVR5cGVTZWxlY3RvciwgXCJjaGFuZ2VcIiwgdGhpcy5vbkZpbHRlclR5cGVDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgQ29tcGFyYWJsZUJhc2VGaWx0ZXIucHJvdG90eXBlLmN1c3RvbUluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRGaWx0ZXIgPSB0aGlzLmdldERlZmF1bHRUeXBlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBhcmFibGVCYXNlRmlsdGVyLnByb3RvdHlwZS5nZW5lcmF0ZUZpbHRlckhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRlZmF1bHRGaWx0ZXJUeXBlcyA9IHRoaXMuZ2V0QXBwbGljYWJsZUZpbHRlclR5cGVzKCk7XG4gICAgICAgIHZhciByZXN0cmljdGVkRmlsdGVyVHlwZXMgPSB0aGlzLmZpbHRlclBhcmFtcy5maWx0ZXJPcHRpb25zO1xuICAgICAgICB2YXIgYWN0dWFsRmlsdGVyVHlwZXMgPSByZXN0cmljdGVkRmlsdGVyVHlwZXMgPyByZXN0cmljdGVkRmlsdGVyVHlwZXMgOiBkZWZhdWx0RmlsdGVyVHlwZXM7XG4gICAgICAgIHZhciBvcHRpb25zSHRtbCA9IGFjdHVhbEZpbHRlclR5cGVzLm1hcChmdW5jdGlvbiAoZmlsdGVyVHlwZSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZUZpbHRlck5hbWUgPSBfdGhpcy50cmFuc2xhdGUoZmlsdGVyVHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gXCI8b3B0aW9uIHZhbHVlPVxcXCJcIiArIGZpbHRlclR5cGUgKyBcIlxcXCI+XCIgKyBsb2NhbGVGaWx0ZXJOYW1lICsgXCI8L29wdGlvbj5cIjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZWFkT25seSA9IG9wdGlvbnNIdG1sLmxlbmd0aCA9PSAxID8gJ2Rpc2FibGVkJyA6ICcnO1xuICAgICAgICByZXR1cm4gb3B0aW9uc0h0bWwubGVuZ3RoIDw9IDAgP1xuICAgICAgICAgICAgJycgOlxuICAgICAgICAgICAgXCI8ZGl2PlxcbiAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVxcXCJhZy1maWx0ZXItc2VsZWN0XFxcIiBpZD1cXFwiZmlsdGVyVHlwZVxcXCIgXCIgKyByZWFkT25seSArIFwiPlxcbiAgICAgICAgICAgICAgICAgICAgXCIgKyBvcHRpb25zSHRtbC5qb2luKCcnKSArIFwiXFxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgIDwvZGl2PlwiO1xuICAgIH07XG4gICAgQ29tcGFyYWJsZUJhc2VGaWx0ZXIucHJvdG90eXBlLmluaXRpYWxpc2VGaWx0ZXJCb2R5VWkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsdGVyVHlwZSh0aGlzLmZpbHRlcik7XG4gICAgfTtcbiAgICBDb21wYXJhYmxlQmFzZUZpbHRlci5wcm90b3R5cGUub25GaWx0ZXJUeXBlQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSB0aGlzLmVUeXBlU2VsZWN0b3IudmFsdWU7XG4gICAgICAgIHRoaXMucmVmcmVzaEZpbHRlckJvZHlVaSgpO1xuICAgICAgICB0aGlzLm9uRmlsdGVyQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgQ29tcGFyYWJsZUJhc2VGaWx0ZXIucHJvdG90eXBlLmlzRmlsdGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmF3RmlsdGVyVmFsdWVzID0gdGhpcy5maWx0ZXJWYWx1ZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyID09PSBCYXNlRmlsdGVyLklOX1JBTkdFKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyVmFsdWVBcnJheSA9IHJhd0ZpbHRlclZhbHVlcztcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJWYWx1ZUFycmF5WzBdICE9IG51bGwgJiYgZmlsdGVyVmFsdWVBcnJheVsxXSAhPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJhd0ZpbHRlclZhbHVlcyAhPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21wYXJhYmxlQmFzZUZpbHRlci5wcm90b3R5cGUuc2V0RmlsdGVyVHlwZSA9IGZ1bmN0aW9uIChmaWx0ZXJUeXBlKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyVHlwZTtcbiAgICAgICAgdGhpcy5lVHlwZVNlbGVjdG9yLnZhbHVlID0gZmlsdGVyVHlwZTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlF1ZXJ5U2VsZWN0b3IoJyNmaWx0ZXJUeXBlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MU2VsZWN0RWxlbWVudClcbiAgICBdLCBDb21wYXJhYmxlQmFzZUZpbHRlci5wcm90b3R5cGUsIFwiZVR5cGVTZWxlY3RvclwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDb21wYXJhYmxlQmFzZUZpbHRlcjtcbn0oQmFzZUZpbHRlcikpO1xuZXhwb3J0cy5Db21wYXJhYmxlQmFzZUZpbHRlciA9IENvbXBhcmFibGVCYXNlRmlsdGVyO1xuLyoqXG4gKiBDb21wYXJhYmxlIGZpbHRlciB3aXRoIHNjYWxhciB1bmRlcmx5aW5nIHZhbHVlcyAoaWUgbnVtYmVycyBhbmQgZGF0ZXMuIFN0cmluZ3MgYXJlIG5vdCBzY2FsYXIgc28gaGF2ZSB0byBleHRlbmRcbiAqIENvbXBhcmFibGVCYXNlRmlsdGVyKVxuICovXG52YXIgU2NhbGFyQmFzZUZpbHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYWxhckJhc2VGaWx0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2NhbGFyQmFzZUZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTY2FsYXJCYXNlRmlsdGVyLnByb3RvdHlwZS5udWxsQ29tcGFyYXRvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsdGVyVmFsdWUsIGdyaWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGdyaWRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bGxWYWx1ZSA9IF90aGlzLnRyYW5zbGF0ZU51bGwodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmZpbHRlciA9PT0gQmFzZUZpbHRlci5FUVVBTFMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsdGVyID09PSBCYXNlRmlsdGVyLkdSRUFURVJfVEhBTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsdGVyID09PSBCYXNlRmlsdGVyLkdSRUFURVJfVEhBTl9PUl9FUVVBTCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsdGVyID09PSBCYXNlRmlsdGVyLkxFU1NfVEhBTl9PUl9FUVVBTCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsdGVyID09PSBCYXNlRmlsdGVyLkxFU1NfVEhBTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsdGVyID09PSBCYXNlRmlsdGVyLk5PVF9FUVVBTCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFjdHVhbENvbXBhcmF0b3IgPSBfdGhpcy5jb21wYXJhdG9yKCk7XG4gICAgICAgICAgICByZXR1cm4gYWN0dWFsQ29tcGFyYXRvcihmaWx0ZXJWYWx1ZSwgZ3JpZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNjYWxhckJhc2VGaWx0ZXIucHJvdG90eXBlLmdldERlZmF1bHRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQmFzZUZpbHRlci5FUVVBTFM7XG4gICAgfTtcbiAgICBTY2FsYXJCYXNlRmlsdGVyLnByb3RvdHlwZS50cmFuc2xhdGVOdWxsID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHJlZHVjZWRUeXBlID0gdHlwZS5pbmRleE9mKCdncmVhdGVyJykgPiAtMSA/ICdncmVhdGVyVGhhbicgOlxuICAgICAgICAgICAgdHlwZS5pbmRleE9mKCdsZXNzVGhhbicpID4gLTEgPyAnbGVzc1RoYW4nIDpcbiAgICAgICAgICAgICAgICAnZXF1YWxzJztcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyUGFyYW1zLm51bGxDb21wYXJhdG9yICYmIHRoaXMuZmlsdGVyUGFyYW1zLm51bGxDb21wYXJhdG9yW3JlZHVjZWRUeXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyUGFyYW1zLm51bGxDb21wYXJhdG9yW3JlZHVjZWRUeXBlXTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHJldHVybiBTY2FsYXJCYXNlRmlsdGVyLkRFRkFVTFRfTlVMTF9DT01QQVJBVE9SW3JlZHVjZWRUeXBlXTtcbiAgICB9O1xuICAgIFNjYWxhckJhc2VGaWx0ZXIucHJvdG90eXBlLmRvZXNGaWx0ZXJQYXNzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmZpbHRlclBhcmFtcy52YWx1ZUdldHRlcihwYXJhbXMubm9kZSk7XG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5udWxsQ29tcGFyYXRvcih0aGlzLmZpbHRlcik7XG4gICAgICAgIHZhciByYXdGaWx0ZXJWYWx1ZXMgPSB0aGlzLmZpbHRlclZhbHVlcygpO1xuICAgICAgICB2YXIgZnJvbSA9IEFycmF5LmlzQXJyYXkocmF3RmlsdGVyVmFsdWVzKSA/IHJhd0ZpbHRlclZhbHVlc1swXSA6IHJhd0ZpbHRlclZhbHVlcztcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgY29tcGFyZVJlc3VsdCA9IGNvbXBhcmF0b3IoZnJvbSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXIgPT09IEJhc2VGaWx0ZXIuRVFVQUxTKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVJlc3VsdCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWx0ZXIgPT09IEJhc2VGaWx0ZXIuR1JFQVRFUl9USEFOKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVJlc3VsdCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyID09PSBCYXNlRmlsdGVyLkdSRUFURVJfVEhBTl9PUl9FUVVBTCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVSZXN1bHQgPj0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWx0ZXIgPT09IEJhc2VGaWx0ZXIuTEVTU19USEFOX09SX0VRVUFMKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVJlc3VsdCA8PSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbHRlciA9PT0gQmFzZUZpbHRlci5MRVNTX1RIQU4pIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlUmVzdWx0IDwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWx0ZXIgPT09IEJhc2VGaWx0ZXIuTk9UX0VRVUFMKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVJlc3VsdCAhPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vRnJvbSBub3cgb24gdGhlIHR5cGUgaXMgYSByYW5nZSBhbmQgcmF3RmlsdGVyVmFsdWVzIG11c3QgYmUgYW4gYXJyYXkhXG4gICAgICAgIHZhciBjb21wYXJlVG9SZXN1bHQgPSBjb21wYXJhdG9yKHJhd0ZpbHRlclZhbHVlc1sxXSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXIgPT09IEJhc2VGaWx0ZXIuSU5fUkFOR0UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWx0ZXJQYXJhbXMuaW5SYW5nZUluY2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlUmVzdWx0ID4gMCAmJiBjb21wYXJlVG9SZXN1bHQgPCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVSZXN1bHQgPj0gMCAmJiBjb21wYXJlVG9SZXN1bHQgPD0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdHlwZSBvZiBkYXRlIGZpbHRlciE6ICcgKyB0aGlzLmZpbHRlcik7XG4gICAgfTtcbiAgICBTY2FsYXJCYXNlRmlsdGVyLkRFRkFVTFRfTlVMTF9DT01QQVJBVE9SID0ge1xuICAgICAgICBlcXVhbHM6IGZhbHNlLFxuICAgICAgICBsZXNzVGhhbjogZmFsc2UsXG4gICAgICAgIGdyZWF0ZXJUaGFuOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIFNjYWxhckJhc2VGaWx0ZXI7XG59KENvbXBhcmFibGVCYXNlRmlsdGVyKSk7XG5leHBvcnRzLlNjYWxhckJhc2VGaWx0ZXIgPSBTY2FsYXJCYXNlRmlsdGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZmlsdGVyL2Jhc2VGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIENzc0NsYXNzQXBwbGllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3NzQ2xhc3NBcHBsaWVyKCkge1xuICAgIH1cbiAgICBDc3NDbGFzc0FwcGxpZXIuYWRkSGVhZGVyQ2xhc3Nlc0Zyb21Db2xEZWYgPSBmdW5jdGlvbiAoYWJzdHJhY3RDb2xEZWYsIGVIZWFkZXJDZWxsLCBncmlkT3B0aW9uc1dyYXBwZXIsIGNvbHVtbiwgY29sdW1uR3JvdXApIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyhhYnN0cmFjdENvbERlZikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZENvbHVtbkNsYXNzZXNGcm9tQ29sbERlZihhYnN0cmFjdENvbERlZi5oZWFkZXJDbGFzcywgYWJzdHJhY3RDb2xEZWYsIGVIZWFkZXJDZWxsLCBncmlkT3B0aW9uc1dyYXBwZXIsIGNvbHVtbiwgY29sdW1uR3JvdXApO1xuICAgIH07XG4gICAgQ3NzQ2xhc3NBcHBsaWVyLmFkZFRvb2xQYW5lbENsYXNzZXNGcm9tQ29sRGVmID0gZnVuY3Rpb24gKGFic3RyYWN0Q29sRGVmLCBlSGVhZGVyQ2VsbCwgZ3JpZE9wdGlvbnNXcmFwcGVyLCBjb2x1bW4sIGNvbHVtbkdyb3VwKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcoYWJzdHJhY3RDb2xEZWYpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRDb2x1bW5DbGFzc2VzRnJvbUNvbGxEZWYoYWJzdHJhY3RDb2xEZWYudG9vbFBhbmVsQ2xhc3MsIGFic3RyYWN0Q29sRGVmLCBlSGVhZGVyQ2VsbCwgZ3JpZE9wdGlvbnNXcmFwcGVyLCBjb2x1bW4sIGNvbHVtbkdyb3VwKTtcbiAgICB9O1xuICAgIENzc0NsYXNzQXBwbGllci5hZGRDb2x1bW5DbGFzc2VzRnJvbUNvbGxEZWYgPSBmdW5jdGlvbiAoY2xhc3Nlc09yRnVuYywgYWJzdHJhY3RDb2xEZWYsIGVIZWFkZXJDZWxsLCBncmlkT3B0aW9uc1dyYXBwZXIsIGNvbHVtbiwgY29sdW1uR3JvdXApIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyhjbGFzc2VzT3JGdW5jKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGFzc1RvVXNlO1xuICAgICAgICBpZiAodHlwZW9mIGNsYXNzZXNPckZ1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgLy8gYmFkIG5hbWluZywgYXMgY29sRGVmIGhlcmUgY2FuIGJlIGEgZ3JvdXAgb3IgYSBjb2x1bW4sXG4gICAgICAgICAgICAgICAgLy8gaG93ZXZlciBtb3N0IHBlb3BsZSB3b24ndCBhcHByZWNpYXRlIHRoZSBkaWZmZXJlbmNlLFxuICAgICAgICAgICAgICAgIC8vIHNvIGtlZXBpbmcgaXQgYXMgY29sRGVmIHRvIGF2b2lkIGNvbmZ1c2lvbi5cbiAgICAgICAgICAgICAgICBjb2xEZWY6IGFic3RyYWN0Q29sRGVmLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIGNvbHVtbkdyb3VwOiBjb2x1bW5Hcm91cCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGFwaTogZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGhlYWRlckNsYXNzRnVuYyA9IGNsYXNzZXNPckZ1bmM7XG4gICAgICAgICAgICBjbGFzc1RvVXNlID0gaGVhZGVyQ2xhc3NGdW5jKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGFzc1RvVXNlID0gY2xhc3Nlc09yRnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNsYXNzVG9Vc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZENzc0NsYXNzKGVIZWFkZXJDZWxsLCBjbGFzc1RvVXNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNsYXNzVG9Vc2UpKSB7XG4gICAgICAgICAgICBjbGFzc1RvVXNlLmZvckVhY2goZnVuY3Rpb24gKGNzc0NsYXNzSXRlbSkge1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkQ3NzQ2xhc3MoZUhlYWRlckNlbGwsIGNzc0NsYXNzSXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENzc0NsYXNzQXBwbGllcjtcbn0oKSk7XG5leHBvcnRzLkNzc0NsYXNzQXBwbGllciA9IENzc0NsYXNzQXBwbGllcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9jc3NDbGFzc0FwcGxpZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgZ3JpZFBhbmVsXzEgPSByZXF1aXJlKFwiLi4vZ3JpZFBhbmVsL2dyaWRQYW5lbFwiKTtcbnZhciBjb2x1bW5fMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9jb2x1bW5cIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBoZWFkZXJDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL2hlYWRlckNvbnRhaW5lclwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xudmFyIHNjcm9sbFZpc2libGVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZ3JpZFBhbmVsL3Njcm9sbFZpc2libGVTZXJ2aWNlXCIpO1xudmFyIEhlYWRlclJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWFkZXJSZW5kZXJlcigpIHtcbiAgICB9XG4gICAgSGVhZGVyUmVuZGVyZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZUhlYWRlclZpZXdwb3J0ID0gdGhpcy5ncmlkUGFuZWwuZ2V0SGVhZGVyVmlld3BvcnQoKTtcbiAgICAgICAgdGhpcy5lUm9vdCA9IHRoaXMuZ3JpZFBhbmVsLmdldFJvb3QoKTtcbiAgICAgICAgdGhpcy5lSGVhZGVyT3ZlcmxheSA9IHRoaXMuZ3JpZFBhbmVsLmdldEhlYWRlck92ZXJsYXkoKTtcbiAgICAgICAgdGhpcy5jZW50ZXJDb250YWluZXIgPSBuZXcgaGVhZGVyQ29udGFpbmVyXzEuSGVhZGVyQ29udGFpbmVyKHRoaXMuZ3JpZFBhbmVsLmdldEhlYWRlckNvbnRhaW5lcigpLCB0aGlzLmdyaWRQYW5lbC5nZXRIZWFkZXJWaWV3cG9ydCgpLCB0aGlzLmVSb290LCBudWxsKTtcbiAgICAgICAgdGhpcy5jaGlsZENvbnRhaW5lcnMgPSBbdGhpcy5jZW50ZXJDb250YWluZXJdO1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKSkge1xuICAgICAgICAgICAgdGhpcy5waW5uZWRMZWZ0Q29udGFpbmVyID0gbmV3IGhlYWRlckNvbnRhaW5lcl8xLkhlYWRlckNvbnRhaW5lcih0aGlzLmdyaWRQYW5lbC5nZXRQaW5uZWRMZWZ0SGVhZGVyKCksIG51bGwsIHRoaXMuZVJvb3QsIGNvbHVtbl8xLkNvbHVtbi5QSU5ORURfTEVGVCk7XG4gICAgICAgICAgICB0aGlzLnBpbm5lZFJpZ2h0Q29udGFpbmVyID0gbmV3IGhlYWRlckNvbnRhaW5lcl8xLkhlYWRlckNvbnRhaW5lcih0aGlzLmdyaWRQYW5lbC5nZXRQaW5uZWRSaWdodEhlYWRlcigpLCBudWxsLCB0aGlzLmVSb290LCBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX1JJR0hUKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRDb250YWluZXJzLnB1c2godGhpcy5waW5uZWRMZWZ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRDb250YWluZXJzLnB1c2godGhpcy5waW5uZWRSaWdodENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZENvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKSB7IHJldHVybiBfdGhpcy5jb250ZXh0LndpcmVCZWFuKGNvbnRhaW5lcik7IH0pO1xuICAgICAgICAvLyB3aGVuIGdyaWQgY29sdW1ucyBjaGFuZ2UsIGl0IG1lYW5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgaGVhZGVyIGhhcyBjaGFuZ2VkIGFuZCBpdCdzIGFsbCBuZXcgY29sdW1uc1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9HUklEX0NPTFVNTlNfQ0hBTkdFRCwgdGhpcy5vbkdyaWRDb2x1bW5zQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gc2hvdGd1biB3YXkgdG8gZ2V0IGxhYmVscyB0byBjaGFuZ2UsIGVnIGZyb20gc3VtKGFtb3VudCkgdG8gYXZnKGFtb3VudClcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1ZBTFVFX0NIQU5HRUQsIHRoaXMucmVmcmVzaEhlYWRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gZm9yIHJlc2l6ZWQsIHRoZSBpbmRpdmlkdWFsIGNlbGxzIHRha2UgY2FyZSBvZiB0aGlzLCBzbyBkb24ndCBuZWVkIHRvIHJlZnJlc2ggZXZlcnl0aGluZ1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUkVTSVpFRCwgdGhpcy5zZXRQaW5uZWRDb2xDb250YWluZXJXaWR0aC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfRElTUExBWUVEX0NPTFVNTlNfQ0hBTkdFRCwgdGhpcy5zZXRQaW5uZWRDb2xDb250YWluZXJXaWR0aC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfU0NST0xMX1ZJU0lCSUxJVFlfQ0hBTkdFRCwgdGhpcy5vblNjcm9sbFZpc2liaWxpdHlDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoSGVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhlYWRlclJlbmRlcmVyLnByb3RvdHlwZS5vblNjcm9sbFZpc2liaWxpdHlDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFBpbm5lZENvbENvbnRhaW5lcldpZHRoKCk7XG4gICAgfTtcbiAgICBIZWFkZXJSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaEhlYWRlckVsZW1lbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jaGlsZENvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRDb250YWluZXIpIHsgcmV0dXJuIGNoaWxkQ29udGFpbmVyLmZvckVhY2hIZWFkZXJFbGVtZW50KGNhbGxiYWNrKTsgfSk7XG4gICAgfTtcbiAgICBIZWFkZXJSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGlsZENvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKSB7IHJldHVybiBjb250YWluZXIuZGVzdHJveSgpOyB9KTtcbiAgICB9O1xuICAgIEhlYWRlclJlbmRlcmVyLnByb3RvdHlwZS5vbkdyaWRDb2x1bW5zQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoKTtcbiAgICB9O1xuICAgIEhlYWRlclJlbmRlcmVyLnByb3RvdHlwZS5yZWZyZXNoSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldEhlaWdodCgpO1xuICAgICAgICB0aGlzLmNoaWxkQ29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpIHsgcmV0dXJuIGNvbnRhaW5lci5yZWZyZXNoKCk7IH0pO1xuICAgICAgICB0aGlzLnNldFBpbm5lZENvbENvbnRhaW5lcldpZHRoKCk7XG4gICAgfTtcbiAgICBIZWFkZXJSZW5kZXJlci5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpZiBmb3JQcmludCwgb3ZlcmxheSBpcyBtaXNzaW5nXG4gICAgICAgIGlmICh0aGlzLmVIZWFkZXJPdmVybGF5KSB7XG4gICAgICAgICAgICB2YXIgcm93SGVpZ2h0ID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0SGVhZGVySGVpZ2h0KCk7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcHJvYmFibHkgZ2V0IHJpZCBvZiB0aGlzIHdoZW4gd2Ugbm8gbG9uZ2VyIG5lZWQgdGhlIG92ZXJsYXlcbiAgICAgICAgICAgIHZhciBkZXB0ID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgICAgICB0aGlzLmVIZWFkZXJPdmVybGF5LnN0eWxlLmhlaWdodCA9IHJvd0hlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmVIZWFkZXJPdmVybGF5LnN0eWxlLnRvcCA9ICgoZGVwdCAtIDEpICogcm93SGVpZ2h0KSArICdweCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhlYWRlclJlbmRlcmVyLnByb3RvdHlwZS5zZXRQaW5uZWRDb2xDb250YWluZXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcGlubmVkIGNvbCBkb2Vzbid0IGV4aXN0IHdoZW4gZG9pbmcgZm9yUHJpbnRcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwaW5uZWRMZWZ0V2lkdGhXaXRoU2Nyb2xsID0gdGhpcy5zY3JvbGxWaXNpYmxlU2VydmljZS5nZXRQaW5uZWRMZWZ0V2l0aFNjcm9sbFdpZHRoKCk7XG4gICAgICAgIHZhciBwaW5uZWRSaWdodFdpZHRoV2l0aFNjcm9sbCA9IHRoaXMuc2Nyb2xsVmlzaWJsZVNlcnZpY2UuZ2V0UGlubmVkUmlnaHRXaXRoU2Nyb2xsV2lkdGgoKTtcbiAgICAgICAgdGhpcy5lSGVhZGVyVmlld3BvcnQuc3R5bGUubWFyZ2luTGVmdCA9IHBpbm5lZExlZnRXaWR0aFdpdGhTY3JvbGwgKyAncHgnO1xuICAgICAgICB0aGlzLmVIZWFkZXJWaWV3cG9ydC5zdHlsZS5tYXJnaW5SaWdodCA9IHBpbm5lZFJpZ2h0V2lkdGhXaXRoU2Nyb2xsICsgJ3B4JztcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBIZWFkZXJSZW5kZXJlci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIEhlYWRlclJlbmRlcmVyLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRQYW5lbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZFBhbmVsXzEuR3JpZFBhbmVsKVxuICAgIF0sIEhlYWRlclJlbmRlcmVyLnByb3RvdHlwZSwgXCJncmlkUGFuZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29udGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29udGV4dF8xLkNvbnRleHQpXG4gICAgXSwgSGVhZGVyUmVuZGVyZXIucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgSGVhZGVyUmVuZGVyZXIucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdzY3JvbGxWaXNpYmxlU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgc2Nyb2xsVmlzaWJsZVNlcnZpY2VfMS5TY3JvbGxWaXNpYmxlU2VydmljZSlcbiAgICBdLCBIZWFkZXJSZW5kZXJlci5wcm90b3R5cGUsIFwic2Nyb2xsVmlzaWJsZVNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgSGVhZGVyUmVuZGVyZXIucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5QcmVEZXN0cm95LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEhlYWRlclJlbmRlcmVyLnByb3RvdHlwZSwgXCJkZXN0cm95XCIsIG51bGwpO1xuICAgIEhlYWRlclJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdoZWFkZXJSZW5kZXJlcicpXG4gICAgXSwgSGVhZGVyUmVuZGVyZXIpO1xuICAgIHJldHVybiBIZWFkZXJSZW5kZXJlcjtcbn0oKSk7XG5leHBvcnRzLkhlYWRlclJlbmRlcmVyID0gSGVhZGVyUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBwb3B1cEVkaXRvcldyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2NlbGxFZGl0b3JzL3BvcHVwRWRpdG9yV3JhcHBlclwiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgY29tcG9uZW50UmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2ZyYW1ld29yay9jb21wb25lbnRSZXNvbHZlclwiKTtcbnZhciBDZWxsRWRpdG9yRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VsbEVkaXRvckZhY3RvcnkoKSB7XG4gICAgfVxuICAgIENlbGxFZGl0b3JGYWN0b3J5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgQ2VsbEVkaXRvckZhY3RvcnkucHJvdG90eXBlLmFkZENlbGxFZGl0b3IgPSBmdW5jdGlvbiAoa2V5LCBjZWxsRWRpdG9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImFnLWdyaWQ6IHNpbmNlIHYxMy4zLjEgdGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBhbnltb3JlLiBJZiB5b3Ugd2FudCB0byByZWdpc3RlciB5b3VyIG93biBlZGl0b3IgY2hlY2sgdGhlIGRvY3M6IGh0dHBzOi8vd3d3LmFnLWdyaWQuY29tL2phdmFzY3JpcHQtZ3JpZC1jZWxsLWVkaXRvci9cIik7XG4gICAgfTtcbiAgICAvLyBwcml2YXRlIHJlZ2lzdGVyRWRpdG9yc0Zyb21HcmlkT3B0aW9ucygpOiB2b2lkIHtcbiAgICAvLyAgICAgbGV0IHVzZXJQcm92aWRlZENlbGxFZGl0b3JzID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q2VsbEVkaXRvcnMoKTtcbiAgICAvLyAgICAgXy5pdGVyYXRlT2JqZWN0KHVzZXJQcm92aWRlZENlbGxFZGl0b3JzLCAoa2V5OiBzdHJpbmcsIGNlbGxFZGl0b3I6IHtuZXcoKTogSUNlbGxFZGl0b3J9KT0+IHtcbiAgICAvLyAgICAgICAgIHRoaXMuYWRkQ2VsbEVkaXRvcihrZXksIGNlbGxFZGl0b3IpO1xuICAgIC8vICAgICB9KTtcbiAgICAvLyB9XG4gICAgQ2VsbEVkaXRvckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUNlbGxFZGl0b3IgPSBmdW5jdGlvbiAoY29sdW1uLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNlbGxFZGl0b3JQcm9taXNlID0gdGhpcy5jb21wb25lbnRSZXNvbHZlci5jcmVhdGVBZ0dyaWRDb21wb25lbnQoY29sdW1uLCBwYXJhbXMsICdjZWxsRWRpdG9yJyk7XG4gICAgICAgIHJldHVybiBjZWxsRWRpdG9yUHJvbWlzZS5tYXAoZnVuY3Rpb24gKGNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBpc1BvcHVwID0gY2VsbEVkaXRvci5pc1BvcHVwICYmIGNlbGxFZGl0b3IuaXNQb3B1cCgpO1xuICAgICAgICAgICAgaWYgKCFpc1BvcHVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxFZGl0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRnVsbFJvd0VkaXQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogcG9wdXAgY2VsbEVkaXRvciBkb2VzIG5vdCB3b3JrIHdpdGggZnVsbFJvd0VkaXQgLSB5b3UgY2Fubm90IHVzZSB0aGVtIGJvdGggJyArXG4gICAgICAgICAgICAgICAgICAgICctIGVpdGhlciB0dXJuIG9mZiBmdWxsUm93RWRpdCwgb3Igc3RvcCB1c2luZyBwb3B1cCBlZGl0b3JzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgYSBwb3B1cCwgdGhlbiB3ZSB3cmFwIGluIGEgcG9wdXAgZWRpdG9yIGFuZCByZXR1cm4gdGhlIHBvcHVwXG4gICAgICAgICAgICB2YXIgcG9wdXBFZGl0b3JXcmFwcGVyID0gbmV3IHBvcHVwRWRpdG9yV3JhcHBlcl8xLlBvcHVwRWRpdG9yV3JhcHBlcihjZWxsRWRpdG9yKTtcbiAgICAgICAgICAgIF90aGlzLmNvbnRleHQud2lyZUJlYW4ocG9wdXBFZGl0b3JXcmFwcGVyKTtcbiAgICAgICAgICAgIHBvcHVwRWRpdG9yV3JhcHBlci5pbml0KHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gcG9wdXBFZGl0b3JXcmFwcGVyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBDZWxsRWRpdG9yRmFjdG9yeS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb21wb25lbnRSZXNvbHZlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29tcG9uZW50UmVzb2x2ZXJfMS5Db21wb25lbnRSZXNvbHZlcilcbiAgICBdLCBDZWxsRWRpdG9yRmFjdG9yeS5wcm90b3R5cGUsIFwiY29tcG9uZW50UmVzb2x2ZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgQ2VsbEVkaXRvckZhY3RvcnkucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBDZWxsRWRpdG9yRmFjdG9yeS5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICBDZWxsRWRpdG9yRmFjdG9yeSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignY2VsbEVkaXRvckZhY3RvcnknKVxuICAgIF0sIENlbGxFZGl0b3JGYWN0b3J5KTtcbiAgICByZXR1cm4gQ2VsbEVkaXRvckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5DZWxsRWRpdG9yRmFjdG9yeSA9IENlbGxFZGl0b3JGYWN0b3J5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxFZGl0b3JGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGV4cHJlc3Npb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVTZXJ2aWNlL2V4cHJlc3Npb25TZXJ2aWNlXCIpO1xudmFyIGFuaW1hdGVTbGlkZUNlbGxSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vY2VsbFJlbmRlcmVycy9hbmltYXRlU2xpZGVDZWxsUmVuZGVyZXJcIik7XG52YXIgYW5pbWF0ZVNob3dDaGFuZ2VDZWxsUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL2NlbGxSZW5kZXJlcnMvYW5pbWF0ZVNob3dDaGFuZ2VDZWxsUmVuZGVyZXJcIik7XG52YXIgZ3JvdXBDZWxsUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL2NlbGxSZW5kZXJlcnMvZ3JvdXBDZWxsUmVuZGVyZXJcIik7XG52YXIgQ2VsbFJlbmRlcmVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VsbFJlbmRlcmVyRmFjdG9yeSgpIHtcbiAgICAgICAgdGhpcy5jZWxsUmVuZGVyZXJNYXAgPSB7fTtcbiAgICB9XG4gICAgQ2VsbFJlbmRlcmVyRmFjdG9yeV8xID0gQ2VsbFJlbmRlcmVyRmFjdG9yeTtcbiAgICBDZWxsUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNlbGxSZW5kZXJlck1hcFtDZWxsUmVuZGVyZXJGYWN0b3J5XzEuQU5JTUFURV9TTElERV0gPSBhbmltYXRlU2xpZGVDZWxsUmVuZGVyZXJfMS5BbmltYXRlU2xpZGVDZWxsUmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyTWFwW0NlbGxSZW5kZXJlckZhY3RvcnlfMS5BTklNQVRFX1NIT1dfQ0hBTkdFXSA9IGFuaW1hdGVTaG93Q2hhbmdlQ2VsbFJlbmRlcmVyXzEuQW5pbWF0ZVNob3dDaGFuZ2VDZWxsUmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyTWFwW0NlbGxSZW5kZXJlckZhY3RvcnlfMS5HUk9VUF0gPSBncm91cENlbGxSZW5kZXJlcl8xLkdyb3VwQ2VsbFJlbmRlcmVyO1xuICAgICAgICAvLyB0aGlzLnJlZ2lzdGVyUmVuZGVyZXJzRnJvbUdyaWRPcHRpb25zKCk7XG4gICAgfTtcbiAgICAvLyBwcml2YXRlIHJlZ2lzdGVyUmVuZGVyZXJzRnJvbUdyaWRPcHRpb25zKCk6IHZvaWQge1xuICAgIC8vICAgICBsZXQgdXNlclByb3ZpZGVkQ2VsbFJlbmRlcmVycyA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENlbGxSZW5kZXJlcnMoKTtcbiAgICAvLyAgICAgXy5pdGVyYXRlT2JqZWN0KHVzZXJQcm92aWRlZENlbGxSZW5kZXJlcnMsIChrZXk6IHN0cmluZywgY2VsbFJlbmRlcmVyOiB7bmV3KCk6IElDZWxsUmVuZGVyZXJ9IHwgSUNlbGxSZW5kZXJlckZ1bmMpPT4ge1xuICAgIC8vICAgICAgICAgdGhpcy5hZGRDZWxsUmVuZGVyZXIoa2V5LCBjZWxsUmVuZGVyZXIpO1xuICAgIC8vICAgICB9KTtcbiAgICAvLyB9XG4gICAgQ2VsbFJlbmRlcmVyRmFjdG9yeS5wcm90b3R5cGUuYWRkQ2VsbFJlbmRlcmVyID0gZnVuY3Rpb24gKGtleSwgY2VsbFJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyTWFwW2tleV0gPSBjZWxsUmVuZGVyZXI7XG4gICAgfTtcbiAgICBDZWxsUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5nZXRDZWxsUmVuZGVyZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNlbGxSZW5kZXJlck1hcFtrZXldO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogdW5hYmxlIHRvIGZpbmQgY2VsbFJlbmRlcmVyIGZvciBrZXkgJyArIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ2VsbFJlbmRlcmVyRmFjdG9yeS5BTklNQVRFX1NMSURFID0gJ2FuaW1hdGVTbGlkZSc7XG4gICAgQ2VsbFJlbmRlcmVyRmFjdG9yeS5BTklNQVRFX1NIT1dfQ0hBTkdFID0gJ2FuaW1hdGVTaG93Q2hhbmdlJztcbiAgICBDZWxsUmVuZGVyZXJGYWN0b3J5LkdST1VQID0gJ2dyb3VwJztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgQ2VsbFJlbmRlcmVyRmFjdG9yeS5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V4cHJlc3Npb25TZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBleHByZXNzaW9uU2VydmljZV8xLkV4cHJlc3Npb25TZXJ2aWNlKVxuICAgIF0sIENlbGxSZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLCBcImV4cHJlc3Npb25TZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIENlbGxSZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBDZWxsUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIENlbGxSZW5kZXJlckZhY3RvcnkgPSBDZWxsUmVuZGVyZXJGYWN0b3J5XzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2NlbGxSZW5kZXJlckZhY3RvcnknKVxuICAgIF0sIENlbGxSZW5kZXJlckZhY3RvcnkpO1xuICAgIHJldHVybiBDZWxsUmVuZGVyZXJGYWN0b3J5O1xuICAgIHZhciBDZWxsUmVuZGVyZXJGYWN0b3J5XzE7XG59KCkpO1xuZXhwb3J0cy5DZWxsUmVuZGVyZXJGYWN0b3J5ID0gQ2VsbFJlbmRlcmVyRmFjdG9yeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsUmVuZGVyZXJGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29tcG9uZW50UmVjaXBlc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvZnJhbWV3b3JrL2NvbXBvbmVudFJlY2lwZXNcIik7XG52YXIgY29tcG9uZW50UmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2ZyYW1ld29yay9jb21wb25lbnRSZXNvbHZlclwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbi8qKiBDbGFzcyB0byB1c2UgYSBjZWxsUmVuZGVyZXIuICovXG52YXIgQ2VsbFJlbmRlcmVyU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VsbFJlbmRlcmVyU2VydmljZSgpIHtcbiAgICB9XG4gICAgQ2VsbFJlbmRlcmVyU2VydmljZS5wcm90b3R5cGUudXNlQ2VsbFJlbmRlcmVyID0gZnVuY3Rpb24gKHRhcmdldCwgZVRhcmdldCwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjZWxsUmVuZGVyZXJQcm9taXNlID0gdGhpcy5jb21wb25lbnRSZWNpcGVzLm5ld0NlbGxSZW5kZXJlcih0YXJnZXQsIHBhcmFtcyk7XG4gICAgICAgIGlmIChjZWxsUmVuZGVyZXJQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNlbGxSZW5kZXJlclByb21pc2UudGhlbihmdW5jdGlvbiAoY2VsbFJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxSZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVUYXJnZXQuaW5uZXJUZXh0ID0gcGFyYW1zLnZhbHVlRm9ybWF0dGVkICE9IG51bGwgPyBwYXJhbXMudmFsdWVGb3JtYXR0ZWQgOiBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5iaW5kVG9IdG1sKGNlbGxSZW5kZXJlclByb21pc2UsIGVUYXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZVRhcmdldC5pbm5lclRleHQgPSBwYXJhbXMudmFsdWVGb3JtYXR0ZWQgIT0gbnVsbCA/IHBhcmFtcy52YWx1ZUZvcm1hdHRlZCA6IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2VsbFJlbmRlcmVyUHJvbWlzZTtcbiAgICB9O1xuICAgIENlbGxSZW5kZXJlclNlcnZpY2UucHJvdG90eXBlLnVzZUZpbHRlckNlbGxSZW5kZXJlciA9IGZ1bmN0aW9uICh0YXJnZXQsIGVUYXJnZXQsIHBhcmFtcykge1xuICAgICAgICB2YXIgY2VsbFJlbmRlcmVyUHJvbWlzZSA9IHRoaXMuY29tcG9uZW50UmVjaXBlcy5uZXdDZWxsUmVuZGVyZXIodGFyZ2V0LmZpbHRlclBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgaWYgKGNlbGxSZW5kZXJlclByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iaW5kVG9IdG1sKGNlbGxSZW5kZXJlclByb21pc2UsIGVUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy52YWx1ZUZvcm1hdHRlZCA9PSBudWxsICYmIHBhcmFtcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsZVRleHRGdW5jID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TG9jYWxlVGV4dEZ1bmMoKTtcbiAgICAgICAgICAgICAgICBlVGFyZ2V0LmlubmVyVGV4dCA9ICcoJyArIGxvY2FsZVRleHRGdW5jKCdibGFua3MnLCAnQmxhbmtzJykgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlVGFyZ2V0LmlubmVyVGV4dCA9IHBhcmFtcy52YWx1ZUZvcm1hdHRlZCAhPSBudWxsID8gcGFyYW1zLnZhbHVlRm9ybWF0dGVkIDogcGFyYW1zLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZWxsUmVuZGVyZXJQcm9taXNlO1xuICAgIH07XG4gICAgQ2VsbFJlbmRlcmVyU2VydmljZS5wcm90b3R5cGUudXNlUmljaFNlbGVjdENlbGxSZW5kZXJlciA9IGZ1bmN0aW9uICh0YXJnZXQsIGVUYXJnZXQsIHBhcmFtcykge1xuICAgICAgICB2YXIgY2VsbFJlbmRlcmVyUHJvbWlzZSA9IHRoaXMuY29tcG9uZW50UmVjaXBlcy5uZXdDZWxsUmVuZGVyZXIodGFyZ2V0LmNlbGxFZGl0b3JQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGlmIChjZWxsUmVuZGVyZXJQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFRvSHRtbChjZWxsUmVuZGVyZXJQcm9taXNlLCBlVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVUYXJnZXQuaW5uZXJUZXh0ID0gcGFyYW1zLnZhbHVlRm9ybWF0dGVkICE9IG51bGwgPyBwYXJhbXMudmFsdWVGb3JtYXR0ZWQgOiBwYXJhbXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxSZW5kZXJlclByb21pc2U7XG4gICAgfTtcbiAgICBDZWxsUmVuZGVyZXJTZXJ2aWNlLnByb3RvdHlwZS51c2VJbm5lckNlbGxSZW5kZXJlciA9IGZ1bmN0aW9uICh0YXJnZXQsIG9yaWdpbmFsQ29sdW1uLCBlVGFyZ2V0LCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlbmRlcmVyVG9Vc2VQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdmFyIGNvbXBvbmVudFRvVXNlID0gdGhpcy5jb21wb25lbnRSZXNvbHZlci5nZXRDb21wb25lbnRUb1VzZSh0YXJnZXQsIFwiaW5uZXJSZW5kZXJlclwiKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFRvVXNlICYmIGNvbXBvbmVudFRvVXNlLmNvbXBvbmVudCAhPSBudWxsICYmIGNvbXBvbmVudFRvVXNlLnNvdXJjZSAhPSBjb21wb25lbnRSZXNvbHZlcl8xLkNvbXBvbmVudFNvdXJjZS5ERUZBVUxUKSB7XG4gICAgICAgICAgICAvL1RIRVJFIElTIE9ORSBJTk5FUiBDRUxMIFJFTkRFUkVSIEhBUkRDT0RFRCBJTiBUSEUgQ09MREVGIEZPUiBUSElTIEdST1VQIENPTFVNTlxuICAgICAgICAgICAgcmVuZGVyZXJUb1VzZVByb21pc2UgPSB0aGlzLmNvbXBvbmVudFJlY2lwZXMubmV3SW5uZXJDZWxsUmVuZGVyZXIodGFyZ2V0LCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG90aGVyUmVuZGVyZXIgPSB0aGlzLmNvbXBvbmVudFJlc29sdmVyLmdldENvbXBvbmVudFRvVXNlKG9yaWdpbmFsQ29sdW1uLCBcImNlbGxSZW5kZXJlclwiKTtcbiAgICAgICAgICAgIGlmIChvdGhlclJlbmRlcmVyICYmIG90aGVyUmVuZGVyZXIuc291cmNlICE9IGNvbXBvbmVudFJlc29sdmVyXzEuQ29tcG9uZW50U291cmNlLkRFRkFVTFQpIHtcbiAgICAgICAgICAgICAgICAvL09ubHkgaWYgdGhlIG9yaWdpbmFsIGNvbHVtbiBpcyB1c2luZyBhbiBzcGVjaWZpYyByZW5kZXJlciwgaXQgaXQgaXMgYSB1c2luZyBhIERFRkFVTFQgb25lXG4gICAgICAgICAgICAgICAgLy9pZ25vcmUgaXRcbiAgICAgICAgICAgICAgICAvL1RISVMgQ09NRVMgRlJPTSBBIENPTFVNTiBXSElDSCBIQVMgQkVFTiBHUk9VUEVEIERZTkFNSUNBTExZLCBXRSBSRVVTRSBJVFMgUkVOREVSRVJcbiAgICAgICAgICAgICAgICByZW5kZXJlclRvVXNlUHJvbWlzZSA9IHRoaXMuY29tcG9uZW50UmVjaXBlcy5uZXdDZWxsUmVuZGVyZXIob3JpZ2luYWxDb2x1bW4sIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlclJlbmRlcmVyICYmIG90aGVyUmVuZGVyZXIuc291cmNlID09IGNvbXBvbmVudFJlc29sdmVyXzEuQ29tcG9uZW50U291cmNlLkRFRkFVTFQgJiYgKHV0aWxzXzEuXy5nZXQob3JpZ2luYWxDb2x1bW4sICdjZWxsUmVuZGVyZXJQYXJhbXMuaW5uZXJSZW5kZXJlcicsIG51bGwpKSkge1xuICAgICAgICAgICAgICAgIC8vRURHRSBDQVNFIC0gVEhJUyBDT01FUyBGUk9NIEEgQ09MVU1OIFdISUNIIEhBUyBCRUVOIEdST1VQRUQgRFlOQU1JQ0FMTFksIFRIQVQgSEFTIEFTIFJFTkRFUkVSICdncm91cCdcbiAgICAgICAgICAgICAgICAvL0FORCBIQVMgQSBJTk5FUiBDRUxMIFJFTkRFUkVSXG4gICAgICAgICAgICAgICAgcmVuZGVyZXJUb1VzZVByb21pc2UgPSB0aGlzLmNvbXBvbmVudFJlY2lwZXMubmV3SW5uZXJDZWxsUmVuZGVyZXIob3JpZ2luYWxDb2x1bW4uY2VsbFJlbmRlcmVyUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9UaGlzIGZvcmNlcyB0aGUgcmV0cmlldmFsIG9mIHRoZSBkZWZhdWx0IHBsYWluIGNlbGxSZW5kZXJlciB0aGF0IGp1c3QgcmVuZGVycyB0aGUgdmFsdWVzLlxuICAgICAgICAgICAgICAgIHJlbmRlcmVyVG9Vc2VQcm9taXNlID0gdGhpcy5jb21wb25lbnRSZWNpcGVzLm5ld0NlbGxSZW5kZXJlcih7fSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVuZGVyZXJUb1VzZVByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVuZGVyZXJUb1VzZVByb21pc2UudGhlbihmdW5jdGlvbiAocmVuZGVyZXJUb1VzZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlclRvVXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZVRhcmdldC5pbm5lclRleHQgPSBwYXJhbXMudmFsdWVGb3JtYXR0ZWQgIT0gbnVsbCA/IHBhcmFtcy52YWx1ZUZvcm1hdHRlZCA6IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5iaW5kVG9IdG1sKHJlbmRlcmVyVG9Vc2VQcm9taXNlLCBlVGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZVRhcmdldC5pbm5lclRleHQgPSBwYXJhbXMudmFsdWVGb3JtYXR0ZWQgIT0gbnVsbCA/IHBhcmFtcy52YWx1ZUZvcm1hdHRlZCA6IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZXJUb1VzZVByb21pc2U7XG4gICAgfTtcbiAgICBDZWxsUmVuZGVyZXJTZXJ2aWNlLnByb3RvdHlwZS51c2VGdWxsV2lkdGhHcm91cFJvd0lubmVyQ2VsbFJlbmRlcmVyID0gZnVuY3Rpb24gKGVUYXJnZXQsIHBhcmFtcykge1xuICAgICAgICB2YXIgY2VsbFJlbmRlcmVyUHJvbWlzZSA9IHRoaXMuY29tcG9uZW50UmVjaXBlcy5uZXdGdWxsV2lkdGhHcm91cFJvd0lubmVyQ2VsbFJlbmRlcmVyKHBhcmFtcyk7XG4gICAgICAgIGlmIChjZWxsUmVuZGVyZXJQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFRvSHRtbChjZWxsUmVuZGVyZXJQcm9taXNlLCBlVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVUYXJnZXQuaW5uZXJUZXh0ID0gcGFyYW1zLnZhbHVlRm9ybWF0dGVkICE9IG51bGwgPyBwYXJhbXMudmFsdWVGb3JtYXR0ZWQgOiBwYXJhbXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxSZW5kZXJlclByb21pc2U7XG4gICAgfTtcbiAgICBDZWxsUmVuZGVyZXJTZXJ2aWNlLnByb3RvdHlwZS5iaW5kVG9IdG1sID0gZnVuY3Rpb24gKGNlbGxSZW5kZXJlclByb21pc2UsIGVUYXJnZXQpIHtcbiAgICAgICAgY2VsbFJlbmRlcmVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChjZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHZhciBndWkgPSBjZWxsUmVuZGVyZXIuZ2V0R3VpKCk7XG4gICAgICAgICAgICBpZiAoZ3VpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGd1aSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBlVGFyZ2V0LmFwcGVuZENoaWxkKGd1aSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlVGFyZ2V0LmlubmVySFRNTCA9IGd1aTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2VsbFJlbmRlcmVyUHJvbWlzZTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb21wb25lbnRSZWNpcGVzJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb21wb25lbnRSZWNpcGVzXzEuQ29tcG9uZW50UmVjaXBlcylcbiAgICBdLCBDZWxsUmVuZGVyZXJTZXJ2aWNlLnByb3RvdHlwZSwgXCJjb21wb25lbnRSZWNpcGVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbXBvbmVudFJlc29sdmVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb21wb25lbnRSZXNvbHZlcl8xLkNvbXBvbmVudFJlc29sdmVyKVxuICAgIF0sIENlbGxSZW5kZXJlclNlcnZpY2UucHJvdG90eXBlLCBcImNvbXBvbmVudFJlc29sdmVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIENlbGxSZW5kZXJlclNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIENlbGxSZW5kZXJlclNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2NlbGxSZW5kZXJlclNlcnZpY2UnKVxuICAgIF0sIENlbGxSZW5kZXJlclNlcnZpY2UpO1xuICAgIHJldHVybiBDZWxsUmVuZGVyZXJTZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuQ2VsbFJlbmRlcmVyU2VydmljZSA9IENlbGxSZW5kZXJlclNlcnZpY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbFJlbmRlcmVyU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgY2VsbENvbXBfMSA9IHJlcXVpcmUoXCIuL2NlbGxDb21wXCIpO1xudmFyIHJvd05vZGVfMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9yb3dOb2RlXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb2x1bW5fMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9jb2x1bW5cIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgY29tcG9uZW50QW5ub3RhdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi93aWRnZXRzL2NvbXBvbmVudEFubm90YXRpb25zXCIpO1xudmFyIExvYWRpbmdDZWxsUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2FkaW5nQ2VsbFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvYWRpbmdDZWxsUmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBMb2FkaW5nQ2VsbFJlbmRlcmVyLlRFTVBMQVRFKSB8fCB0aGlzO1xuICAgIH1cbiAgICBMb2FkaW5nQ2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgZUxvYWRpbmdJY29uID0gdXRpbHNfMS5fLmNyZWF0ZUljb25Ob1NwYW4oJ2dyb3VwTG9hZGluZycsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBudWxsKTtcbiAgICAgICAgdGhpcy5lTG9hZGluZ0ljb24uYXBwZW5kQ2hpbGQoZUxvYWRpbmdJY29uKTtcbiAgICAgICAgdmFyIGxvY2FsZVRleHRGdW5jID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TG9jYWxlVGV4dEZ1bmMoKTtcbiAgICAgICAgdGhpcy5lTG9hZGluZ1RleHQuaW5uZXJUZXh0ID0gbG9jYWxlVGV4dEZ1bmMoJ2xvYWRpbmdPb28nLCAnTG9hZGluZycpO1xuICAgIH07XG4gICAgTG9hZGluZ0NlbGxSZW5kZXJlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTG9hZGluZ0NlbGxSZW5kZXJlci5URU1QTEFURSA9IFwiPGRpdiBjbGFzcz1cXFwiYWctc3R1Yi1jZWxsXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiYWctbG9hZGluZy1pY29uXFxcIiByZWY9XFxcImVMb2FkaW5nSWNvblxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJhZy1sb2FkaW5nLXRleHRcXFwiIHJlZj1cXFwiZUxvYWRpbmdUZXh0XFxcIj48L3NwYW4+XFxuICAgICAgICA8L2Rpdj5cIjtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgTG9hZGluZ0NlbGxSZW5kZXJlci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2VMb2FkaW5nSWNvbicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgTG9hZGluZ0NlbGxSZW5kZXJlci5wcm90b3R5cGUsIFwiZUxvYWRpbmdJY29uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2VMb2FkaW5nVGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgTG9hZGluZ0NlbGxSZW5kZXJlci5wcm90b3R5cGUsIFwiZUxvYWRpbmdUZXh0XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIExvYWRpbmdDZWxsUmVuZGVyZXI7XG59KGNvbXBvbmVudF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Mb2FkaW5nQ2VsbFJlbmRlcmVyID0gTG9hZGluZ0NlbGxSZW5kZXJlcjtcbnZhciBSb3dDb21wID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm93Q29tcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb3dDb21wKHBhcmVudFNjb3BlLCBib2R5Q29udGFpbmVyQ29tcCwgcGlubmVkTGVmdENvbnRhaW5lckNvbXAsIHBpbm5lZFJpZ2h0Q29udGFpbmVyQ29tcCwgZnVsbFdpZHRoQ29udGFpbmVyQ29tcCwgcm93Tm9kZSwgYmVhbnMsIGFuaW1hdGVJbiwgdXNlQW5pbWF0aW9uRnJhbWVGb3JDcmVhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZUFsbFJvd0NvbnRhaW5lcnMgPSBbXTtcbiAgICAgICAgX3RoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuY29sdW1uUmVmcmVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY2VsbENvbXBzID0ge307XG4gICAgICAgIC8vIGZvciBhbmltYXRpb25zLCB0aGVyZSBhcmUgYml0cyB3ZSB3YW50IGRvbmUgaW4gdGhlIG5leHQgVk0gdHVybiwgdG8gYWxsIERPTSB0byB1cGRhdGUgZmlyc3QuXG4gICAgICAgIC8vIGluc3RlYWQgb2YgZWFjaCByb3cgZG9pbmcgYSBzZXRUaW1lb3V0KGZ1bmMsMCksIHdlIHB1dCB0aGUgZnVuY3Rpb25zIGhlcmUgYW5kIHRoZSByb3dSZW5kZXJlclxuICAgICAgICAvLyBleGVjdXRlcyB0aGVtIGFsbCBpbiBvbmUgdGltZW91dFxuICAgICAgICBfdGhpcy5jcmVhdGVTZWNvbmRQYXNzRnVuY3MgPSBbXTtcbiAgICAgICAgLy8gdGhlc2UgZ2V0IGNhbGxlZCBiZWZvcmUgdGhlIHJvdyBpcyBkZXN0cm95ZWQgLSB0aGV5IHNldCB1cCB0aGUgRE9NIGZvciB0aGUgcmVtb3ZlIGFuaW1hdGlvbiAoaWUgdGhleVxuICAgICAgICAvLyBzZXQgdGhlIERPTSB1cCBmb3IgdGhlIGFuaW1hdGlvbiksIHRoZW4gdGhlIGRlbGF5ZWREZXN0cm95RnVuY3Rpb25zIGdldCBjYWxsZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGlzXG4gICAgICAgIC8vIGNvbXBsZXRlIChpZSByZW1vdmVzIGZyb20gdGhlIGRvbSkuXG4gICAgICAgIF90aGlzLnJlbW92ZUZpcnN0UGFzc0Z1bmNzID0gW107XG4gICAgICAgIC8vIGZvciBhbmltYXRpb25zLCB0aGVzZSBmdW5jdGlvbnMgZ2V0IGNhbGxlZCA0MDBtcyBhZnRlciB0aGUgcm93IGlzIGNsZWFyZWQsIGNhbGxlZCBieSB0aGUgcm93UmVuZGVyZXJcbiAgICAgICAgLy8gc28gZWFjaCByb3cgaXNuJ3Qgc2V0dGluZyB1cCBpdCdzIG93biB0aW1lb3V0XG4gICAgICAgIF90aGlzLnJlbW92ZVNlY29uZFBhc3NGdW5jcyA9IFtdO1xuICAgICAgICBfdGhpcy5pbml0aWFsaXNlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5wYXJlbnRTY29wZSA9IHBhcmVudFNjb3BlO1xuICAgICAgICBfdGhpcy5iZWFucyA9IGJlYW5zO1xuICAgICAgICBfdGhpcy5ib2R5Q29udGFpbmVyQ29tcCA9IGJvZHlDb250YWluZXJDb21wO1xuICAgICAgICBfdGhpcy5waW5uZWRMZWZ0Q29udGFpbmVyQ29tcCA9IHBpbm5lZExlZnRDb250YWluZXJDb21wO1xuICAgICAgICBfdGhpcy5waW5uZWRSaWdodENvbnRhaW5lckNvbXAgPSBwaW5uZWRSaWdodENvbnRhaW5lckNvbXA7XG4gICAgICAgIF90aGlzLmZ1bGxXaWR0aENvbnRhaW5lckNvbXAgPSBmdWxsV2lkdGhDb250YWluZXJDb21wO1xuICAgICAgICBfdGhpcy5yb3dOb2RlID0gcm93Tm9kZTtcbiAgICAgICAgX3RoaXMucm93SXNFdmVuID0gX3RoaXMucm93Tm9kZS5yb3dJbmRleCAlIDIgPT09IDA7XG4gICAgICAgIF90aGlzLnBhZ2luYXRpb25QYWdlID0gX3RoaXMuYmVhbnMucGFnaW5hdGlvblByb3h5LmdldEN1cnJlbnRQYWdlKCk7XG4gICAgICAgIF90aGlzLnVzZUFuaW1hdGlvbkZyYW1lRm9yQ3JlYXRlID0gdXNlQW5pbWF0aW9uRnJhbWVGb3JDcmVhdGU7XG4gICAgICAgIF90aGlzLnNldEFuaW1hdGVGbGFncyhhbmltYXRlSW4pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJvd0NvbXAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucm93Rm9jdXNlZCA9IHRoaXMuYmVhbnMuZm9jdXNlZENlbGxDb250cm9sbGVyLmlzUm93Rm9jdXNlZCh0aGlzLnJvd05vZGUucm93SW5kZXgsIHRoaXMucm93Tm9kZS5yb3dQaW5uZWQpO1xuICAgICAgICB0aGlzLnNjb3BlID0gdGhpcy5jcmVhdGVDaGlsZFNjb3BlT3JOdWxsKHRoaXMucm93Tm9kZS5kYXRhKTtcbiAgICAgICAgdGhpcy5zZXR1cFJvd0NvbnRhaW5lcnMoKTtcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuc2xpZGVSb3dJbikge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVTZWNvbmRQYXNzRnVuY3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25Ub3BDaGFuZ2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mYWRlUm93SW4pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2Vjb25kUGFzc0Z1bmNzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVBbGxSb3dDb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKGVSb3cpIHsgcmV0dXJuIHV0aWxzXzEuXy5yZW1vdmVDc3NDbGFzcyhlUm93LCAnYWctb3BhY2l0eS16ZXJvJyk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leGVjdXRlUHJvY2Vzc1Jvd1Bvc3RDcmVhdGVGdW5jKCk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5jcmVhdGVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb250ZW50cywgZXh0cmFDc3NDbGFzcykge1xuICAgICAgICBpZiAoZXh0cmFDc3NDbGFzcyA9PT0gdm9pZCAwKSB7IGV4dHJhQ3NzQ2xhc3MgPSBudWxsOyB9XG4gICAgICAgIHZhciB0ZW1wbGF0ZVBhcnRzID0gW107XG4gICAgICAgIHZhciByb3dIZWlnaHQgPSB0aGlzLnJvd05vZGUucm93SGVpZ2h0O1xuICAgICAgICB2YXIgcm93Q2xhc3NlcyA9IHRoaXMuZ2V0SW5pdGlhbFJvd0NsYXNzZXMoZXh0cmFDc3NDbGFzcykuam9pbignICcpO1xuICAgICAgICB2YXIgcm93SWQgPSB0aGlzLnJvd05vZGUuaWQ7XG4gICAgICAgIHZhciB1c2VyUm93U3R5bGVzID0gdGhpcy5wcmVQcm9jZXNzU3R5bGVzRnJvbUdyaWRPcHRpb25zKCk7XG4gICAgICAgIHZhciBidXNpbmVzc0tleSA9IHRoaXMuZ2V0Um93QnVzaW5lc3NLZXkoKTtcbiAgICAgICAgdmFyIHJvd1RvcFN0eWxlID0gdGhpcy5nZXRJbml0aWFsUm93VG9wU3R5bGUoKTtcbiAgICAgICAgdGVtcGxhdGVQYXJ0cy5wdXNoKFwiPGRpdlwiKTtcbiAgICAgICAgdGVtcGxhdGVQYXJ0cy5wdXNoKFwiIHJvbGU9XFxcInJvd1xcXCJcIik7XG4gICAgICAgIHRlbXBsYXRlUGFydHMucHVzaChcIiByb3ctaW5kZXg9XFxcIlwiICsgdGhpcy5yb3dOb2RlLmdldFJvd0luZGV4U3RyaW5nKCkgKyBcIlxcXCJcIik7XG4gICAgICAgIHRlbXBsYXRlUGFydHMucHVzaChyb3dJZCA/IFwiIHJvdy1pZD1cXFwiXCIgKyByb3dJZCArIFwiXFxcIlwiIDogXCJcIik7XG4gICAgICAgIHRlbXBsYXRlUGFydHMucHVzaChidXNpbmVzc0tleSA/IFwiIHJvdy1idXNpbmVzcy1rZXk9XFxcIlwiICsgYnVzaW5lc3NLZXkgKyBcIlxcXCJcIiA6IFwiXCIpO1xuICAgICAgICB0ZW1wbGF0ZVBhcnRzLnB1c2goXCIgY29tcC1pZD1cXFwiXCIgKyB0aGlzLmdldENvbXBJZCgpICsgXCJcXFwiXCIpO1xuICAgICAgICB0ZW1wbGF0ZVBhcnRzLnB1c2goXCIgY2xhc3M9XFxcIlwiICsgcm93Q2xhc3NlcyArIFwiXFxcIlwiKTtcbiAgICAgICAgdGVtcGxhdGVQYXJ0cy5wdXNoKFwiIHN0eWxlPVxcXCJoZWlnaHQ6IFwiICsgcm93SGVpZ2h0ICsgXCJweDsgXCIgKyByb3dUb3BTdHlsZSArIFwiIFwiICsgdXNlclJvd1N0eWxlcyArIFwiXFxcIj5cIik7XG4gICAgICAgIC8vIGFkZCBpbiB0aGUgdGVtcGxhdGUgZm9yIHRoZSBjZWxsc1xuICAgICAgICB0ZW1wbGF0ZVBhcnRzLnB1c2goY29udGVudHMpO1xuICAgICAgICB0ZW1wbGF0ZVBhcnRzLnB1c2goXCI8L2Rpdj5cIik7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZVBhcnRzLmpvaW4oJycpO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuZ2V0Q2VsbEZvckNvbCA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIGNlbGxDb21wID0gdGhpcy5jZWxsQ29tcHNbY29sdW1uLmdldENvbElkKCldO1xuICAgICAgICBpZiAoY2VsbENvbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsQ29tcC5nZXRHdWkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5hZnRlckZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGlzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGlzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5leGVjdXRlUHJvY2Vzc1Jvd1Bvc3RDcmVhdGVGdW5jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmV4ZWN1dGVQcm9jZXNzUm93UG9zdENyZWF0ZUZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmdW5jID0gdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0UHJvY2Vzc1Jvd1Bvc3RDcmVhdGVGdW5jKCk7XG4gICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGVSb3c6IHRoaXMuZUJvZHlSb3csXG4gICAgICAgICAgICAgICAgZVBpbm5lZExlZnRSb3c6IHRoaXMuZVBpbm5lZExlZnRSb3csXG4gICAgICAgICAgICAgICAgZVBpbm5lZFJpZ2h0Um93OiB0aGlzLmVQaW5uZWRSaWdodFJvdyxcbiAgICAgICAgICAgICAgICBub2RlOiB0aGlzLnJvd05vZGUsXG4gICAgICAgICAgICAgICAgYXBpOiB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBcGkoKSxcbiAgICAgICAgICAgICAgICByb3dJbmRleDogdGhpcy5yb3dOb2RlLnJvd0luZGV4LFxuICAgICAgICAgICAgICAgIGFkZFJlbmRlcmVkUm93TGlzdGVuZXI6IHRoaXMuYWRkRXZlbnRMaXN0ZW5lci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29sdW1uQXBpKCksXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuYyhwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5nZXRJbml0aWFsUm93VG9wU3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dUb3BTdHlsZSA9ICcnO1xuICAgICAgICB2YXIgc2V0Um93VG9wID0gIXRoaXMuYmVhbnMuZm9yUHJpbnQgJiYgIXRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzQXV0b0hlaWdodCgpO1xuICAgICAgICBpZiAoc2V0Um93VG9wKSB7XG4gICAgICAgICAgICAvLyBpZiBzbGlkaW5nIGluLCB3ZSB0YWtlIHRoZSBvbGQgcm93IHRvcC4gb3RoZXJ3aXNlIHdlIGp1c3Qgc2V0IHRoZSBjdXJyZW50IHJvdyB0b3AuXG4gICAgICAgICAgICB2YXIgcGl4ZWxzID0gdGhpcy5zbGlkZVJvd0luID8gdGhpcy5yb3VuZFJvd1RvcFRvQm91bmRzKHRoaXMucm93Tm9kZS5vbGRSb3dUb3ApIDogdGhpcy5yb3dOb2RlLnJvd1RvcDtcbiAgICAgICAgICAgIHZhciBwaXhlbHNXaXRoT2Zmc2V0ID0gdGhpcy5hcHBseVBpeGVsT2Zmc2V0KHBpeGVscyk7XG4gICAgICAgICAgICAvLyBpZiBub3Qgc2V0dGluZyByb3cgdG9wLCB0aGVuIGJlbG93IGlzIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgcm93VG9wU3R5bGUgPSBcInRvcDogXCIgKyBwaXhlbHNXaXRoT2Zmc2V0ICsgXCJweDsgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd1RvcFN0eWxlO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuZ2V0Um93QnVzaW5lc3NLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QnVzaW5lc3NLZXlGb3JOb2RlRnVuYygpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgYnVzaW5lc3NLZXkgPSB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRCdXNpbmVzc0tleUZvck5vZGVGdW5jKCkodGhpcy5yb3dOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBidXNpbmVzc0tleTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUubGF6eUNyZWF0ZUNlbGxzID0gZnVuY3Rpb24gKGNvbHMsIGVSb3cpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgY2VsbFRlbXBsYXRlc0FuZENvbXBzID0gdGhpcy5jcmVhdGVDZWxscyhjb2xzKTtcbiAgICAgICAgICAgIGVSb3cuaW5uZXJIVE1MID0gY2VsbFRlbXBsYXRlc0FuZENvbXBzLnRlbXBsYXRlO1xuICAgICAgICAgICAgdGhpcy5jYWxsQWZ0ZXJSb3dBdHRhY2hlZE9uQ2VsbHMoY2VsbFRlbXBsYXRlc0FuZENvbXBzLmNlbGxDb21wcywgZVJvdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmNyZWF0ZVJvd0NvbnRhaW5lciA9IGZ1bmN0aW9uIChyb3dDb250YWluZXJDb21wLCBjb2xzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2VsbFRlbXBsYXRlc0FuZENvbXBzO1xuICAgICAgICBpZiAodGhpcy51c2VBbmltYXRpb25GcmFtZUZvckNyZWF0ZSkge1xuICAgICAgICAgICAgY2VsbFRlbXBsYXRlc0FuZENvbXBzID0geyBjZWxsQ29tcHM6IFtdLCB0ZW1wbGF0ZTogJycgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxUZW1wbGF0ZXNBbmRDb21wcyA9IHRoaXMuY3JlYXRlQ2VsbHMoY29scyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvd1RlbXBsYXRlID0gdGhpcy5jcmVhdGVUZW1wbGF0ZShjZWxsVGVtcGxhdGVzQW5kQ29tcHMudGVtcGxhdGUpO1xuICAgICAgICByb3dDb250YWluZXJDb21wLmFwcGVuZFJvd1RlbXBsYXRlKHJvd1RlbXBsYXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZVJvdyA9IHJvd0NvbnRhaW5lckNvbXAuZ2V0Um93RWxlbWVudChfdGhpcy5nZXRDb21wSWQoKSk7XG4gICAgICAgICAgICBfdGhpcy5hZnRlclJvd0F0dGFjaGVkKHJvd0NvbnRhaW5lckNvbXAsIGVSb3cpO1xuICAgICAgICAgICAgY2FsbGJhY2soZVJvdyk7XG4gICAgICAgICAgICBpZiAoX3RoaXMudXNlQW5pbWF0aW9uRnJhbWVGb3JDcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5iZWFucy50YXNrUXVldWUuYWRkUDFUYXNrKF90aGlzLmxhenlDcmVhdGVDZWxscy5iaW5kKF90aGlzLCBjb2xzLCBlUm93KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jYWxsQWZ0ZXJSb3dBdHRhY2hlZE9uQ2VsbHMoY2VsbFRlbXBsYXRlc0FuZENvbXBzLmNlbGxDb21wcywgZVJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuY3JlYXRlQ2hpbGRTY29wZU9yTnVsbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5pc0FuZ3VsYXJDb21waWxlUm93cygpKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGRTY29wZSA9IHRoaXMucGFyZW50U2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgbmV3Q2hpbGRTY29wZS5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIG5ld0NoaWxkU2NvcGUucm93Tm9kZSA9IHRoaXMucm93Tm9kZTtcbiAgICAgICAgICAgIG5ld0NoaWxkU2NvcGUuY29udGV4dCA9IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZFNjb3BlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLnNldHVwUm93U3R1YiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mdWxsV2lkdGhSb3cgPSB0cnVlO1xuICAgICAgICB0aGlzLmZ1bGxXaWR0aFJvd0VtYmVkZGVkID0gdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbWJlZEZ1bGxXaWR0aFJvd3MoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVGdWxsV2lkdGhSb3dzKFJvd0NvbXAuTE9BRElOR19DRUxMX1JFTkRFUkVSKTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLnNldHVwUm93Q29udGFpbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlzRnVsbFdpZHRoQ2VsbEZ1bmMgPSB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRJc0Z1bGxXaWR0aENlbGxGdW5jKCk7XG4gICAgICAgIHZhciBpc0Z1bGxXaWR0aENlbGwgPSBpc0Z1bGxXaWR0aENlbGxGdW5jID8gaXNGdWxsV2lkdGhDZWxsRnVuYyh0aGlzLnJvd05vZGUpIDogZmFsc2U7XG4gICAgICAgIHZhciBpc0dyb3VwU3Bhbm5pbmdSb3cgPSB0aGlzLnJvd05vZGUuZ3JvdXAgJiYgdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNHcm91cFVzZUVudGlyZVJvdygpO1xuICAgICAgICBpZiAodGhpcy5yb3dOb2RlLnN0dWIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBSb3dTdHViKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGdWxsV2lkdGhDZWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwRnVsbFdpZHRoQ29udGFpbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzR3JvdXBTcGFubmluZ1Jvdykge1xuICAgICAgICAgICAgdGhpcy5zZXR1cEZ1bGxXaWR0aEdyb3VwQ29udGFpbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXR1cE5vcm1hbFJvd0NvbnRhaW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuc2V0dXBGdWxsV2lkdGhDb250YWluZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZ1bGxXaWR0aFJvdyA9IHRydWU7XG4gICAgICAgIHRoaXMuZnVsbFdpZHRoUm93RW1iZWRkZWQgPSB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5pc0VtYmVkRnVsbFdpZHRoUm93cygpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZ1bGxXaWR0aFJvd3MoUm93Q29tcC5GVUxMX1dJRFRIX0NFTExfUkVOREVSRVIpO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuc2V0dXBGdWxsV2lkdGhHcm91cENvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnVsbFdpZHRoUm93ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mdWxsV2lkdGhSb3dFbWJlZGRlZCA9IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW1iZWRGdWxsV2lkdGhSb3dzKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlRnVsbFdpZHRoUm93cyhSb3dDb21wLkdST1VQX1JPV19SRU5ERVJFUik7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5zZXR1cE5vcm1hbFJvd0NvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjZW50ZXJDb2xzID0gdGhpcy5iZWFucy5jb2x1bW5Db250cm9sbGVyLmdldEFsbERpc3BsYXllZENlbnRlclZpcnR1YWxDb2x1bW5zRm9yUm93KHRoaXMucm93Tm9kZSk7XG4gICAgICAgIHRoaXMuY3JlYXRlUm93Q29udGFpbmVyKHRoaXMuYm9keUNvbnRhaW5lckNvbXAsIGNlbnRlckNvbHMsIGZ1bmN0aW9uIChlUm93KSB7IHJldHVybiBfdGhpcy5lQm9keVJvdyA9IGVSb3c7IH0pO1xuICAgICAgICBpZiAoIXRoaXMuYmVhbnMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0Q29scyA9IHRoaXMuYmVhbnMuY29sdW1uQ29udHJvbGxlci5nZXREaXNwbGF5ZWRMZWZ0Q29sdW1uc0ZvclJvdyh0aGlzLnJvd05vZGUpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q29scyA9IHRoaXMuYmVhbnMuY29sdW1uQ29udHJvbGxlci5nZXREaXNwbGF5ZWRSaWdodENvbHVtbnNGb3JSb3codGhpcy5yb3dOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUm93Q29udGFpbmVyKHRoaXMucGlubmVkUmlnaHRDb250YWluZXJDb21wLCByaWdodENvbHMsIGZ1bmN0aW9uIChlUm93KSB7IHJldHVybiBfdGhpcy5lUGlubmVkUmlnaHRSb3cgPSBlUm93OyB9KTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUm93Q29udGFpbmVyKHRoaXMucGlubmVkTGVmdENvbnRhaW5lckNvbXAsIGxlZnRDb2xzLCBmdW5jdGlvbiAoZVJvdykgeyByZXR1cm4gX3RoaXMuZVBpbm5lZExlZnRSb3cgPSBlUm93OyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuY3JlYXRlRnVsbFdpZHRoUm93cyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmZ1bGxXaWR0aFJvd0VtYmVkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZ1bGxXaWR0aFJvd0NvbnRhaW5lcih0aGlzLmJvZHlDb250YWluZXJDb21wLCBudWxsLCBudWxsLCB0eXBlLCBmdW5jdGlvbiAoZVJvdykge1xuICAgICAgICAgICAgICAgIF90aGlzLmVGdWxsV2lkdGhSb3dCb2R5ID0gZVJvdztcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChjZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5mdWxsV2lkdGhSb3dDb21wb25lbnRCb2R5ID0gY2VsbFJlbmRlcmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZ1bGxXaWR0aFJvd0NvbnRhaW5lcih0aGlzLnBpbm5lZExlZnRDb250YWluZXJDb21wLCBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX0xFRlQsICdhZy1jZWxsLWxhc3QtbGVmdC1waW5uZWQnLCB0eXBlLCBmdW5jdGlvbiAoZVJvdykge1xuICAgICAgICAgICAgICAgIF90aGlzLmVGdWxsV2lkdGhSb3dMZWZ0ID0gZVJvdztcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChjZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5mdWxsV2lkdGhSb3dDb21wb25lbnRMZWZ0ID0gY2VsbFJlbmRlcmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZ1bGxXaWR0aFJvd0NvbnRhaW5lcih0aGlzLnBpbm5lZFJpZ2h0Q29udGFpbmVyQ29tcCwgY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9SSUdIVCwgJ2FnLWNlbGwtZmlyc3QtcmlnaHQtcGlubmVkJywgdHlwZSwgZnVuY3Rpb24gKGVSb3cpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lRnVsbFdpZHRoUm93UmlnaHQgPSBlUm93O1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGNlbGxSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmZ1bGxXaWR0aFJvd0NvbXBvbmVudFJpZ2h0ID0gY2VsbFJlbmRlcmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYWRkIHRvIHRoZSBmdWxsV2lkdGggY29udGFpbmVyIGFzIG5vcm1hbFxuICAgICAgICAgICAgLy8gbGV0IHByZXZpb3VzRnVsbFdpZHRoID0gZW5zdXJlRG9tT3JkZXIgPyB0aGlzLmxhc3RQbGFjZWRFbGVtZW50cy5lRnVsbFdpZHRoIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnVsbFdpZHRoUm93Q29udGFpbmVyKHRoaXMuZnVsbFdpZHRoQ29udGFpbmVyQ29tcCwgbnVsbCwgbnVsbCwgdHlwZSwgZnVuY3Rpb24gKGVSb3cpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lRnVsbFdpZHRoUm93ID0gZVJvdztcbiAgICAgICAgICAgICAgICAvLyBhbmQgZmFrZSB0aGUgbW91c2Ugd2hlZWwgZm9yIHRoZSBmdWxsV2lkdGggY29udGFpbmVyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5iZWFucy5mb3JQcmludCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRNb3VzZVdoZWVsTGlzdGVuZXJUb0Z1bGxXaWR0aFJvdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChjZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5mdWxsV2lkdGhSb3dDb21wb25lbnQgPSBjZWxsUmVuZGVyZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuYWRkTW91c2VXaGVlbExpc3RlbmVyVG9GdWxsV2lkdGhSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb3VzZVdoZWVsTGlzdGVuZXIgPSB0aGlzLmJlYW5zLmdyaWRQYW5lbC5nZW5lcmljTW91c2VXaGVlbExpc3RlbmVyLmJpbmQodGhpcy5iZWFucy5ncmlkUGFuZWwpO1xuICAgICAgICAvLyBJRTksIENocm9tZSwgU2FmYXJpLCBPcGVyYVxuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVGdWxsV2lkdGhSb3csICdtb3VzZXdoZWVsJywgbW91c2VXaGVlbExpc3RlbmVyKTtcbiAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVGdWxsV2lkdGhSb3csICdET01Nb3VzZVNjcm9sbCcsIG1vdXNlV2hlZWxMaXN0ZW5lcik7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5zZXRBbmltYXRlRmxhZ3MgPSBmdW5jdGlvbiAoYW5pbWF0ZUluKSB7XG4gICAgICAgIGlmIChhbmltYXRlSW4pIHtcbiAgICAgICAgICAgIHZhciBvbGRSb3dUb3BFeGlzdHMgPSB1dGlsc18xLl8uZXhpc3RzKHRoaXMucm93Tm9kZS5vbGRSb3dUb3ApO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHJvdyBoYWQgYSBwcmV2aW91cyBwb3NpdGlvbiwgd2Ugc2xpZGUgaXQgaW4gKGFuaW1hdGUgcm93IHRvcClcbiAgICAgICAgICAgIHRoaXMuc2xpZGVSb3dJbiA9IG9sZFJvd1RvcEV4aXN0cztcbiAgICAgICAgICAgIC8vIGlmIHRoZSByb3cgaGFkIG5vIHByZXZpb3VzIHBvc2l0aW9uLCB3ZSBmYWRlIGl0IGluIChhbmltYXRlXG4gICAgICAgICAgICB0aGlzLmZhZGVSb3dJbiA9ICFvbGRSb3dUb3BFeGlzdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNsaWRlUm93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmFkZVJvd0luID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmlzRWRpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuc3RvcFJvd0VkaXRpbmcgPSBmdW5jdGlvbiAoY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoY2FuY2VsKTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmlzRnVsbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdWxsV2lkdGhSb3c7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5hZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMucm93Tm9kZSwgcm93Tm9kZV8xLlJvd05vZGUuRVZFTlRfSEVJR0hUX0NIQU5HRUQsIHRoaXMub25Sb3dIZWlnaHRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLnJvd05vZGUsIHJvd05vZGVfMS5Sb3dOb2RlLkVWRU5UX1JPV19TRUxFQ1RFRCwgdGhpcy5vblJvd1NlbGVjdGVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLnJvd05vZGUsIHJvd05vZGVfMS5Sb3dOb2RlLkVWRU5UX1JPV19JTkRFWF9DSEFOR0VELCB0aGlzLm9uUm93SW5kZXhDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLnJvd05vZGUsIHJvd05vZGVfMS5Sb3dOb2RlLkVWRU5UX1RPUF9DSEFOR0VELCB0aGlzLm9uVG9wQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5yb3dOb2RlLCByb3dOb2RlXzEuUm93Tm9kZS5FVkVOVF9FWFBBTkRFRF9DSEFOR0VELCB0aGlzLm9uRXhwYW5kZWRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLnJvd05vZGUsIHJvd05vZGVfMS5Sb3dOb2RlLkVWRU5UX0RBVEFfQ0hBTkdFRCwgdGhpcy5vblJvd05vZGVEYXRhQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5yb3dOb2RlLCByb3dOb2RlXzEuUm93Tm9kZS5FVkVOVF9DRUxMX0NIQU5HRUQsIHRoaXMub25Sb3dOb2RlQ2VsbENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHZhciBldmVudFNlcnZpY2UgPSB0aGlzLmJlYW5zLmV2ZW50U2VydmljZTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfRElTUExBWUVEX0NPTFVNTlNfQ0hBTkdFRCwgdGhpcy5vbkRpc3BsYXllZENvbHVtbnNDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcihldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9WSVJUVUFMX0NPTFVNTlNfQ0hBTkdFRCwgdGhpcy5vblZpcnR1YWxDb2x1bW5zQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1JFU0laRUQsIHRoaXMub25Db2x1bW5SZXNpemVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcihldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DRUxMX0ZPQ1VTRUQsIHRoaXMub25DZWxsRm9jdXNDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcihldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9QQUdJTkFUSU9OX0NIQU5HRUQsIHRoaXMub25QYWdpbmF0aW9uQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfR1JJRF9DT0xVTU5TX0NIQU5HRUQsIHRoaXMub25HcmlkQ29sdW1uc0NoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICAvLyB3aGVuIGdyaWQgY29sdW1ucyBjaGFuZ2UsIHRoZW4gYWxsIGNlbGxzIHNob3VsZCBiZSBjbGVhbmVkIG91dCxcbiAgICAvLyBhcyB0aGUgbmV3IGNvbHVtbnMgY291bGQgaGF2ZSBzYW1lIGlkIGFzIHRoZSBwcmV2aW91cyBjb2x1bW5zIGFuZCBtYXkgY29uZmxpY3RcbiAgICBSb3dDb21wLnByb3RvdHlwZS5vbkdyaWRDb2x1bW5zQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsbFJlbmRlcmVkQ2VsbElkcyA9IE9iamVjdC5rZXlzKHRoaXMuY2VsbENvbXBzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVSZW5kZXJlZENlbGxzKGFsbFJlbmRlcmVkQ2VsbElkcyk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5vblJvd05vZGVEYXRhQ2hhbmdlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIHVwZGF0ZSwgd2Ugd2FudCB0byByZWZyZXNoLCBhcyB0aGlzIHdpbGwgYWxsb3cgdGhlIHVzZXIgdG8gcHV0IGluIGEgdHJhbnNpdGlvblxuICAgICAgICAvLyBpbnRvIHRoZSBjZWxsUmVuZGVyZXIgcmVmcmVzaCBtZXRob2QuIG90aGVyd2lzZSB0aGlzIG1pZ2h0IGJlIGNvbXBsZXRlbHkgbmV3IGRhdGEsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgLy8gd2Ugd2lsbCB3YW50IHRvIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGUgY2VsbHNcbiAgICAgICAgdGhpcy5mb3JFYWNoQ2VsbENvbXAoZnVuY3Rpb24gKGNlbGxDb21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbENvbXAucmVmcmVzaENlbGwoe1xuICAgICAgICAgICAgICAgIHN1cHByZXNzRmxhc2g6ICFldmVudC51cGRhdGUsXG4gICAgICAgICAgICAgICAgbmV3RGF0YTogIWV2ZW50LnVwZGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjaGVjayBmb3Igc2VsZWN0ZWQgYWxzbywgYXMgdGhpcyBjb3VsZCBiZSBhZnRlciBsYXp5IGxvYWRpbmcgb2YgdGhlIHJvdyBkYXRhLCBpbiB3aGljaCBjYXNlXG4gICAgICAgIC8vIHRoZSBpZCBtaWdodCBvZiBqdXN0IGdvdHRlbiBzZXQgaW5zaWRlIHRoZSByb3cgYW5kIHRoZSByb3cgc2VsZWN0ZWQgc3RhdGUgbWF5IG9mIGNoYW5nZWRcbiAgICAgICAgLy8gYXMgYSByZXN1bHQuIHRoaXMgaXMgd2hhdCBoYXBwZW5zIHdoZW4gc2VsZWN0ZWQgcm93cyBhcmUgbG9hZGVkIGluIHZpcnR1YWwgcGFnaW5hdGlvbi5cbiAgICAgICAgLy8gLSBuaWFsbCBub3RlIC0gc2luY2UgbW92aW5nIHRvIHRoZSBzdHViIGNvbXBvbmVudCwgdGhpcyBtYXkgbm8gbG9uZ2VyIGJlIHRydWUsIGFzIHJlcGxhY2luZ1xuICAgICAgICAvLyB0aGUgc3R1YiBjb21wb25lbnQgbm93IHJlcGxhY2VzIHRoZSBlbnRpcmUgcm93XG4gICAgICAgIHRoaXMub25Sb3dTZWxlY3RlZCgpO1xuICAgICAgICAvLyBhcyBkYXRhIGhhcyBjaGFuZ2VkLCB0aGVuIHRoZSBzdHlsZSBhbmQgY2xhc3MgbmVlZHMgdG8gYmUgcmVjb21wdXRlZFxuICAgICAgICB0aGlzLnBvc3RQcm9jZXNzQ3NzKCk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5vblJvd05vZGVDZWxsQ2hhbmdlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBhcyBkYXRhIGhhcyBjaGFuZ2VkLCB0aGVuIHRoZSBzdHlsZSBhbmQgY2xhc3MgbmVlZHMgdG8gYmUgcmVjb21wdXRlZFxuICAgICAgICB0aGlzLnBvc3RQcm9jZXNzQ3NzKCk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5wb3N0UHJvY2Vzc0NzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc1N0eWxlc0Zyb21HcmlkT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnBvc3RQcm9jZXNzQ2xhc3Nlc0Zyb21HcmlkT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnBvc3RQcm9jZXNzUm93Q2xhc3NSdWxlcygpO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUub25FeHBhbmRlZENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvd05vZGUuZ3JvdXAgJiYgIXRoaXMucm93Tm9kZS5mb290ZXIpIHtcbiAgICAgICAgICAgIHZhciBleHBhbmRlZF8xID0gdGhpcy5yb3dOb2RlLmV4cGFuZGVkO1xuICAgICAgICAgICAgdGhpcy5lQWxsUm93Q29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKHJvdywgJ2FnLXJvdy1ncm91cC1leHBhbmRlZCcsIGV4cGFuZGVkXzEpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuZUFsbFJvd0NvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiB1dGlsc18xLl8uYWRkT3JSZW1vdmVDc3NDbGFzcyhyb3csICdhZy1yb3ctZ3JvdXAtY29udHJhY3RlZCcsICFleHBhbmRlZF8xKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLm9uRGlzcGxheWVkQ29sdW1uc0NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5mdWxsV2lkdGhSb3cpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENlbGxzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmRlc3Ryb3lGdWxsV2lkdGhDb21wb25lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5mdWxsV2lkdGhSb3dDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bGxXaWR0aFJvd0NvbXBvbmVudC5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsV2lkdGhSb3dDb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mdWxsV2lkdGhSb3dDb21wb25lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZ1bGxXaWR0aFJvd0NvbXBvbmVudEJvZHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bGxXaWR0aFJvd0NvbXBvbmVudEJvZHkuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnVsbFdpZHRoUm93Q29tcG9uZW50Qm9keS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZ1bGxXaWR0aFJvd0NvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnVsbFdpZHRoUm93Q29tcG9uZW50TGVmdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnVsbFdpZHRoUm93Q29tcG9uZW50TGVmdC5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsV2lkdGhSb3dDb21wb25lbnRMZWZ0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnVsbFdpZHRoUm93Q29tcG9uZW50TGVmdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnVsbFdpZHRoUm93Q29tcG9uZW50UmlnaHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bGxXaWR0aFJvd0NvbXBvbmVudFJpZ2h0LmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZ1bGxXaWR0aFJvd0NvbXBvbmVudFJpZ2h0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnVsbFdpZHRoUm93Q29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuZ2V0Q29udGFpbmVyRm9yQ2VsbCA9IGZ1bmN0aW9uIChwaW5uZWRUeXBlKSB7XG4gICAgICAgIHN3aXRjaCAocGlubmVkVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX0xFRlQ6IHJldHVybiB0aGlzLmVQaW5uZWRMZWZ0Um93O1xuICAgICAgICAgICAgY2FzZSBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX1JJR0hUOiByZXR1cm4gdGhpcy5lUGlubmVkUmlnaHRSb3c7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gdGhpcy5lQm9keVJvdztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUub25WaXJ0dWFsQ29sdW1uc0NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5mdWxsV2lkdGhSb3cpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENlbGxzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLm9uQ29sdW1uUmVzaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZ1bGxXaWR0aFJvdykge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ2VsbHMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUucmVmcmVzaENlbGxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc0FuaW1hdGlvbkZyYW1lKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENlbGxzSW5BbmltYXRpb25GcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uUmVmcmVzaFBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJlYW5zLnRhc2tRdWV1ZS5hZGRQMVRhc2sodGhpcy5yZWZyZXNoQ2VsbHNJbkFuaW1hdGlvbkZyYW1lLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5yZWZyZXNoQ2VsbHNJbkFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5SZWZyZXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgY2VudGVyQ29scyA9IHRoaXMuYmVhbnMuY29sdW1uQ29udHJvbGxlci5nZXRBbGxEaXNwbGF5ZWRDZW50ZXJWaXJ0dWFsQ29sdW1uc0ZvclJvdyh0aGlzLnJvd05vZGUpO1xuICAgICAgICB2YXIgbGVmdENvbHMgPSB0aGlzLmJlYW5zLmNvbHVtbkNvbnRyb2xsZXIuZ2V0RGlzcGxheWVkTGVmdENvbHVtbnNGb3JSb3codGhpcy5yb3dOb2RlKTtcbiAgICAgICAgdmFyIHJpZ2h0Q29scyA9IHRoaXMuYmVhbnMuY29sdW1uQ29udHJvbGxlci5nZXREaXNwbGF5ZWRSaWdodENvbHVtbnNGb3JSb3codGhpcy5yb3dOb2RlKTtcbiAgICAgICAgdGhpcy5pbnNlcnRDZWxsc0ludG9Db250YWluZXIodGhpcy5lQm9keVJvdywgY2VudGVyQ29scyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2VsbHNJbnRvQ29udGFpbmVyKHRoaXMuZVBpbm5lZExlZnRSb3csIGxlZnRDb2xzKTtcbiAgICAgICAgdGhpcy5pbnNlcnRDZWxsc0ludG9Db250YWluZXIodGhpcy5lUGlubmVkUmlnaHRSb3csIHJpZ2h0Q29scyk7XG4gICAgICAgIHZhciBjb2xJZHNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKHRoaXMuY2VsbENvbXBzKTtcbiAgICAgICAgY2VudGVyQ29scy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHsgcmV0dXJuIHV0aWxzXzEuXy5yZW1vdmVGcm9tQXJyYXkoY29sSWRzVG9SZW1vdmUsIGNvbC5nZXRJZCgpKTsgfSk7XG4gICAgICAgIGxlZnRDb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbCkgeyByZXR1cm4gdXRpbHNfMS5fLnJlbW92ZUZyb21BcnJheShjb2xJZHNUb1JlbW92ZSwgY29sLmdldElkKCkpOyB9KTtcbiAgICAgICAgcmlnaHRDb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbCkgeyByZXR1cm4gdXRpbHNfMS5fLnJlbW92ZUZyb21BcnJheShjb2xJZHNUb1JlbW92ZSwgY29sLmdldElkKCkpOyB9KTtcbiAgICAgICAgLy8gd2UgbmV2ZXIgcmVtb3ZlIGVkaXRpbmcgY2VsbHMsIGFzIHRoaXMgd291bGQgY2F1c2UgdGhlIGNlbGxzIHRvIGxvb3NlIHRoZWlyIHZhbHVlcyB3aGlsZSBlZGl0aW5nXG4gICAgICAgIC8vIGFzIHRoZSBncmlkIGlzIHNjcm9sbGluZyBob3Jpem9udGFsbHkuXG4gICAgICAgIGNvbElkc1RvUmVtb3ZlID0gdXRpbHNfMS5fLmZpbHRlcihjb2xJZHNUb1JlbW92ZSwgdGhpcy5pc0NlbGxFbGlnaWJsZVRvQmVSZW1vdmVkLmJpbmQodGhpcykpO1xuICAgICAgICAvLyByZW1vdmUgb2xkIGNlbGxzIGZyb20gZ3VpLCBidXQgd2UgZG9uJ3QgZGVzdHJveSB0aGVtLCB3ZSBtaWdodCB1c2UgdGhlbSBhZ2FpblxuICAgICAgICB0aGlzLnJlbW92ZVJlbmRlcmVkQ2VsbHMoY29sSWRzVG9SZW1vdmUpO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUucmVtb3ZlUmVuZGVyZWRDZWxscyA9IGZ1bmN0aW9uIChjb2xJZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29sSWRzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGNlbGxDb21wID0gX3RoaXMuY2VsbENvbXBzW2tleV07XG4gICAgICAgICAgICAvLyBjb3VsZCBiZSBvbGQgcmVmZXJlbmNlLCBpZSByZW1vdmVkIGNlbGxcbiAgICAgICAgICAgIGlmICh1dGlsc18xLl8ubWlzc2luZyhjZWxsQ29tcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsQ29tcC5kZXRhY2goKTtcbiAgICAgICAgICAgIGNlbGxDb21wLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIF90aGlzLmNlbGxDb21wc1trZXldID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5pc0NlbGxFbGlnaWJsZVRvQmVSZW1vdmVkID0gZnVuY3Rpb24gKGluZGV4U3RyKSB7XG4gICAgICAgIHZhciBkaXNwbGF5ZWRDb2x1bW5zID0gdGhpcy5iZWFucy5jb2x1bW5Db250cm9sbGVyLmdldEFsbERpc3BsYXllZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIFJFTU9WRV9DRUxMID0gdHJ1ZTtcbiAgICAgICAgdmFyIEtFRVBfQ0VMTCA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVuZGVyZWRDZWxsID0gdGhpcy5jZWxsQ29tcHNbaW5kZXhTdHJdO1xuICAgICAgICBpZiAoIXJlbmRlcmVkQ2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFJFTU9WRV9DRUxMO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsd2F5cyByZW1vdmUgdGhlIGNlbGwgaWYgaXQncyBpbiB0aGUgd3JvbmcgcGlubmVkIGxvY2F0aW9uXG4gICAgICAgIGlmICh0aGlzLmlzQ2VsbEluV3JvbmdSb3cocmVuZGVyZWRDZWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFJFTU9WRV9DRUxMO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gdHJ5IGFuZCBrZWVwIGVkaXRpbmcgYW5kIGZvY3VzZWQgY2VsbHNcbiAgICAgICAgdmFyIGVkaXRpbmcgPSByZW5kZXJlZENlbGwuaXNFZGl0aW5nKCk7XG4gICAgICAgIHZhciBmb2N1c2VkID0gdGhpcy5iZWFucy5mb2N1c2VkQ2VsbENvbnRyb2xsZXIuaXNDZWxsRm9jdXNlZChyZW5kZXJlZENlbGwuZ2V0R3JpZENlbGwoKSk7XG4gICAgICAgIHZhciBtaWdodFdhbnRUb0tlZXBDZWxsID0gZWRpdGluZyB8fCBmb2N1c2VkO1xuICAgICAgICBpZiAobWlnaHRXYW50VG9LZWVwQ2VsbCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHJlbmRlcmVkQ2VsbC5nZXRDb2x1bW4oKTtcbiAgICAgICAgICAgIHZhciBjZWxsU3RpbGxEaXNwbGF5ZWQgPSBkaXNwbGF5ZWRDb2x1bW5zLmluZGV4T2YoY29sdW1uKSA+PSAwO1xuICAgICAgICAgICAgcmV0dXJuIGNlbGxTdGlsbERpc3BsYXllZCA/IEtFRVBfQ0VMTCA6IFJFTU9WRV9DRUxMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFJFTU9WRV9DRUxMO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5lbnN1cmVDZWxsSW5Db3JyZWN0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNlbGxDb21wKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gY2VsbENvbXAuZ2V0R3VpKCk7XG4gICAgICAgIHZhciBjb2x1bW4gPSBjZWxsQ29tcC5nZXRDb2x1bW4oKTtcbiAgICAgICAgdmFyIHBpbm5lZFR5cGUgPSBjb2x1bW4uZ2V0UGlubmVkKCk7XG4gICAgICAgIHZhciBlQ29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXJGb3JDZWxsKHBpbm5lZFR5cGUpO1xuICAgICAgICAvLyBpZiBpbiB3cm9uZyBjb250YWluZXIsIHJlbW92ZSBpdFxuICAgICAgICB2YXIgZU9sZENvbnRhaW5lciA9IGNlbGxDb21wLmdldFBhcmVudFJvdygpO1xuICAgICAgICB2YXIgaW5Xcm9uZ1JvdyA9IGVPbGRDb250YWluZXIgIT09IGVDb250YWluZXI7XG4gICAgICAgIGlmIChpbldyb25nUm93KSB7XG4gICAgICAgICAgICAvLyB0YWtlIG91dCBmcm9tIG9sZCByb3dcbiAgICAgICAgICAgIGlmIChlT2xkQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgZU9sZENvbnRhaW5lci5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVDb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICBjZWxsQ29tcC5zZXRQYXJlbnRSb3coZUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmlzQ2VsbEluV3JvbmdSb3cgPSBmdW5jdGlvbiAoY2VsbENvbXApIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IGNlbGxDb21wLmdldENvbHVtbigpO1xuICAgICAgICB2YXIgcm93V2VXYW50ID0gdGhpcy5nZXRDb250YWluZXJGb3JDZWxsKGNvbHVtbi5nZXRQaW5uZWQoKSk7XG4gICAgICAgIC8vIGlmIGluIHdyb25nIGNvbnRhaW5lciwgcmVtb3ZlIGl0XG4gICAgICAgIHZhciBvbGRSb3cgPSBjZWxsQ29tcC5nZXRQYXJlbnRSb3coKTtcbiAgICAgICAgcmV0dXJuIG9sZFJvdyAhPT0gcm93V2VXYW50O1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuaW5zZXJ0Q2VsbHNJbnRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGVSb3csIGNvbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFlUm93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlbGxUZW1wbGF0ZXMgPSBbXTtcbiAgICAgICAgdmFyIG5ld0NlbGxDb21wcyA9IFtdO1xuICAgICAgICBjb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgdmFyIGNvbElkID0gY29sLmdldElkKCk7XG4gICAgICAgICAgICB2YXIgb2xkQ2VsbCA9IF90aGlzLmNlbGxDb21wc1tjb2xJZF07XG4gICAgICAgICAgICBpZiAob2xkQ2VsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVuc3VyZUNlbGxJbkNvcnJlY3RDb250YWluZXIob2xkQ2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVOZXdDZWxsKGNvbCwgZVJvdywgY2VsbFRlbXBsYXRlcywgbmV3Q2VsbENvbXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjZWxsVGVtcGxhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5hcHBlbmRIdG1sKGVSb3csIGNlbGxUZW1wbGF0ZXMuam9pbignJykpO1xuICAgICAgICAgICAgdGhpcy5jYWxsQWZ0ZXJSb3dBdHRhY2hlZE9uQ2VsbHMobmV3Q2VsbENvbXBzLCBlUm93KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuYWRkRG9tRGF0YSA9IGZ1bmN0aW9uIChlUm93Q29udGFpbmVyKSB7XG4gICAgICAgIHZhciBnb3cgPSB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlcjtcbiAgICAgICAgZ293LnNldERvbURhdGEoZVJvd0NvbnRhaW5lciwgUm93Q29tcC5ET01fREFUQV9LRVlfUkVOREVSRURfUk9XLCB0aGlzKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95RnVuYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnb3cuc2V0RG9tRGF0YShlUm93Q29udGFpbmVyLCBSb3dDb21wLkRPTV9EQVRBX0tFWV9SRU5ERVJFRF9ST1csIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmNyZWF0ZU5ld0NlbGwgPSBmdW5jdGlvbiAoY29sLCBlQ29udGFpbmVyLCBjZWxsVGVtcGxhdGVzLCBuZXdDZWxsQ29tcHMpIHtcbiAgICAgICAgdmFyIG5ld0NlbGxDb21wID0gbmV3IGNlbGxDb21wXzEuQ2VsbENvbXAodGhpcy5zY29wZSwgdGhpcy5iZWFucywgY29sLCB0aGlzLnJvd05vZGUsIHRoaXMpO1xuICAgICAgICB2YXIgY2VsbFRlbXBsYXRlID0gbmV3Q2VsbENvbXAuZ2V0Q3JlYXRlVGVtcGxhdGUoKTtcbiAgICAgICAgY2VsbFRlbXBsYXRlcy5wdXNoKGNlbGxUZW1wbGF0ZSk7XG4gICAgICAgIG5ld0NlbGxDb21wcy5wdXNoKG5ld0NlbGxDb21wKTtcbiAgICAgICAgdGhpcy5jZWxsQ29tcHNbY29sLmdldElkKCldID0gbmV3Q2VsbENvbXA7XG4gICAgICAgIG5ld0NlbGxDb21wLnNldFBhcmVudFJvdyhlQ29udGFpbmVyKTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLm9uTW91c2VFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIG1vdXNlRXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uUm93RGJsQ2xpY2sobW91c2VFdmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgdGhpcy5vblJvd0NsaWNrKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5jcmVhdGVSb3dFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBkb21FdmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMucm93Tm9kZSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMucm93Tm9kZS5kYXRhLFxuICAgICAgICAgICAgcm93SW5kZXg6IHRoaXMucm93Tm9kZS5yb3dJbmRleCxcbiAgICAgICAgICAgIHJvd1Bpbm5lZDogdGhpcy5yb3dOb2RlLnJvd1Bpbm5lZCxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgIGFwaTogdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbHVtbkFwaSgpLFxuICAgICAgICAgICAgZXZlbnQ6IGRvbUV2ZW50XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5jcmVhdGVSb3dFdmVudFdpdGhTb3VyY2UgPSBmdW5jdGlvbiAodHlwZSwgZG9tRXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5jcmVhdGVSb3dFdmVudCh0eXBlLCBkb21FdmVudCk7XG4gICAgICAgIC8vIHdoZW4gZmlyc3QgZGV2ZWxvcGluZyB0aGlzLCB3ZSBpbmNsdWRlZCB0aGUgcm93Q29tcCBpbiB0aGUgZXZlbnQuXG4gICAgICAgIC8vIHRoaXMgc2VlbXMgdmVyeSB3ZWlyZC4gc28gd2hlbiBpbnRyb2R1Y2luZyB0aGUgZXZlbnQgdHlwZXMsIGkgbGVmdCB0aGUgJ3NvdXJjZSdcbiAgICAgICAgLy8gb3V0IG9mIHRoZSB0eXBlLCBhbmQganVzdCBpbmNsdWRlIHRoZSBzb3VyY2UgaW4gdGhlIHR3byBwbGFjZXMgd2hlcmUgdGhpcyBldmVudFxuICAgICAgICAvLyB3YXMgZmlyZWQgKHJvd0NsaWNrZWQgYW5kIHJvd0RvdWJsZUNsaWNrZWQpLiBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIGFueVxuICAgICAgICAvLyB1c2VycyB0byBiZSB1c2luZyB0aGlzLCBhcyB0aGUgcm93Q29tcCBpc24ndCBhbiBvYmplY3Qgd2UgZXhwb3NlLCBzbyB3b3VsZCBiZVxuICAgICAgICAvLyB2ZXJ5IHN1cnByaXNpbmcgaWYgYSB1c2VyIHdhcyB1c2luZyBpdC5cbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUub25Sb3dEYmxDbGljayA9IGZ1bmN0aW9uIChtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBhZ0V2ZW50ID0gdGhpcy5jcmVhdGVSb3dFdmVudFdpdGhTb3VyY2UoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1JPV19ET1VCTEVfQ0xJQ0tFRCwgbW91c2VFdmVudCk7XG4gICAgICAgIHRoaXMuYmVhbnMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoYWdFdmVudCk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5vblJvd0NsaWNrID0gZnVuY3Rpb24gKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIGFnRXZlbnQgPSB0aGlzLmNyZWF0ZVJvd0V2ZW50V2l0aFNvdXJjZShldmVudHNfMS5FdmVudHMuRVZFTlRfUk9XX0NMSUNLRUQsIG1vdXNlRXZlbnQpO1xuICAgICAgICB0aGlzLmJlYW5zLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGFnRXZlbnQpO1xuICAgICAgICAvLyBjdHJsS2V5IGZvciB3aW5kb3dzLCBtZXRhS2V5IGZvciBBcHBsZVxuICAgICAgICB2YXIgbXVsdGlTZWxlY3RLZXlQcmVzc2VkID0gbW91c2VFdmVudC5jdHJsS2V5IHx8IG1vdXNlRXZlbnQubWV0YUtleTtcbiAgICAgICAgdmFyIHNoaWZ0S2V5UHJlc3NlZCA9IG1vdXNlRXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIC8vIHdlIGRvIG5vdCBhbGxvdyBzZWxlY3RpbmcgZ3JvdXBzIGJ5IGNsaWNraW5nIChhcyB0aGUgY2xpY2sgaGVyZSBleHBhbmRzIHRoZSBncm91cClcbiAgICAgICAgLy8gc28gcmV0dXJuIGlmIGl0J3MgYSBncm91cCByb3dcbiAgICAgICAgaWYgKHRoaXMucm93Tm9kZS5ncm91cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGFsc28gZG9uJ3QgYWxsb3cgc2VsZWN0aW9uIG9mIHBpbm5lZCByb3dzXG4gICAgICAgIGlmICh0aGlzLnJvd05vZGUucm93UGlubmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm8gc2VsZWN0aW9uIG1ldGhvZCBlbmFibGVkLCBkbyBub3RoaW5nXG4gICAgICAgIGlmICghdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNSb3dTZWxlY3Rpb24oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGNsaWNrIHNlbGVjdGlvbiBzdXBwcmVzc2VkLCBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzUm93Q2xpY2tTZWxlY3Rpb24oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvd05vZGUuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICBpZiAobXVsdGlTZWxlY3RLZXlQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzUm93RGVzZWxlY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd05vZGUuc2V0U2VsZWN0ZWRQYXJhbXMoeyBuZXdWYWx1ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0ZWQgd2l0aCBubyBtdWx0aSBrZXksIG11c3QgbWFrZSBzdXJlIGFueXRoaW5nIGVsc2UgaXMgdW5zZWxlY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMucm93Tm9kZS5zZXRTZWxlY3RlZFBhcmFtcyh7IG5ld1ZhbHVlOiB0cnVlLCBjbGVhclNlbGVjdGlvbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm93Tm9kZS5zZXRTZWxlY3RlZFBhcmFtcyh7IG5ld1ZhbHVlOiB0cnVlLCBjbGVhclNlbGVjdGlvbjogIW11bHRpU2VsZWN0S2V5UHJlc3NlZCwgcmFuZ2VTZWxlY3Q6IHNoaWZ0S2V5UHJlc3NlZCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuY3JlYXRlRnVsbFdpZHRoUm93Q29udGFpbmVyID0gZnVuY3Rpb24gKHJvd0NvbnRhaW5lckNvbXAsIHBpbm5lZCwgZXh0cmFDc3NDbGFzcywgY2VsbFJlbmRlcmVyVHlwZSwgZVJvd0NhbGxiYWNrLCBjZWxsUmVuZGVyZXJDYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcm93VGVtcGxhdGUgPSB0aGlzLmNyZWF0ZVRlbXBsYXRlKCcnLCBleHRyYUNzc0NsYXNzKTtcbiAgICAgICAgcm93Q29udGFpbmVyQ29tcC5hcHBlbmRSb3dUZW1wbGF0ZShyb3dUZW1wbGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVSb3cgPSByb3dDb250YWluZXJDb21wLmdldFJvd0VsZW1lbnQoX3RoaXMuZ2V0Q29tcElkKCkpO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IF90aGlzLmNyZWF0ZUZ1bGxXaWR0aFBhcmFtcyhlUm93LCBwaW5uZWQpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGNlbGxSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0FsaXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGd1aSA9IGNlbGxSZW5kZXJlci5nZXRHdWkoKTtcbiAgICAgICAgICAgICAgICAgICAgZVJvdy5hcHBlbmRDaGlsZChndWkpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsUmVuZGVyZXJDYWxsYmFjayhjZWxsUmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxSZW5kZXJlci5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsUmVuZGVyZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLmJlYW5zLmNvbXBvbmVudFJlc29sdmVyLmNyZWF0ZUFnR3JpZENvbXBvbmVudChudWxsLCBwYXJhbXMsIGNlbGxSZW5kZXJlclR5cGUpLnRoZW4oY2FsbGJhY2spO1xuICAgICAgICAgICAgX3RoaXMuYWZ0ZXJSb3dBdHRhY2hlZChyb3dDb250YWluZXJDb21wLCBlUm93KTtcbiAgICAgICAgICAgIGVSb3dDYWxsYmFjayhlUm93KTtcbiAgICAgICAgICAgIF90aGlzLmFuZ3VsYXIxQ29tcGlsZShlUm93KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5hbmd1bGFyMUNvbXBpbGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgICAgICAgdGhpcy5iZWFucy4kY29tcGlsZShlbGVtZW50KSh0aGlzLnNjb3BlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuY3JlYXRlRnVsbFdpZHRoUGFyYW1zID0gZnVuY3Rpb24gKGVSb3csIHBpbm5lZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgZnVsbFdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5yb3dOb2RlLmRhdGEsXG4gICAgICAgICAgICBub2RlOiB0aGlzLnJvd05vZGUsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5yb3dOb2RlLmtleSxcbiAgICAgICAgICAgICRzY29wZTogdGhpcy5zY29wZSxcbiAgICAgICAgICAgIHJvd0luZGV4OiB0aGlzLnJvd05vZGUucm93SW5kZXgsXG4gICAgICAgICAgICBhcGk6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb2x1bW5BcGkoKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgIC8vIHRoZXNlIG5lZWQgdG8gYmUgdGFrZW4gb3V0LCBhcyBwYXJ0IG9mICdhZnRlckF0dGFjaGVkJyBub3dcbiAgICAgICAgICAgIGVHcmlkQ2VsbDogZVJvdyxcbiAgICAgICAgICAgIGVQYXJlbnRPZlZhbHVlOiBlUm93LFxuICAgICAgICAgICAgcGlubmVkOiBwaW5uZWQsXG4gICAgICAgICAgICBhZGRSZW5kZXJlZFJvd0xpc3RlbmVyOiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIuYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuZ2V0SW5pdGlhbFJvd0NsYXNzZXMgPSBmdW5jdGlvbiAoZXh0cmFDc3NDbGFzcykge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xuICAgICAgICBpZiAodXRpbHNfMS5fLmV4aXN0cyhleHRyYUNzc0NsYXNzKSkge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGV4dHJhQ3NzQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzZXMucHVzaCgnYWctcm93Jyk7XG4gICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLnJvd0ZvY3VzZWQgPyAnYWctcm93LWZvY3VzJyA6ICdhZy1yb3ctbm8tZm9jdXMnKTtcbiAgICAgICAgaWYgKHRoaXMuZmFkZVJvd0luKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2FnLW9wYWNpdHktemVybycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvd0lzRXZlbikge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhZy1yb3ctZXZlbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhZy1yb3ctb2RkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzQW5pbWF0ZVJvd3MoKSkge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhZy1yb3ctYW5pbWF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2FnLXJvdy1uby1hbmltYXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb3dOb2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhZy1yb3ctc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb3dOb2RlLmdyb3VwKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2FnLXJvdy1ncm91cCcpO1xuICAgICAgICAgICAgLy8gaWYgYSBncm91cCwgcHV0IHRoZSBsZXZlbCBvZiB0aGUgZ3JvdXAgaW5cbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnYWctcm93LWxldmVsLScgKyB0aGlzLnJvd05vZGUubGV2ZWwpO1xuICAgICAgICAgICAgaWYgKHRoaXMucm93Tm9kZS5mb290ZXIpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2FnLXJvdy1mb290ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGEgbGVhZiwgYW5kIGEgcGFyZW50IGV4aXN0cywgcHV0IGEgbGV2ZWwgb2YgdGhlIHBhcmVudCwgZWxzZSBwdXQgbGV2ZWwgb2YgMCBmb3IgdG9wIGxldmVsIGl0ZW1cbiAgICAgICAgICAgIGlmICh0aGlzLnJvd05vZGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhZy1yb3ctbGV2ZWwtJyArICh0aGlzLnJvd05vZGUucGFyZW50LmxldmVsICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhZy1yb3ctbGV2ZWwtMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvd05vZGUuc3R1Yikge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhZy1yb3ctc3R1YicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZ1bGxXaWR0aFJvdykge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhZy1mdWxsLXdpZHRoLXJvdycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvd05vZGUuZ3JvdXAgJiYgIXRoaXMucm93Tm9kZS5mb290ZXIpIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLnJvd05vZGUuZXhwYW5kZWQgPyAnYWctcm93LWdyb3VwLWV4cGFuZGVkJyA6ICdhZy1yb3ctZ3JvdXAtY29udHJhY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxzXzEuXy5wdXNoQWxsKGNsYXNzZXMsIHRoaXMucHJvY2Vzc0NsYXNzZXNGcm9tR3JpZE9wdGlvbnMoKSk7XG4gICAgICAgIHV0aWxzXzEuXy5wdXNoQWxsKGNsYXNzZXMsIHRoaXMucHJlUHJvY2Vzc1Jvd0NsYXNzUnVsZXMoKSk7XG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUucHJlUHJvY2Vzc1Jvd0NsYXNzUnVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUm93Q2xhc3NSdWxlcyhmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXMucHVzaChjbGFzc05hbWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAvLyBub3QgY2F0ZXJlZCBmb3IsIGlmIGNyZWF0aW5nLCBubyBuZWVkXG4gICAgICAgICAgICAvLyB0byByZW1vdmUgY2xhc3MgYXMgaXQgd2FzIG5ldmVyIHRoZXJlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUucHJvY2Vzc1Jvd0NsYXNzUnVsZXMgPSBmdW5jdGlvbiAob25BcHBsaWNhYmxlQ2xhc3MsIG9uTm90QXBwbGljYWJsZUNsYXNzKSB7XG4gICAgICAgIHRoaXMuYmVhbnMuc3R5bGluZ1NlcnZpY2UucHJvY2Vzc0NsYXNzUnVsZXModGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIucm93Q2xhc3NSdWxlcygpLCB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLnJvd05vZGUuZGF0YSxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMucm93Tm9kZSxcbiAgICAgICAgICAgIHJvd0luZGV4OiB0aGlzLnJvd05vZGUucm93SW5kZXgsXG4gICAgICAgICAgICBhcGk6IHRoaXMuYmVhbnMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpXG4gICAgICAgIH0sIG9uQXBwbGljYWJsZUNsYXNzLCBvbk5vdEFwcGxpY2FibGVDbGFzcyk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5zdG9wRWRpdGluZyA9IGZ1bmN0aW9uIChjYW5jZWwpIHtcbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gdm9pZCAwKSB7IGNhbmNlbCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuZm9yRWFjaENlbGxDb21wKGZ1bmN0aW9uIChyZW5kZXJlZENlbGwpIHtcbiAgICAgICAgICAgIHJlbmRlcmVkQ2VsbC5zdG9wRWRpdGluZyhjYW5jZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGluZ1Jvdykge1xuICAgICAgICAgICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMSA9IHRoaXMuY3JlYXRlUm93RXZlbnQoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1JPV19WQUxVRV9DSEFOR0VEKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJlYW5zLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRFZGl0aW5nUm93KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuc2V0RWRpdGluZ1JvdyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVkaXRpbmdSb3cgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5lQWxsUm93Q29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKHJvdywgJ2FnLXJvdy1lZGl0aW5nJywgdmFsdWUpOyB9KTtcbiAgICAgICAgdmFyIGV2ZW50ID0gdmFsdWUgP1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVSb3dFdmVudChldmVudHNfMS5FdmVudHMuRVZFTlRfUk9XX0VESVRJTkdfU1RBUlRFRClcbiAgICAgICAgICAgIDogdGhpcy5jcmVhdGVSb3dFdmVudChldmVudHNfMS5FdmVudHMuRVZFTlRfUk9XX0VESVRJTkdfU1RPUFBFRCk7XG4gICAgICAgIHRoaXMuYmVhbnMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuc3RhcnRSb3dFZGl0aW5nID0gZnVuY3Rpb24gKGtleVByZXNzLCBjaGFyUHJlc3MsIHNvdXJjZVJlbmRlcmVkQ2VsbCkge1xuICAgICAgICBpZiAoa2V5UHJlc3MgPT09IHZvaWQgMCkgeyBrZXlQcmVzcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGNoYXJQcmVzcyA9PT0gdm9pZCAwKSB7IGNoYXJQcmVzcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHNvdXJjZVJlbmRlcmVkQ2VsbCA9PT0gdm9pZCAwKSB7IHNvdXJjZVJlbmRlcmVkQ2VsbCA9IG51bGw7IH1cbiAgICAgICAgLy8gZG9uJ3QgZG8gaXQgaWYgYWxyZWFkeSBlZGl0aW5nXG4gICAgICAgIGlmICh0aGlzLmVkaXRpbmdSb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvckVhY2hDZWxsQ29tcChmdW5jdGlvbiAocmVuZGVyZWRDZWxsKSB7XG4gICAgICAgICAgICB2YXIgY2VsbFN0YXJ0ZWRFZGl0ID0gcmVuZGVyZWRDZWxsID09PSBzb3VyY2VSZW5kZXJlZENlbGw7XG4gICAgICAgICAgICBpZiAoY2VsbFN0YXJ0ZWRFZGl0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRDZWxsLnN0YXJ0RWRpdGluZ0lmRW5hYmxlZChrZXlQcmVzcywgY2hhclByZXNzLCBjZWxsU3RhcnRlZEVkaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRDZWxsLnN0YXJ0RWRpdGluZ0lmRW5hYmxlZChudWxsLCBudWxsLCBjZWxsU3RhcnRlZEVkaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRFZGl0aW5nUm93KHRydWUpO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuZm9yRWFjaENlbGxDb21wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHV0aWxzXzEuXy5pdGVyYXRlT2JqZWN0KHRoaXMuY2VsbENvbXBzLCBmdW5jdGlvbiAoa2V5LCBjZWxsQ29tcCkge1xuICAgICAgICAgICAgaWYgKGNlbGxDb21wKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY2VsbENvbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLnBvc3RQcm9jZXNzQ2xhc3Nlc0Zyb21HcmlkT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNzc0NsYXNzZXMgPSB0aGlzLnByb2Nlc3NDbGFzc2VzRnJvbUdyaWRPcHRpb25zKCk7XG4gICAgICAgIGlmIChjc3NDbGFzc2VzKSB7XG4gICAgICAgICAgICBjc3NDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzU3RyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZUFsbFJvd0NvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiB1dGlsc18xLl8uYWRkQ3NzQ2xhc3Mocm93LCBjbGFzc1N0cik7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLnBvc3RQcm9jZXNzUm93Q2xhc3NSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm9jZXNzUm93Q2xhc3NSdWxlcyhmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBfdGhpcy5lQWxsUm93Q29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHV0aWxzXzEuXy5hZGRDc3NDbGFzcyhyb3csIGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBfdGhpcy5lQWxsUm93Q29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHV0aWxzXzEuXy5yZW1vdmVDc3NDbGFzcyhyb3csIGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLnByb2Nlc3NDbGFzc2VzRnJvbUdyaWRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gKHJvd0NsYXNzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvd0NsYXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHJvd0NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocm93Q2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgcm93Q2xhc3MuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcmVzLnB1c2goZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBwYXJ0IDEgLSByb3dDbGFzc1xuICAgICAgICB2YXIgcm93Q2xhc3MgPSB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRSb3dDbGFzcygpO1xuICAgICAgICBpZiAocm93Q2xhc3MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm93Q2xhc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IHJvd0NsYXNzIHNob3VsZCBub3QgYmUgYSBmdW5jdGlvbiwgcGxlYXNlIHVzZSBnZXRSb3dDbGFzcyBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzcyhyb3dDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydCAyIC0gcm93Q2xhc3NGdW5jXG4gICAgICAgIHZhciByb3dDbGFzc0Z1bmMgPSB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRSb3dDbGFzc0Z1bmMoKTtcbiAgICAgICAgaWYgKHJvd0NsYXNzRnVuYykge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiB0aGlzLnJvd05vZGUsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5yb3dOb2RlLmRhdGEsXG4gICAgICAgICAgICAgICAgcm93SW5kZXg6IHRoaXMucm93Tm9kZS5yb3dJbmRleCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICAgICAgYXBpOiB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBcGkoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByb3dDbGFzc0Z1bmNSZXN1bHQgPSByb3dDbGFzc0Z1bmMocGFyYW1zKTtcbiAgICAgICAgICAgIHByb2Nlc3Mocm93Q2xhc3NGdW5jUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUucHJlUHJvY2Vzc1N0eWxlc0Zyb21HcmlkT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd1N0eWxlcyA9IHRoaXMucHJvY2Vzc1N0eWxlc0Zyb21HcmlkT3B0aW9ucygpO1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5fLmNzc1N0eWxlT2JqZWN0VG9NYXJrdXAocm93U3R5bGVzKTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLnBvc3RQcm9jZXNzU3R5bGVzRnJvbUdyaWRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93U3R5bGVzID0gdGhpcy5wcm9jZXNzU3R5bGVzRnJvbUdyaWRPcHRpb25zKCk7XG4gICAgICAgIHRoaXMuZUFsbFJvd0NvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiB1dGlsc18xLl8uYWRkU3R5bGVzVG9FbGVtZW50KHJvdywgcm93U3R5bGVzKTsgfSk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5wcm9jZXNzU3R5bGVzRnJvbUdyaWRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBwYXJ0IDEgLSByb3dTdHlsZVxuICAgICAgICB2YXIgcm93U3R5bGUgPSB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5nZXRSb3dTdHlsZSgpO1xuICAgICAgICBpZiAocm93U3R5bGUgJiYgdHlwZW9mIHJvd1N0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogcm93U3R5bGUgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgc3R5bGVzLCBub3QgYmUgYSBmdW5jdGlvbiwgdXNlIGdldFJvd1N0eWxlKCkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnQgMSAtIHJvd1N0eWxlRnVuY1xuICAgICAgICB2YXIgcm93U3R5bGVGdW5jID0gdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Um93U3R5bGVGdW5jKCk7XG4gICAgICAgIHZhciByb3dTdHlsZUZ1bmNSZXN1bHQ7XG4gICAgICAgIGlmIChyb3dTdHlsZUZ1bmMpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5yb3dOb2RlLmRhdGEsXG4gICAgICAgICAgICAgICAgbm9kZTogdGhpcy5yb3dOb2RlLFxuICAgICAgICAgICAgICAgIGFwaTogdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCksXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5iZWFucy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgICRzY29wZTogdGhpcy5zY29wZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvd1N0eWxlRnVuY1Jlc3VsdCA9IHJvd1N0eWxlRnVuYyhwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsc18xLl8uYXNzaWduKHt9LCByb3dTdHlsZSwgcm93U3R5bGVGdW5jUmVzdWx0KTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmNyZWF0ZUNlbGxzID0gZnVuY3Rpb24gKGNvbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRlbXBsYXRlUGFydHMgPSBbXTtcbiAgICAgICAgdmFyIG5ld0NlbGxDb21wcyA9IFtdO1xuICAgICAgICBjb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgdmFyIG5ld0NlbGxDb21wID0gbmV3IGNlbGxDb21wXzEuQ2VsbENvbXAoX3RoaXMuc2NvcGUsIF90aGlzLmJlYW5zLCBjb2wsIF90aGlzLnJvd05vZGUsIF90aGlzKTtcbiAgICAgICAgICAgIHZhciBjZWxsVGVtcGxhdGUgPSBuZXdDZWxsQ29tcC5nZXRDcmVhdGVUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgdGVtcGxhdGVQYXJ0cy5wdXNoKGNlbGxUZW1wbGF0ZSk7XG4gICAgICAgICAgICBuZXdDZWxsQ29tcHMucHVzaChuZXdDZWxsQ29tcCk7XG4gICAgICAgICAgICBfdGhpcy5jZWxsQ29tcHNbY29sLmdldElkKCldID0gbmV3Q2VsbENvbXA7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdGVtcGxhdGVBbmRDb21wcyA9IHtcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZVBhcnRzLmpvaW4oJycpLFxuICAgICAgICAgICAgY2VsbENvbXBzOiBuZXdDZWxsQ29tcHNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlQW5kQ29tcHM7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5vblJvd1NlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLnJvd05vZGUuaXNTZWxlY3RlZCgpO1xuICAgICAgICB0aGlzLmVBbGxSb3dDb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gdXRpbHNfMS5fLmFkZE9yUmVtb3ZlQ3NzQ2xhc3Mocm93LCAnYWctcm93LXNlbGVjdGVkJywgc2VsZWN0ZWQpOyB9KTtcbiAgICB9O1xuICAgIC8vIGNhbGxlZDpcbiAgICAvLyArIGFmdGVyIHJvdyBjcmVhdGVkIGZvciBmaXJzdCB0aW1lXG4gICAgLy8gKyBhZnRlciBob3Jpem9udGFsIHNjcm9sbCwgc28gbmV3IGNlbGxzIGR1ZSB0byBjb2x1bW4gdmlydHVhbGlzYXRpb25cbiAgICBSb3dDb21wLnByb3RvdHlwZS5jYWxsQWZ0ZXJSb3dBdHRhY2hlZE9uQ2VsbHMgPSBmdW5jdGlvbiAobmV3Q2VsbENvbXBzLCBlUm93KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG5ld0NlbGxDb21wcy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsQ29tcCkge1xuICAgICAgICAgICAgY2VsbENvbXAuc2V0UGFyZW50Um93KGVSb3cpO1xuICAgICAgICAgICAgY2VsbENvbXAuYWZ0ZXJBdHRhY2hlZCgpO1xuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGVkaXRpbmcgdGhlIHJvdywgdGhlbiB0aGUgY2VsbCBuZWVkcyB0byB0dXJuXG4gICAgICAgICAgICAvLyBpbnRvIGVkaXQgbW9kZVxuICAgICAgICAgICAgaWYgKF90aGlzLmVkaXRpbmdSb3cpIHtcbiAgICAgICAgICAgICAgICBjZWxsQ29tcC5zdGFydEVkaXRpbmdJZkVuYWJsZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5hZnRlclJvd0F0dGFjaGVkID0gZnVuY3Rpb24gKHJvd0NvbnRhaW5lckNvbXAsIGVSb3cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hZGREb21EYXRhKGVSb3cpO1xuICAgICAgICB0aGlzLnJlbW92ZVNlY29uZFBhc3NGdW5jcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGVSb3cpO1xuICAgICAgICAgICAgcm93Q29udGFpbmVyQ29tcC5yZW1vdmVSb3dFbGVtZW50KGVSb3cpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW1vdmVGaXJzdFBhc3NGdW5jcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLl8uZXhpc3RzKF90aGlzLnJvd05vZGUucm93VG9wKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSByb3cgdG9wIGlzIHVwZGF0ZWQgYW55d2F5LCBob3dldmVyIHdlIHNldCBpdCBoZXJlIGFnYWluXG4gICAgICAgICAgICAgICAgLy8gdG8gc29tZXRoaW5nIG1vcmUgcmVhc29uYWJsZSBmb3IgdGhlIGFuaW1hdGlvbiAtIGllIGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJvdyB0b3AgaXMgMTAwMDBweCBhd2F5LCB0aGUgcm93IHdpbGwgZmxhc2ggb3V0LCBzbyB0aGlzXG4gICAgICAgICAgICAgICAgLy8gZ2l2ZXMgaXQgYSByb3VuZGVkIHZhbHVlLCBzbyByb3cgYW5pbWF0ZXMgb3V0IG1vcmUgc2xvd2x5XG4gICAgICAgICAgICAgICAgdmFyIHJvd1RvcCA9IF90aGlzLnJvdW5kUm93VG9wVG9Cb3VuZHMoX3RoaXMucm93Tm9kZS5yb3dUb3ApO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFJvd1RvcChyb3dUb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5fLmFkZENzc0NsYXNzKGVSb3csICdhZy1vcGFjaXR5LXplcm8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZUFsbFJvd0NvbnRhaW5lcnMucHVzaChlUm93KTtcbiAgICAgICAgLy8gYWRkaW5nIGhvdmVyIGZ1bmN0aW9uYWxpdHkgYWRkcyBsaXN0ZW5lciB0byB0aGlzIHJvdywgc28gd2VcbiAgICAgICAgLy8gZG8gaXQgbGF6aWx5IGluIGFuIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAodGhpcy51c2VBbmltYXRpb25GcmFtZUZvckNyZWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5iZWFucy50YXNrUXVldWUuYWRkUDFUYXNrKHRoaXMuYWRkSG92ZXJGdW5jdGlvbmFsaXR5LmJpbmQodGhpcywgZVJvdykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRIb3ZlckZ1bmN0aW9uYWxpdHkoZVJvdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmFkZEhvdmVyRnVuY3Rpb25hbGl0eSA9IGZ1bmN0aW9uIChlUm93KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgdXNlIGFuaW1hdGlvbiBmcmFtZXMgdG8gZG8gdGhpcywgaXQncyBwb3NzaWJsZSB0aGUgcm93IG5vIGxvbmdlciBleGlzdHNcbiAgICAgICAgLy8gYnkgdGhlIHRpbWUgd2UgZ2V0IHRvIGFkZCBpdFxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmVjYXVzZSBtb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlIGRvIG5vdCBwcm9wYWdhdGUsIHdlIGNhbm5vdCBsaXN0ZW4gb24gdGhlIGdyaWRQYW5lbFxuICAgICAgICAvLyBsaWtlIHdlIGRvIGZvciBhbGwgdGhlIG90aGVyIG1vdXNlIGV2ZW50cy5cbiAgICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgcGlubmluZywgd2UgY2Fubm90IHNpbXBseSBhZGQgLyByZW1vdmUgdGhlIGNsYXNzIGJhc2VkIG9uIHRoZSBlUm93LiB3ZVxuICAgICAgICAvLyBoYXZlIHRvIGNoZWNrIGFsbCBlUm93J3MgKGJvZHkgJiBwaW5uZWQpLiBzbyB0aGUgdHJpY2sgaXMgaWYgYW55IG9mIHRoZSByb3dzIGdldHMgYVxuICAgICAgICAvLyBtb3VzZSBob3ZlciwgaXQgc2V0cyBzdWNoIGluIHRoZSByb3dOb2RlLCBhbmQgdGhlbiBhbGwgdGhyZWUgcmVmbGVjdCB0aGUgY2hhbmdlIGFzXG4gICAgICAgIC8vIGFsbCBhcmUgbGlzdGVuaW5nIGZvciBldmVudCBvbiB0aGUgcm93IG5vZGUuXG4gICAgICAgIC8vIHN0ZXAgMSAtIGFkZCBsaXN0ZW5lciwgdG8gc2V0IGZsYWcgb24gcm93IG5vZGVcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoZVJvdywgJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yb3dOb2RlLm9uTW91c2VFbnRlcigpOyB9KTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoZVJvdywgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yb3dOb2RlLm9uTW91c2VMZWF2ZSgpOyB9KTtcbiAgICAgICAgLy8gc3RlcCAyIC0gbGlzdGVuIGZvciBjaGFuZ2VzIG9uIHJvdyBub2RlICh3aGljaCBhbnkgZVJvdyBjYW4gdHJpZ2dlcilcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5yb3dOb2RlLCByb3dOb2RlXzEuUm93Tm9kZS5FVkVOVF9NT1VTRV9FTlRFUiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXRpbHNfMS5fLmFkZENzc0NsYXNzKGVSb3csICdhZy1yb3ctaG92ZXInKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMucm93Tm9kZSwgcm93Tm9kZV8xLlJvd05vZGUuRVZFTlRfTU9VU0VfTEVBVkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuXy5yZW1vdmVDc3NDbGFzcyhlUm93LCAnYWctcm93LWhvdmVyJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gZm9yIGFuaW1hdGlvbiwgd2UgZG9uJ3Qgd2FudCB0byBhbmltYXRlIGVudHJ5IG9yIGV4aXQgdG8gYSB2ZXJ5IGZhciBhd2F5IHBpeGVsLFxuICAgIC8vIG90aGVyd2lzZSB0aGUgcm93IHdvdWxkIG1vdmUgc28gZmFzdCwgaXQgd291bGQgYXBwZWFyIHRvIGRpc2FwcGVhci4gc28gdGhpcyBtZXRob2RcbiAgICAvLyBtb3ZlcyB0aGUgcm93IGNsb3NlciB0byB0aGUgdmlld3BvcnQgaWYgaXQgaXMgZmFyIGF3YXksIHNvIHRoZSByb3cgc2xpZGUgaW4gLyBvdXRcbiAgICAvLyBhdCBhIHNwZWVkIHRoZSB1c2VyIGNhbiBzZWUuXG4gICAgUm93Q29tcC5wcm90b3R5cGUucm91bmRSb3dUb3BUb0JvdW5kcyA9IGZ1bmN0aW9uIChyb3dUb3ApIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5iZWFucy5ncmlkUGFuZWwuZ2V0VmVydGljYWxQaXhlbFJhbmdlKCk7XG4gICAgICAgIHZhciBtaW5QaXhlbCA9IHJhbmdlLnRvcCAtIDEwMDtcbiAgICAgICAgdmFyIG1heFBpeGVsID0gcmFuZ2UuYm90dG9tICsgMTAwO1xuICAgICAgICBpZiAocm93VG9wIDwgbWluUGl4ZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW5QaXhlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3dUb3AgPiBtYXhQaXhlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heFBpeGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJvd1RvcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUub25Sb3dIZWlnaHRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgZXhpc3RzIGZpcnN0IC0gaWYgdGhlIHVzZXIgaXMgcmVzZXR0aW5nIHRoZSByb3cgaGVpZ2h0LCB0aGVuXG4gICAgICAgIC8vIGl0IHdpbGwgYmUgbnVsbCAob3IgdW5kZWZpbmVkKSBtb21lbnRhcmlseSB1bnRpbCB0aGUgbmV4dCB0aW1lIHRoZSBmbGF0dGVuXG4gICAgICAgIC8vIHN0YWdlIGlzIGNhbGxlZCB3aGVyZSB0aGUgcm93IHdpbGwgdGhlbiB1cGRhdGUgYWdhaW4gd2l0aCBhIG5ldyBoZWlnaHRcbiAgICAgICAgaWYgKHV0aWxzXzEuXy5leGlzdHModGhpcy5yb3dOb2RlLnJvd0hlaWdodCkpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHRQeF8xID0gdGhpcy5yb3dOb2RlLnJvd0hlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmVBbGxSb3dDb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93LnN0eWxlLmhlaWdodCA9IGhlaWdodFB4XzE7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ3JlbmRlcmVkUm93UmVtb3ZlZCcgfHwgZXZlbnRUeXBlID09PSAncm93UmVtb3ZlZCcpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9WSVJUVUFMX1JPV19SRU1PVkVEO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBTaW5jZSB2ZXJzaW9uIDExLCBldmVudCByZW5kZXJlZFJvd1JlbW92ZWQgaXMgbm93IGNhbGxlZCAnICsgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1ZJUlRVQUxfUk9XX1JFTU9WRUQpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICdyZW5kZXJlZFJvd1JlbW92ZWQnIHx8IGV2ZW50VHlwZSA9PT0gJ3Jvd1JlbW92ZWQnKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSBldmVudHNfMS5FdmVudHMuRVZFTlRfVklSVFVBTF9ST1dfUkVNT1ZFRDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogU2luY2UgdmVyc2lvbiAxMSwgZXZlbnQgcmVuZGVyZWRSb3dSZW1vdmVkIGFuZCByb3dSZW1vdmVkIGlzIG5vdyBjYWxsZWQgJyArIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9WSVJUVUFMX1JPV19SRU1PVkVEKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmRlc3Ryb3lTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGFuaW1hdGUpIHtcbiAgICAgICAgaWYgKGFuaW1hdGUgPT09IHZvaWQgMCkgeyBhbmltYXRlID0gZmFsc2U7IH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveVNjb3BlKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIHdoeSBkbyB3ZSBoYXZlIHRoaXMgbWV0aG9kPyBzaG91bGRuJ3QgZXZlcnl0aGluZyBiZWxvdyBiZSBhZGRlZCBhcyBhIGRlc3Ryb3kgZnVuYyBiZXNpZGVcbiAgICAgICAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgY3JlYXRlIGxvZ2ljP1xuICAgICAgICB0aGlzLmRlc3Ryb3lGdWxsV2lkdGhDb21wb25lbnRzKCk7XG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZpcnN0UGFzc0Z1bmNzLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIGZ1bmMoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNlY29uZFBhc3NGdW5jcy5wdXNoKHRoaXMuZGVzdHJveUNvbnRhaW5pbmdDZWxscy5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUNvbnRhaW5pbmdDZWxscygpO1xuICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCBhbmltYXRpbmcsIHNvIGV4ZWN1dGUgdGhlIHNlY29uZCBzdGFnZSBvZiByZW1vdmFsIG5vdy5cbiAgICAgICAgICAgIC8vIHdlIGNhbGwgZ2V0QW5kQ2xlYXIsIHNvIHRoYXQgdGhleSBhcmUgb25seSBjYWxsZWQgb25jZVxuICAgICAgICAgICAgdmFyIGRlbGF5ZWREZXN0cm95RnVuY3Rpb25zID0gdGhpcy5nZXRBbmRDbGVhckRlbGF5ZWREZXN0cm95RnVuY3Rpb25zKCk7XG4gICAgICAgICAgICBkZWxheWVkRGVzdHJveUZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7IHJldHVybiBmdW5jKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuY3JlYXRlUm93RXZlbnQoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1ZJUlRVQUxfUk9XX1JFTU9WRUQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLmJlYW5zLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmRlc3Ryb3lDb250YWluaW5nQ2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaENlbGxDb21wKGZ1bmN0aW9uIChyZW5kZXJlZENlbGwpIHsgcmV0dXJuIHJlbmRlcmVkQ2VsbC5kZXN0cm95KCk7IH0pO1xuICAgICAgICB0aGlzLmRlc3Ryb3lGdWxsV2lkdGhDb21wb25lbnRzKCk7XG4gICAgfTtcbiAgICAvLyB3ZSBjbGVhciBzbyB0aGF0IHRoZSBmdW5jdGlvbnMgYXJlIG5ldmVyIGV4ZWN1dGVkIHR3aWNlXG4gICAgUm93Q29tcC5wcm90b3R5cGUuZ2V0QW5kQ2xlYXJEZWxheWVkRGVzdHJveUZ1bmN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVtb3ZlU2Vjb25kUGFzc0Z1bmNzO1xuICAgICAgICB0aGlzLnJlbW92ZVNlY29uZFBhc3NGdW5jcyA9IFtdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUub25DZWxsRm9jdXNDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93Rm9jdXNlZCA9IHRoaXMuYmVhbnMuZm9jdXNlZENlbGxDb250cm9sbGVyLmlzUm93Rm9jdXNlZCh0aGlzLnJvd05vZGUucm93SW5kZXgsIHRoaXMucm93Tm9kZS5yb3dQaW5uZWQpO1xuICAgICAgICBpZiAocm93Rm9jdXNlZCAhPT0gdGhpcy5yb3dGb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmVBbGxSb3dDb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gdXRpbHNfMS5fLmFkZE9yUmVtb3ZlQ3NzQ2xhc3Mocm93LCAnYWctcm93LWZvY3VzJywgcm93Rm9jdXNlZCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5lQWxsUm93Q29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHV0aWxzXzEuXy5hZGRPclJlbW92ZUNzc0NsYXNzKHJvdywgJ2FnLXJvdy1uby1mb2N1cycsICFyb3dGb2N1c2VkKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnJvd0ZvY3VzZWQgPSByb3dGb2N1c2VkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGFyZSBlZGl0aW5nLCB0aGVuIG1vdmluZyB0aGUgZm9jdXMgb3V0IG9mIGEgcm93IHdpbGwgc3RvcCBlZGl0aW5nXG4gICAgICAgIGlmICghcm93Rm9jdXNlZCAmJiB0aGlzLmVkaXRpbmdSb3cpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5vblBhZ2luYXRpb25DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudFBhZ2UgPSB0aGlzLmJlYW5zLnBhZ2luYXRpb25Qcm94eS5nZXRDdXJyZW50UGFnZSgpO1xuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGlzIHJvdyBpcyBpbiB0aGUgbmV3IHBhZ2UsIGJ1dCB0aGUgcGFnZSBudW1iZXIgaGFzIGNoYW5nZWQsIHdoaWNoIG1lYW5zXG4gICAgICAgIC8vIGl0IG5lZWRzIHRvIHJlcG9zaXRpb24gaXRzZWxmIHJlbGF0aXZlIHRvIHRoZSBuZXcgcGFnZVxuICAgICAgICBpZiAodGhpcy5wYWdpbmF0aW9uUGFnZSAhPT0gY3VycmVudFBhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdGlvblBhZ2UgPSBjdXJyZW50UGFnZTtcbiAgICAgICAgICAgIHRoaXMub25Ub3BDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLm9uVG9wQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdG9wIGlzIG5vdCB1c2VkIGluIGZvclByaW50LCBhcyB0aGUgcm93cyBhcmUganVzdCBsYWlkIG91dCBuYXR1cmFsbHlcbiAgICAgICAgdmFyIGRvTm90U2V0Um93VG9wID0gdGhpcy5iZWFucy5mb3JQcmludCB8fCB0aGlzLmJlYW5zLmdyaWRPcHRpb25zV3JhcHBlci5pc0F1dG9IZWlnaHQoKTtcbiAgICAgICAgaWYgKGRvTm90U2V0Um93VG9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRSb3dUb3AodGhpcy5yb3dOb2RlLnJvd1RvcCk7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5hcHBseVBpeGVsT2Zmc2V0ID0gZnVuY3Rpb24gKHBpeGVscykge1xuICAgICAgICBpZiAodGhpcy5yb3dOb2RlLmlzUm93UGlubmVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXhlbHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxzIC0gdGhpcy5iZWFucy5wYWdpbmF0aW9uUHJveHkuZ2V0UGl4ZWxPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuc2V0Um93VG9wID0gZnVuY3Rpb24gKHBpeGVscykge1xuICAgICAgICAvLyBuZWVkIHRvIG1ha2Ugc3VyZSByb3dUb3AgaXMgbm90IG51bGwsIGFzIHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbm9kZSB3YXMgb25jZVxuICAgICAgICAvLyB2aXNpYmxlIChpZSBwYXJlbnQgZ3JvdXAgd2FzIGV4cGFuZGVkKSBidXQgaXMgbm93IG5vdCB2aXNpYmxlXG4gICAgICAgIGlmICh1dGlsc18xLl8uZXhpc3RzKHBpeGVscykpIHtcbiAgICAgICAgICAgIHZhciBwaXhlbHNXaXRoT2Zmc2V0ID0gdGhpcy5hcHBseVBpeGVsT2Zmc2V0KHBpeGVscyk7XG4gICAgICAgICAgICB2YXIgdG9wUHhfMSA9IHBpeGVsc1dpdGhPZmZzZXQgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVBbGxSb3dDb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93LnN0eWxlLnRvcCA9IHRvcFB4XzE7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB3ZSBjbGVhciBzbyB0aGF0IHRoZSBmdW5jdGlvbnMgYXJlIG5ldmVyIGV4ZWN1dGVkIHR3aWNlXG4gICAgUm93Q29tcC5wcm90b3R5cGUuZ2V0QW5kQ2xlYXJOZXh0Vk1UdXJuRnVuY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jcmVhdGVTZWNvbmRQYXNzRnVuY3M7XG4gICAgICAgIHRoaXMuY3JlYXRlU2Vjb25kUGFzc0Z1bmNzID0gW107XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBSb3dDb21wLnByb3RvdHlwZS5nZXRSb3dOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dOb2RlO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUuZ2V0UmVuZGVyZWRDZWxsRm9yQ29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsQ29tcHNbY29sdW1uLmdldENvbElkKCldO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUub25Sb3dJbmRleENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25DZWxsRm9jdXNDaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUm93SW5kZXhlcygpO1xuICAgIH07XG4gICAgUm93Q29tcC5wcm90b3R5cGUudXBkYXRlUm93SW5kZXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd0luZGV4U3RyID0gdGhpcy5yb3dOb2RlLmdldFJvd0luZGV4U3RyaW5nKCk7XG4gICAgICAgIHZhciByb3dJc0V2ZW4gPSB0aGlzLnJvd05vZGUucm93SW5kZXggJSAyID09PSAwO1xuICAgICAgICB2YXIgcm93SXNFdmVuQ2hhbmdlZCA9IHRoaXMucm93SXNFdmVuICE9PSByb3dJc0V2ZW47XG4gICAgICAgIGlmIChyb3dJc0V2ZW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0lzRXZlbiA9IHJvd0lzRXZlbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVBbGxSb3dDb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKGVSb3cpIHtcbiAgICAgICAgICAgIGVSb3cuc2V0QXR0cmlidXRlKCdpbmRleCcsIHJvd0luZGV4U3RyKTtcbiAgICAgICAgICAgIGlmIChyb3dJc0V2ZW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5fLmFkZE9yUmVtb3ZlQ3NzQ2xhc3MoZVJvdywgJ2FnLXJvdy1ldmVuJywgcm93SXNFdmVuKTtcbiAgICAgICAgICAgICAgICB1dGlsc18xLl8uYWRkT3JSZW1vdmVDc3NDbGFzcyhlUm93LCAnYWctcm93LW9kZCcsICFyb3dJc0V2ZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd0NvbXAucHJvdG90eXBlLmVuc3VyZURvbU9yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMuZ2V0Qm9keVJvd0VsZW1lbnQoKTtcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keUNvbnRhaW5lckNvbXAuZW5zdXJlRG9tT3JkZXIoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmdldFBpbm5lZExlZnRSb3dFbGVtZW50KCk7XG4gICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICB0aGlzLnBpbm5lZExlZnRDb250YWluZXJDb21wLmVuc3VyZURvbU9yZGVyKGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMuZ2V0UGlubmVkUmlnaHRSb3dFbGVtZW50KCk7XG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgdGhpcy5waW5uZWRSaWdodENvbnRhaW5lckNvbXAuZW5zdXJlRG9tT3JkZXIocmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdWxsV2lkdGggPSB0aGlzLmdldEZ1bGxXaWR0aFJvd0VsZW1lbnQoKTtcbiAgICAgICAgaWYgKGZ1bGxXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5mdWxsV2lkdGhDb250YWluZXJDb21wLmVuc3VyZURvbU9yZGVyKGZ1bGxXaWR0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHJldHVybnMgdGhlIHBpbm5lZCBsZWZ0IGNvbnRhaW5lciwgZWl0aGVyIHRoZSBub3JtYWwgb25lLCBvciB0aGUgZW1iZWRkZWQgZnVsbCB3aXRoIG9uZSBpZiBleGlzdHNcbiAgICBSb3dDb21wLnByb3RvdHlwZS5nZXRQaW5uZWRMZWZ0Um93RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZVBpbm5lZExlZnRSb3cgPyB0aGlzLmVQaW5uZWRMZWZ0Um93IDogdGhpcy5lRnVsbFdpZHRoUm93TGVmdDtcbiAgICB9O1xuICAgIC8vIHJldHVybnMgdGhlIHBpbm5lZCByaWdodCBjb250YWluZXIsIGVpdGhlciB0aGUgbm9ybWFsIG9uZSwgb3IgdGhlIGVtYmVkZGVkIGZ1bGwgd2l0aCBvbmUgaWYgZXhpc3RzXG4gICAgUm93Q29tcC5wcm90b3R5cGUuZ2V0UGlubmVkUmlnaHRSb3dFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lUGlubmVkUmlnaHRSb3cgPyB0aGlzLmVQaW5uZWRSaWdodFJvdyA6IHRoaXMuZUZ1bGxXaWR0aFJvd1JpZ2h0O1xuICAgIH07XG4gICAgLy8gcmV0dXJucyB0aGUgYm9keSBjb250YWluZXIsIGVpdGhlciB0aGUgbm9ybWFsIG9uZSwgb3IgdGhlIGVtYmVkZGVkIGZ1bGwgd2l0aCBvbmUgaWYgZXhpc3RzXG4gICAgUm93Q29tcC5wcm90b3R5cGUuZ2V0Qm9keVJvd0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVCb2R5Um93ID8gdGhpcy5lQm9keVJvdyA6IHRoaXMuZUZ1bGxXaWR0aFJvd0JvZHk7XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIHRoZSBmdWxsIHdpZHRoIGNvbnRhaW5lclxuICAgIFJvd0NvbXAucHJvdG90eXBlLmdldEZ1bGxXaWR0aFJvd0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVGdWxsV2lkdGhSb3c7XG4gICAgfTtcbiAgICBSb3dDb21wLkRPTV9EQVRBX0tFWV9SRU5ERVJFRF9ST1cgPSAncmVuZGVyZWRSb3cnO1xuICAgIFJvd0NvbXAuRlVMTF9XSURUSF9DRUxMX1JFTkRFUkVSID0gJ2Z1bGxXaWR0aENlbGxSZW5kZXJlcic7XG4gICAgUm93Q29tcC5HUk9VUF9ST1dfUkVOREVSRVIgPSAnZ3JvdXBSb3dSZW5kZXJlcic7XG4gICAgUm93Q29tcC5MT0FESU5HX0NFTExfUkVOREVSRVIgPSAnbG9hZGluZ0NlbGxSZW5kZXJlcic7XG4gICAgcmV0dXJuIFJvd0NvbXA7XG59KGNvbXBvbmVudF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Sb3dDb21wID0gUm93Q29tcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9yb3dDb21wLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIHJvd05vZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnRpdGllcy9yb3dOb2RlXCIpO1xudmFyIGJlYW5TdHViXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9iZWFuU3R1YlwiKTtcbnZhciBSb3dOb2RlQmxvY2sgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb3dOb2RlQmxvY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm93Tm9kZUJsb2NrKGJsb2NrTnVtYmVyLCByb3dOb2RlQ2FjaGVQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmVyc2lvbiA9IDA7XG4gICAgICAgIF90aGlzLnN0YXRlID0gUm93Tm9kZUJsb2NrLlNUQVRFX0RJUlRZO1xuICAgICAgICBfdGhpcy5yb3dOb2RlQ2FjaGVQYXJhbXMgPSByb3dOb2RlQ2FjaGVQYXJhbXM7XG4gICAgICAgIF90aGlzLmJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gY2FsY3VsYXRlIHRoZXNlIG5vdywgYXMgdGhlIGlucHV0cyBkb24ndCBjaGFuZ2UsXG4gICAgICAgIC8vIGhvd2V2ZXIgaXQgbWFrZXMgdGhlIGNvZGUgZWFzaWVyIHRvIHJlYWQgaWYgd2Ugd29yayB0aGVtIG91dCB1cCBmcm9udFxuICAgICAgICBfdGhpcy5zdGFydFJvdyA9IGJsb2NrTnVtYmVyICogcm93Tm9kZUNhY2hlUGFyYW1zLmJsb2NrU2l6ZTtcbiAgICAgICAgX3RoaXMuZW5kUm93ID0gX3RoaXMuc3RhcnRSb3cgKyByb3dOb2RlQ2FjaGVQYXJhbXMuYmxvY2tTaXplO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUuaXNBbnlOb2RlT3BlbiA9IGZ1bmN0aW9uIChyb3dDb3VudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9yRWFjaE5vZGVDYWxsYmFjayhmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHJvd05vZGUuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCByb3dDb3VudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2sucHJvdG90eXBlLmZvckVhY2hOb2RlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHJvd0NvdW50KSB7XG4gICAgICAgIGZvciAodmFyIHJvd0luZGV4ID0gdGhpcy5zdGFydFJvdzsgcm93SW5kZXggPCB0aGlzLmVuZFJvdzsgcm93SW5kZXgrKykge1xuICAgICAgICAgICAgLy8gd2UgY2hlY2sgYWdhaW5zdCByb3dDb3VudCBhcyB0aGlzIHBhZ2UgbWF5IGJlIHRoZSBsYXN0IG9uZSwgYW5kIGlmIGl0IGlzLCB0aGVuXG4gICAgICAgICAgICAvLyB0aGUgbGFzdCByb3dzIGFyZSBub3QgcGFydCBvZiB0aGUgc2V0XG4gICAgICAgICAgICBpZiAocm93SW5kZXggPCByb3dDb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciByb3dOb2RlID0gdGhpcy5nZXRSb3dVc2luZ0xvY2FsSW5kZXgocm93SW5kZXgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJvd05vZGUsIHJvd0luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Tm9kZUJsb2NrLnByb3RvdHlwZS5mb3JFYWNoTm9kZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgc2VxdWVuY2UsIHJvd0NvdW50LCBkZWVwKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE5vZGVDYWxsYmFjayhmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICAgICAgY2FsbGJhY2socm93Tm9kZSwgc2VxdWVuY2UubmV4dCgpKTtcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBvbmx5IGV2ZXJ5IGhhcHBlbiBmb3IgZW50ZXJwcmlzZSByb3cgbW9kZWwsIGFzIGluZmluaXRlXG4gICAgICAgICAgICAvLyByb3cgbW9kZWwgZG9lc24ndCBoYXZlIGdyb3Vwc1xuICAgICAgICAgICAgaWYgKGRlZXAgJiYgcm93Tm9kZS5jaGlsZHJlbkNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5jaGlsZHJlbkNhY2hlLmZvckVhY2hOb2RlRGVlcChjYWxsYmFjaywgc2VxdWVuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCByb3dDb3VudCk7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2sucHJvdG90eXBlLmZvckVhY2hOb2RlRGVlcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgc2VxdWVuY2UsIHJvd0NvdW50KSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE5vZGUoY2FsbGJhY2ssIHNlcXVlbmNlLCByb3dDb3VudCwgdHJ1ZSk7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2sucHJvdG90eXBlLmZvckVhY2hOb2RlU2hhbGxvdyA9IGZ1bmN0aW9uIChjYWxsYmFjaywgc2VxdWVuY2UsIHJvd0NvdW50KSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE5vZGUoY2FsbGJhY2ssIHNlcXVlbmNlLCByb3dDb3VudCwgZmFsc2UpO1xuICAgIH07XG4gICAgUm93Tm9kZUJsb2NrLnByb3RvdHlwZS5nZXRWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgIH07XG4gICAgUm93Tm9kZUJsb2NrLnByb3RvdHlwZS5nZXRMYXN0QWNjZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RBY2Nlc3NlZDtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUuZ2V0Um93VXNpbmdMb2NhbEluZGV4ID0gZnVuY3Rpb24gKHJvd0luZGV4KSB7XG4gICAgICAgIHRoaXMubGFzdEFjY2Vzc2VkID0gdGhpcy5yb3dOb2RlQ2FjaGVQYXJhbXMubGFzdEFjY2Vzc2VkU2VxdWVuY2UubmV4dCgpO1xuICAgICAgICB2YXIgbG9jYWxJbmRleCA9IHJvd0luZGV4IC0gdGhpcy5zdGFydFJvdztcbiAgICAgICAgcmV0dXJuIHRoaXMucm93Tm9kZXNbbG9jYWxJbmRleF07XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2sucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYmVhbnMpIHtcbiAgICAgICAgdGhpcy5iZWFucyA9IGJlYW5zO1xuICAgICAgICB0aGlzLmNyZWF0ZVJvd05vZGVzKCk7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2sucHJvdG90eXBlLmdldFN0YXJ0Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFJvdztcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUuZ2V0RW5kUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRSb3c7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2sucHJvdG90eXBlLmdldEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja051bWJlcjtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGluIGNhc2UgYW55IGN1cnJlbnQgbG9hZHMgaW4gcHJvZ3Jlc3MsIHRoaXMgd2lsbCBoYXZlIHRoZWlyIHJlc3VsdHMgaWdub3JlZFxuICAgICAgICB0aGlzLnZlcnNpb24rKztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJvd05vZGVCbG9jay5TVEFURV9ESVJUWTtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUuc2V0RGlydHlBbmRQdXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSgpO1xuICAgICAgICB0aGlzLnJvd05vZGVzLmZvckVhY2goZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgICAgIHJvd05vZGUuc2V0RGF0YShudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2sucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUuc2V0Um93Tm9kZSA9IGZ1bmN0aW9uIChyb3dJbmRleCwgcm93Tm9kZSkge1xuICAgICAgICB2YXIgbG9jYWxJbmRleCA9IHJvd0luZGV4IC0gdGhpcy5zdGFydFJvdztcbiAgICAgICAgdGhpcy5yb3dOb2Rlc1tsb2NhbEluZGV4XSA9IHJvd05vZGU7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2sucHJvdG90eXBlLnNldEJsYW5rUm93Tm9kZSA9IGZ1bmN0aW9uIChyb3dJbmRleCkge1xuICAgICAgICB2YXIgbG9jYWxJbmRleCA9IHJvd0luZGV4IC0gdGhpcy5zdGFydFJvdztcbiAgICAgICAgdmFyIG5ld1Jvd05vZGUgPSB0aGlzLmNyZWF0ZUJsYW5rUm93Tm9kZShyb3dJbmRleCk7XG4gICAgICAgIHRoaXMucm93Tm9kZXNbbG9jYWxJbmRleF0gPSBuZXdSb3dOb2RlO1xuICAgICAgICByZXR1cm4gbmV3Um93Tm9kZTtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUuc2V0TmV3RGF0YSA9IGZ1bmN0aW9uIChyb3dJbmRleCwgZGF0YUl0ZW0pIHtcbiAgICAgICAgdmFyIG5ld1Jvd05vZGUgPSB0aGlzLnNldEJsYW5rUm93Tm9kZShyb3dJbmRleCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YUFuZElkKG5ld1Jvd05vZGUsIGRhdGFJdGVtLCB0aGlzLnN0YXJ0Um93ICsgcm93SW5kZXgpO1xuICAgICAgICByZXR1cm4gbmV3Um93Tm9kZTtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUuY3JlYXRlQmxhbmtSb3dOb2RlID0gZnVuY3Rpb24gKHJvd0luZGV4KSB7XG4gICAgICAgIHZhciByb3dOb2RlID0gbmV3IHJvd05vZGVfMS5Sb3dOb2RlKCk7XG4gICAgICAgIHRoaXMuYmVhbnMuY29udGV4dC53aXJlQmVhbihyb3dOb2RlKTtcbiAgICAgICAgcm93Tm9kZS5zZXRSb3dIZWlnaHQodGhpcy5yb3dOb2RlQ2FjaGVQYXJhbXMucm93SGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHJvd05vZGU7XG4gICAgfTtcbiAgICAvLyBjcmVhdGVzIGVtcHR5IHJvdyBub2RlcywgZGF0YSBpcyBtaXNzaW5nIGFzIG5vdCBsb2FkZWQgeWV0XG4gICAgUm93Tm9kZUJsb2NrLnByb3RvdHlwZS5jcmVhdGVSb3dOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yb3dOb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93Tm9kZUNhY2hlUGFyYW1zLmJsb2NrU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93SW5kZXggPSB0aGlzLnN0YXJ0Um93ICsgaTtcbiAgICAgICAgICAgIHZhciByb3dOb2RlID0gdGhpcy5jcmVhdGVCbGFua1Jvd05vZGUocm93SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5yb3dOb2Rlcy5wdXNoKHJvd05vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2sucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBSb3dOb2RlQmxvY2suU1RBVEVfTE9BRElORztcbiAgICAgICAgdGhpcy5sb2FkRnJvbURhdGFzb3VyY2UoKTtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUucGFnZUxvYWRGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBSb3dOb2RlQmxvY2suU1RBVEVfRkFJTEVEO1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBSb3dOb2RlQmxvY2suRVZFTlRfTE9BRF9DT01QTEVURSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgcGFnZTogdGhpcyxcbiAgICAgICAgICAgIGxhc3RSb3c6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUucG9wdWxhdGVXaXRoUm93RGF0YSA9IGZ1bmN0aW9uIChyb3dzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByb3dOb2Rlc1RvUmVmcmVzaCA9IFtdO1xuICAgICAgICB0aGlzLnJvd05vZGVzLmZvckVhY2goZnVuY3Rpb24gKHJvd05vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJvd3NbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHJvd05vZGUuc3R1Yikge1xuICAgICAgICAgICAgICAgIHJvd05vZGVzVG9SZWZyZXNoLnB1c2gocm93Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zZXREYXRhQW5kSWQocm93Tm9kZSwgZGF0YSwgX3RoaXMuc3RhcnRSb3cgKyBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocm93Tm9kZXNUb1JlZnJlc2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5iZWFucy5yb3dSZW5kZXJlci5yZWRyYXdSb3dzKHJvd05vZGVzVG9SZWZyZXNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Tm9kZUJsb2NrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5yb3dOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3dOb2RlKSB7XG4gICAgICAgICAgICBpZiAocm93Tm9kZS5jaGlsZHJlbkNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5jaGlsZHJlbkNhY2hlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICByb3dOb2RlLmNoaWxkcmVuQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9jay5wcm90b3R5cGUucGFnZUxvYWRlZCA9IGZ1bmN0aW9uICh2ZXJzaW9uLCByb3dzLCBsYXN0Um93KSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgdGhlIHZlcnNpb24sIGluIGNhc2UgdGhlcmUgd2FzIGFuIG9sZCByZXF1ZXN0XG4gICAgICAgIC8vIGZyb20gdGhlIHNlcnZlciB0aGF0IHdhcyBzZW50IGJlZm9yZSB3ZSByZWZyZXNoZWQgdGhlIGNhY2hlLFxuICAgICAgICAvLyBpZiB0aGUgbG9hZCB3YXMgZG9uZSBhcyBhIHJlc3VsdCBvZiBhIGNhY2hlIHJlZnJlc2hcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IHRoaXMudmVyc2lvbikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJvd05vZGVCbG9jay5TVEFURV9MT0FERUQ7XG4gICAgICAgICAgICB0aGlzLnBvcHVsYXRlV2l0aFJvd0RhdGEocm93cyk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJvdyA9IHV0aWxzXzEuVXRpbHMuY2xlYW5OdW1iZXIobGFzdFJvdyk7XG4gICAgICAgIC8vIGNoZWNrIGhlcmUgaWYgbGFzdHJvdyBzaG91bGQgYmUgc2V0XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFJvd05vZGVCbG9jay5FVkVOVF9MT0FEX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHBhZ2U6IHRoaXMsXG4gICAgICAgICAgICBsYXN0Um93OiBsYXN0Um93XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2suRVZFTlRfTE9BRF9DT01QTEVURSA9ICdsb2FkQ29tcGxldGUnO1xuICAgIFJvd05vZGVCbG9jay5TVEFURV9ESVJUWSA9ICdkaXJ0eSc7XG4gICAgUm93Tm9kZUJsb2NrLlNUQVRFX0xPQURJTkcgPSAnbG9hZGluZyc7XG4gICAgUm93Tm9kZUJsb2NrLlNUQVRFX0xPQURFRCA9ICdsb2FkZWQnO1xuICAgIFJvd05vZGVCbG9jay5TVEFURV9GQUlMRUQgPSAnZmFpbGVkJztcbiAgICByZXR1cm4gUm93Tm9kZUJsb2NrO1xufShiZWFuU3R1Yl8xLkJlYW5TdHViKSk7XG5leHBvcnRzLlJvd05vZGVCbG9jayA9IFJvd05vZGVCbG9jaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9jYWNoZS9yb3dOb2RlQmxvY2suanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbnRleHRfMiA9IHJlcXVpcmUoXCIuL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBUZW1wbGF0ZVNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlU2VydmljZSgpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUNhY2hlID0ge307XG4gICAgICAgIHRoaXMud2FpdGluZ0NhbGxiYWNrcyA9IHt9O1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSB0ZW1wbGF0ZSBpZiBpdCBpcyBsb2FkZWQsIG9yIG51bGwgaWYgaXQgaXMgbm90IGxvYWRlZFxuICAgIC8vIGJ1dCB3aWxsIGNhbGwgdGhlIGNhbGxiYWNrIHdoZW4gaXQgaXMgbG9hZGVkXG4gICAgVGVtcGxhdGVTZXJ2aWNlLnByb3RvdHlwZS5nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZUZyb21DYWNoZSA9IHRoaXMudGVtcGxhdGVDYWNoZVt1cmxdO1xuICAgICAgICBpZiAodGVtcGxhdGVGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZUZyb21DYWNoZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2tMaXN0ID0gdGhpcy53YWl0aW5nQ2FsbGJhY2tzW3VybF07XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKCFjYWxsYmFja0xpc3QpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgdGhpcyB3YXMgY2FsbGVkLCBzbyBuZWVkIGEgbmV3IGxpc3QgZm9yIGNhbGxiYWNrc1xuICAgICAgICAgICAgY2FsbGJhY2tMaXN0ID0gW107XG4gICAgICAgICAgICB0aGlzLndhaXRpbmdDYWxsYmFja3NbdXJsXSA9IGNhbGxiYWNrTGlzdDtcbiAgICAgICAgICAgIC8vIGFuZCBhbHNvIG5lZWQgdG8gZG8gdGhlIGh0dHAgcmVxdWVzdFxuICAgICAgICAgICAgdmFyIGNsaWVudCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgY2xpZW50Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZUh0dHBSZXN1bHQodGhpcywgdXJsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbGllbnQub3BlbihcIkdFVFwiLCB1cmwpO1xuICAgICAgICAgICAgY2xpZW50LnNlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhpcyBjYWxsYmFja1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrTGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsZXIgbmVlZHMgdG8gd2FpdCBmb3IgdGVtcGxhdGUgdG8gbG9hZCwgc28gcmV0dXJuIG51bGxcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVNlcnZpY2UucHJvdG90eXBlLmhhbmRsZUh0dHBSZXN1bHQgPSBmdW5jdGlvbiAoaHR0cFJlc3VsdCwgdXJsKSB7XG4gICAgICAgIGlmIChodHRwUmVzdWx0LnN0YXR1cyAhPT0gMjAwIHx8IGh0dHBSZXN1bHQucmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGdldCB0ZW1wbGF0ZSBlcnJvciAnICsgaHR0cFJlc3VsdC5zdGF0dXMgKyAnIC0gJyArIHVybCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzcG9uc2Ugc3VjY2Vzcywgc28gcHJvY2VzcyBpdFxuICAgICAgICAvLyBpbiBJRTkgdGhlIHJlc3BvbnNlIGlzIGluIC0gcmVzcG9uc2VUZXh0XG4gICAgICAgIHRoaXMudGVtcGxhdGVDYWNoZVt1cmxdID0gaHR0cFJlc3VsdC5yZXNwb25zZSB8fCBodHRwUmVzdWx0LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgLy8gaW5mb3JtIGFsbCBsaXN0ZW5lcnMgdGhhdCB0aGlzIGlzIG5vdyBpbiB0aGUgY2FjaGVcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMud2FpdGluZ0NhbGxiYWNrc1t1cmxdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgLy8gd2UgY291bGQgcGFzcyB0aGUgY2FsbGJhY2sgdGhlIHJlc3BvbnNlLCBob3dldmVyIHdlIGtub3cgdGhlIGNsaWVudCBvZiB0aGlzIGNvZGVcbiAgICAgICAgICAgIC8vIGlzIHRoZSBjZWxsIHJlbmRlcmVyLCBhbmQgaXQgcGFzc2VzIHRoZSAnY2VsbFJlZnJlc2gnIG1ldGhvZCBpbiBhcyB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIC8vIHdoaWNoIGRvZXNuJ3QgdGFrZSBhbnkgcGFyYW1ldGVycy5cbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgdGhhdF8xID0gdGhpcztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXRfMS4kc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMi5BdXRvd2lyZWQoJyRzY29wZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRlbXBsYXRlU2VydmljZS5wcm90b3R5cGUsIFwiJHNjb3BlXCIsIHZvaWQgMCk7XG4gICAgVGVtcGxhdGVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCd0ZW1wbGF0ZVNlcnZpY2UnKVxuICAgIF0sIFRlbXBsYXRlU2VydmljZSk7XG4gICAgcmV0dXJuIFRlbXBsYXRlU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlRlbXBsYXRlU2VydmljZSA9IFRlbXBsYXRlU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3RlbXBsYXRlU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50XCIpO1xudmFyIGNvbXBvbmVudEFubm90YXRpb25zXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRBbm5vdGF0aW9uc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIEFnQ2hlY2tib3ggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZ0NoZWNrYm94LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFnQ2hlY2tib3goKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnBhc3NpdmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZ0NoZWNrYm94LnByb3RvdHlwZS5wb3N0Q29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFRlbXBsYXRlKEFnQ2hlY2tib3guVEVNUExBVEUpO1xuICAgICAgICB0aGlzLmxvYWRJY29ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUljb25zKCk7XG4gICAgfTtcbiAgICBBZ0NoZWNrYm94LnByb3RvdHlwZS5hdHRyaWJ1dGVzU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmF0dHJpYnV0ZXNTZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5lTGFiZWwuaW5uZXJUZXh0ID0gbGFiZWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFnQ2hlY2tib3gucHJvdG90eXBlLmxvYWRJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVBbGxDaGlsZHJlbih0aGlzLmVDaGVja2VkKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVBbGxDaGlsZHJlbih0aGlzLmVVbmNoZWNrZWQpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUFsbENoaWxkcmVuKHRoaXMuZUluZGV0ZXJtaW5hdGUpO1xuICAgICAgICBpZiAodGhpcy5yZWFkT25seSkge1xuICAgICAgICAgICAgdGhpcy5lQ2hlY2tlZC5hcHBlbmRDaGlsZCh1dGlsc18xLlV0aWxzLmNyZWF0ZUljb25Ob1NwYW4oJ2NoZWNrYm94Q2hlY2tlZFJlYWRPbmx5JywgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIG51bGwpKTtcbiAgICAgICAgICAgIHRoaXMuZVVuY2hlY2tlZC5hcHBlbmRDaGlsZCh1dGlsc18xLlV0aWxzLmNyZWF0ZUljb25Ob1NwYW4oJ2NoZWNrYm94VW5jaGVja2VkUmVhZE9ubHknLCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgbnVsbCkpO1xuICAgICAgICAgICAgdGhpcy5lSW5kZXRlcm1pbmF0ZS5hcHBlbmRDaGlsZCh1dGlsc18xLlV0aWxzLmNyZWF0ZUljb25Ob1NwYW4oJ2NoZWNrYm94SW5kZXRlcm1pbmF0ZVJlYWRPbmx5JywgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZUNoZWNrZWQuYXBwZW5kQ2hpbGQodXRpbHNfMS5VdGlscy5jcmVhdGVJY29uTm9TcGFuKCdjaGVja2JveENoZWNrZWQnLCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgbnVsbCkpO1xuICAgICAgICAgICAgdGhpcy5lVW5jaGVja2VkLmFwcGVuZENoaWxkKHV0aWxzXzEuVXRpbHMuY3JlYXRlSWNvbk5vU3BhbignY2hlY2tib3hVbmNoZWNrZWQnLCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgbnVsbCkpO1xuICAgICAgICAgICAgdGhpcy5lSW5kZXRlcm1pbmF0ZS5hcHBlbmRDaGlsZCh1dGlsc18xLlV0aWxzLmNyZWF0ZUljb25Ob1NwYW4oJ2NoZWNrYm94SW5kZXRlcm1pbmF0ZScsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBudWxsKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFnQ2hlY2tib3gucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkT25seSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWdDaGVja2JveC5wcm90b3R5cGUuZ2V0TmV4dFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5zZWxlY3RlZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWdDaGVja2JveC5wcm90b3R5cGUuc2V0UGFzc2l2ZSA9IGZ1bmN0aW9uIChwYXNzaXZlKSB7XG4gICAgICAgIHRoaXMucGFzc2l2ZSA9IHBhc3NpdmU7XG4gICAgfTtcbiAgICBBZ0NoZWNrYm94LnByb3RvdHlwZS5zZXRSZWFkT25seSA9IGZ1bmN0aW9uIChyZWFkT25seSkge1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICAgIHRoaXMubG9hZEljb25zKCk7XG4gICAgfTtcbiAgICBBZ0NoZWNrYm94LnByb3RvdHlwZS5pc1JlYWRPbmx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkT25seTtcbiAgICB9O1xuICAgIEFnQ2hlY2tib3gucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH07XG4gICAgQWdDaGVja2JveC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gdGhpcy5nZXROZXh0VmFsdWUoKTtcbiAgICAgICAgaWYgKHRoaXMucGFzc2l2ZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogQWdDaGVja2JveC5FVkVOVF9DSEFOR0VELFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBuZXh0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnRfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkKG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFnQ2hlY2tib3gucHJvdG90eXBlLnNldFNlbGVjdGVkID0gZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkID09PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlSWNvbnMoKTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogQWdDaGVja2JveC5FVkVOVF9DSEFOR0VELFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIEFnQ2hlY2tib3gucHJvdG90eXBlLnVwZGF0ZUljb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsc18xLlV0aWxzLnNldFZpc2libGUodGhpcy5lQ2hlY2tlZCwgdGhpcy5zZWxlY3RlZCA9PT0gdHJ1ZSk7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuc2V0VmlzaWJsZSh0aGlzLmVVbmNoZWNrZWQsIHRoaXMuc2VsZWN0ZWQgPT09IGZhbHNlKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5zZXRWaXNpYmxlKHRoaXMuZUluZGV0ZXJtaW5hdGUsIHRoaXMuc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBBZ0NoZWNrYm94LkVWRU5UX0NIQU5HRUQgPSAnY2hhbmdlJztcbiAgICBBZ0NoZWNrYm94LlRFTVBMQVRFID0gJzxzcGFuIGNsYXNzPVwiYWctY2hlY2tib3hcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+JyArXG4gICAgICAgICcgIDxzcGFuIGNsYXNzPVwiYWctY2hlY2tib3gtY2hlY2tlZFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L3NwYW4+JyArXG4gICAgICAgICcgIDxzcGFuIGNsYXNzPVwiYWctY2hlY2tib3gtdW5jaGVja2VkXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjwvc3Bhbj4nICtcbiAgICAgICAgJyAgPHNwYW4gY2xhc3M9XCJhZy1jaGVja2JveC1pbmRldGVybWluYXRlXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjwvc3Bhbj4nICtcbiAgICAgICAgJyAgPHNwYW4gY2xhc3M9XCJhZy1jaGVja2JveC1sYWJlbFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L3NwYW4+JyArXG4gICAgICAgICc8L3NwYW4+JztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgQWdDaGVja2JveC5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUXVlcnlTZWxlY3RvcignLmFnLWNoZWNrYm94LWNoZWNrZWQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEFnQ2hlY2tib3gucHJvdG90eXBlLCBcImVDaGVja2VkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUXVlcnlTZWxlY3RvcignLmFnLWNoZWNrYm94LXVuY2hlY2tlZCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgQWdDaGVja2JveC5wcm90b3R5cGUsIFwiZVVuY2hlY2tlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlF1ZXJ5U2VsZWN0b3IoJy5hZy1jaGVja2JveC1pbmRldGVybWluYXRlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MRWxlbWVudClcbiAgICBdLCBBZ0NoZWNrYm94LnByb3RvdHlwZSwgXCJlSW5kZXRlcm1pbmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlF1ZXJ5U2VsZWN0b3IoJy5hZy1jaGVja2JveC1sYWJlbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgQWdDaGVja2JveC5wcm90b3R5cGUsIFwiZUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEFnQ2hlY2tib3gucHJvdG90eXBlLCBcInBvc3RDb25zdHJ1Y3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuTGlzdGVuZXIoJ2NsaWNrJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgQWdDaGVja2JveC5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcbiAgICByZXR1cm4gQWdDaGVja2JveDtcbn0oY29tcG9uZW50XzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkFnQ2hlY2tib3ggPSBBZ0NoZWNrYm94O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvd2lkZ2V0cy9hZ0NoZWNrYm94LmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgVG91Y2hMaXN0ZW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG91Y2hMaXN0ZW5lcihlRWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlc3Ryb3lGdW5jcyA9IFtdO1xuICAgICAgICB0aGlzLnRvdWNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlID0gbmV3IGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSgpO1xuICAgICAgICB0aGlzLmVFbGVtZW50ID0gZUVsZW1lbnQ7XG4gICAgICAgIHZhciBzdGFydExpc3RlbmVyID0gdGhpcy5vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIG1vdmVMaXN0ZW5lciA9IHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGVuZExpc3RlbmVyID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHN0YXJ0TGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5lRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBtb3ZlTGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5lRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGVuZExpc3RlbmVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZGVzdHJveUZ1bmNzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHN0YXJ0TGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIF90aGlzLmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdmVMaXN0ZW5lciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgX3RoaXMuZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBlbmRMaXN0ZW5lciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVG91Y2hMaXN0ZW5lci5wcm90b3R5cGUuZ2V0QWN0aXZlVG91Y2ggPSBmdW5jdGlvbiAodG91Y2hMaXN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG91Y2hMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRvdWNoTGlzdFtpXS5pZGVudGlmaWVyID09PSB0aGlzLnRvdWNoU3RhcnQuaWRlbnRpZmllcjtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvdWNoTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRvdWNoTGlzdGVuZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgVG91Y2hMaXN0ZW5lci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBUb3VjaExpc3RlbmVyLnByb3RvdHlwZS5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbiAodG91Y2hFdmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBvbmx5IGxvb2tpbmcgYXQgb25lIHRvdWNoIHBvaW50IGF0IGFueSB0aW1lXG4gICAgICAgIGlmICh0aGlzLnRvdWNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0ID0gdG91Y2hFdmVudC50b3VjaGVzWzBdO1xuICAgICAgICB0aGlzLnRvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdG91Y2hTdGFydENvcHkgPSB0aGlzLnRvdWNoU3RhcnQ7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoZXNNYXRjaCA9IF90aGlzLnRvdWNoU3RhcnQgPT09IHRvdWNoU3RhcnRDb3B5O1xuICAgICAgICAgICAgaWYgKF90aGlzLnRvdWNoaW5nICYmIHRvdWNoZXNNYXRjaCAmJiAhX3RoaXMubW92ZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRvdWNoTGlzdGVuZXIuRVZFTlRfTE9OR19UQVAsXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoU3RhcnQ6IF90aGlzLnRvdWNoU3RhcnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgIH07XG4gICAgVG91Y2hMaXN0ZW5lci5wcm90b3R5cGUub25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAodG91Y2hFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudG91Y2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG91Y2ggPSB0aGlzLmdldEFjdGl2ZVRvdWNoKHRvdWNoRXZlbnQudG91Y2hlcyk7XG4gICAgICAgIGlmICghdG91Y2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRJc0ZhckF3YXkgPSAhdXRpbHNfMS5VdGlscy5hcmVFdmVudHNOZWFyKHRvdWNoLCB0aGlzLnRvdWNoU3RhcnQsIDQpO1xuICAgICAgICBpZiAoZXZlbnRJc0ZhckF3YXkpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb3VjaExpc3RlbmVyLnByb3RvdHlwZS5vblRvdWNoRW5kID0gZnVuY3Rpb24gKHRvdWNoRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRvdWNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1vdmVkKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb3VjaExpc3RlbmVyLkVWRU5UX1RBUCxcbiAgICAgICAgICAgICAgICB0b3VjaFN0YXJ0OiB0aGlzLnRvdWNoU3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50XzIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRvdWNoTGlzdGVuZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUZ1bmNzLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIGZ1bmMoKTsgfSk7XG4gICAgfTtcbiAgICAvLyBwcml2YXRlIG1vc3RSZWNlbnRUb3VjaDogVG91Y2g7XG4gICAgVG91Y2hMaXN0ZW5lci5FVkVOVF9UQVAgPSAndGFwJztcbiAgICBUb3VjaExpc3RlbmVyLkVWRU5UX0xPTkdfVEFQID0gJ2xvbmdUYXAnO1xuICAgIHJldHVybiBUb3VjaExpc3RlbmVyO1xufSgpKTtcbmV4cG9ydHMuVG91Y2hMaXN0ZW5lciA9IFRvdWNoTGlzdGVuZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi93aWRnZXRzL3RvdWNoTGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbG9iYWxPYmogPSB0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/IHt9IDogZ2xvYmFsO1xuZ2xvYmFsT2JqLkhUTUxFbGVtZW50ID0gdHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJyA/IHt9IDogSFRNTEVsZW1lbnQ7XG5nbG9iYWxPYmouSFRNTEJ1dHRvbkVsZW1lbnQgPSB0eXBlb2YgSFRNTEJ1dHRvbkVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8ge30gOiBIVE1MQnV0dG9uRWxlbWVudDtcbmdsb2JhbE9iai5IVE1MU2VsZWN0RWxlbWVudCA9IHR5cGVvZiBIVE1MU2VsZWN0RWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IEhUTUxTZWxlY3RFbGVtZW50O1xuZ2xvYmFsT2JqLkhUTUxJbnB1dEVsZW1lbnQgPSB0eXBlb2YgSFRNTElucHV0RWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IEhUTUxJbnB1dEVsZW1lbnQ7XG5nbG9iYWxPYmouTm9kZSA9IHR5cGVvZiBOb2RlID09PSAndW5kZWZpbmVkJyA/IHt9IDogTm9kZTtcbi8vIGNvbHVtbkNvbnRyb2xsZXJcbnZhciBiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9jb2x1bW5Db250cm9sbGVyL2JhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXJcIik7XG5leHBvcnRzLkJhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXIgPSBiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyXzEuQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlcjtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG5leHBvcnRzLkNvbHVtbkNvbnRyb2xsZXIgPSBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQ29udHJvbGxlcjtcbnZhciBjb2x1bW5LZXlDcmVhdG9yXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbktleUNyZWF0b3JcIik7XG5leHBvcnRzLkNvbHVtbktleUNyZWF0b3IgPSBjb2x1bW5LZXlDcmVhdG9yXzEuQ29sdW1uS2V5Q3JlYXRvcjtcbnZhciBjb2x1bW5VdGlsc18xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9jb2x1bW5VdGlsc1wiKTtcbmV4cG9ydHMuQ29sdW1uVXRpbHMgPSBjb2x1bW5VdGlsc18xLkNvbHVtblV0aWxzO1xudmFyIGRpc3BsYXllZEdyb3VwQ3JlYXRvcl8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9kaXNwbGF5ZWRHcm91cENyZWF0b3JcIik7XG5leHBvcnRzLkRpc3BsYXllZEdyb3VwQ3JlYXRvciA9IGRpc3BsYXllZEdyb3VwQ3JlYXRvcl8xLkRpc3BsYXllZEdyb3VwQ3JlYXRvcjtcbnZhciBncm91cEluc3RhbmNlSWRDcmVhdG9yXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9jb2x1bW5Db250cm9sbGVyL2dyb3VwSW5zdGFuY2VJZENyZWF0b3JcIik7XG5leHBvcnRzLkdyb3VwSW5zdGFuY2VJZENyZWF0b3IgPSBncm91cEluc3RhbmNlSWRDcmVhdG9yXzEuR3JvdXBJbnN0YW5jZUlkQ3JlYXRvcjtcbi8vIGNvbXBvbmVudHNcbnZhciBjb21wb25lbnRVdGlsXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9jb21wb25lbnRzL2NvbXBvbmVudFV0aWxcIik7XG5leHBvcnRzLkNvbXBvbmVudFV0aWwgPSBjb21wb25lbnRVdGlsXzEuQ29tcG9uZW50VXRpbDtcbnZhciBjb2xEZWZVdGlsXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9jb21wb25lbnRzL2NvbERlZlV0aWxcIik7XG5leHBvcnRzLkNvbERlZlV0aWwgPSBjb2xEZWZVdGlsXzEuQ29sRGVmVXRpbDtcbnZhciBjb21wb25lbnRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UHJvdmlkZXJcIik7XG5leHBvcnRzLkNvbXBvbmVudFByb3ZpZGVyID0gY29tcG9uZW50UHJvdmlkZXJfMS5Db21wb25lbnRQcm92aWRlcjtcbnZhciBhZ0dyaWROZzFfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2NvbXBvbmVudHMvYWdHcmlkTmcxXCIpO1xuZXhwb3J0cy5pbml0aWFsaXNlQWdHcmlkV2l0aEFuZ3VsYXIxID0gYWdHcmlkTmcxXzEuaW5pdGlhbGlzZUFnR3JpZFdpdGhBbmd1bGFyMTtcbnZhciBhZ0dyaWRXZWJDb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2NvbXBvbmVudHMvYWdHcmlkV2ViQ29tcG9uZW50XCIpO1xuZXhwb3J0cy5pbml0aWFsaXNlQWdHcmlkV2l0aFdlYkNvbXBvbmVudHMgPSBhZ0dyaWRXZWJDb21wb25lbnRfMS5pbml0aWFsaXNlQWdHcmlkV2l0aFdlYkNvbXBvbmVudHM7XG4vLyBjb250ZXh0XG52YXIgYmVhblN0dWJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2NvbnRleHQvYmVhblN0dWJcIik7XG5leHBvcnRzLkJlYW5TdHViID0gYmVhblN0dWJfMS5CZWFuU3R1YjtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9jb250ZXh0L2NvbnRleHRcIik7XG5leHBvcnRzLkNvbnRleHQgPSBjb250ZXh0XzEuQ29udGV4dDtcbmV4cG9ydHMuQXV0b3dpcmVkID0gY29udGV4dF8xLkF1dG93aXJlZDtcbmV4cG9ydHMuUG9zdENvbnN0cnVjdCA9IGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0O1xuZXhwb3J0cy5QcmVDb25zdHJ1Y3QgPSBjb250ZXh0XzEuUHJlQ29uc3RydWN0O1xuZXhwb3J0cy5PcHRpb25hbCA9IGNvbnRleHRfMS5PcHRpb25hbDtcbmV4cG9ydHMuQmVhbiA9IGNvbnRleHRfMS5CZWFuO1xuZXhwb3J0cy5RdWFsaWZpZXIgPSBjb250ZXh0XzEuUXVhbGlmaWVyO1xuZXhwb3J0cy5QcmVEZXN0cm95ID0gY29udGV4dF8xLlByZURlc3Ryb3k7XG52YXIgY29tcG9uZW50QW5ub3RhdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3dpZGdldHMvY29tcG9uZW50QW5ub3RhdGlvbnNcIik7XG5leHBvcnRzLlF1ZXJ5U2VsZWN0b3IgPSBjb21wb25lbnRBbm5vdGF0aW9uc18xLlF1ZXJ5U2VsZWN0b3I7XG5leHBvcnRzLkxpc3RlbmVyID0gY29tcG9uZW50QW5ub3RhdGlvbnNfMS5MaXN0ZW5lcjtcbmV4cG9ydHMuUmVmU2VsZWN0b3IgPSBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yO1xuLy8gZHJhZ0FuZERyb3BcbnZhciBkcmFnQW5kRHJvcFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2RyYWdBbmREcm9wL2RyYWdBbmREcm9wU2VydmljZVwiKTtcbmV4cG9ydHMuRHJhZ0FuZERyb3BTZXJ2aWNlID0gZHJhZ0FuZERyb3BTZXJ2aWNlXzEuRHJhZ0FuZERyb3BTZXJ2aWNlO1xuZXhwb3J0cy5EcmFnU291cmNlVHlwZSA9IGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdTb3VyY2VUeXBlO1xuZXhwb3J0cy5IRGlyZWN0aW9uID0gZHJhZ0FuZERyb3BTZXJ2aWNlXzEuSERpcmVjdGlvbjtcbmV4cG9ydHMuVkRpcmVjdGlvbiA9IGRyYWdBbmREcm9wU2VydmljZV8xLlZEaXJlY3Rpb247XG52YXIgZHJhZ1NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2RyYWdBbmREcm9wL2RyYWdTZXJ2aWNlXCIpO1xuZXhwb3J0cy5EcmFnU2VydmljZSA9IGRyYWdTZXJ2aWNlXzEuRHJhZ1NlcnZpY2U7XG4vLyBlbnRpdGllc1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvZW50aXRpZXMvY29sdW1uXCIpO1xuZXhwb3J0cy5Db2x1bW4gPSBjb2x1bW5fMS5Db2x1bW47XG52YXIgY29sdW1uR3JvdXBfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2VudGl0aWVzL2NvbHVtbkdyb3VwXCIpO1xuZXhwb3J0cy5Db2x1bW5Hcm91cCA9IGNvbHVtbkdyb3VwXzEuQ29sdW1uR3JvdXA7XG52YXIgZ3JpZENlbGxfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2VudGl0aWVzL2dyaWRDZWxsXCIpO1xuZXhwb3J0cy5HcmlkQ2VsbCA9IGdyaWRDZWxsXzEuR3JpZENlbGw7XG52YXIgZ3JpZFJvd18xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvZW50aXRpZXMvZ3JpZFJvd1wiKTtcbmV4cG9ydHMuR3JpZFJvdyA9IGdyaWRSb3dfMS5HcmlkUm93O1xudmFyIG9yaWdpbmFsQ29sdW1uR3JvdXBfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2VudGl0aWVzL29yaWdpbmFsQ29sdW1uR3JvdXBcIik7XG5leHBvcnRzLk9yaWdpbmFsQ29sdW1uR3JvdXAgPSBvcmlnaW5hbENvbHVtbkdyb3VwXzEuT3JpZ2luYWxDb2x1bW5Hcm91cDtcbnZhciByb3dOb2RlXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9lbnRpdGllcy9yb3dOb2RlXCIpO1xuZXhwb3J0cy5Sb3dOb2RlID0gcm93Tm9kZV8xLlJvd05vZGU7XG4vLyBmaWx0ZXJcbnZhciBiYXNlRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9maWx0ZXIvYmFzZUZpbHRlclwiKTtcbmV4cG9ydHMuQmFzZUZpbHRlciA9IGJhc2VGaWx0ZXJfMS5CYXNlRmlsdGVyO1xudmFyIGRhdGVGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2ZpbHRlci9kYXRlRmlsdGVyXCIpO1xuZXhwb3J0cy5EYXRlRmlsdGVyID0gZGF0ZUZpbHRlcl8xLkRhdGVGaWx0ZXI7XG52YXIgZmlsdGVyTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvZmlsdGVyL2ZpbHRlck1hbmFnZXJcIik7XG5leHBvcnRzLkZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyXzEuRmlsdGVyTWFuYWdlcjtcbnZhciBudW1iZXJGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2ZpbHRlci9udW1iZXJGaWx0ZXJcIik7XG5leHBvcnRzLk51bWJlckZpbHRlciA9IG51bWJlckZpbHRlcl8xLk51bWJlckZpbHRlcjtcbnZhciB0ZXh0RmlsdGVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9maWx0ZXIvdGV4dEZpbHRlclwiKTtcbmV4cG9ydHMuVGV4dEZpbHRlciA9IHRleHRGaWx0ZXJfMS5UZXh0RmlsdGVyO1xuLy8gZ3JpZFBhbmVsXG52YXIgZ3JpZFBhbmVsXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9ncmlkUGFuZWwvZ3JpZFBhbmVsXCIpO1xuZXhwb3J0cy5HcmlkUGFuZWwgPSBncmlkUGFuZWxfMS5HcmlkUGFuZWw7XG52YXIgc2Nyb2xsVmlzaWJsZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2dyaWRQYW5lbC9zY3JvbGxWaXNpYmxlU2VydmljZVwiKTtcbmV4cG9ydHMuU2Nyb2xsVmlzaWJsZVNlcnZpY2UgPSBzY3JvbGxWaXNpYmxlU2VydmljZV8xLlNjcm9sbFZpc2libGVTZXJ2aWNlO1xudmFyIG1vdXNlRXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9ncmlkUGFuZWwvbW91c2VFdmVudFNlcnZpY2VcIik7XG5leHBvcnRzLk1vdXNlRXZlbnRTZXJ2aWNlID0gbW91c2VFdmVudFNlcnZpY2VfMS5Nb3VzZUV2ZW50U2VydmljZTtcbi8vIGhlYWRlclJlbmRlcmluZ1xudmFyIGJvZHlEcm9wUGl2b3RUYXJnZXRfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9ib2R5RHJvcFBpdm90VGFyZ2V0XCIpO1xuZXhwb3J0cy5Cb2R5RHJvcFBpdm90VGFyZ2V0ID0gYm9keURyb3BQaXZvdFRhcmdldF8xLkJvZHlEcm9wUGl2b3RUYXJnZXQ7XG52YXIgYm9keURyb3BUYXJnZXRfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9ib2R5RHJvcFRhcmdldFwiKTtcbmV4cG9ydHMuQm9keURyb3BUYXJnZXQgPSBib2R5RHJvcFRhcmdldF8xLkJvZHlEcm9wVGFyZ2V0O1xudmFyIGNzc0NsYXNzQXBwbGllcl8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2Nzc0NsYXNzQXBwbGllclwiKTtcbmV4cG9ydHMuQ3NzQ2xhc3NBcHBsaWVyID0gY3NzQ2xhc3NBcHBsaWVyXzEuQ3NzQ2xhc3NBcHBsaWVyO1xudmFyIGhlYWRlckNvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2hlYWRlckNvbnRhaW5lclwiKTtcbmV4cG9ydHMuSGVhZGVyQ29udGFpbmVyID0gaGVhZGVyQ29udGFpbmVyXzEuSGVhZGVyQ29udGFpbmVyO1xudmFyIGhlYWRlclJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyUmVuZGVyZXJcIik7XG5leHBvcnRzLkhlYWRlclJlbmRlcmVyID0gaGVhZGVyUmVuZGVyZXJfMS5IZWFkZXJSZW5kZXJlcjtcbnZhciBoZWFkZXJSb3dDb21wXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyUm93Q29tcFwiKTtcbmV4cG9ydHMuSGVhZGVyUm93Q29tcCA9IGhlYWRlclJvd0NvbXBfMS5IZWFkZXJSb3dDb21wO1xudmFyIGhlYWRlclRlbXBsYXRlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvZGVwcmVjYXRlZC9oZWFkZXJUZW1wbGF0ZUxvYWRlclwiKTtcbmV4cG9ydHMuSGVhZGVyVGVtcGxhdGVMb2FkZXIgPSBoZWFkZXJUZW1wbGF0ZUxvYWRlcl8xLkhlYWRlclRlbXBsYXRlTG9hZGVyO1xudmFyIGhvcml6b250YWxEcmFnU2VydmljZV8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2hvcml6b250YWxEcmFnU2VydmljZVwiKTtcbmV4cG9ydHMuSG9yaXpvbnRhbERyYWdTZXJ2aWNlID0gaG9yaXpvbnRhbERyYWdTZXJ2aWNlXzEuSG9yaXpvbnRhbERyYWdTZXJ2aWNlO1xudmFyIG1vdmVDb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvbW92ZUNvbHVtbkNvbnRyb2xsZXJcIik7XG5leHBvcnRzLk1vdmVDb2x1bW5Db250cm9sbGVyID0gbW92ZUNvbHVtbkNvbnRyb2xsZXJfMS5Nb3ZlQ29sdW1uQ29udHJvbGxlcjtcbnZhciByZW5kZXJlZEhlYWRlckNlbGxfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9kZXByZWNhdGVkL3JlbmRlcmVkSGVhZGVyQ2VsbFwiKTtcbmV4cG9ydHMuUmVuZGVyZWRIZWFkZXJDZWxsID0gcmVuZGVyZWRIZWFkZXJDZWxsXzEuUmVuZGVyZWRIZWFkZXJDZWxsO1xudmFyIHN0YW5kYXJkTWVudV8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL3N0YW5kYXJkTWVudVwiKTtcbmV4cG9ydHMuU3RhbmRhcmRNZW51RmFjdG9yeSA9IHN0YW5kYXJkTWVudV8xLlN0YW5kYXJkTWVudUZhY3Rvcnk7XG4vLyBsYXlvdXRcbnZhciBib3JkZXJMYXlvdXRfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2xheW91dC9ib3JkZXJMYXlvdXRcIik7XG5leHBvcnRzLkJvcmRlckxheW91dCA9IGJvcmRlckxheW91dF8xLkJvcmRlckxheW91dDtcbnZhciB0YWJiZWRMYXlvdXRfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2xheW91dC90YWJiZWRMYXlvdXRcIik7XG5leHBvcnRzLlRhYmJlZExheW91dCA9IHRhYmJlZExheW91dF8xLlRhYmJlZExheW91dDtcbnZhciB2ZXJ0aWNhbFN0YWNrXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9sYXlvdXQvdmVydGljYWxTdGFja1wiKTtcbmV4cG9ydHMuVmVydGljYWxTdGFjayA9IHZlcnRpY2FsU3RhY2tfMS5WZXJ0aWNhbFN0YWNrO1xuLy8gbWlzY1xudmFyIHNpbXBsZUh0dHBSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9taXNjL3NpbXBsZUh0dHBSZXF1ZXN0XCIpO1xuZXhwb3J0cy5zaW1wbGVIdHRwUmVxdWVzdCA9IHNpbXBsZUh0dHBSZXF1ZXN0XzEuc2ltcGxlSHR0cFJlcXVlc3Q7XG52YXIgbGFyZ2VUZXh0Q2VsbEVkaXRvcl8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxFZGl0b3JzL2xhcmdlVGV4dENlbGxFZGl0b3JcIik7XG5leHBvcnRzLkxhcmdlVGV4dENlbGxFZGl0b3IgPSBsYXJnZVRleHRDZWxsRWRpdG9yXzEuTGFyZ2VUZXh0Q2VsbEVkaXRvcjtcbnZhciBwb3B1cEVkaXRvcldyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsRWRpdG9ycy9wb3B1cEVkaXRvcldyYXBwZXJcIik7XG5leHBvcnRzLlBvcHVwRWRpdG9yV3JhcHBlciA9IHBvcHVwRWRpdG9yV3JhcHBlcl8xLlBvcHVwRWRpdG9yV3JhcHBlcjtcbnZhciBwb3B1cFNlbGVjdENlbGxFZGl0b3JfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsRWRpdG9ycy9wb3B1cFNlbGVjdENlbGxFZGl0b3JcIik7XG5leHBvcnRzLlBvcHVwU2VsZWN0Q2VsbEVkaXRvciA9IHBvcHVwU2VsZWN0Q2VsbEVkaXRvcl8xLlBvcHVwU2VsZWN0Q2VsbEVkaXRvcjtcbnZhciBwb3B1cFRleHRDZWxsRWRpdG9yXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbEVkaXRvcnMvcG9wdXBUZXh0Q2VsbEVkaXRvclwiKTtcbmV4cG9ydHMuUG9wdXBUZXh0Q2VsbEVkaXRvciA9IHBvcHVwVGV4dENlbGxFZGl0b3JfMS5Qb3B1cFRleHRDZWxsRWRpdG9yO1xudmFyIHNlbGVjdENlbGxFZGl0b3JfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsRWRpdG9ycy9zZWxlY3RDZWxsRWRpdG9yXCIpO1xuZXhwb3J0cy5TZWxlY3RDZWxsRWRpdG9yID0gc2VsZWN0Q2VsbEVkaXRvcl8xLlNlbGVjdENlbGxFZGl0b3I7XG52YXIgdGV4dENlbGxFZGl0b3JfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsRWRpdG9ycy90ZXh0Q2VsbEVkaXRvclwiKTtcbmV4cG9ydHMuVGV4dENlbGxFZGl0b3IgPSB0ZXh0Q2VsbEVkaXRvcl8xLlRleHRDZWxsRWRpdG9yO1xudmFyIGFuaW1hdGVTaG93Q2hhbmdlQ2VsbFJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbFJlbmRlcmVycy9hbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlclwiKTtcbmV4cG9ydHMuQW5pbWF0ZVNob3dDaGFuZ2VDZWxsUmVuZGVyZXIgPSBhbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlcl8xLkFuaW1hdGVTaG93Q2hhbmdlQ2VsbFJlbmRlcmVyO1xudmFyIGFuaW1hdGVTbGlkZUNlbGxSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxSZW5kZXJlcnMvYW5pbWF0ZVNsaWRlQ2VsbFJlbmRlcmVyXCIpO1xuZXhwb3J0cy5BbmltYXRlU2xpZGVDZWxsUmVuZGVyZXIgPSBhbmltYXRlU2xpZGVDZWxsUmVuZGVyZXJfMS5BbmltYXRlU2xpZGVDZWxsUmVuZGVyZXI7XG52YXIgZ3JvdXBDZWxsUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsUmVuZGVyZXJzL2dyb3VwQ2VsbFJlbmRlcmVyXCIpO1xuZXhwb3J0cy5Hcm91cENlbGxSZW5kZXJlciA9IGdyb3VwQ2VsbFJlbmRlcmVyXzEuR3JvdXBDZWxsUmVuZGVyZXI7XG4vLyBmZWF0dXJlc1xudmFyIHNldExlZnRGZWF0dXJlXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9yZW5kZXJpbmcvZmVhdHVyZXMvc2V0TGVmdEZlYXR1cmVcIik7XG5leHBvcnRzLlNldExlZnRGZWF0dXJlID0gc2V0TGVmdEZlYXR1cmVfMS5TZXRMZWZ0RmVhdHVyZTtcbi8vIHJlbmRlcmluZ1xudmFyIGF1dG9XaWR0aENhbGN1bGF0b3JfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9hdXRvV2lkdGhDYWxjdWxhdG9yXCIpO1xuZXhwb3J0cy5BdXRvV2lkdGhDYWxjdWxhdG9yID0gYXV0b1dpZHRoQ2FsY3VsYXRvcl8xLkF1dG9XaWR0aENhbGN1bGF0b3I7XG52YXIgY2VsbEVkaXRvckZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsRWRpdG9yRmFjdG9yeVwiKTtcbmV4cG9ydHMuQ2VsbEVkaXRvckZhY3RvcnkgPSBjZWxsRWRpdG9yRmFjdG9yeV8xLkNlbGxFZGl0b3JGYWN0b3J5O1xudmFyIGNlbGxSZW5kZXJlckZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsUmVuZGVyZXJGYWN0b3J5XCIpO1xuZXhwb3J0cy5DZWxsUmVuZGVyZXJGYWN0b3J5ID0gY2VsbFJlbmRlcmVyRmFjdG9yeV8xLkNlbGxSZW5kZXJlckZhY3Rvcnk7XG52YXIgY2VsbFJlbmRlcmVyU2VydmljZV8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxSZW5kZXJlclNlcnZpY2VcIik7XG5leHBvcnRzLkNlbGxSZW5kZXJlclNlcnZpY2UgPSBjZWxsUmVuZGVyZXJTZXJ2aWNlXzEuQ2VsbFJlbmRlcmVyU2VydmljZTtcbnZhciBjaGVja2JveFNlbGVjdGlvbkNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvcmVuZGVyaW5nL2NoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50XCIpO1xuZXhwb3J0cy5DaGVja2JveFNlbGVjdGlvbkNvbXBvbmVudCA9IGNoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50XzEuQ2hlY2tib3hTZWxlY3Rpb25Db21wb25lbnQ7XG52YXIgY2VsbENvbXBfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsQ29tcFwiKTtcbmV4cG9ydHMuQ2VsbENvbXAgPSBjZWxsQ29tcF8xLkNlbGxDb21wO1xudmFyIHJvd0NvbXBfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9yb3dDb21wXCIpO1xuZXhwb3J0cy5Sb3dDb21wID0gcm93Q29tcF8xLlJvd0NvbXA7XG52YXIgcm93UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3JlbmRlcmluZy9yb3dSZW5kZXJlclwiKTtcbmV4cG9ydHMuUm93UmVuZGVyZXIgPSByb3dSZW5kZXJlcl8xLlJvd1JlbmRlcmVyO1xudmFyIHZhbHVlRm9ybWF0dGVyU2VydmljZV8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvcmVuZGVyaW5nL3ZhbHVlRm9ybWF0dGVyU2VydmljZVwiKTtcbmV4cG9ydHMuVmFsdWVGb3JtYXR0ZXJTZXJ2aWNlID0gdmFsdWVGb3JtYXR0ZXJTZXJ2aWNlXzEuVmFsdWVGb3JtYXR0ZXJTZXJ2aWNlO1xuLy8gcm93Q29udHJvbGxlcnMvaW5NZW1vcnlcbnZhciBmaWx0ZXJTdGFnZV8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvcm93TW9kZWxzL2luTWVtb3J5L2ZpbHRlclN0YWdlXCIpO1xuZXhwb3J0cy5GaWx0ZXJTdGFnZSA9IGZpbHRlclN0YWdlXzEuRmlsdGVyU3RhZ2U7XG52YXIgZmxhdHRlblN0YWdlXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9yb3dNb2RlbHMvaW5NZW1vcnkvZmxhdHRlblN0YWdlXCIpO1xuZXhwb3J0cy5GbGF0dGVuU3RhZ2UgPSBmbGF0dGVuU3RhZ2VfMS5GbGF0dGVuU3RhZ2U7XG52YXIgc29ydFN0YWdlXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9yb3dNb2RlbHMvaW5NZW1vcnkvc29ydFN0YWdlXCIpO1xuZXhwb3J0cy5Tb3J0U3RhZ2UgPSBzb3J0U3RhZ2VfMS5Tb3J0U3RhZ2U7XG4vLyByb3cgbW9kZWxzXG52YXIgcGlubmVkUm93TW9kZWxfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3Jvd01vZGVscy9waW5uZWRSb3dNb2RlbFwiKTtcbmV4cG9ydHMuUGlubmVkUm93TW9kZWwgPSBwaW5uZWRSb3dNb2RlbF8xLlBpbm5lZFJvd01vZGVsO1xudmFyIGluTWVtb3J5Um93TW9kZWxfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3Jvd01vZGVscy9pbk1lbW9yeS9pbk1lbW9yeVJvd01vZGVsXCIpO1xuZXhwb3J0cy5Jbk1lbW9yeVJvd01vZGVsID0gaW5NZW1vcnlSb3dNb2RlbF8xLkluTWVtb3J5Um93TW9kZWw7XG52YXIgY2hhbmdlZFBhdGhfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3Jvd01vZGVscy9pbk1lbW9yeS9jaGFuZ2VkUGF0aFwiKTtcbmV4cG9ydHMuQ2hhbmdlZFBhdGggPSBjaGFuZ2VkUGF0aF8xLkNoYW5nZWRQYXRoO1xudmFyIGluTWVtb3J5Tm9kZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3Jvd01vZGVscy9pbk1lbW9yeS9pbk1lbW9yeU5vZGVNYW5hZ2VyXCIpO1xuZXhwb3J0cy5Jbk1lbW9yeU5vZGVNYW5hZ2VyID0gaW5NZW1vcnlOb2RlTWFuYWdlcl8xLkluTWVtb3J5Tm9kZU1hbmFnZXI7XG52YXIgaW5maW5pdGVSb3dNb2RlbF8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvcm93TW9kZWxzL2luZmluaXRlL2luZmluaXRlUm93TW9kZWxcIik7XG5leHBvcnRzLkluZmluaXRlUm93TW9kZWwgPSBpbmZpbml0ZVJvd01vZGVsXzEuSW5maW5pdGVSb3dNb2RlbDtcbnZhciByb3dOb2RlQmxvY2tfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3Jvd01vZGVscy9jYWNoZS9yb3dOb2RlQmxvY2tcIik7XG5leHBvcnRzLlJvd05vZGVCbG9jayA9IHJvd05vZGVCbG9ja18xLlJvd05vZGVCbG9jaztcbnZhciByb3dOb2RlQmxvY2tMb2FkZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3Jvd01vZGVscy9jYWNoZS9yb3dOb2RlQmxvY2tMb2FkZXJcIik7XG5leHBvcnRzLlJvd05vZGVCbG9ja0xvYWRlciA9IHJvd05vZGVCbG9ja0xvYWRlcl8xLlJvd05vZGVCbG9ja0xvYWRlcjtcbnZhciByb3dOb2RlQ2FjaGVfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3Jvd01vZGVscy9jYWNoZS9yb3dOb2RlQ2FjaGVcIik7XG5leHBvcnRzLlJvd05vZGVDYWNoZSA9IHJvd05vZGVDYWNoZV8xLlJvd05vZGVDYWNoZTtcbi8vc3R5bGluZ1xudmFyIHN0eWxpbmdTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9zdHlsaW5nL3N0eWxpbmdTZXJ2aWNlXCIpO1xuZXhwb3J0cy5TdHlsaW5nU2VydmljZSA9IHN0eWxpbmdTZXJ2aWNlXzEuU3R5bGluZ1NlcnZpY2U7XG4vLyB3aWRnZXRzXG52YXIgYWdDaGVja2JveF8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvd2lkZ2V0cy9hZ0NoZWNrYm94XCIpO1xuZXhwb3J0cy5BZ0NoZWNrYm94ID0gYWdDaGVja2JveF8xLkFnQ2hlY2tib3g7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi93aWRnZXRzL2NvbXBvbmVudFwiKTtcbmV4cG9ydHMuQ29tcG9uZW50ID0gY29tcG9uZW50XzEuQ29tcG9uZW50O1xudmFyIHBvcHVwU2VydmljZV8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvd2lkZ2V0cy9wb3B1cFNlcnZpY2VcIik7XG5leHBvcnRzLlBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZV8xLlBvcHVwU2VydmljZTtcbnZhciB0b3VjaExpc3RlbmVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi93aWRnZXRzL3RvdWNoTGlzdGVuZXJcIik7XG5leHBvcnRzLlRvdWNoTGlzdGVuZXIgPSB0b3VjaExpc3RlbmVyXzEuVG91Y2hMaXN0ZW5lcjtcbi8vIHJvb3RcbnZhciBiYXNlRnJhbWV3b3JrRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvYmFzZUZyYW1ld29ya0ZhY3RvcnlcIik7XG5leHBvcnRzLkJhc2VGcmFtZXdvcmtGYWN0b3J5ID0gYmFzZUZyYW1ld29ya0ZhY3RvcnlfMS5CYXNlRnJhbWV3b3JrRmFjdG9yeTtcbnZhciBjZWxsTmF2aWdhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2NlbGxOYXZpZ2F0aW9uU2VydmljZVwiKTtcbmV4cG9ydHMuQ2VsbE5hdmlnYXRpb25TZXJ2aWNlID0gY2VsbE5hdmlnYXRpb25TZXJ2aWNlXzEuQ2VsbE5hdmlnYXRpb25TZXJ2aWNlO1xudmFyIGFsaWduZWRHcmlkc1NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2FsaWduZWRHcmlkc1NlcnZpY2VcIik7XG5leHBvcnRzLkFsaWduZWRHcmlkc1NlcnZpY2UgPSBhbGlnbmVkR3JpZHNTZXJ2aWNlXzEuQWxpZ25lZEdyaWRzU2VydmljZTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2NvbnN0YW50c1wiKTtcbmV4cG9ydHMuQ29uc3RhbnRzID0gY29uc3RhbnRzXzEuQ29uc3RhbnRzO1xudmFyIGNzdkNyZWF0b3JfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2NzdkNyZWF0b3JcIik7XG5leHBvcnRzLkNzdkNyZWF0b3IgPSBjc3ZDcmVhdG9yXzEuQ3N2Q3JlYXRvcjtcbmV4cG9ydHMuQmFzZUNyZWF0b3IgPSBjc3ZDcmVhdG9yXzEuQmFzZUNyZWF0b3I7XG52YXIgZG93bmxvYWRlcl8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvZG93bmxvYWRlclwiKTtcbmV4cG9ydHMuRG93bmxvYWRlciA9IGRvd25sb2FkZXJfMS5Eb3dubG9hZGVyO1xudmFyIGdyaWRfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2dyaWRcIik7XG5leHBvcnRzLkdyaWQgPSBncmlkXzEuR3JpZDtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9ncmlkQXBpXCIpO1xuZXhwb3J0cy5HcmlkQXBpID0gZ3JpZEFwaV8xLkdyaWRBcGk7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9ldmVudHNcIik7XG5leHBvcnRzLkV2ZW50cyA9IGV2ZW50c18xLkV2ZW50cztcbnZhciBmb2N1c2VkQ2VsbENvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2ZvY3VzZWRDZWxsQ29udHJvbGxlclwiKTtcbmV4cG9ydHMuRm9jdXNlZENlbGxDb250cm9sbGVyID0gZm9jdXNlZENlbGxDb250cm9sbGVyXzEuRm9jdXNlZENlbGxDb250cm9sbGVyO1xudmFyIGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvZnVuY3Rpb25zXCIpO1xuZXhwb3J0cy5kZWZhdWx0R3JvdXBDb21wYXJhdG9yID0gZnVuY3Rpb25zXzEuZGVmYXVsdEdyb3VwQ29tcGFyYXRvcjtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbmV4cG9ydHMuR3JpZE9wdGlvbnNXcmFwcGVyID0gZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvZXZlbnRTZXJ2aWNlXCIpO1xuZXhwb3J0cy5FdmVudFNlcnZpY2UgPSBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2U7XG52YXIgZ3JpZENvcmVfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2dyaWRDb3JlXCIpO1xuZXhwb3J0cy5HcmlkQ29yZSA9IGdyaWRDb3JlXzEuR3JpZENvcmU7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9sb2dnZXJcIik7XG5leHBvcnRzLkxvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlcjtcbnZhciBzZWxlY3Rpb25Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9zZWxlY3Rpb25Db250cm9sbGVyXCIpO1xuZXhwb3J0cy5TZWxlY3Rpb25Db250cm9sbGVyID0gc2VsZWN0aW9uQ29udHJvbGxlcl8xLlNlbGVjdGlvbkNvbnRyb2xsZXI7XG52YXIgc29ydENvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL3NvcnRDb250cm9sbGVyXCIpO1xuZXhwb3J0cy5Tb3J0Q29udHJvbGxlciA9IHNvcnRDb250cm9sbGVyXzEuU29ydENvbnRyb2xsZXI7XG52YXIgdGVtcGxhdGVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi90ZW1wbGF0ZVNlcnZpY2VcIik7XG5leHBvcnRzLlRlbXBsYXRlU2VydmljZSA9IHRlbXBsYXRlU2VydmljZV8xLlRlbXBsYXRlU2VydmljZTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvdXRpbHNcIik7XG5leHBvcnRzLlV0aWxzID0gdXRpbHNfMS5VdGlscztcbmV4cG9ydHMuTnVtYmVyU2VxdWVuY2UgPSB1dGlsc18xLk51bWJlclNlcXVlbmNlO1xuZXhwb3J0cy5fID0gdXRpbHNfMS5fO1xuZXhwb3J0cy5Qcm9taXNlID0gdXRpbHNfMS5Qcm9taXNlO1xudmFyIHZhbHVlU2VydmljZV8xID0gcmVxdWlyZShcIi4vZGlzdC9saWIvdmFsdWVTZXJ2aWNlL3ZhbHVlU2VydmljZVwiKTtcbmV4cG9ydHMuVmFsdWVTZXJ2aWNlID0gdmFsdWVTZXJ2aWNlXzEuVmFsdWVTZXJ2aWNlO1xudmFyIGV4cHJlc3Npb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi92YWx1ZVNlcnZpY2UvZXhwcmVzc2lvblNlcnZpY2VcIik7XG5leHBvcnRzLkV4cHJlc3Npb25TZXJ2aWNlID0gZXhwcmVzc2lvblNlcnZpY2VfMS5FeHByZXNzaW9uU2VydmljZTtcbnZhciB4bWxGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi94bWxGYWN0b3J5XCIpO1xuZXhwb3J0cy5YbWxGYWN0b3J5ID0geG1sRmFjdG9yeV8xLlhtbEZhY3Rvcnk7XG52YXIgZ3JpZFNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2dyaWRTZXJpYWxpemVyXCIpO1xuZXhwb3J0cy5HcmlkU2VyaWFsaXplciA9IGdyaWRTZXJpYWxpemVyXzEuR3JpZFNlcmlhbGl6ZXI7XG5leHBvcnRzLkJhc2VHcmlkU2VyaWFsaXppbmdTZXNzaW9uID0gZ3JpZFNlcmlhbGl6ZXJfMS5CYXNlR3JpZFNlcmlhbGl6aW5nU2Vzc2lvbjtcbmV4cG9ydHMuUm93VHlwZSA9IGdyaWRTZXJpYWxpemVyXzEuUm93VHlwZTtcbnZhciBsb2dnZXJfMiA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2xvZ2dlclwiKTtcbmV4cG9ydHMuTG9nZ2VyRmFjdG9yeSA9IGxvZ2dlcl8yLkxvZ2dlckZhY3Rvcnk7XG52YXIgY29sdW1uQ29udHJvbGxlcl8yID0gcmVxdWlyZShcIi4vZGlzdC9saWIvY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xuZXhwb3J0cy5Db2x1bW5BcGkgPSBjb2x1bW5Db250cm9sbGVyXzIuQ29sdW1uQXBpO1xudmFyIGZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2Rpc3QvbGliL2NvbXBvbmVudHMvZnJhbWV3b3JrL2ZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXJcIik7XG5leHBvcnRzLkJhc2VDb21wb25lbnRXcmFwcGVyID0gZnJhbWV3b3JrQ29tcG9uZW50V3JhcHBlcl8xLkJhc2VDb21wb25lbnRXcmFwcGVyO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9kaXN0L2xpYi9lbnZpcm9ubWVudFwiKTtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBncmlkUm93XzEgPSByZXF1aXJlKFwiLi9lbnRpdGllcy9ncmlkUm93XCIpO1xudmFyIGdyaWRDZWxsXzEgPSByZXF1aXJlKFwiLi9lbnRpdGllcy9ncmlkQ2VsbFwiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBwaW5uZWRSb3dNb2RlbF8xID0gcmVxdWlyZShcIi4vcm93TW9kZWxzL3Bpbm5lZFJvd01vZGVsXCIpO1xudmFyIENlbGxOYXZpZ2F0aW9uU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VsbE5hdmlnYXRpb25TZXJ2aWNlKCkge1xuICAgIH1cbiAgICAvLyByZXR1cm5zIG51bGwgaWYgbm8gY2VsbCB0byBmb2N1cyBvbiwgaWUgYXQgdGhlIGVuZCBvZiB0aGUgZ3JpZFxuICAgIENlbGxOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0TmV4dENlbGxUb0ZvY3VzID0gZnVuY3Rpb24gKGtleSwgbGFzdENlbGxUb0ZvY3VzKSB7XG4gICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggdGhlIHByb3ZpZGVkIGNlbGwsIHdlIGtlZXAgbW92aW5nIHVudGlsIHdlIGZpbmQgYSBjZWxsIHdlIGNhblxuICAgICAgICAvLyBmb2N1cyBvbi5cbiAgICAgICAgdmFyIHBvaW50ZXIgPSBsYXN0Q2VsbFRvRm9jdXM7XG4gICAgICAgIHZhciBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAvLyBmaW5pc2hlZCB3aWxsIGJlIHRydWUgd2hlbiBlaXRoZXI6XG4gICAgICAgIC8vIGEpIGNlbGwgZm91bmQgdGhhdCB3ZSBjYW4gZm9jdXMgb25cbiAgICAgICAgLy8gYikgcnVuIG91dCBvZiBjZWxscyAoaWUgdGhlIG1ldGhvZCByZXR1cm5zIG51bGwpXG4gICAgICAgIHdoaWxlICghZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX1VQOlxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRDZWxsQWJvdmUocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9ET1dOOlxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRDZWxsQmVsb3cocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldENlbGxUb0xlZnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRDZWxsVG9SaWdodChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldENlbGxUb1JpZ2h0KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0Q2VsbFRvTGVmdChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogdW5rbm93biBrZXkgZm9yIG5hdmlnYXRpb24gJyArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0aGlzLmlzQ2VsbEdvb2RUb0ZvY3VzT24ocG9pbnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50ZXI7XG4gICAgfTtcbiAgICBDZWxsTmF2aWdhdGlvblNlcnZpY2UucHJvdG90eXBlLmlzQ2VsbEdvb2RUb0ZvY3VzT24gPSBmdW5jdGlvbiAoZ3JpZENlbGwpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IGdyaWRDZWxsLmNvbHVtbjtcbiAgICAgICAgdmFyIHJvd05vZGU7XG4gICAgICAgIHN3aXRjaCAoZ3JpZENlbGwuZmxvYXRpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9UT1A6XG4gICAgICAgICAgICAgICAgcm93Tm9kZSA9IHRoaXMucGlubmVkUm93TW9kZWwuZ2V0UGlubmVkVG9wUm93KGdyaWRDZWxsLnJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9CT1RUT006XG4gICAgICAgICAgICAgICAgcm93Tm9kZSA9IHRoaXMucGlubmVkUm93TW9kZWwuZ2V0UGlubmVkQm90dG9tUm93KGdyaWRDZWxsLnJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcm93Tm9kZSA9IHRoaXMucm93TW9kZWwuZ2V0Um93KGdyaWRDZWxsLnJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VwcHJlc3NOYXZpZ2FibGUgPSBjb2x1bW4uaXNTdXBwcmVzc05hdmlnYWJsZShyb3dOb2RlKTtcbiAgICAgICAgcmV0dXJuICFzdXBwcmVzc05hdmlnYWJsZTtcbiAgICB9O1xuICAgIENlbGxOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q2VsbFRvTGVmdCA9IGZ1bmN0aW9uIChsYXN0Q2VsbCkge1xuICAgICAgICB2YXIgY29sVG9MZWZ0ID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldERpc3BsYXllZENvbEJlZm9yZShsYXN0Q2VsbC5jb2x1bW4pO1xuICAgICAgICBpZiAoIWNvbFRvTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ3JpZENlbGxEZWYgPSB7IHJvd0luZGV4OiBsYXN0Q2VsbC5yb3dJbmRleCwgY29sdW1uOiBjb2xUb0xlZnQsIGZsb2F0aW5nOiBsYXN0Q2VsbC5mbG9hdGluZyB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBncmlkQ2VsbF8xLkdyaWRDZWxsKGdyaWRDZWxsRGVmKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRDZWxsVG9SaWdodCA9IGZ1bmN0aW9uIChsYXN0Q2VsbCkge1xuICAgICAgICB2YXIgY29sVG9SaWdodCA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXREaXNwbGF5ZWRDb2xBZnRlcihsYXN0Q2VsbC5jb2x1bW4pO1xuICAgICAgICAvLyBpZiBhbHJlYWR5IG9uIHJpZ2h0LCBkbyBub3RoaW5nXG4gICAgICAgIGlmICghY29sVG9SaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ3JpZENlbGxEZWYgPSB7IHJvd0luZGV4OiBsYXN0Q2VsbC5yb3dJbmRleCwgY29sdW1uOiBjb2xUb1JpZ2h0LCBmbG9hdGluZzogbGFzdENlbGwuZmxvYXRpbmcgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ3JpZENlbGxfMS5HcmlkQ2VsbChncmlkQ2VsbERlZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Um93QmVsb3cgPSBmdW5jdGlvbiAobGFzdFJvdykge1xuICAgICAgICAvLyBpZiBhbHJlYWR5IG9uIHRvcCByb3csIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuaXNMYXN0Um93SW5Db250YWluZXIobGFzdFJvdykpIHtcbiAgICAgICAgICAgIGlmIChsYXN0Um93LmlzRmxvYXRpbmdCb3R0b20oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFzdFJvdy5pc05vdEZsb2F0aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5waW5uZWRSb3dNb2RlbC5pc1Jvd3NUb1JlbmRlcihjb25zdGFudHNfMS5Db25zdGFudHMuUElOTkVEX0JPVFRPTSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBncmlkUm93XzEuR3JpZFJvdygwLCBjb25zdGFudHNfMS5Db25zdGFudHMuUElOTkVEX0JPVFRPTSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3dNb2RlbC5pc1Jvd3NUb1JlbmRlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZ3JpZFJvd18xLkdyaWRSb3coMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGlubmVkUm93TW9kZWwuaXNSb3dzVG9SZW5kZXIoY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9CT1RUT00pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZ3JpZFJvd18xLkdyaWRSb3coMCwgY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9CT1RUT00pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBncmlkUm93XzEuR3JpZFJvdyhsYXN0Um93LnJvd0luZGV4ICsgMSwgbGFzdFJvdy5mbG9hdGluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q2VsbEJlbG93ID0gZnVuY3Rpb24gKGxhc3RDZWxsKSB7XG4gICAgICAgIHZhciByb3dCZWxvdyA9IHRoaXMuZ2V0Um93QmVsb3cobGFzdENlbGwuZ2V0R3JpZFJvdygpKTtcbiAgICAgICAgaWYgKHJvd0JlbG93KSB7XG4gICAgICAgICAgICB2YXIgZ3JpZENlbGxEZWYgPSB7IHJvd0luZGV4OiByb3dCZWxvdy5yb3dJbmRleCwgY29sdW1uOiBsYXN0Q2VsbC5jb2x1bW4sIGZsb2F0aW5nOiByb3dCZWxvdy5mbG9hdGluZyB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBncmlkQ2VsbF8xLkdyaWRDZWxsKGdyaWRDZWxsRGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsTmF2aWdhdGlvblNlcnZpY2UucHJvdG90eXBlLmlzTGFzdFJvd0luQ29udGFpbmVyID0gZnVuY3Rpb24gKGdyaWRSb3cpIHtcbiAgICAgICAgaWYgKGdyaWRSb3cuaXNGbG9hdGluZ1RvcCgpKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFRvcEluZGV4ID0gdGhpcy5waW5uZWRSb3dNb2RlbC5nZXRQaW5uZWRUb3BSb3dEYXRhKCkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHJldHVybiBsYXN0VG9wSW5kZXggPD0gZ3JpZFJvdy5yb3dJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChncmlkUm93LmlzRmxvYXRpbmdCb3R0b20oKSkge1xuICAgICAgICAgICAgdmFyIGxhc3RCb3R0b21JbmRleCA9IHRoaXMucGlubmVkUm93TW9kZWwuZ2V0UGlubmVkQm90dG9tUm93RGF0YSgpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICByZXR1cm4gbGFzdEJvdHRvbUluZGV4IDw9IGdyaWRSb3cucm93SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFzdEJvZHlJbmRleCA9IHRoaXMucm93TW9kZWwuZ2V0UGFnZUxhc3RSb3coKTtcbiAgICAgICAgICAgIHJldHVybiBsYXN0Qm9keUluZGV4IDw9IGdyaWRSb3cucm93SW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Um93QWJvdmUgPSBmdW5jdGlvbiAobGFzdFJvdykge1xuICAgICAgICAvLyBpZiBhbHJlYWR5IG9uIHRvcCByb3csIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKGxhc3RSb3cucm93SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChsYXN0Um93LmlzRmxvYXRpbmdUb3AoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFzdFJvdy5pc05vdEZsb2F0aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5waW5uZWRSb3dNb2RlbC5pc1Jvd3NUb1JlbmRlcihjb25zdGFudHNfMS5Db25zdGFudHMuUElOTkVEX1RPUCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFzdEZsb2F0aW5nVG9wUm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBsYXN0IGZsb2F0aW5nIGJvdHRvbVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvd01vZGVsLmlzUm93c1RvUmVuZGVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFzdEJvZHlDZWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGlubmVkUm93TW9kZWwuaXNSb3dzVG9SZW5kZXIoY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9UT1ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExhc3RGbG9hdGluZ1RvcFJvdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBncmlkUm93XzEuR3JpZFJvdyhsYXN0Um93LnJvd0luZGV4IC0gMSwgbGFzdFJvdy5mbG9hdGluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q2VsbEFib3ZlID0gZnVuY3Rpb24gKGxhc3RDZWxsKSB7XG4gICAgICAgIHZhciByb3dBYm92ZSA9IHRoaXMuZ2V0Um93QWJvdmUobGFzdENlbGwuZ2V0R3JpZFJvdygpKTtcbiAgICAgICAgaWYgKHJvd0Fib3ZlKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZENlbGxEZWYgPSB7IHJvd0luZGV4OiByb3dBYm92ZS5yb3dJbmRleCwgY29sdW1uOiBsYXN0Q2VsbC5jb2x1bW4sIGZsb2F0aW5nOiByb3dBYm92ZS5mbG9hdGluZyB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBncmlkQ2VsbF8xLkdyaWRDZWxsKGdyaWRDZWxsRGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWxsTmF2aWdhdGlvblNlcnZpY2UucHJvdG90eXBlLmdldExhc3RCb2R5Q2VsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhc3RCb2R5Um93ID0gdGhpcy5yb3dNb2RlbC5nZXRQYWdlTGFzdFJvdygpO1xuICAgICAgICByZXR1cm4gbmV3IGdyaWRSb3dfMS5HcmlkUm93KGxhc3RCb2R5Um93LCBudWxsKTtcbiAgICB9O1xuICAgIENlbGxOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0TGFzdEZsb2F0aW5nVG9wUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFzdEZsb2F0aW5nUm93ID0gdGhpcy5waW5uZWRSb3dNb2RlbC5nZXRQaW5uZWRUb3BSb3dEYXRhKCkubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIG5ldyBncmlkUm93XzEuR3JpZFJvdyhsYXN0RmxvYXRpbmdSb3csIGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfVE9QKTtcbiAgICB9O1xuICAgIENlbGxOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0TmV4dFRhYmJlZENlbGwgPSBmdW5jdGlvbiAoZ3JpZENlbGwsIGJhY2t3YXJkcykge1xuICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0VGFiYmVkQ2VsbEJhY2t3YXJkcyhncmlkQ2VsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0VGFiYmVkQ2VsbEZvcndhcmRzKGdyaWRDZWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2VsbE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXROZXh0VGFiYmVkQ2VsbEZvcndhcmRzID0gZnVuY3Rpb24gKGdyaWRDZWxsKSB7XG4gICAgICAgIHZhciBkaXNwbGF5ZWRDb2x1bW5zID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldEFsbERpc3BsYXllZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIG5ld1Jvd0luZGV4ID0gZ3JpZENlbGwucm93SW5kZXg7XG4gICAgICAgIHZhciBuZXdGbG9hdGluZyA9IGdyaWRDZWxsLmZsb2F0aW5nO1xuICAgICAgICAvLyBtb3ZlIGFsb25nIHRvIHRoZSBuZXh0IGNlbGxcbiAgICAgICAgdmFyIG5ld0NvbHVtbiA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXREaXNwbGF5ZWRDb2xBZnRlcihncmlkQ2VsbC5jb2x1bW4pO1xuICAgICAgICAvLyBjaGVjayBpZiBlbmQgb2YgdGhlIHJvdywgYW5kIGlmIHNvLCBnbyBmb3J3YXJkIGEgcm93XG4gICAgICAgIGlmICghbmV3Q29sdW1uKSB7XG4gICAgICAgICAgICBuZXdDb2x1bW4gPSBkaXNwbGF5ZWRDb2x1bW5zWzBdO1xuICAgICAgICAgICAgdmFyIHJvd0JlbG93ID0gdGhpcy5nZXRSb3dCZWxvdyhncmlkQ2VsbC5nZXRHcmlkUm93KCkpO1xuICAgICAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyhyb3dCZWxvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdSb3dJbmRleCA9IHJvd0JlbG93LnJvd0luZGV4O1xuICAgICAgICAgICAgbmV3RmxvYXRpbmcgPSByb3dCZWxvdy5mbG9hdGluZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JpZENlbGxEZWYgPSB7IHJvd0luZGV4OiBuZXdSb3dJbmRleCwgY29sdW1uOiBuZXdDb2x1bW4sIGZsb2F0aW5nOiBuZXdGbG9hdGluZyB9O1xuICAgICAgICByZXR1cm4gbmV3IGdyaWRDZWxsXzEuR3JpZENlbGwoZ3JpZENlbGxEZWYpO1xuICAgIH07XG4gICAgQ2VsbE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXROZXh0VGFiYmVkQ2VsbEJhY2t3YXJkcyA9IGZ1bmN0aW9uIChncmlkQ2VsbCkge1xuICAgICAgICB2YXIgZGlzcGxheWVkQ29sdW1ucyA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgICAgIHZhciBuZXdSb3dJbmRleCA9IGdyaWRDZWxsLnJvd0luZGV4O1xuICAgICAgICB2YXIgbmV3RmxvYXRpbmcgPSBncmlkQ2VsbC5mbG9hdGluZztcbiAgICAgICAgLy8gbW92ZSBhbG9uZyB0byB0aGUgbmV4dCBjZWxsXG4gICAgICAgIHZhciBuZXdDb2x1bW4gPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0RGlzcGxheWVkQ29sQmVmb3JlKGdyaWRDZWxsLmNvbHVtbik7XG4gICAgICAgIC8vIGNoZWNrIGlmIGVuZCBvZiB0aGUgcm93LCBhbmQgaWYgc28sIGdvIGZvcndhcmQgYSByb3dcbiAgICAgICAgaWYgKCFuZXdDb2x1bW4pIHtcbiAgICAgICAgICAgIG5ld0NvbHVtbiA9IGRpc3BsYXllZENvbHVtbnNbZGlzcGxheWVkQ29sdW1ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciByb3dBYm92ZSA9IHRoaXMuZ2V0Um93QWJvdmUoZ3JpZENlbGwuZ2V0R3JpZFJvdygpKTtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3Npbmcocm93QWJvdmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Um93SW5kZXggPSByb3dBYm92ZS5yb3dJbmRleDtcbiAgICAgICAgICAgIG5ld0Zsb2F0aW5nID0gcm93QWJvdmUuZmxvYXRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyaWRDZWxsRGVmID0geyByb3dJbmRleDogbmV3Um93SW5kZXgsIGNvbHVtbjogbmV3Q29sdW1uLCBmbG9hdGluZzogbmV3RmxvYXRpbmcgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBncmlkQ2VsbF8xLkdyaWRDZWxsKGdyaWRDZWxsRGVmKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5Db250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQ29udHJvbGxlcilcbiAgICBdLCBDZWxsTmF2aWdhdGlvblNlcnZpY2UucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncm93TW9kZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDZWxsTmF2aWdhdGlvblNlcnZpY2UucHJvdG90eXBlLCBcInJvd01vZGVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3Bpbm5lZFJvd01vZGVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBwaW5uZWRSb3dNb2RlbF8xLlBpbm5lZFJvd01vZGVsKVxuICAgIF0sIENlbGxOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUsIFwicGlubmVkUm93TW9kZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgQ2VsbE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBDZWxsTmF2aWdhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2NlbGxOYXZpZ2F0aW9uU2VydmljZScpXG4gICAgXSwgQ2VsbE5hdmlnYXRpb25TZXJ2aWNlKTtcbiAgICByZXR1cm4gQ2VsbE5hdmlnYXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuQ2VsbE5hdmlnYXRpb25TZXJ2aWNlID0gQ2VsbE5hdmlnYXRpb25TZXJ2aWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY2VsbE5hdmlnYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBjbGFzcyByZXR1cm5zIHVuaXF1ZSBpbnN0YW5jZSBpZCdzIGZvciBjb2x1bW5zLlxuLy8gZWcsIHRoZSBmb2xsb3dpbmcgY2FsbHMgKGluIHRoaXMgb3JkZXIpIHdpbGwgcmVzdWx0IGluOlxuLy9cbi8vIGdldEluc3RhbmNlSWRGb3JLZXkoJ2NvdW50cnknKSA9PiAwXG4vLyBnZXRJbnN0YW5jZUlkRm9yS2V5KCdjb3VudHJ5JykgPT4gMVxuLy8gZ2V0SW5zdGFuY2VJZEZvcktleSgnY291bnRyeScpID0+IDJcbi8vIGdldEluc3RhbmNlSWRGb3JLZXkoJ2NvdW50cnknKSA9PiAzXG4vLyBnZXRJbnN0YW5jZUlkRm9yS2V5KCdhZ2UnKSA9PiAwXG4vLyBnZXRJbnN0YW5jZUlkRm9yS2V5KCdhZ2UnKSA9PiAxXG4vLyBnZXRJbnN0YW5jZUlkRm9yS2V5KCdjb3VudHJ5JykgPT4gNFxudmFyIEdyb3VwSW5zdGFuY2VJZENyZWF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyb3VwSW5zdGFuY2VJZENyZWF0b3IoKSB7XG4gICAgICAgIC8vIHRoaXMgbWFwIGNvbnRhaW5zIGtleXMgdG8gbnVtYmVycywgc28gd2UgcmVtZW1iZXIgd2hhdCB0aGUgbGFzdCBjYWxsIHdhc1xuICAgICAgICB0aGlzLmV4aXN0aW5nSWRzID0ge307XG4gICAgfVxuICAgIEdyb3VwSW5zdGFuY2VJZENyZWF0b3IucHJvdG90eXBlLmdldEluc3RhbmNlSWRGb3JLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBsYXN0UmVzdWx0ID0gdGhpcy5leGlzdGluZ0lkc1trZXldO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodHlwZW9mIGxhc3RSZXN1bHQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB0aW1lIHRoaXMga2V5XG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gbGFzdFJlc3VsdCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leGlzdGluZ0lkc1trZXldID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwSW5zdGFuY2VJZENyZWF0b3I7XG59KCkpO1xuZXhwb3J0cy5Hcm91cEluc3RhbmNlSWRDcmVhdG9yID0gR3JvdXBJbnN0YW5jZUlkQ3JlYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbHVtbkNvbnRyb2xsZXIvZ3JvdXBJbnN0YW5jZUlkQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4uL2V2ZW50c1wiKTtcbnZhciBwcm9wZXJ0eUtleXNfMSA9IHJlcXVpcmUoXCIuLi9wcm9wZXJ0eUtleXNcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBDb21wb25lbnRVdGlsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRVdGlsKCkge1xuICAgIH1cbiAgICBDb21wb25lbnRVdGlsLmdldEV2ZW50Q2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIUNvbXBvbmVudFV0aWwuRVZFTlRfQ0FMTEJBQ0tTKSB7XG4gICAgICAgICAgICBDb21wb25lbnRVdGlsLkVWRU5UX0NBTExCQUNLUyA9IFtdO1xuICAgICAgICAgICAgQ29tcG9uZW50VXRpbC5FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50VXRpbC5FVkVOVF9DQUxMQkFDS1MucHVzaChDb21wb25lbnRVdGlsLmdldENhbGxiYWNrRm9yRXZlbnQoZXZlbnROYW1lKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29tcG9uZW50VXRpbC5FVkVOVF9DQUxMQkFDS1M7XG4gICAgfTtcbiAgICBDb21wb25lbnRVdGlsLmNvcHlBdHRyaWJ1dGVzVG9HcmlkT3B0aW9ucyA9IGZ1bmN0aW9uIChncmlkT3B0aW9ucywgY29tcG9uZW50KSB7XG4gICAgICAgIGNoZWNrRm9yRGVwcmVjYXRlZChjb21wb25lbnQpO1xuICAgICAgICAvLyBjcmVhdGUgZW1wdHkgZ3JpZCBvcHRpb25zIGlmIG5vbmUgd2VyZSBwYXNzZWRcbiAgICAgICAgaWYgKHR5cGVvZiBncmlkT3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGdyaWRPcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG8gYWxsb3cgYXJyYXkgc3R5bGUgbG9va3VwIGluIFR5cGVTY3JpcHQsIHRha2UgdHlwZSBhd2F5IGZyb20gJ3RoaXMnIGFuZCAnZ3JpZE9wdGlvbnMnXG4gICAgICAgIHZhciBwR3JpZE9wdGlvbnMgPSBncmlkT3B0aW9ucztcbiAgICAgICAgLy8gYWRkIGluIGFsbCB0aGUgc2ltcGxlIHByb3BlcnRpZXNcbiAgICAgICAgQ29tcG9uZW50VXRpbC5BUlJBWV9QUk9QRVJUSUVTXG4gICAgICAgICAgICAuY29uY2F0KENvbXBvbmVudFV0aWwuU1RSSU5HX1BST1BFUlRJRVMpXG4gICAgICAgICAgICAuY29uY2F0KENvbXBvbmVudFV0aWwuT0JKRUNUX1BST1BFUlRJRVMpXG4gICAgICAgICAgICAuY29uY2F0KENvbXBvbmVudFV0aWwuRlVOQ1RJT05fUFJPUEVSVElFUylcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50W2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcEdyaWRPcHRpb25zW2tleV0gPSBjb21wb25lbnRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIENvbXBvbmVudFV0aWwuQk9PTEVBTl9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwR3JpZE9wdGlvbnNba2V5XSA9IENvbXBvbmVudFV0aWwudG9Cb29sZWFuKGNvbXBvbmVudFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIENvbXBvbmVudFV0aWwuTlVNQkVSX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudFtrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBHcmlkT3B0aW9uc1trZXldID0gQ29tcG9uZW50VXRpbC50b051bWJlcihjb21wb25lbnRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBDb21wb25lbnRVdGlsLmdldEV2ZW50Q2FsbGJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAoZnVuY05hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50W2Z1bmNOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwR3JpZE9wdGlvbnNbZnVuY05hbWVdID0gY29tcG9uZW50W2Z1bmNOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncmlkT3B0aW9ucztcbiAgICB9O1xuICAgIENvbXBvbmVudFV0aWwuZ2V0Q2FsbGJhY2tGb3JFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFldmVudE5hbWUgfHwgZXZlbnROYW1lLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ29uJyArIGV2ZW50TmFtZVswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnROYW1lLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gY2hhbmdlIHRoaXMgbWV0aG9kLCB0aGUgY2FsbGVyIHNob3VsZCBrbm93IGlmIGl0J3MgaW5pdGlhbGlzZWQgb3Igbm90LCBwbHVzICdpbml0aWFsaXNlZCdcbiAgICAvLyBpcyBub3QgcmVsZXZhbnQgZm9yIGFsbCBjb21wb25lbnQgdHlwZXMuIG1heWJlIHBhc3MgaW4gdGhlIGFwaSBhbmQgY29sdW1uQXBpIGluc3RlYWQ/Pz9cbiAgICBDb21wb25lbnRVdGlsLnByb2Nlc3NPbkNoYW5nZSA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBncmlkT3B0aW9ucywgYXBpLCBjb2x1bW5BcGkpIHtcbiAgICAgICAgLy9pZiAoIWNvbXBvbmVudC5faW5pdGlhbGlzZWQgfHwgIWNoYW5nZXMpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRm9yRGVwcmVjYXRlZChjaGFuZ2VzKTtcbiAgICAgICAgLy8gdG8gYWxsb3cgYXJyYXkgc3R5bGUgbG9va3VwIGluIFR5cGVTY3JpcHQsIHRha2UgdHlwZSBhd2F5IGZyb20gJ3RoaXMnIGFuZCAnZ3JpZE9wdGlvbnMnXG4gICAgICAgIHZhciBwR3JpZE9wdGlvbnMgPSBncmlkT3B0aW9ucztcbiAgICAgICAgLy8gY2hlY2sgaWYgYW55IGNoYW5nZSBmb3IgdGhlIHNpbXBsZSB0eXBlcywgYW5kIGlmIHNvLCB0aGVuIGp1c3QgY29weSBpbiB0aGUgbmV3IHZhbHVlXG4gICAgICAgIENvbXBvbmVudFV0aWwuQVJSQVlfUFJPUEVSVElFU1xuICAgICAgICAgICAgLmNvbmNhdChDb21wb25lbnRVdGlsLk9CSkVDVF9QUk9QRVJUSUVTKVxuICAgICAgICAgICAgLmNvbmNhdChDb21wb25lbnRVdGlsLlNUUklOR19QUk9QRVJUSUVTKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHBHcmlkT3B0aW9uc1trZXldID0gY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIENvbXBvbmVudFV0aWwuQk9PTEVBTl9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHBHcmlkT3B0aW9uc1trZXldID0gQ29tcG9uZW50VXRpbC50b0Jvb2xlYW4oY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBDb21wb25lbnRVdGlsLk5VTUJFUl9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHBHcmlkT3B0aW9uc1trZXldID0gQ29tcG9uZW50VXRpbC50b051bWJlcihjaGFuZ2VzW2tleV0uY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIENvbXBvbmVudFV0aWwuZ2V0RXZlbnRDYWxsYmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jTmFtZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXNbZnVuY05hbWVdKSB7XG4gICAgICAgICAgICAgICAgcEdyaWRPcHRpb25zW2Z1bmNOYW1lXSA9IGNoYW5nZXNbZnVuY05hbWVdLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjaGFuZ2VzLnNob3dUb29sUGFuZWwpIHtcbiAgICAgICAgICAgIGFwaS5zaG93VG9vbFBhbmVsKENvbXBvbmVudFV0aWwudG9Cb29sZWFuKGNoYW5nZXMuc2hvd1Rvb2xQYW5lbC5jdXJyZW50VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5xdWlja0ZpbHRlclRleHQpIHtcbiAgICAgICAgICAgIGFwaS5zZXRRdWlja0ZpbHRlcihjaGFuZ2VzLnF1aWNrRmlsdGVyVGV4dC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnJvd0RhdGEpIHtcbiAgICAgICAgICAgIGFwaS5zZXRSb3dEYXRhKGNoYW5nZXMucm93RGF0YS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnBpbm5lZFRvcFJvd0RhdGEpIHtcbiAgICAgICAgICAgIGFwaS5zZXRQaW5uZWRUb3BSb3dEYXRhKGNoYW5nZXMucGlubmVkVG9wUm93RGF0YS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnBpbm5lZEJvdHRvbVJvd0RhdGEpIHtcbiAgICAgICAgICAgIGFwaS5zZXRQaW5uZWRCb3R0b21Sb3dEYXRhKGNoYW5nZXMucGlubmVkQm90dG9tUm93RGF0YS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLmNvbHVtbkRlZnMpIHtcbiAgICAgICAgICAgIGFwaS5zZXRDb2x1bW5EZWZzKGNoYW5nZXMuY29sdW1uRGVmcy5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLmRhdGFzb3VyY2UpIHtcbiAgICAgICAgICAgIGFwaS5zZXREYXRhc291cmNlKGNoYW5nZXMuZGF0YXNvdXJjZS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLmhlYWRlckhlaWdodCkge1xuICAgICAgICAgICAgYXBpLnNldEhlYWRlckhlaWdodChDb21wb25lbnRVdGlsLnRvTnVtYmVyKGNoYW5nZXMuaGVhZGVySGVpZ2h0LmN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnBhZ2luYXRpb25QYWdlU2l6ZSkge1xuICAgICAgICAgICAgYXBpLnBhZ2luYXRpb25TZXRQYWdlU2l6ZShDb21wb25lbnRVdGlsLnRvTnVtYmVyKGNoYW5nZXMucGFnaW5hdGlvblBhZ2VTaXplLmN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnBpdm90TW9kZSkge1xuICAgICAgICAgICAgY29sdW1uQXBpLnNldFBpdm90TW9kZShDb21wb25lbnRVdGlsLnRvQm9vbGVhbihjaGFuZ2VzLnBpdm90TW9kZS5jdXJyZW50VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5ncm91cFJlbW92ZVNpbmdsZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICBhcGkuc2V0R3JvdXBSZW1vdmVTaW5nbGVDaGlsZHJlbihDb21wb25lbnRVdGlsLnRvQm9vbGVhbihjaGFuZ2VzLmdyb3VwUmVtb3ZlU2luZ2xlQ2hpbGRyZW4uY3VycmVudFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBjaGFuZ2VzIGludG8gYW4gZXZlbnQgZm9yIGRpc3BhdGNoXG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT01QT05FTlRfU1RBVEVfQ0hBTkdFRCxcbiAgICAgICAgICAgIGFwaTogZ3JpZE9wdGlvbnMuYXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiBncmlkT3B0aW9ucy5jb2x1bW5BcGlcbiAgICAgICAgfTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KGNoYW5nZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBldmVudFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBhcGkuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcbiAgICBDb21wb25lbnRVdGlsLnRvQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBmb3IgYm9vbGVhbiwgY29tcGFyZSB0byBlbXB0eSBTdHJpbmcgdG8gYWxsb3cgYXR0cmlidXRlcyBhcHBlYXJpbmcgd2l0aFxuICAgICAgICAgICAgLy8gbm90IHZhbHVlIHRvIGJlIHRyZWF0ZWQgYXMgJ3RydWUnXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSVUUnIHx8IHZhbHVlID09ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21wb25lbnRVdGlsLnRvTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBhbGwgdGhlIGV2ZW50cyBhcmUgcG9wdWxhdGVkIGluIGhlcmUgQUZURVIgdGhpcyBjbGFzcyAoYXQgdGhlIGJvdHRvbSBvZiB0aGUgZmlsZSkuXG4gICAgQ29tcG9uZW50VXRpbC5FVkVOVFMgPSBbXTtcbiAgICBDb21wb25lbnRVdGlsLlNUUklOR19QUk9QRVJUSUVTID0gcHJvcGVydHlLZXlzXzEuUHJvcGVydHlLZXlzLlNUUklOR19QUk9QRVJUSUVTO1xuICAgIENvbXBvbmVudFV0aWwuT0JKRUNUX1BST1BFUlRJRVMgPSBwcm9wZXJ0eUtleXNfMS5Qcm9wZXJ0eUtleXMuT0JKRUNUX1BST1BFUlRJRVM7XG4gICAgQ29tcG9uZW50VXRpbC5BUlJBWV9QUk9QRVJUSUVTID0gcHJvcGVydHlLZXlzXzEuUHJvcGVydHlLZXlzLkFSUkFZX1BST1BFUlRJRVM7XG4gICAgQ29tcG9uZW50VXRpbC5OVU1CRVJfUFJPUEVSVElFUyA9IHByb3BlcnR5S2V5c18xLlByb3BlcnR5S2V5cy5OVU1CRVJfUFJPUEVSVElFUztcbiAgICBDb21wb25lbnRVdGlsLkJPT0xFQU5fUFJPUEVSVElFUyA9IHByb3BlcnR5S2V5c18xLlByb3BlcnR5S2V5cy5CT09MRUFOX1BST1BFUlRJRVM7XG4gICAgQ29tcG9uZW50VXRpbC5GVU5DVElPTl9QUk9QRVJUSUVTID0gcHJvcGVydHlLZXlzXzEuUHJvcGVydHlLZXlzLkZVTkNUSU9OX1BST1BFUlRJRVM7XG4gICAgQ29tcG9uZW50VXRpbC5BTExfUFJPUEVSVElFUyA9IHByb3BlcnR5S2V5c18xLlByb3BlcnR5S2V5cy5BTExfUFJPUEVSVElFUztcbiAgICByZXR1cm4gQ29tcG9uZW50VXRpbDtcbn0oKSk7XG5leHBvcnRzLkNvbXBvbmVudFV0aWwgPSBDb21wb25lbnRVdGlsO1xudXRpbHNfMS5VdGlscy5pdGVyYXRlT2JqZWN0KGV2ZW50c18xLkV2ZW50cywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBDb21wb25lbnRVdGlsLkVWRU5UUy5wdXNoKHZhbHVlKTtcbn0pO1xuZnVuY3Rpb24gY2hlY2tGb3JEZXByZWNhdGVkKGNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5yb3dEZXNlbGVjdGVkIHx8IGNoYW5nZXMub25Sb3dEZXNlbGVjdGVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogYXMgb2YgdjMuNCByb3dEZXNlbGVjdGVkIG5vIGxvbmdlciBleGlzdHMuIFBsZWFzZSBjaGVjayB0aGUgZG9jcy4nKTtcbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9jb21wb25lbnRzL2NvbXBvbmVudFV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBhZ0NvbXBvbmVudFV0aWxzXzEgPSByZXF1aXJlKFwiLi9hZ0NvbXBvbmVudFV0aWxzXCIpO1xudmFyIENvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXIoKSB7XG4gICAgfVxuICAgIENvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXIucHJvdG90eXBlLnBvc3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWV0YURhdGEgPSB7XG4gICAgICAgICAgICBkYXRlQ29tcG9uZW50OiB7XG4gICAgICAgICAgICAgICAgbWFuZGF0b3J5TWV0aG9kTGlzdDogWydnZXREYXRlJywgJ3NldERhdGUnXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbE1ldGhvZExpc3Q6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVyQ29tcG9uZW50OiB7XG4gICAgICAgICAgICAgICAgbWFuZGF0b3J5TWV0aG9kTGlzdDogW10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxNZXRob2RMaXN0OiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlckdyb3VwQ29tcG9uZW50OiB7XG4gICAgICAgICAgICAgICAgbWFuZGF0b3J5TWV0aG9kTGlzdDogW10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxNZXRob2RMaXN0OiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsb2F0aW5nRmlsdGVyQ29tcG9uZW50OiB7XG4gICAgICAgICAgICAgICAgbWFuZGF0b3J5TWV0aG9kTGlzdDogWydvblBhcmVudE1vZGVsQ2hhbmdlZCddLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsTWV0aG9kTGlzdDogWydhZnRlckd1aUF0dGFjaGVkJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wb25lbnQ6IHtcbiAgICAgICAgICAgICAgICBtYW5kYXRvcnlNZXRob2RMaXN0OiBbXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbE1ldGhvZExpc3Q6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyQ29tcG9uZW50OiB7XG4gICAgICAgICAgICAgICAgbWFuZGF0b3J5TWV0aG9kTGlzdDogWydpc0ZpbHRlckFjdGl2ZScsICdkb2VzRmlsdGVyUGFzcycsICdnZXRNb2RlbCcsICdzZXRNb2RlbCddLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsTWV0aG9kTGlzdDogWydhZnRlckd1aUF0dGFjaGVkJywgJ29uTmV3Um93c0xvYWRlZCcsICdnZXRNb2RlbEFzU3RyaW5nJywgJ29uRmxvYXRpbmdGaWx0ZXJDaGFuZ2VkJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZWxsUmVuZGVyZXI6IHtcbiAgICAgICAgICAgICAgICBtYW5kYXRvcnlNZXRob2RMaXN0OiBbJ3JlZnJlc2gnXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbE1ldGhvZExpc3Q6IFsnYWZ0ZXJHdWlBdHRhY2hlZCddLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQWRhcHRlcjogdGhpcy5hZ0NvbXBvbmVudFV0aWxzLmFkYXB0Q2VsbFJlbmRlcmVyRnVuY3Rpb24uYmluZCh0aGlzLmFnQ29tcG9uZW50VXRpbHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2VsbEVkaXRvcjoge1xuICAgICAgICAgICAgICAgIG1hbmRhdG9yeU1ldGhvZExpc3Q6IFsnZ2V0VmFsdWUnXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbE1ldGhvZExpc3Q6IFsnaXNQb3B1cCcsICdpc0NhbmNlbEJlZm9yZVN0YXJ0JywgJ2lzQ2FuY2VsQWZ0ZXJFbmQnLCAnZm9jdXNJbicsICdmb2N1c091dCcsICdhZnRlckd1aUF0dGFjaGVkJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbm5lclJlbmRlcmVyOiB7XG4gICAgICAgICAgICAgICAgbWFuZGF0b3J5TWV0aG9kTGlzdDogW10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxNZXRob2RMaXN0OiBbJ2FmdGVyR3VpQXR0YWNoZWQnXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkFkYXB0ZXI6IHRoaXMuYWdDb21wb25lbnRVdGlscy5hZGFwdENlbGxSZW5kZXJlckZ1bmN0aW9uLmJpbmQodGhpcy5hZ0NvbXBvbmVudFV0aWxzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bGxXaWR0aENlbGxSZW5kZXJlcjoge1xuICAgICAgICAgICAgICAgIG1hbmRhdG9yeU1ldGhvZExpc3Q6IFtdLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsTWV0aG9kTGlzdDogWydhZnRlckd1aUF0dGFjaGVkJ10sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25BZGFwdGVyOiB0aGlzLmFnQ29tcG9uZW50VXRpbHMuYWRhcHRDZWxsUmVuZGVyZXJGdW5jdGlvbi5iaW5kKHRoaXMuYWdDb21wb25lbnRVdGlscylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaW5uZWRSb3dDZWxsUmVuZGVyZXI6IHtcbiAgICAgICAgICAgICAgICBtYW5kYXRvcnlNZXRob2RMaXN0OiBbXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbE1ldGhvZExpc3Q6IFsnYWZ0ZXJHdWlBdHRhY2hlZCddLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQWRhcHRlcjogdGhpcy5hZ0NvbXBvbmVudFV0aWxzLmFkYXB0Q2VsbFJlbmRlcmVyRnVuY3Rpb24uYmluZCh0aGlzLmFnQ29tcG9uZW50VXRpbHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ3JvdXBSb3dJbm5lclJlbmRlcmVyOiB7XG4gICAgICAgICAgICAgICAgbWFuZGF0b3J5TWV0aG9kTGlzdDogW10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxNZXRob2RMaXN0OiBbJ2FmdGVyR3VpQXR0YWNoZWQnXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkFkYXB0ZXI6IHRoaXMuYWdDb21wb25lbnRVdGlscy5hZGFwdENlbGxSZW5kZXJlckZ1bmN0aW9uLmJpbmQodGhpcy5hZ0NvbXBvbmVudFV0aWxzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgIG1hbmRhdG9yeU1ldGhvZExpc3Q6IFsnaXNGaWx0ZXJBY3RpdmUnLCAnZG9lc0ZpbHRlclBhc3MnLCAnZ2V0TW9kZWwnLCAnc2V0TW9kZWwnXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbE1ldGhvZExpc3Q6IFsnb25OZXdSb3dzTG9hZGVkJywgJ29uRmxvYXRpbmdGaWx0ZXJDaGFuZ2VkJ10sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25BZGFwdGVyOiB0aGlzLmFnQ29tcG9uZW50VXRpbHMuYWRhcHRDZWxsUmVuZGVyZXJGdW5jdGlvbi5iaW5kKHRoaXMuYWdDb21wb25lbnRVdGlscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXIucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50TWV0YURhdGFbbmFtZV07XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZChcImFnQ29tcG9uZW50VXRpbHNcIiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBhZ0NvbXBvbmVudFV0aWxzXzEuQWdDb21wb25lbnRVdGlscylcbiAgICBdLCBDb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyLnByb3RvdHlwZSwgXCJhZ0NvbXBvbmVudFV0aWxzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIENvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXIucHJvdG90eXBlLCBcInBvc3RDb25zdHJ1Y3RcIiwgbnVsbCk7XG4gICAgQ29tcG9uZW50TWV0YWRhdGFQcm92aWRlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbihcImNvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXJcIilcbiAgICBdLCBDb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyKTtcbiAgICByZXR1cm4gQ29tcG9uZW50TWV0YWRhdGFQcm92aWRlcjtcbn0oKSk7XG5leHBvcnRzLkNvbXBvbmVudE1ldGFkYXRhUHJvdmlkZXIgPSBDb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50TWV0YWRhdGFQcm92aWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZXh0Q2VsbEVkaXRvcl8xID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmluZy9jZWxsRWRpdG9ycy90ZXh0Q2VsbEVkaXRvclwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGRhdGVGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWx0ZXIvZGF0ZUZpbHRlclwiKTtcbnZhciBoZWFkZXJDb21wXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVhZGVyUmVuZGVyaW5nL2hlYWRlci9oZWFkZXJDb21wXCIpO1xudmFyIGhlYWRlckdyb3VwQ29tcF8xID0gcmVxdWlyZShcIi4uLy4uL2hlYWRlclJlbmRlcmluZy9oZWFkZXJHcm91cC9oZWFkZXJHcm91cENvbXBcIik7XG52YXIgZmxvYXRpbmdGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWx0ZXIvZmxvYXRpbmdGaWx0ZXJcIik7XG52YXIgZmxvYXRpbmdGaWx0ZXJXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZmlsdGVyL2Zsb2F0aW5nRmlsdGVyV3JhcHBlclwiKTtcbnZhciBjb21wb25lbnRSZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50UmVzb2x2ZXJcIik7XG52YXIgZ3JvdXBDZWxsUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJpbmcvY2VsbFJlbmRlcmVycy9ncm91cENlbGxSZW5kZXJlclwiKTtcbnZhciBhbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmluZy9jZWxsUmVuZGVyZXJzL2FuaW1hdGVTaG93Q2hhbmdlQ2VsbFJlbmRlcmVyXCIpO1xudmFyIGFuaW1hdGVTbGlkZUNlbGxSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmluZy9jZWxsUmVuZGVyZXJzL2FuaW1hdGVTbGlkZUNlbGxSZW5kZXJlclwiKTtcbnZhciByb3dDb21wXzEgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyaW5nL3Jvd0NvbXBcIik7XG52YXIgc2VsZWN0Q2VsbEVkaXRvcl8xID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmluZy9jZWxsRWRpdG9ycy9zZWxlY3RDZWxsRWRpdG9yXCIpO1xudmFyIHBvcHVwVGV4dENlbGxFZGl0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJpbmcvY2VsbEVkaXRvcnMvcG9wdXBUZXh0Q2VsbEVkaXRvclwiKTtcbnZhciBwb3B1cFNlbGVjdENlbGxFZGl0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJpbmcvY2VsbEVkaXRvcnMvcG9wdXBTZWxlY3RDZWxsRWRpdG9yXCIpO1xudmFyIGxhcmdlVGV4dENlbGxFZGl0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJpbmcvY2VsbEVkaXRvcnMvbGFyZ2VUZXh0Q2VsbEVkaXRvclwiKTtcbnZhciB0ZXh0RmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZmlsdGVyL3RleHRGaWx0ZXJcIik7XG52YXIgbnVtYmVyRmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZmlsdGVyL251bWJlckZpbHRlclwiKTtcbnZhciBSZWdpc3RlcmVkQ29tcG9uZW50U291cmNlO1xuKGZ1bmN0aW9uIChSZWdpc3RlcmVkQ29tcG9uZW50U291cmNlKSB7XG4gICAgUmVnaXN0ZXJlZENvbXBvbmVudFNvdXJjZVtSZWdpc3RlcmVkQ29tcG9uZW50U291cmNlW1wiREVGQVVMVFwiXSA9IDBdID0gXCJERUZBVUxUXCI7XG4gICAgUmVnaXN0ZXJlZENvbXBvbmVudFNvdXJjZVtSZWdpc3RlcmVkQ29tcG9uZW50U291cmNlW1wiUkVHSVNURVJFRFwiXSA9IDFdID0gXCJSRUdJU1RFUkVEXCI7XG59KShSZWdpc3RlcmVkQ29tcG9uZW50U291cmNlID0gZXhwb3J0cy5SZWdpc3RlcmVkQ29tcG9uZW50U291cmNlIHx8IChleHBvcnRzLlJlZ2lzdGVyZWRDb21wb25lbnRTb3VyY2UgPSB7fSkpO1xudmFyIENvbXBvbmVudFByb3ZpZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRQcm92aWRlcigpIHtcbiAgICAgICAgdGhpcy5qc0NvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5mcmFtZXdvcmtDb21wb25lbnRzID0ge307XG4gICAgfVxuICAgIENvbXBvbmVudFByb3ZpZGVyLnByb3RvdHlwZS5wb3N0Q29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFnR3JpZERlZmF1bHRzID0ge1xuICAgICAgICAgICAgLy9USEUgRk9MTE9XSU5HIENPTVBPTkVOVFMgSEFWRSBOTyBERUZBVUxUUywgVEhFWSBORUVEIFRPIEJFIFNQRUNJRklFRCBBUyBBTiBTUEVDSUZJQyBGTEFWT1VSXG4gICAgICAgICAgICAvL1RIRVJFIEFSRSBOTyBERUZBVUxUUyBUSEFUIEZJVCBBTEwgUFVSUE9TRVNcbiAgICAgICAgICAgIC8vVEhFWSBBUkUgQURERUQgSEVSRSBUTyBBVk9JRCBUSEUgTk9UIEZPVU5EIFdBUk5JTkcuXG4gICAgICAgICAgICBmaWx0ZXJDb21wb25lbnQ6IG51bGwsXG4gICAgICAgICAgICBjdXN0b21GbG9hdGluZ0ZpbHRlckNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgICAgIC8vZGF0ZVxuICAgICAgICAgICAgZGF0ZUNvbXBvbmVudDogZGF0ZUZpbHRlcl8xLkRlZmF1bHREYXRlQ29tcG9uZW50LFxuICAgICAgICAgICAgLy9oZWFkZXJcbiAgICAgICAgICAgIGhlYWRlckNvbXBvbmVudDogaGVhZGVyQ29tcF8xLkhlYWRlckNvbXAsXG4gICAgICAgICAgICBoZWFkZXJHcm91cENvbXBvbmVudDogaGVhZGVyR3JvdXBDb21wXzEuSGVhZGVyR3JvdXBDb21wLFxuICAgICAgICAgICAgLy9mbG9hdGluZyBmaWx0ZXJzXG4gICAgICAgICAgICBzZXRGbG9hdGluZ0ZpbHRlckNvbXBvbmVudDogZmxvYXRpbmdGaWx0ZXJfMS5TZXRGbG9hdGluZ0ZpbHRlckNvbXAsXG4gICAgICAgICAgICB0ZXh0RmxvYXRpbmdGaWx0ZXJDb21wb25lbnQ6IGZsb2F0aW5nRmlsdGVyXzEuVGV4dEZsb2F0aW5nRmlsdGVyQ29tcCxcbiAgICAgICAgICAgIG51bWJlckZsb2F0aW5nRmlsdGVyQ29tcG9uZW50OiBmbG9hdGluZ0ZpbHRlcl8xLk51bWJlckZsb2F0aW5nRmlsdGVyQ29tcCxcbiAgICAgICAgICAgIGRhdGVGbG9hdGluZ0ZpbHRlckNvbXBvbmVudDogZmxvYXRpbmdGaWx0ZXJfMS5EYXRlRmxvYXRpbmdGaWx0ZXJDb21wLFxuICAgICAgICAgICAgcmVhZE1vZGVsQXNTdHJpbmdGbG9hdGluZ0ZpbHRlckNvbXBvbmVudDogZmxvYXRpbmdGaWx0ZXJfMS5SZWFkTW9kZWxBc1N0cmluZ0Zsb2F0aW5nRmlsdGVyQ29tcCxcbiAgICAgICAgICAgIGZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXBvbmVudDogZmxvYXRpbmdGaWx0ZXJXcmFwcGVyXzEuRmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcCxcbiAgICAgICAgICAgIGVtcHR5RmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcG9uZW50OiBmbG9hdGluZ0ZpbHRlcldyYXBwZXJfMS5FbXB0eUZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXAsXG4gICAgICAgICAgICAvL3JlbmRlcmVyc1xuICAgICAgICAgICAgY2VsbFJlbmRlcmVyOiBudWxsLFxuICAgICAgICAgICAgZnVsbFdpZHRoQ2VsbFJlbmRlcmVyOiBudWxsLFxuICAgICAgICAgICAgaW5uZXJSZW5kZXJlcjogbnVsbCxcbiAgICAgICAgICAgIGdyb3VwUm93SW5uZXJSZW5kZXJlcjogbnVsbCxcbiAgICAgICAgICAgIGFuaW1hdGVTaG93Q2hhbmdlOiBhbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlcl8xLkFuaW1hdGVTaG93Q2hhbmdlQ2VsbFJlbmRlcmVyLFxuICAgICAgICAgICAgYW5pbWF0ZVNsaWRlOiBhbmltYXRlU2xpZGVDZWxsUmVuZGVyZXJfMS5BbmltYXRlU2xpZGVDZWxsUmVuZGVyZXIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXBDZWxsUmVuZGVyZXJfMS5Hcm91cENlbGxSZW5kZXJlcixcbiAgICAgICAgICAgIGdyb3VwUm93UmVuZGVyZXI6IGdyb3VwQ2VsbFJlbmRlcmVyXzEuR3JvdXBDZWxsUmVuZGVyZXIsXG4gICAgICAgICAgICBsb2FkaW5nQ2VsbFJlbmRlcmVyOiByb3dDb21wXzEuTG9hZGluZ0NlbGxSZW5kZXJlcixcbiAgICAgICAgICAgIHBpbm5lZFJvd0NlbGxSZW5kZXJlcjogbnVsbCxcbiAgICAgICAgICAgIC8vZWRpdG9yc1xuICAgICAgICAgICAgY2VsbEVkaXRvcjogdGV4dENlbGxFZGl0b3JfMS5UZXh0Q2VsbEVkaXRvcixcbiAgICAgICAgICAgIHRleHRDZWxsRWRpdG9yOiB0ZXh0Q2VsbEVkaXRvcl8xLlRleHRDZWxsRWRpdG9yLFxuICAgICAgICAgICAgdGV4dDogdGV4dENlbGxFZGl0b3JfMS5UZXh0Q2VsbEVkaXRvcixcbiAgICAgICAgICAgIHNlbGVjdENlbGxFZGl0b3I6IHNlbGVjdENlbGxFZGl0b3JfMS5TZWxlY3RDZWxsRWRpdG9yLFxuICAgICAgICAgICAgc2VsZWN0OiBzZWxlY3RDZWxsRWRpdG9yXzEuU2VsZWN0Q2VsbEVkaXRvcixcbiAgICAgICAgICAgIHBvcHVwVGV4dENlbGxFZGl0b3I6IHBvcHVwVGV4dENlbGxFZGl0b3JfMS5Qb3B1cFRleHRDZWxsRWRpdG9yLFxuICAgICAgICAgICAgcG9wdXBUZXh0OiBwb3B1cFRleHRDZWxsRWRpdG9yXzEuUG9wdXBUZXh0Q2VsbEVkaXRvcixcbiAgICAgICAgICAgIHBvcHVwU2VsZWN0Q2VsbEVkaXRvcjogcG9wdXBTZWxlY3RDZWxsRWRpdG9yXzEuUG9wdXBTZWxlY3RDZWxsRWRpdG9yLFxuICAgICAgICAgICAgcG9wdXBTZWxlY3Q6IHBvcHVwU2VsZWN0Q2VsbEVkaXRvcl8xLlBvcHVwU2VsZWN0Q2VsbEVkaXRvcixcbiAgICAgICAgICAgIGxhcmdlVGV4dENlbGxFZGl0b3I6IGxhcmdlVGV4dENlbGxFZGl0b3JfMS5MYXJnZVRleHRDZWxsRWRpdG9yLFxuICAgICAgICAgICAgbGFyZ2VUZXh0OiBsYXJnZVRleHRDZWxsRWRpdG9yXzEuTGFyZ2VUZXh0Q2VsbEVkaXRvcixcbiAgICAgICAgICAgIC8vZmlsdGVyXG4gICAgICAgICAgICB0ZXh0Q29sdW1uRmlsdGVyOiB0ZXh0RmlsdGVyXzEuVGV4dEZpbHRlcixcbiAgICAgICAgICAgIG51bWJlckNvbHVtbkZpbHRlcjogbnVtYmVyRmlsdGVyXzEuTnVtYmVyRmlsdGVyLFxuICAgICAgICAgICAgZGF0ZUNvbHVtbkZpbHRlcjogZGF0ZUZpbHRlcl8xLkRhdGVGaWx0ZXIsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb21wb25lbnRQcm92aWRlci5wcm90b3R5cGUucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybihgYWctZ3JpZDogcmVnaXN0ZXJpbmcgY29tcG9uZW50cyBpcyBhIGxhYiBmZWF0dXJlLCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBvciBzdXBwb3J0ZWQgeWV0LmApO1xuICAgICAgICBpZiAodGhpcy5mcmFtZXdvcmtDb21wb25lbnRzW25hbWVdKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVHJ5aW5nIHRvIHJlZ2lzdGVyIGEgY29tcG9uZW50IHRoYXQgeW91IGhhdmUgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBmcmFtZXdvcmtzOiBcIiArIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuanNDb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQiB0aGUgYnVzaW5lc3MgaW50ZXJmYWNlIChpZSBJSGVhZGVyKVxuICAgICAqIEEgdGhlIGFnR3JpZENvbXBvbmVudCBpbnRlcmZhY2UgKGllIElIZWFkZXJDb21wKS4gVGhlIGZpbmFsIG9iamVjdCBhY2NlcHRhYmxlIGJ5IGFnLWdyaWRcbiAgICAgKi9cbiAgICBDb21wb25lbnRQcm92aWRlci5wcm90b3R5cGUucmVnaXN0ZXJGd0NvbXBvbmVudCA9IGZ1bmN0aW9uIChuYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKGBhZy1ncmlkOiByZWdpc3RlcmluZyBjb21wb25lbnRzIGlzIGEgbGFiIGZlYXR1cmUsIGlzIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIG9yIHN1cHBvcnRlZCB5ZXQuYCk7XG4gICAgICAgIGlmICh0aGlzLmpzQ29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRyeWluZyB0byByZWdpc3RlciBhIGNvbXBvbmVudCB0aGF0IHlvdSBoYXZlIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgcGxhaW4gamF2YXNjcmlwdDogXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYW1ld29ya0NvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCIHRoZSBidXNpbmVzcyBpbnRlcmZhY2UgKGllIElIZWFkZXIpXG4gICAgICogQSB0aGUgYWdHcmlkQ29tcG9uZW50IGludGVyZmFjZSAoaWUgSUhlYWRlckNvbXApLiBUaGUgZmluYWwgb2JqZWN0IGFjY2VwdGFibGUgYnkgYWctZ3JpZFxuICAgICAqL1xuICAgIENvbXBvbmVudFByb3ZpZGVyLnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmZyYW1ld29ya0NvbXBvbmVudHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogY29tcG9uZW50UmVzb2x2ZXJfMS5Db21wb25lbnRUeXBlLkZSQU1FV09SSyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuZnJhbWV3b3JrQ29tcG9uZW50c1tuYW1lXSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFJlZ2lzdGVyZWRDb21wb25lbnRTb3VyY2UuUkVHSVNURVJFRFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5qc0NvbXBvbmVudHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogY29tcG9uZW50UmVzb2x2ZXJfMS5Db21wb25lbnRUeXBlLkFHX0dSSUQsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLmpzQ29tcG9uZW50c1tuYW1lXSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFJlZ2lzdGVyZWRDb21wb25lbnRTb3VyY2UuUkVHSVNURVJFRFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hZ0dyaWREZWZhdWx0c1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBjb21wb25lbnRSZXNvbHZlcl8xLkNvbXBvbmVudFR5cGUuQUdfR1JJRCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuYWdHcmlkRGVmYXVsdHNbbmFtZV0sXG4gICAgICAgICAgICAgICAgc291cmNlOiBSZWdpc3RlcmVkQ29tcG9uZW50U291cmNlLkRFRkFVTFRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuYWdHcmlkRGVmYXVsdHMpLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1ncmlkOiBMb29raW5nIGZvciBjb21wb25lbnQgW1wiICsgbmFtZSArIFwiXSBidXQgaXQgd2Fzbid0IGZvdW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBDb21wb25lbnRQcm92aWRlci5wcm90b3R5cGUsIFwicG9zdENvbnN0cnVjdFwiLCBudWxsKTtcbiAgICBDb21wb25lbnRQcm92aWRlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignY29tcG9uZW50UHJvdmlkZXInKVxuICAgIF0sIENvbXBvbmVudFByb3ZpZGVyKTtcbiAgICByZXR1cm4gQ29tcG9uZW50UHJvdmlkZXI7XG59KCkpO1xuZXhwb3J0cy5Db21wb25lbnRQcm92aWRlciA9IENvbXBvbmVudFByb3ZpZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UHJvdmlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgRG93bmxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG93bmxvYWRlcigpIHtcbiAgICB9XG4gICAgRG93bmxvYWRlci5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbiAoZmlsZU5hbWUsIGNvbnRlbnQsIG1pbWVUeXBlKSB7XG4gICAgICAgIC8vIGZvciBFeGNlbCwgd2UgbmVlZCBcXHVmZWZmIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3ODc5MTk4L2FkZGluZy11dGYtOC1ib20tdG8tc3RyaW5nLWJsb2JcbiAgICAgICAgdmFyIGJsb2JPYmplY3QgPSBuZXcgQmxvYihbXCJcXHVmZWZmXCIsIGNvbnRlbnRdLCB7XG4gICAgICAgICAgICB0eXBlOiBtaW1lVHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJsb2JPYmplY3QsIGZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENocm9tZVxuICAgICAgICAgICAgdmFyIGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgZG93bmxvYWRMaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iT2JqZWN0KTtcbiAgICAgICAgICAgIGRvd25sb2FkTGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZExpbmspO1xuICAgICAgICAgICAgZG93bmxvYWRMaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRvd25sb2FkTGluayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvd25sb2FkZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2Rvd25sb2FkZXInKVxuICAgIF0sIERvd25sb2FkZXIpO1xuICAgIHJldHVybiBEb3dubG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuRG93bmxvYWRlciA9IERvd25sb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9kb3dubG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgZ3JpZENlbGxfMSA9IHJlcXVpcmUoXCIuL2dyaWRDZWxsXCIpO1xudmFyIEdyaWRSb3cgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyaWRSb3cocm93SW5kZXgsIGZsb2F0aW5nKSB7XG4gICAgICAgIHRoaXMucm93SW5kZXggPSByb3dJbmRleDtcbiAgICAgICAgdGhpcy5mbG9hdGluZyA9IHV0aWxzXzEuVXRpbHMubWFrZU51bGwoZmxvYXRpbmcpO1xuICAgIH1cbiAgICBHcmlkUm93LnByb3RvdHlwZS5pc0Zsb2F0aW5nVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdGluZyA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9UT1A7XG4gICAgfTtcbiAgICBHcmlkUm93LnByb3RvdHlwZS5pc0Zsb2F0aW5nQm90dG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdGluZyA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9CT1RUT007XG4gICAgfTtcbiAgICBHcmlkUm93LnByb3RvdHlwZS5pc05vdEZsb2F0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNGbG9hdGluZ0JvdHRvbSgpICYmICF0aGlzLmlzRmxvYXRpbmdUb3AoKTtcbiAgICB9O1xuICAgIEdyaWRSb3cucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlclNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmRleCA9PT0gb3RoZXJTZWxlY3Rpb24ucm93SW5kZXhcbiAgICAgICAgICAgICYmIHRoaXMuZmxvYXRpbmcgPT09IG90aGVyU2VsZWN0aW9uLmZsb2F0aW5nO1xuICAgIH07XG4gICAgR3JpZFJvdy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcInJvd0luZGV4ID0gXCIgKyB0aGlzLnJvd0luZGV4ICsgXCIsIGZsb2F0aW5nID0gXCIgKyB0aGlzLmZsb2F0aW5nO1xuICAgIH07XG4gICAgR3JpZFJvdy5wcm90b3R5cGUuZ2V0R3JpZENlbGwgPSBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHZhciBncmlkQ2VsbERlZiA9IHsgcm93SW5kZXg6IHRoaXMucm93SW5kZXgsIGZsb2F0aW5nOiB0aGlzLmZsb2F0aW5nLCBjb2x1bW46IGNvbHVtbiB9O1xuICAgICAgICByZXR1cm4gbmV3IGdyaWRDZWxsXzEuR3JpZENlbGwoZ3JpZENlbGxEZWYpO1xuICAgIH07XG4gICAgLy8gdGVzdHMgaWYgdGhpcyByb3cgc2VsZWN0aW9uIGlzIGJlZm9yZSB0aGUgb3RoZXIgcm93IHNlbGVjdGlvblxuICAgIEdyaWRSb3cucHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uIChvdGhlclNlbGVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXJGbG9hdGluZyA9IG90aGVyU2VsZWN0aW9uLmZsb2F0aW5nO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZmxvYXRpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9UT1A6XG4gICAgICAgICAgICAgICAgLy8gd2Ugd2UgYXJlIGZsb2F0aW5nIHRvcCwgYW5kIG90aGVyIGlzbid0LCB0aGVuIHdlIGFyZSBhbHdheXMgYmVmb3JlXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyRmxvYXRpbmcgIT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLlBJTk5FRF9CT1RUT006XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGZsb2F0aW5nIGJvdHRvbSwgYW5kIHRoZSBvdGhlciBpc24ndCwgdGhlbiB3ZSBhcmUgbmV2ZXIgYmVmb3JlXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyRmxvYXRpbmcgIT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5QSU5ORURfQk9UVE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBub3QgZmxvYXRpbmcsIGJ1dCB0aGUgb3RoZXIgb25lIGlzIGZsb2F0aW5nLi4uXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKG90aGVyRmxvYXRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckZsb2F0aW5nID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuUElOTkVEX1RPUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCBmbG9hdGluZywgb3RoZXIgaXMgZmxvYXRpbmcgdG9wLCB3ZSBhcmUgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgZmxvYXRpbmcsIG90aGVyIGlzIGZsb2F0aW5nIGJvdHRvbSwgd2UgYXJlIGFsd2F5cyBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm93SW5kZXggPCBvdGhlclNlbGVjdGlvbi5yb3dJbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBHcmlkUm93O1xufSgpKTtcbmV4cG9ydHMuR3JpZFJvdyA9IEdyaWRSb3c7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9lbnRpdGllcy9ncmlkUm93LmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgY29tcG9uZW50QW5ub3RhdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi93aWRnZXRzL2NvbXBvbmVudEFubm90YXRpb25zXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgYmFzZUZpbHRlcl8xID0gcmVxdWlyZShcIi4vYmFzZUZpbHRlclwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbXBvbmVudFJlY2lwZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2ZyYW1ld29yay9jb21wb25lbnRSZWNpcGVzXCIpO1xudmFyIERhdGVGaWx0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRlRmlsdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERhdGVGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRGF0ZUZpbHRlci5wcm90b3R5cGUubW9kZWxGcm9tRmxvYXRpbmdGaWx0ZXIgPSBmdW5jdGlvbiAoZnJvbSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZUZyb206IGZyb20sXG4gICAgICAgICAgICBkYXRlVG86IHRoaXMuZ2V0RGF0ZVRvKCksXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmZpbHRlcixcbiAgICAgICAgICAgIGZpbHRlclR5cGU6ICdkYXRlJ1xuICAgICAgICB9O1xuICAgIH07XG4gICAgRGF0ZUZpbHRlci5wcm90b3R5cGUuZ2V0QXBwbGljYWJsZUZpbHRlclR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW2Jhc2VGaWx0ZXJfMS5CYXNlRmlsdGVyLkVRVUFMUywgYmFzZUZpbHRlcl8xLkJhc2VGaWx0ZXIuR1JFQVRFUl9USEFOLCBiYXNlRmlsdGVyXzEuQmFzZUZpbHRlci5MRVNTX1RIQU4sIGJhc2VGaWx0ZXJfMS5CYXNlRmlsdGVyLk5PVF9FUVVBTCwgYmFzZUZpbHRlcl8xLkJhc2VGaWx0ZXIuSU5fUkFOR0VdO1xuICAgIH07XG4gICAgRGF0ZUZpbHRlci5wcm90b3R5cGUuYm9keVRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJhZy1maWx0ZXItYm9keVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhZy1maWx0ZXItZGF0ZS1mcm9tXFxcIiBpZD1cXFwiZmlsdGVyRGF0ZUZyb21QYW5lbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImFnLWZpbHRlci1kYXRlLXRvXFxcIiBpZD1cXFwiZmlsdGVyRGF0ZVRvUGFuZWxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlwiO1xuICAgIH07XG4gICAgRGF0ZUZpbHRlci5wcm90b3R5cGUuaW5pdGlhbGlzZUZpbHRlckJvZHlVaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGVDb21wb25lbnRQYXJhbXMgPSB7XG4gICAgICAgICAgICBvbkRhdGVDaGFuZ2VkOiB0aGlzLm9uRGF0ZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlY2lwZXMubmV3RGF0ZUNvbXBvbmVudChkYXRlQ29tcG9uZW50UGFyYW1zKS50aGVuKGZ1bmN0aW9uIChkYXRlVG9Db21wb25lbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmRhdGVUb0NvbXBvbmVudCA9IGRhdGVUb0NvbXBvbmVudDtcbiAgICAgICAgICAgIHZhciBkYXRlVG9FbGVtZW50ID0gX3RoaXMuZGF0ZVRvQ29tcG9uZW50LmdldEd1aSgpO1xuICAgICAgICAgICAgX3RoaXMuZURhdGVUb1BhbmVsLmFwcGVuZENoaWxkKGRhdGVUb0VsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmRhdGVUb0NvbXBvbmVudC5hZnRlckd1aUF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0ZVRvQ29tcG9uZW50LmFmdGVyR3VpQXR0YWNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVjaXBlcy5uZXdEYXRlQ29tcG9uZW50KGRhdGVDb21wb25lbnRQYXJhbXMpLnRoZW4oZnVuY3Rpb24gKGRhdGVGcm9tQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5kYXRlRnJvbUNvbXBvbmVudCA9IGRhdGVGcm9tQ29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIGRhdGVGcm9tRWxlbWVudCA9IF90aGlzLmRhdGVGcm9tQ29tcG9uZW50LmdldEd1aSgpO1xuICAgICAgICAgICAgX3RoaXMuZURhdGVGcm9tUGFuZWwuYXBwZW5kQ2hpbGQoZGF0ZUZyb21FbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kYXRlRnJvbUNvbXBvbmVudC5hZnRlckd1aUF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0ZUZyb21Db21wb25lbnQuYWZ0ZXJHdWlBdHRhY2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhdGVGaWx0ZXIucHJvdG90eXBlLm9uRGF0ZUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0ZUZyb20gPSBEYXRlRmlsdGVyLnJlbW92ZVRpbWV6b25lKHRoaXMuZGF0ZUZyb21Db21wb25lbnQuZ2V0RGF0ZSgpKTtcbiAgICAgICAgdGhpcy5kYXRlVG8gPSBEYXRlRmlsdGVyLnJlbW92ZVRpbWV6b25lKHRoaXMuZGF0ZVRvQ29tcG9uZW50LmdldERhdGUoKSk7XG4gICAgICAgIHRoaXMub25GaWx0ZXJDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBEYXRlRmlsdGVyLnByb3RvdHlwZS5yZWZyZXNoRmlsdGVyQm9keVVpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuZmlsdGVyID09PSBiYXNlRmlsdGVyXzEuQmFzZUZpbHRlci5JTl9SQU5HRTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5zZXRWaXNpYmxlKHRoaXMuZURhdGVUb1BhbmVsLCB2aXNpYmxlKTtcbiAgICB9O1xuICAgIERhdGVGaWx0ZXIucHJvdG90eXBlLmNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlclBhcmFtcy5jb21wYXJhdG9yID8gdGhpcy5maWx0ZXJQYXJhbXMuY29tcGFyYXRvciA6IHRoaXMuZGVmYXVsdENvbXBhcmF0b3IuYmluZCh0aGlzKTtcbiAgICB9O1xuICAgIERhdGVGaWx0ZXIucHJvdG90eXBlLmRlZmF1bHRDb21wYXJhdG9yID0gZnVuY3Rpb24gKGZpbHRlckRhdGUsIGNlbGxWYWx1ZSkge1xuICAgICAgICAvL1RoZSBkZWZhdWx0IGNvbXBhcmF0b3IgYXNzdW1lcyB0aGF0IHRoZSBjZWxsVmFsdWUgaXMgYSBkYXRlXG4gICAgICAgIHZhciBjZWxsQXNEYXRlID0gY2VsbFZhbHVlO1xuICAgICAgICBpZiAoY2VsbEFzRGF0ZSA8IGZpbHRlckRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbEFzRGF0ZSA+IGZpbHRlckRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZWxsVmFsdWUgIT0gbnVsbCA/IDAgOiAtMTtcbiAgICB9O1xuICAgIERhdGVGaWx0ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGVUbzogdXRpbHNfMS5VdGlscy5zZXJpYWxpemVEYXRlVG9ZeXl5TW1EZCh0aGlzLmRhdGVUb0NvbXBvbmVudC5nZXREYXRlKCksIFwiLVwiKSxcbiAgICAgICAgICAgIGRhdGVGcm9tOiB1dGlsc18xLlV0aWxzLnNlcmlhbGl6ZURhdGVUb1l5eXlNbURkKHRoaXMuZGF0ZUZyb21Db21wb25lbnQuZ2V0RGF0ZSgpLCBcIi1cIiksXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmZpbHRlciA/IHRoaXMuZmlsdGVyIDogdGhpcy5kZWZhdWx0RmlsdGVyLFxuICAgICAgICAgICAgZmlsdGVyVHlwZTogJ2RhdGUnXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEYXRlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXJWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlciAhPT0gYmFzZUZpbHRlcl8xLkJhc2VGaWx0ZXIuSU5fUkFOR0UgP1xuICAgICAgICAgICAgdGhpcy5kYXRlRnJvbUNvbXBvbmVudC5nZXREYXRlKCkgOlxuICAgICAgICAgICAgW3RoaXMuZGF0ZUZyb21Db21wb25lbnQuZ2V0RGF0ZSgpLCB0aGlzLmRhdGVUb0NvbXBvbmVudC5nZXREYXRlKCldO1xuICAgIH07XG4gICAgLy8gbm90IHVzZWQgYnkgYWctR3JpZCwgYnV0IGV4cG9zZWQgYXMgcGFydCBvZiB0aGUgZmlsdGVyIEFQSSBmb3IgdGhlIGNsaWVudCBpZiB0aGV5IHdhbnQgaXRcbiAgICBEYXRlRmlsdGVyLnByb3RvdHlwZS5nZXREYXRlRnJvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMuc2VyaWFsaXplRGF0ZVRvWXl5eU1tRGQodGhpcy5kYXRlRnJvbUNvbXBvbmVudC5nZXREYXRlKCksIFwiLVwiKTtcbiAgICB9O1xuICAgIC8vIG5vdCB1c2VkIGJ5IGFnLUdyaWQsIGJ1dCBleHBvc2VkIGFzIHBhcnQgb2YgdGhlIGZpbHRlciBBUEkgZm9yIHRoZSBjbGllbnQgaWYgdGhleSB3YW50IGl0XG4gICAgRGF0ZUZpbHRlci5wcm90b3R5cGUuZ2V0RGF0ZVRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5VdGlscy5zZXJpYWxpemVEYXRlVG9ZeXl5TW1EZCh0aGlzLmRhdGVUb0NvbXBvbmVudC5nZXREYXRlKCksIFwiLVwiKTtcbiAgICB9O1xuICAgIC8vIG5vdCB1c2VkIGJ5IGFnLUdyaWQsIGJ1dCBleHBvc2VkIGFzIHBhcnQgb2YgdGhlIGZpbHRlciBBUEkgZm9yIHRoZSBjbGllbnQgaWYgdGhleSB3YW50IGl0XG4gICAgRGF0ZUZpbHRlci5wcm90b3R5cGUuZ2V0RmlsdGVyVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuICAgIH07XG4gICAgRGF0ZUZpbHRlci5wcm90b3R5cGUuc2V0RGF0ZUZyb20gPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICB0aGlzLmRhdGVGcm9tID0gdXRpbHNfMS5VdGlscy5wYXJzZVl5eXlNbURkVG9EYXRlKGRhdGUsIFwiLVwiKTtcbiAgICAgICAgdGhpcy5kYXRlRnJvbUNvbXBvbmVudC5zZXREYXRlKHRoaXMuZGF0ZUZyb20pO1xuICAgIH07XG4gICAgRGF0ZUZpbHRlci5wcm90b3R5cGUuc2V0RGF0ZVRvID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdGhpcy5kYXRlVG8gPSB1dGlsc18xLlV0aWxzLnBhcnNlWXl5eU1tRGRUb0RhdGUoZGF0ZSwgXCItXCIpO1xuICAgICAgICB0aGlzLmRhdGVUb0NvbXBvbmVudC5zZXREYXRlKHRoaXMuZGF0ZVRvKTtcbiAgICB9O1xuICAgIERhdGVGaWx0ZXIucHJvdG90eXBlLnJlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0ZUZyb20obnVsbCk7XG4gICAgICAgIHRoaXMuc2V0RGF0ZVRvKG51bGwpO1xuICAgICAgICB0aGlzLnNldEZpbHRlclR5cGUodGhpcy5kZWZhdWx0RmlsdGVyKTtcbiAgICB9O1xuICAgIERhdGVGaWx0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0ZUZyb20obW9kZWwuZGF0ZUZyb20pO1xuICAgICAgICB0aGlzLnNldERhdGVUbyhtb2RlbC5kYXRlVG8pO1xuICAgICAgICB0aGlzLnNldEZpbHRlclR5cGUobW9kZWwudHlwZSk7XG4gICAgfTtcbiAgICBEYXRlRmlsdGVyLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24gKGZpbHRlclR5cGUpIHtcbiAgICAgICAgdGhpcy5zZXRGaWx0ZXJUeXBlKGZpbHRlclR5cGUpO1xuICAgIH07XG4gICAgRGF0ZUZpbHRlci5yZW1vdmVUaW1lem9uZSA9IGZ1bmN0aW9uIChmcm9tKSB7XG4gICAgICAgIGlmICghZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZnJvbS5nZXRGdWxsWWVhcigpLCBmcm9tLmdldE1vbnRoKCksIGZyb20uZ2V0RGF0ZSgpKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb21wb25lbnRSZWNpcGVzJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb21wb25lbnRSZWNpcGVzXzEuQ29tcG9uZW50UmVjaXBlcylcbiAgICBdLCBEYXRlRmlsdGVyLnByb3RvdHlwZSwgXCJjb21wb25lbnRSZWNpcGVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUXVlcnlTZWxlY3RvcignI2ZpbHRlckRhdGVGcm9tUGFuZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIERhdGVGaWx0ZXIucHJvdG90eXBlLCBcImVEYXRlRnJvbVBhbmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUXVlcnlTZWxlY3RvcignI2ZpbHRlckRhdGVUb1BhbmVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MRWxlbWVudClcbiAgICBdLCBEYXRlRmlsdGVyLnByb3RvdHlwZSwgXCJlRGF0ZVRvUGFuZWxcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gRGF0ZUZpbHRlcjtcbn0oYmFzZUZpbHRlcl8xLlNjYWxhckJhc2VGaWx0ZXIpKTtcbmV4cG9ydHMuRGF0ZUZpbHRlciA9IERhdGVGaWx0ZXI7XG52YXIgRGVmYXVsdERhdGVDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWZhdWx0RGF0ZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0RGF0ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiPGlucHV0IGNsYXNzPVxcXCJhZy1maWx0ZXItZmlsdGVyXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwieXl5eS1tbS1kZFxcXCI+XCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIERlZmF1bHREYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLmVEYXRlSW5wdXQgPSB0aGlzLmdldEd1aSgpO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5pc0Jyb3dzZXJDaHJvbWUoKSkge1xuICAgICAgICAgICAgdGhpcy5lRGF0ZUlucHV0LnR5cGUgPSAnZGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IHBhcmFtcy5vbkRhdGVDaGFuZ2VkO1xuICAgICAgICB0aGlzLmFkZEd1aUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgfTtcbiAgICBEZWZhdWx0RGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMucGFyc2VZeXl5TW1EZFRvRGF0ZSh0aGlzLmVEYXRlSW5wdXQudmFsdWUsIFwiLVwiKTtcbiAgICB9O1xuICAgIERlZmF1bHREYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zZXREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdGhpcy5lRGF0ZUlucHV0LnZhbHVlID0gdXRpbHNfMS5VdGlscy5zZXJpYWxpemVEYXRlVG9ZeXl5TW1EZChkYXRlLCBcIi1cIik7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdERhdGVDb21wb25lbnQ7XG59KGNvbXBvbmVudF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5EZWZhdWx0RGF0ZUNvbXBvbmVudCA9IERlZmF1bHREYXRlQ29tcG9uZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZmlsdGVyL2RhdGVGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBzZWxlY3Rpb25Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9zZWxlY3Rpb25Db250cm9sbGVyXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciByb3dSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vcmVuZGVyaW5nL3Jvd1JlbmRlcmVyXCIpO1xudmFyIGhlYWRlclJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyUmVuZGVyZXJcIik7XG52YXIgZmlsdGVyTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyL2ZpbHRlck1hbmFnZXJcIik7XG52YXIgdmFsdWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi92YWx1ZVNlcnZpY2UvdmFsdWVTZXJ2aWNlXCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGdyaWRQYW5lbF8xID0gcmVxdWlyZShcIi4vZ3JpZFBhbmVsL2dyaWRQYW5lbFwiKTtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi9ncmlkQXBpXCIpO1xudmFyIGhlYWRlclRlbXBsYXRlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi9oZWFkZXJSZW5kZXJpbmcvZGVwcmVjYXRlZC9oZWFkZXJUZW1wbGF0ZUxvYWRlclwiKTtcbnZhciBiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Db250cm9sbGVyL2JhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXJcIik7XG52YXIgZGlzcGxheWVkR3JvdXBDcmVhdG9yXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Db250cm9sbGVyL2Rpc3BsYXllZEdyb3VwQ3JlYXRvclwiKTtcbnZhciBleHByZXNzaW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vdmFsdWVTZXJ2aWNlL2V4cHJlc3Npb25TZXJ2aWNlXCIpO1xudmFyIHRlbXBsYXRlU2VydmljZV8xID0gcmVxdWlyZShcIi4vdGVtcGxhdGVTZXJ2aWNlXCIpO1xudmFyIHBvcHVwU2VydmljZV8xID0gcmVxdWlyZShcIi4vd2lkZ2V0cy9wb3B1cFNlcnZpY2VcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG52YXIgY29sdW1uVXRpbHNfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uVXRpbHNcIik7XG52YXIgYXV0b1dpZHRoQ2FsY3VsYXRvcl8xID0gcmVxdWlyZShcIi4vcmVuZGVyaW5nL2F1dG9XaWR0aENhbGN1bGF0b3JcIik7XG52YXIgaG9yaXpvbnRhbERyYWdTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9oZWFkZXJSZW5kZXJpbmcvaG9yaXpvbnRhbERyYWdTZXJ2aWNlXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjc3ZDcmVhdG9yXzEgPSByZXF1aXJlKFwiLi9jc3ZDcmVhdG9yXCIpO1xudmFyIGdyaWRDb3JlXzEgPSByZXF1aXJlKFwiLi9ncmlkQ29yZVwiKTtcbnZhciBzdGFuZGFyZE1lbnVfMSA9IHJlcXVpcmUoXCIuL2hlYWRlclJlbmRlcmluZy9zdGFuZGFyZE1lbnVcIik7XG52YXIgZHJhZ0FuZERyb3BTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9kcmFnQW5kRHJvcC9kcmFnQW5kRHJvcFNlcnZpY2VcIik7XG52YXIgZHJhZ1NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2RyYWdBbmREcm9wL2RyYWdTZXJ2aWNlXCIpO1xudmFyIHNvcnRDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9zb3J0Q29udHJvbGxlclwiKTtcbnZhciBmb2N1c2VkQ2VsbENvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL2ZvY3VzZWRDZWxsQ29udHJvbGxlclwiKTtcbnZhciBtb3VzZUV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4vZ3JpZFBhbmVsL21vdXNlRXZlbnRTZXJ2aWNlXCIpO1xudmFyIGNlbGxOYXZpZ2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vY2VsbE5hdmlnYXRpb25TZXJ2aWNlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBmaWx0ZXJTdGFnZV8xID0gcmVxdWlyZShcIi4vcm93TW9kZWxzL2luTWVtb3J5L2ZpbHRlclN0YWdlXCIpO1xudmFyIHNvcnRTdGFnZV8xID0gcmVxdWlyZShcIi4vcm93TW9kZWxzL2luTWVtb3J5L3NvcnRTdGFnZVwiKTtcbnZhciBmbGF0dGVuU3RhZ2VfMSA9IHJlcXVpcmUoXCIuL3Jvd01vZGVscy9pbk1lbW9yeS9mbGF0dGVuU3RhZ2VcIik7XG52YXIgY2VsbEVkaXRvckZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmluZy9jZWxsRWRpdG9yRmFjdG9yeVwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcbnZhciBpbmZpbml0ZVJvd01vZGVsXzEgPSByZXF1aXJlKFwiLi9yb3dNb2RlbHMvaW5maW5pdGUvaW5maW5pdGVSb3dNb2RlbFwiKTtcbnZhciBpbk1lbW9yeVJvd01vZGVsXzEgPSByZXF1aXJlKFwiLi9yb3dNb2RlbHMvaW5NZW1vcnkvaW5NZW1vcnlSb3dNb2RlbFwiKTtcbnZhciBjZWxsUmVuZGVyZXJGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9yZW5kZXJpbmcvY2VsbFJlbmRlcmVyRmFjdG9yeVwiKTtcbnZhciBjZWxsUmVuZGVyZXJTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9yZW5kZXJpbmcvY2VsbFJlbmRlcmVyU2VydmljZVwiKTtcbnZhciB2YWx1ZUZvcm1hdHRlclNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmluZy92YWx1ZUZvcm1hdHRlclNlcnZpY2VcIik7XG52YXIgYWdDaGVja2JveF8xID0gcmVxdWlyZShcIi4vd2lkZ2V0cy9hZ0NoZWNrYm94XCIpO1xudmFyIGJhc2VGcmFtZXdvcmtGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9iYXNlRnJhbWV3b3JrRmFjdG9yeVwiKTtcbnZhciBzY3JvbGxWaXNpYmxlU2VydmljZV8xID0gcmVxdWlyZShcIi4vZ3JpZFBhbmVsL3Njcm9sbFZpc2libGVTZXJ2aWNlXCIpO1xudmFyIGRvd25sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkZXJcIik7XG52YXIgeG1sRmFjdG9yeV8xID0gcmVxdWlyZShcIi4veG1sRmFjdG9yeVwiKTtcbnZhciBncmlkU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vZ3JpZFNlcmlhbGl6ZXJcIik7XG52YXIgc3R5bGluZ1NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3N0eWxpbmcvc3R5bGluZ1NlcnZpY2VcIik7XG52YXIgY29sdW1uSG92ZXJTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9yZW5kZXJpbmcvY29sdW1uSG92ZXJTZXJ2aWNlXCIpO1xudmFyIGNvbHVtbkFuaW1hdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmluZy9jb2x1bW5BbmltYXRpb25TZXJ2aWNlXCIpO1xudmFyIHNvcnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9yb3dOb2Rlcy9zb3J0U2VydmljZVwiKTtcbnZhciBmaWx0ZXJTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9yb3dOb2Rlcy9maWx0ZXJTZXJ2aWNlXCIpO1xudmFyIHJvd05vZGVGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9yb3dOb2Rlcy9yb3dOb2RlRmFjdG9yeVwiKTtcbnZhciBhdXRvR3JvdXBDb2xTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Db250cm9sbGVyL2F1dG9Hcm91cENvbFNlcnZpY2VcIik7XG52YXIgcGFnaW5hdGlvblByb3h5XzEgPSByZXF1aXJlKFwiLi9yb3dNb2RlbHMvcGFnaW5hdGlvblByb3h5XCIpO1xudmFyIGltbXV0YWJsZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3Jvd01vZGVscy9pbk1lbW9yeS9pbW11dGFibGVTZXJ2aWNlXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIHZhbHVlQ2FjaGVfMSA9IHJlcXVpcmUoXCIuL3ZhbHVlU2VydmljZS92YWx1ZUNhY2hlXCIpO1xudmFyIGNoYW5nZURldGVjdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3ZhbHVlU2VydmljZS9jaGFuZ2VEZXRlY3Rpb25TZXJ2aWNlXCIpO1xudmFyIGFsaWduZWRHcmlkc1NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2FsaWduZWRHcmlkc1NlcnZpY2VcIik7XG52YXIgcGlubmVkUm93TW9kZWxfMSA9IHJlcXVpcmUoXCIuL3Jvd01vZGVscy9waW5uZWRSb3dNb2RlbFwiKTtcbnZhciBjb21wb25lbnRSZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UmVzb2x2ZXJcIik7XG52YXIgY29tcG9uZW50UmVjaXBlc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UmVjaXBlc1wiKTtcbnZhciBjb21wb25lbnRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UHJvdmlkZXJcIik7XG52YXIgYWdDb21wb25lbnRVdGlsc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9mcmFtZXdvcmsvYWdDb21wb25lbnRVdGlsc1wiKTtcbnZhciBjb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2ZyYW1ld29yay9jb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXCIpO1xudmFyIG5hbWVkQ29tcG9uZW50UmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZnJhbWV3b3JrL25hbWVkQ29tcG9uZW50UmVzb2x2ZXJcIik7XG52YXIgYmVhbnNfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmluZy9iZWFuc1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgYW5pbWF0aW9uRnJhbWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9taXNjL2FuaW1hdGlvbkZyYW1lU2VydmljZVwiKTtcbnZhciBuYXZpZ2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vZ3JpZFBhbmVsL25hdmlnYXRpb25TZXJ2aWNlXCIpO1xudmFyIEdyaWQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyaWQoZUdyaWREaXYsIGdyaWRPcHRpb25zLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFlR3JpZERpdikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogbm8gZGl2IGVsZW1lbnQgcHJvdmlkZWQgdG8gdGhlIGdyaWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdyaWRPcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBubyBncmlkT3B0aW9ucyBwcm92aWRlZCB0byB0aGUgZ3JpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3dNb2RlbENsYXNzID0gdGhpcy5nZXRSb3dNb2RlbENsYXNzKGdyaWRPcHRpb25zKTtcbiAgICAgICAgdmFyIGVudGVycHJpc2UgPSB1dGlsc18xLlV0aWxzLmV4aXN0cyhHcmlkLmVudGVycHJpc2VCZWFucyk7XG4gICAgICAgIHZhciBmcmFtZXdvcmtGYWN0b3J5ID0gcGFyYW1zID8gcGFyYW1zLmZyYW1ld29ya0ZhY3RvcnkgOiBudWxsO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKGZyYW1ld29ya0ZhY3RvcnkpKSB7XG4gICAgICAgICAgICBmcmFtZXdvcmtGYWN0b3J5ID0gbmV3IGJhc2VGcmFtZXdvcmtGYWN0b3J5XzEuQmFzZUZyYW1ld29ya0ZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3ZlcnJpZGVCZWFucyA9IFtdO1xuICAgICAgICBpZiAoR3JpZC5lbnRlcnByaXNlQmVhbnMpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlQmVhbnMgPSBvdmVycmlkZUJlYW5zLmNvbmNhdChHcmlkLmVudGVycHJpc2VCZWFucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEdyaWQuZnJhbWV3b3JrQmVhbnMpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlQmVhbnMgPSBvdmVycmlkZUJlYW5zLmNvbmNhdChHcmlkLmZyYW1ld29ya0JlYW5zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VlZCA9IHtcbiAgICAgICAgICAgIGVudGVycHJpc2U6IGVudGVycHJpc2UsXG4gICAgICAgICAgICBncmlkT3B0aW9uczogZ3JpZE9wdGlvbnMsXG4gICAgICAgICAgICBlR3JpZERpdjogZUdyaWREaXYsXG4gICAgICAgICAgICAkc2NvcGU6IHBhcmFtcyA/IHBhcmFtcy4kc2NvcGUgOiBudWxsLFxuICAgICAgICAgICAgJGNvbXBpbGU6IHBhcmFtcyA/IHBhcmFtcy4kY29tcGlsZSA6IG51bGwsXG4gICAgICAgICAgICBxdWlja0ZpbHRlck9uU2NvcGU6IHBhcmFtcyA/IHBhcmFtcy5xdWlja0ZpbHRlck9uU2NvcGUgOiBudWxsLFxuICAgICAgICAgICAgZ2xvYmFsRXZlbnRMaXN0ZW5lcjogcGFyYW1zID8gcGFyYW1zLmdsb2JhbEV2ZW50TGlzdGVuZXIgOiBudWxsLFxuICAgICAgICAgICAgZnJhbWV3b3JrRmFjdG9yeTogZnJhbWV3b3JrRmFjdG9yeVxuICAgICAgICB9O1xuICAgICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5zZWVkQmVhbkluc3RhbmNlcykge1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5hc3NpZ24oc2VlZCwgcGFyYW1zLnNlZWRCZWFuSW5zdGFuY2VzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IHtcbiAgICAgICAgICAgIG92ZXJyaWRlQmVhbnM6IG92ZXJyaWRlQmVhbnMsXG4gICAgICAgICAgICBzZWVkOiBzZWVkLFxuICAgICAgICAgICAgLy9DYXJlZnVsIHdpdGggdGhlIG9yZGVyIG9mIHRoZSBiZWFucyBoZXJlLCB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzIGJldHdlZW4gdGhlbSB0aGF0IG5lZWQgdG8gYmUga2VwdFxuICAgICAgICAgICAgYmVhbnM6IFtyb3dNb2RlbENsYXNzLCBwYWdpbmF0aW9uUHJveHlfMS5QYWdpbmF0aW9uQXV0b1BhZ2VTaXplU2VydmljZSwgZ3JpZEFwaV8xLkdyaWRBcGksIGNvbXBvbmVudFByb3ZpZGVyXzEuQ29tcG9uZW50UHJvdmlkZXIsIGFnQ29tcG9uZW50VXRpbHNfMS5BZ0NvbXBvbmVudFV0aWxzLCBjb21wb25lbnRNZXRhZGF0YVByb3ZpZGVyXzEuQ29tcG9uZW50TWV0YWRhdGFQcm92aWRlcixcbiAgICAgICAgICAgICAgICBjb21wb25lbnRQcm92aWRlcl8xLkNvbXBvbmVudFByb3ZpZGVyLCBjb21wb25lbnRSZXNvbHZlcl8xLkNvbXBvbmVudFJlc29sdmVyLCBjb21wb25lbnRSZWNpcGVzXzEuQ29tcG9uZW50UmVjaXBlcywgbmFtZWRDb21wb25lbnRSZXNvbHZlcl8xLk5hbWVkQ29tcG9uZW50UmVzb2x2ZXIsXG4gICAgICAgICAgICAgICAgY2VsbFJlbmRlcmVyRmFjdG9yeV8xLkNlbGxSZW5kZXJlckZhY3RvcnksIGhvcml6b250YWxEcmFnU2VydmljZV8xLkhvcml6b250YWxEcmFnU2VydmljZSwgaGVhZGVyVGVtcGxhdGVMb2FkZXJfMS5IZWFkZXJUZW1wbGF0ZUxvYWRlciwgcGlubmVkUm93TW9kZWxfMS5QaW5uZWRSb3dNb2RlbCwgZHJhZ1NlcnZpY2VfMS5EcmFnU2VydmljZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5ZWRHcm91cENyZWF0b3JfMS5EaXNwbGF5ZWRHcm91cENyZWF0b3IsIGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyLCBzZWxlY3Rpb25Db250cm9sbGVyXzEuU2VsZWN0aW9uQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyXzEuRmlsdGVyTWFuYWdlciwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIsIHBhZ2luYXRpb25Qcm94eV8xLlBhZ2luYXRpb25Qcm94eSwgcm93UmVuZGVyZXJfMS5Sb3dSZW5kZXJlciwgaGVhZGVyUmVuZGVyZXJfMS5IZWFkZXJSZW5kZXJlciwgZXhwcmVzc2lvblNlcnZpY2VfMS5FeHByZXNzaW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICBiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyXzEuQmFsYW5jZWRDb2x1bW5UcmVlQnVpbGRlciwgY3N2Q3JlYXRvcl8xLkNzdkNyZWF0b3IsIGRvd25sb2FkZXJfMS5Eb3dubG9hZGVyLCB4bWxGYWN0b3J5XzEuWG1sRmFjdG9yeSwgZ3JpZFNlcmlhbGl6ZXJfMS5HcmlkU2VyaWFsaXplciwgdGVtcGxhdGVTZXJ2aWNlXzEuVGVtcGxhdGVTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25TZXJ2aWNlXzEuTmF2aWdhdGlvblNlcnZpY2UsIGdyaWRQYW5lbF8xLkdyaWRQYW5lbCwgcG9wdXBTZXJ2aWNlXzEuUG9wdXBTZXJ2aWNlLCB2YWx1ZUNhY2hlXzEuVmFsdWVDYWNoZSwgdmFsdWVTZXJ2aWNlXzEuVmFsdWVTZXJ2aWNlLCBhbGlnbmVkR3JpZHNTZXJ2aWNlXzEuQWxpZ25lZEdyaWRzU2VydmljZSxcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5Mb2dnZXJGYWN0b3J5LCBjb2x1bW5VdGlsc18xLkNvbHVtblV0aWxzLCBhdXRvV2lkdGhDYWxjdWxhdG9yXzEuQXV0b1dpZHRoQ2FsY3VsYXRvciwgcG9wdXBTZXJ2aWNlXzEuUG9wdXBTZXJ2aWNlLCBncmlkQ29yZV8xLkdyaWRDb3JlLCBzdGFuZGFyZE1lbnVfMS5TdGFuZGFyZE1lbnVGYWN0b3J5LFxuICAgICAgICAgICAgICAgIGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdBbmREcm9wU2VydmljZSwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkFwaSwgZm9jdXNlZENlbGxDb250cm9sbGVyXzEuRm9jdXNlZENlbGxDb250cm9sbGVyLCBtb3VzZUV2ZW50U2VydmljZV8xLk1vdXNlRXZlbnRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIGNlbGxOYXZpZ2F0aW9uU2VydmljZV8xLkNlbGxOYXZpZ2F0aW9uU2VydmljZSwgZmlsdGVyU3RhZ2VfMS5GaWx0ZXJTdGFnZSwgc29ydFN0YWdlXzEuU29ydFN0YWdlLCBmbGF0dGVuU3RhZ2VfMS5GbGF0dGVuU3RhZ2UsIGZpbHRlclNlcnZpY2VfMS5GaWx0ZXJTZXJ2aWNlLCByb3dOb2RlRmFjdG9yeV8xLlJvd05vZGVGYWN0b3J5LFxuICAgICAgICAgICAgICAgIGNlbGxFZGl0b3JGYWN0b3J5XzEuQ2VsbEVkaXRvckZhY3RvcnksIGNlbGxSZW5kZXJlclNlcnZpY2VfMS5DZWxsUmVuZGVyZXJTZXJ2aWNlLCB2YWx1ZUZvcm1hdHRlclNlcnZpY2VfMS5WYWx1ZUZvcm1hdHRlclNlcnZpY2UsIHN0eWxpbmdTZXJ2aWNlXzEuU3R5bGluZ1NlcnZpY2UsIHNjcm9sbFZpc2libGVTZXJ2aWNlXzEuU2Nyb2xsVmlzaWJsZVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgY29sdW1uSG92ZXJTZXJ2aWNlXzEuQ29sdW1uSG92ZXJTZXJ2aWNlLCBjb2x1bW5BbmltYXRpb25TZXJ2aWNlXzEuQ29sdW1uQW5pbWF0aW9uU2VydmljZSwgc29ydFNlcnZpY2VfMS5Tb3J0U2VydmljZSwgYXV0b0dyb3VwQ29sU2VydmljZV8xLkF1dG9Hcm91cENvbFNlcnZpY2UsIGltbXV0YWJsZVNlcnZpY2VfMS5JbW11dGFibGVTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvblNlcnZpY2VfMS5DaGFuZ2VEZXRlY3Rpb25TZXJ2aWNlLCBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50LCBiZWFuc18xLkJlYW5zLCBhbmltYXRpb25GcmFtZVNlcnZpY2VfMS5BbmltYXRpb25GcmFtZVNlcnZpY2UsIHNvcnRDb250cm9sbGVyXzEuU29ydENvbnRyb2xsZXJdLFxuICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgIHsgY29tcG9uZW50TmFtZTogJ0FnQ2hlY2tib3gnLCB0aGVDbGFzczogYWdDaGVja2JveF8xLkFnQ2hlY2tib3ggfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlYnVnOiAhIWdyaWRPcHRpb25zLmRlYnVnXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc0xvZ2dpbmdGdW5jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udGV4dFBhcmFtcy5kZWJ1ZzsgfTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IGNvbnRleHRfMS5Db250ZXh0KGNvbnRleHRQYXJhbXMsIG5ldyBsb2dnZXJfMS5Mb2dnZXIoJ0NvbnRleHQnLCBpc0xvZ2dpbmdGdW5jKSk7XG4gICAgICAgIC8vIHdlIGRvIHRoaXMgYXQgdGhlIGVuZCwgYWZ0ZXIgdGhlIGJvb3Qgc2VxdWVuY2UgaXMgY29tcGxldGVcbiAgICAgICAgdGhpcy5yZWdpc3RlckNvbXBvbmVudHMoZ3JpZE9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldENvbHVtbnNBbmREYXRhKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hHcmlkUmVhZHlFdmVudChncmlkT3B0aW9ucyk7XG4gICAgICAgIGlmIChncmlkT3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FnLUdyaWQgLT4gaW5pdGlhbGlzZWQgc3VjY2Vzc2Z1bGx5LCBlbnRlcnByaXNlID0gJyArIGVudGVycHJpc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEdyaWQuc2V0RW50ZXJwcmlzZUJlYW5zID0gZnVuY3Rpb24gKGVudGVycHJpc2VCZWFucywgcm93TW9kZWxDbGFzc2VzKSB7XG4gICAgICAgIHRoaXMuZW50ZXJwcmlzZUJlYW5zID0gZW50ZXJwcmlzZUJlYW5zO1xuICAgICAgICAvLyB0aGUgZW50ZXJwcmlzZSBjYW4gaW5qZWN0IGFkZGl0aW9uYWwgcm93IG1vZGVscy4gdGhpcyBpcyBob3cgaXQgaW5qZWN0cyB0aGUgdmlld3BvcnRSb3dNb2RlbFxuICAgICAgICB1dGlsc18xLlV0aWxzLml0ZXJhdGVPYmplY3Qocm93TW9kZWxDbGFzc2VzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgeyByZXR1cm4gR3JpZC5Sb3dNb2RlbENsYXNzZXNba2V5XSA9IHZhbHVlOyB9KTtcbiAgICB9O1xuICAgIEdyaWQuc2V0RnJhbWV3b3JrQmVhbnMgPSBmdW5jdGlvbiAoZnJhbWV3b3JrQmVhbnMpIHtcbiAgICAgICAgdGhpcy5mcmFtZXdvcmtCZWFucyA9IGZyYW1ld29ya0JlYW5zO1xuICAgIH07XG4gICAgR3JpZC5wcm90b3R5cGUucmVnaXN0ZXJDb21wb25lbnRzID0gZnVuY3Rpb24gKGdyaWRPcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRQcm92aWRlciA9IHRoaXMuY29udGV4dC5nZXRCZWFuKCdjb21wb25lbnRQcm92aWRlcicpO1xuICAgICAgICBpZiAoZ3JpZE9wdGlvbnMuY29tcG9uZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhncmlkT3B0aW9ucy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3ZpZGVyLnJlZ2lzdGVyQ29tcG9uZW50KGl0LCBncmlkT3B0aW9ucy5jb21wb25lbnRzW2l0XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZE9wdGlvbnMuZnJhbWV3b3JrQ29tcG9uZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhncmlkT3B0aW9ucy5mcmFtZXdvcmtDb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3ZpZGVyLnJlZ2lzdGVyRndDb21wb25lbnQoaXQsIGdyaWRPcHRpb25zLmZyYW1ld29ya0NvbXBvbmVudHNbaXRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmlkLnByb3RvdHlwZS5zZXRDb2x1bW5zQW5kRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyaWRPcHRpb25zV3JhcHBlciA9IHRoaXMuY29udGV4dC5nZXRCZWFuKCdncmlkT3B0aW9uc1dyYXBwZXInKTtcbiAgICAgICAgdmFyIGNvbHVtbkNvbnRyb2xsZXIgPSB0aGlzLmNvbnRleHQuZ2V0QmVhbignY29sdW1uQ29udHJvbGxlcicpO1xuICAgICAgICB2YXIgcm93TW9kZWwgPSB0aGlzLmNvbnRleHQuZ2V0QmVhbigncm93TW9kZWwnKTtcbiAgICAgICAgdmFyIGNvbHVtbkRlZnMgPSBncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29sdW1uRGVmcygpO1xuICAgICAgICB2YXIgcm93RGF0YSA9IGdyaWRPcHRpb25zV3JhcHBlci5nZXRSb3dEYXRhKCk7XG4gICAgICAgIHZhciBub3RoaW5nVG9TZXQgPSB1dGlsc18xLlV0aWxzLm1pc3NpbmcoY29sdW1uRGVmcykgJiYgdXRpbHNfMS5VdGlscy5taXNzaW5nKHJvd0RhdGEpO1xuICAgICAgICBpZiAobm90aGluZ1RvU2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlU2VydmljZSA9IHRoaXMuY29udGV4dC5nZXRCZWFuKCd2YWx1ZVNlcnZpY2UnKTtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKGNvbHVtbkRlZnMpKSB7XG4gICAgICAgICAgICBjb2x1bW5Db250cm9sbGVyLnNldENvbHVtbkRlZnMoY29sdW1uRGVmcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHJvd0RhdGEpICYmIHJvd01vZGVsLmdldFR5cGUoKSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0lOX01FTU9SWSkge1xuICAgICAgICAgICAgdmFyIGluTWVtb3J5Um93TW9kZWwgPSByb3dNb2RlbDtcbiAgICAgICAgICAgIGluTWVtb3J5Um93TW9kZWwuc2V0Um93RGF0YShyb3dEYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZC5wcm90b3R5cGUuZGlzcGF0Y2hHcmlkUmVhZHlFdmVudCA9IGZ1bmN0aW9uIChncmlkT3B0aW9ucykge1xuICAgICAgICB2YXIgZXZlbnRTZXJ2aWNlID0gdGhpcy5jb250ZXh0LmdldEJlYW4oJ2V2ZW50U2VydmljZScpO1xuICAgICAgICB2YXIgcmVhZHlFdmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9HUklEX1JFQURZLFxuICAgICAgICAgICAgYXBpOiBncmlkT3B0aW9ucy5hcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IGdyaWRPcHRpb25zLmNvbHVtbkFwaVxuICAgICAgICB9O1xuICAgICAgICBldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChyZWFkeUV2ZW50KTtcbiAgICB9O1xuICAgIEdyaWQucHJvdG90eXBlLmdldFJvd01vZGVsQ2xhc3MgPSBmdW5jdGlvbiAoZ3JpZE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJvd01vZGVsVHlwZSA9IGdyaWRPcHRpb25zLnJvd01vZGVsVHlwZTtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHJvd01vZGVsVHlwZSkpIHtcbiAgICAgICAgICAgIHZhciByb3dNb2RlbENsYXNzID0gR3JpZC5Sb3dNb2RlbENsYXNzZXNbcm93TW9kZWxUeXBlXTtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhyb3dNb2RlbENsYXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3dNb2RlbENsYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd01vZGVsVHlwZSA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYWctR3JpZDogbm9ybWFsIHJvd01vZGVsIGRlcHJlY2F0ZWQuIFNob3VsZCBub3cgYmUgY2FsbGVkIGluTWVtb3J5IHJvd01vZGVsIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5NZW1vcnlSb3dNb2RlbF8xLkluTWVtb3J5Um93TW9kZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FnLUdyaWQ6IGNvdWxkIG5vdCBmaW5kIG1hdGNoaW5nIHJvdyBtb2RlbCBmb3Igcm93TW9kZWxUeXBlICcgKyByb3dNb2RlbFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChyb3dNb2RlbFR5cGUgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogcm93TW9kZWxUeXBlIHZpZXdwb3J0IGlzIG9ubHkgYXZhaWxhYmxlIGluIGFnLUdyaWQgRW50ZXJwcmlzZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm93TW9kZWxUeXBlID09PSAnZW50ZXJwcmlzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogcm93TW9kZWxUeXBlIHZpZXdwb3J0IGlzIG9ubHkgYXZhaWxhYmxlIGluIGFnLUdyaWQgRW50ZXJwcmlzZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5NZW1vcnlSb3dNb2RlbF8xLkluTWVtb3J5Um93TW9kZWw7XG4gICAgfTtcbiAgICA7XG4gICAgR3JpZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIC8vIHRoZSBkZWZhdWx0IGlzIEluTWVtb3J5Um93TW9kZWwsIHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgcGFnaW5hdGlvbi5cbiAgICAvLyB0aGUgZW50ZXJwcmlzZSBhZGRzIHZpZXdwb3J0IHRvIHRoaXMgbGlzdC5cbiAgICBHcmlkLlJvd01vZGVsQ2xhc3NlcyA9IHtcbiAgICAgICAgaW5maW5pdGU6IGluZmluaXRlUm93TW9kZWxfMS5JbmZpbml0ZVJvd01vZGVsLFxuICAgICAgICBpbk1lbW9yeTogaW5NZW1vcnlSb3dNb2RlbF8xLkluTWVtb3J5Um93TW9kZWxcbiAgICB9O1xuICAgIHJldHVybiBHcmlkO1xufSgpKTtcbmV4cG9ydHMuR3JpZCA9IEdyaWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9ncmlkLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHNlbGVjdGlvbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL3NlbGVjdGlvbkNvbnRyb2xsZXJcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgZGlzcGxheWVkR3JvdXBDcmVhdG9yXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Db250cm9sbGVyL2Rpc3BsYXllZEdyb3VwQ3JlYXRvclwiKTtcbnZhciBiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5Db250cm9sbGVyL2JhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXJcIik7XG52YXIgZ3JvdXBJbnN0YW5jZUlkQ3JlYXRvcl8xID0gcmVxdWlyZShcIi4vY29sdW1uQ29udHJvbGxlci9ncm91cEluc3RhbmNlSWRDcmVhdG9yXCIpO1xudmFyIGNvbHVtbkdyb3VwXzEgPSByZXF1aXJlKFwiLi9lbnRpdGllcy9jb2x1bW5Hcm91cFwiKTtcbnZhciBwaW5uZWRSb3dNb2RlbF8xID0gcmVxdWlyZShcIi4vcm93TW9kZWxzL3Bpbm5lZFJvd01vZGVsXCIpO1xudmFyIEJhc2VHcmlkU2VyaWFsaXppbmdTZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlR3JpZFNlcmlhbGl6aW5nU2Vzc2lvbihjb2x1bW5Db250cm9sbGVyLCB2YWx1ZVNlcnZpY2UsIGdyaWRPcHRpb25zV3JhcHBlciwgcHJvY2Vzc0NlbGxDYWxsYmFjaywgcHJvY2Vzc0hlYWRlckNhbGxiYWNrLCBjZWxsQW5kSGVhZGVyRXNjYXBlcikge1xuICAgICAgICB0aGlzLmNvbHVtbkNvbnRyb2xsZXIgPSBjb2x1bW5Db250cm9sbGVyO1xuICAgICAgICB0aGlzLnZhbHVlU2VydmljZSA9IHZhbHVlU2VydmljZTtcbiAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIgPSBncmlkT3B0aW9uc1dyYXBwZXI7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NlbGxDYWxsYmFjayA9IHByb2Nlc3NDZWxsQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMucHJvY2Vzc0hlYWRlckNhbGxiYWNrID0gcHJvY2Vzc0hlYWRlckNhbGxiYWNrO1xuICAgICAgICB0aGlzLmNlbGxBbmRIZWFkZXJFc2NhcGVyID0gY2VsbEFuZEhlYWRlckVzY2FwZXI7XG4gICAgfVxuICAgIEJhc2VHcmlkU2VyaWFsaXppbmdTZXNzaW9uLnByb3RvdHlwZS5leHRyYWN0SGVhZGVyVmFsdWUgPSBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHZhciBuYW1lRm9yQ29sID0gdGhpcy5nZXRIZWFkZXJOYW1lKHRoaXMucHJvY2Vzc0hlYWRlckNhbGxiYWNrLCBjb2x1bW4pO1xuICAgICAgICBpZiAobmFtZUZvckNvbCA9PT0gbnVsbCB8fCBuYW1lRm9yQ29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5hbWVGb3JDb2wgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jZWxsQW5kSGVhZGVyRXNjYXBlciA/IHRoaXMuY2VsbEFuZEhlYWRlckVzY2FwZXIobmFtZUZvckNvbCkgOiBuYW1lRm9yQ29sO1xuICAgIH07XG4gICAgQmFzZUdyaWRTZXJpYWxpemluZ1Nlc3Npb24ucHJvdG90eXBlLmV4dHJhY3RSb3dDZWxsVmFsdWUgPSBmdW5jdGlvbiAoY29sdW1uLCBpbmRleCwgdHlwZSwgbm9kZSkge1xuICAgICAgICB2YXIgaXNSb3dHcm91cGluZyA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRSb3dHcm91cENvbHVtbnMoKS5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgdmFsdWVGb3JDZWxsO1xuICAgICAgICBpZiAobm9kZS5ncm91cCAmJiBpc1Jvd0dyb3VwaW5nICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB2YWx1ZUZvckNlbGwgPSB0aGlzLmNyZWF0ZVZhbHVlRm9yR3JvdXBOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVGb3JDZWxsID0gdGhpcy52YWx1ZVNlcnZpY2UuZ2V0VmFsdWUoY29sdW1uLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZUZvckNlbGwgPSB0aGlzLnByb2Nlc3NDZWxsKG5vZGUsIGNvbHVtbiwgdmFsdWVGb3JDZWxsLCB0aGlzLnByb2Nlc3NDZWxsQ2FsbGJhY2ssIHR5cGUpO1xuICAgICAgICBpZiAodmFsdWVGb3JDZWxsID09PSBudWxsIHx8IHZhbHVlRm9yQ2VsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZUZvckNlbGwgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jZWxsQW5kSGVhZGVyRXNjYXBlciA/IHRoaXMuY2VsbEFuZEhlYWRlckVzY2FwZXIodmFsdWVGb3JDZWxsKSA6IHZhbHVlRm9yQ2VsbDtcbiAgICB9O1xuICAgIEJhc2VHcmlkU2VyaWFsaXppbmdTZXNzaW9uLnByb3RvdHlwZS5nZXRIZWFkZXJOYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCksXG4gICAgICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb2x1bW5BcGkoKSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb250ZXh0KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXREaXNwbGF5TmFtZUZvckNvbHVtbihjb2x1bW4sICdjc3YnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZUdyaWRTZXJpYWxpemluZ1Nlc3Npb24ucHJvdG90eXBlLmNyZWF0ZVZhbHVlRm9yR3JvdXBOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbbm9kZS5rZXldO1xuICAgICAgICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIGtleXMucHVzaChub2RlLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXMucmV2ZXJzZSgpLmpvaW4oJyAtPiAnKTtcbiAgICB9O1xuICAgIEJhc2VHcmlkU2VyaWFsaXppbmdTZXNzaW9uLnByb3RvdHlwZS5wcm9jZXNzQ2VsbCA9IGZ1bmN0aW9uIChyb3dOb2RlLCBjb2x1bW4sIHZhbHVlLCBwcm9jZXNzQ2VsbENhbGxiYWNrLCB0eXBlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzQ2VsbENhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0NlbGxDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgbm9kZTogcm93Tm9kZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBcGkoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbHVtbkFwaSgpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJhc2VHcmlkU2VyaWFsaXppbmdTZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuQmFzZUdyaWRTZXJpYWxpemluZ1Nlc3Npb24gPSBCYXNlR3JpZFNlcmlhbGl6aW5nU2Vzc2lvbjtcbnZhciBHcmlkU2VyaWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JpZFNlcmlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIEdyaWRTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoZ3JpZFNlcmlhbGl6aW5nU2Vzc2lvbiwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBkb250U2tpcFJvd3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgdmFyIHNraXBHcm91cHMgPSBwYXJhbXMgJiYgcGFyYW1zLnNraXBHcm91cHM7XG4gICAgICAgIHZhciBza2lwSGVhZGVyID0gcGFyYW1zICYmIHBhcmFtcy5za2lwSGVhZGVyO1xuICAgICAgICB2YXIgY29sdW1uR3JvdXBzID0gcGFyYW1zICYmIHBhcmFtcy5jb2x1bW5Hcm91cHM7XG4gICAgICAgIHZhciBza2lwRm9vdGVycyA9IHBhcmFtcyAmJiBwYXJhbXMuc2tpcEZvb3RlcnM7XG4gICAgICAgIHZhciBza2lwUGlubmVkVG9wID0gcGFyYW1zICYmIHBhcmFtcy5za2lwUGlubmVkVG9wO1xuICAgICAgICB2YXIgc2tpcFBpbm5lZEJvdHRvbSA9IHBhcmFtcyAmJiBwYXJhbXMuc2tpcFBpbm5lZEJvdHRvbTtcbiAgICAgICAgdmFyIGluY2x1ZGVDdXN0b21IZWFkZXIgPSBwYXJhbXMgJiYgcGFyYW1zLmN1c3RvbUhlYWRlcjtcbiAgICAgICAgdmFyIGluY2x1ZGVDdXN0b21Gb290ZXIgPSBwYXJhbXMgJiYgcGFyYW1zLmN1c3RvbUZvb3RlcjtcbiAgICAgICAgdmFyIGFsbENvbHVtbnMgPSBwYXJhbXMgJiYgcGFyYW1zLmFsbENvbHVtbnM7XG4gICAgICAgIHZhciBvbmx5U2VsZWN0ZWQgPSBwYXJhbXMgJiYgcGFyYW1zLm9ubHlTZWxlY3RlZDtcbiAgICAgICAgdmFyIGNvbHVtbktleXMgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbHVtbktleXM7XG4gICAgICAgIHZhciBvbmx5U2VsZWN0ZWRBbGxQYWdlcyA9IHBhcmFtcyAmJiBwYXJhbXMub25seVNlbGVjdGVkQWxsUGFnZXM7XG4gICAgICAgIHZhciByb3dTa2lwcGVyID0gKHBhcmFtcyAmJiBwYXJhbXMuc2hvdWxkUm93QmVTa2lwcGVkKSB8fCBkb250U2tpcFJvd3M7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBcGkoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb250ZXh0KCk7XG4gICAgICAgIC8vIHdoZW4gaW4gcGl2b3QgbW9kZSwgd2UgYWx3YXlzIHJlbmRlciBjb2xzIG9uIHNjcmVlbiwgbmV2ZXIgJ2FsbCBjb2x1bW5zJ1xuICAgICAgICB2YXIgaXNQaXZvdE1vZGUgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNQaXZvdE1vZGUoKTtcbiAgICAgICAgdmFyIHJvd01vZGVsTm9ybWFsID0gdGhpcy5yb3dNb2RlbC5nZXRUeXBlKCkgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5ST1dfTU9ERUxfVFlQRV9JTl9NRU1PUlk7XG4gICAgICAgIHZhciBvbmx5U2VsZWN0ZWROb25TdGFuZGFyZE1vZGVsID0gIXJvd01vZGVsTm9ybWFsICYmIG9ubHlTZWxlY3RlZDtcbiAgICAgICAgdmFyIGNvbHVtbnNUb0V4cG9ydDtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzQW5kTm90RW1wdHkoY29sdW1uS2V5cykpIHtcbiAgICAgICAgICAgIGNvbHVtbnNUb0V4cG9ydCA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRHcmlkQ29sdW1ucyhjb2x1bW5LZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxDb2x1bW5zICYmICFpc1Bpdm90TW9kZSkge1xuICAgICAgICAgICAgY29sdW1uc1RvRXhwb3J0ID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldEFsbFByaW1hcnlDb2x1bW5zKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW5zVG9FeHBvcnQgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0QWxsRGlzcGxheWVkQ29sdW1ucygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29sdW1uc1RvRXhwb3J0IHx8IGNvbHVtbnNUb0V4cG9ydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBncmlkU2VyaWFsaXppbmdTZXNzaW9uLnByZXBhcmUoY29sdW1uc1RvRXhwb3J0KTtcbiAgICAgICAgaWYgKGluY2x1ZGVDdXN0b21IZWFkZXIpIHtcbiAgICAgICAgICAgIGdyaWRTZXJpYWxpemluZ1Nlc3Npb24uYWRkQ3VzdG9tSGVhZGVyKHBhcmFtcy5jdXN0b21IZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IHBhc3MsIHB1dCBpbiB0aGUgaGVhZGVyIG5hbWVzIG9mIHRoZSBjb2xzXG4gICAgICAgIGlmIChjb2x1bW5Hcm91cHMpIHtcbiAgICAgICAgICAgIHZhciBncm91cEluc3RhbmNlSWRDcmVhdG9yID0gbmV3IGdyb3VwSW5zdGFuY2VJZENyZWF0b3JfMS5Hcm91cEluc3RhbmNlSWRDcmVhdG9yKCk7XG4gICAgICAgICAgICB2YXIgZGlzcGxheWVkR3JvdXBzID0gdGhpcy5kaXNwbGF5ZWRHcm91cENyZWF0b3IuY3JlYXRlRGlzcGxheWVkR3JvdXBzKGNvbHVtbnNUb0V4cG9ydCwgdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldEdyaWRCYWxhbmNlZFRyZWUoKSwgZ3JvdXBJbnN0YW5jZUlkQ3JlYXRvcik7XG4gICAgICAgICAgICB0aGlzLnJlY3Vyc2l2ZWx5QWRkSGVhZGVyR3JvdXBzKGRpc3BsYXllZEdyb3VwcywgZ3JpZFNlcmlhbGl6aW5nU2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFza2lwSGVhZGVyKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZFJvd0l0ZXJhdG9yXzEgPSBncmlkU2VyaWFsaXppbmdTZXNzaW9uLm9uTmV3SGVhZGVyUm93KCk7XG4gICAgICAgICAgICBjb2x1bW5zVG9FeHBvcnQuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGdyaWRSb3dJdGVyYXRvcl8xLm9uQ29sdW1uKGNvbHVtbiwgaW5kZXgsIG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5waW5uZWRSb3dNb2RlbC5mb3JFYWNoUGlubmVkVG9wUm93KHByb2Nlc3NSb3cpO1xuICAgICAgICBpZiAoaXNQaXZvdE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucm93TW9kZWwuZm9yRWFjaFBpdm90Tm9kZShwcm9jZXNzUm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9ubHlTZWxlY3RlZEFsbFBhZ2VzOiB1c2VyIGRvaW5nIHBhZ2luYXRpb24gYW5kIHdhbnRzIHNlbGVjdGVkIGl0ZW1zIGZyb21cbiAgICAgICAgICAgIC8vIG90aGVyIHBhZ2VzLCBzbyBjYW5ub3QgdXNlIHRoZSBzdGFuZGFyZCByb3cgbW9kZWwgYXMgaXQgd29uJ3QgaGF2ZSByb3dzIGZyb21cbiAgICAgICAgICAgIC8vIG90aGVyIHBhZ2VzLlxuICAgICAgICAgICAgLy8gb25seVNlbGVjdGVkTm9uU3RhbmRhcmRNb2RlbDogaWYgdXNlciB3YW50cyBzZWxlY3RlZCBpbiBub24gc3RhbmRhcmQgcm93IG1vZGVsXG4gICAgICAgICAgICAvLyAoZWcgdmlld3BvcnQpIHRoZW4gYWdhaW4gcm93bW9kZWwgY2Fubm90IGJlIHVzZWQsIHNvIG5lZWQgdG8gdXNlIHNlbGVjdGVkIGluc3RlYWQuXG4gICAgICAgICAgICBpZiAob25seVNlbGVjdGVkQWxsUGFnZXMgfHwgb25seVNlbGVjdGVkTm9uU3RhbmRhcmRNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLmdldFNlbGVjdGVkTm9kZXMoKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc1Jvdyhub2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhlcmUgaXMgZXZlcnl0aGluZyBlbHNlIC0gaW5jbHVkaW5nIHN0YW5kYXJkIHJvdyBtb2RlbCBhbmQgc2VsZWN0ZWQuIHdlIGRvbid0IHVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZWxlY3Rpb24gbW9kZWwgZXZlbiB3aGVuIGp1c3QgdXNpbmcgc2VsZWN0ZWQsIHNvIHRoYXQgdGhlIHJlc3VsdCBpcyB0aGUgb3JkZXJcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgcm93cyBhcHBlYXJpbmcgb24gdGhlIHNjcmVlbi5cbiAgICAgICAgICAgICAgICBpZiAocm93TW9kZWxOb3JtYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dNb2RlbC5mb3JFYWNoTm9kZUFmdGVyRmlsdGVyQW5kU29ydChwcm9jZXNzUm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93TW9kZWwuZm9yRWFjaE5vZGUocHJvY2Vzc1Jvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGlubmVkUm93TW9kZWwuZm9yRWFjaFBpbm5lZEJvdHRvbVJvdyhwcm9jZXNzUm93KTtcbiAgICAgICAgaWYgKGluY2x1ZGVDdXN0b21Gb290ZXIpIHtcbiAgICAgICAgICAgIGdyaWRTZXJpYWxpemluZ1Nlc3Npb24uYWRkQ3VzdG9tRm9vdGVyKHBhcmFtcy5jdXN0b21Gb290ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NSb3cobm9kZSkge1xuICAgICAgICAgICAgaWYgKHNraXBHcm91cHMgJiYgbm9kZS5ncm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChza2lwRm9vdGVycyAmJiBub2RlLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbmx5U2VsZWN0ZWQgJiYgIW5vZGUuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNraXBQaW5uZWRUb3AgJiYgbm9kZS5yb3dQaW5uZWQgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNraXBQaW5uZWRCb3R0b20gJiYgbm9kZS5yb3dQaW5uZWQgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGluIHBpdm90TW9kZSwgdGhlbiB0aGUgZ3JpZCB3aWxsIHNob3cgdGhlIHJvb3Qgbm9kZSBvbmx5XG4gICAgICAgICAgICAvLyBpZiBpdCdzIG5vdCBhIGxlYWYgZ3JvdXBcbiAgICAgICAgICAgIHZhciBub2RlSXNSb290Tm9kZSA9IG5vZGUubGV2ZWwgPT09IC0xO1xuICAgICAgICAgICAgaWYgKG5vZGVJc1Jvb3ROb2RlICYmICFub2RlLmxlYWZHcm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaG91bGRSb3dCZVNraXBwZWQgPSByb3dTa2lwcGVyKHtcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIGFwaTogYXBpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJvd0JlU2tpcHBlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcm93QWNjdW11bGF0b3IgPSBncmlkU2VyaWFsaXppbmdTZXNzaW9uLm9uTmV3Qm9keVJvdygpO1xuICAgICAgICAgICAgY29sdW1uc1RvRXhwb3J0LmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByb3dBY2N1bXVsYXRvci5vbkNvbHVtbihjb2x1bW4sIGluZGV4LCBub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmlkU2VyaWFsaXppbmdTZXNzaW9uLnBhcnNlKCk7XG4gICAgfTtcbiAgICBHcmlkU2VyaWFsaXplci5wcm90b3R5cGUucmVjdXJzaXZlbHlBZGRIZWFkZXJHcm91cHMgPSBmdW5jdGlvbiAoZGlzcGxheWVkR3JvdXBzLCBncmlkU2VyaWFsaXppbmdTZXNzaW9uKSB7XG4gICAgICAgIHZhciBkaXJlY3RDaGlsZHJlbkhlYWRlckdyb3VwcyA9IFtdO1xuICAgICAgICBkaXNwbGF5ZWRHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uR3JvdXBDaGlsZCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbkdyb3VwID0gY29sdW1uR3JvdXBDaGlsZDtcbiAgICAgICAgICAgIGlmICghY29sdW1uR3JvdXAuZ2V0Q2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29sdW1uR3JvdXAuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChpdCkgeyByZXR1cm4gZGlyZWN0Q2hpbGRyZW5IZWFkZXJHcm91cHMucHVzaChpdCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpc3BsYXllZEdyb3Vwcy5sZW5ndGggPiAwICYmIGRpc3BsYXllZEdyb3Vwc1swXSBpbnN0YW5jZW9mIGNvbHVtbkdyb3VwXzEuQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuZG9BZGRIZWFkZXJIZWFkZXIoZ3JpZFNlcmlhbGl6aW5nU2Vzc2lvbiwgZGlzcGxheWVkR3JvdXBzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0Q2hpbGRyZW5IZWFkZXJHcm91cHMgJiYgZGlyZWN0Q2hpbGRyZW5IZWFkZXJHcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZWN1cnNpdmVseUFkZEhlYWRlckdyb3VwcyhkaXJlY3RDaGlsZHJlbkhlYWRlckdyb3VwcywgZ3JpZFNlcmlhbGl6aW5nU2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyaWRTZXJpYWxpemVyLnByb3RvdHlwZS5kb0FkZEhlYWRlckhlYWRlciA9IGZ1bmN0aW9uIChncmlkU2VyaWFsaXppbmdTZXNzaW9uLCBkaXNwbGF5ZWRHcm91cHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdyaWRSb3dJdGVyYXRvciA9IGdyaWRTZXJpYWxpemluZ1Nlc3Npb24ub25OZXdIZWFkZXJHcm91cGluZ1JvdygpO1xuICAgICAgICB2YXIgY29sdW1uSW5kZXggPSAwO1xuICAgICAgICBkaXNwbGF5ZWRHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uR3JvdXBDaGlsZCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbkdyb3VwID0gY29sdW1uR3JvdXBDaGlsZDtcbiAgICAgICAgICAgIHZhciBjb2xEZWYgPSBjb2x1bW5Hcm91cC5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICB2YXIgY29sdW1uTmFtZSA9IF90aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0RGlzcGxheU5hbWVGb3JDb2x1bW5Hcm91cChjb2x1bW5Hcm91cCwgJ2hlYWRlcicpO1xuICAgICAgICAgICAgZ3JpZFJvd0l0ZXJhdG9yLm9uQ29sdW1uKGNvbHVtbk5hbWUsIGNvbHVtbkluZGV4KyssIGNvbHVtbkdyb3VwLmdldExlYWZDb2x1bW5zKCkubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2Rpc3BsYXllZEdyb3VwQ3JlYXRvcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZGlzcGxheWVkR3JvdXBDcmVhdG9yXzEuRGlzcGxheWVkR3JvdXBDcmVhdG9yKVxuICAgIF0sIEdyaWRTZXJpYWxpemVyLnByb3RvdHlwZSwgXCJkaXNwbGF5ZWRHcm91cENyZWF0b3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgR3JpZFNlcmlhbGl6ZXIucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncm93TW9kZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHcmlkU2VyaWFsaXplci5wcm90b3R5cGUsIFwicm93TW9kZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncGlubmVkUm93TW9kZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHBpbm5lZFJvd01vZGVsXzEuUGlubmVkUm93TW9kZWwpXG4gICAgXSwgR3JpZFNlcmlhbGl6ZXIucHJvdG90eXBlLCBcInBpbm5lZFJvd01vZGVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3NlbGVjdGlvbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNlbGVjdGlvbkNvbnRyb2xsZXJfMS5TZWxlY3Rpb25Db250cm9sbGVyKVxuICAgIF0sIEdyaWRTZXJpYWxpemVyLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2JhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGJhbGFuY2VkQ29sdW1uVHJlZUJ1aWxkZXJfMS5CYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyKVxuICAgIF0sIEdyaWRTZXJpYWxpemVyLnByb3RvdHlwZSwgXCJiYWxhbmNlZENvbHVtblRyZWVCdWlsZGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEdyaWRTZXJpYWxpemVyLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBHcmlkU2VyaWFsaXplciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbihcImdyaWRTZXJpYWxpemVyXCIpXG4gICAgXSwgR3JpZFNlcmlhbGl6ZXIpO1xuICAgIHJldHVybiBHcmlkU2VyaWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLkdyaWRTZXJpYWxpemVyID0gR3JpZFNlcmlhbGl6ZXI7XG52YXIgUm93VHlwZTtcbihmdW5jdGlvbiAoUm93VHlwZSkge1xuICAgIFJvd1R5cGVbUm93VHlwZVtcIkhFQURFUl9HUk9VUElOR1wiXSA9IDBdID0gXCJIRUFERVJfR1JPVVBJTkdcIjtcbiAgICBSb3dUeXBlW1Jvd1R5cGVbXCJIRUFERVJcIl0gPSAxXSA9IFwiSEVBREVSXCI7XG4gICAgUm93VHlwZVtSb3dUeXBlW1wiQk9EWVwiXSA9IDJdID0gXCJCT0RZXCI7XG59KShSb3dUeXBlID0gZXhwb3J0cy5Sb3dUeXBlIHx8IChleHBvcnRzLlJvd1R5cGUgPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZ3JpZFNlcmlhbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBIZWFkZXJUZW1wbGF0ZUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVhZGVyVGVtcGxhdGVMb2FkZXIoKSB7XG4gICAgfVxuICAgIEhlYWRlclRlbXBsYXRlTG9hZGVyXzEgPSBIZWFkZXJUZW1wbGF0ZUxvYWRlcjtcbiAgICBIZWFkZXJUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUuY3JlYXRlSGVhZGVyRWxlbWVudCA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgY29sRGVmOiBjb2x1bW4uZ2V0Q29sRGVmLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBcGkoKVxuICAgICAgICB9O1xuICAgICAgICAvLyBvcHRpb24gMSAtIHNlZSBpZiB1c2VyIHByb3ZpZGVkIGEgdGVtcGxhdGUgaW4gY29sRGVmXG4gICAgICAgIHZhciB1c2VyUHJvdmlkZWRUZW1wbGF0ZSA9IGNvbHVtbi5nZXRDb2xEZWYoKS5oZWFkZXJDZWxsVGVtcGxhdGU7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlclByb3ZpZGVkVGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBjb2xEZWZGdW5jID0gdXNlclByb3ZpZGVkVGVtcGxhdGU7XG4gICAgICAgICAgICB1c2VyUHJvdmlkZWRUZW1wbGF0ZSA9IGNvbERlZkZ1bmMocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpb24gMiAtIGNoZWNrIHRoZSBncmlkT3B0aW9ucyBmb3IgY2VsbFRlbXBsYXRlXG4gICAgICAgIGlmICghdXNlclByb3ZpZGVkVGVtcGxhdGUgJiYgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0SGVhZGVyQ2VsbFRlbXBsYXRlKCkpIHtcbiAgICAgICAgICAgIHVzZXJQcm92aWRlZFRlbXBsYXRlID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0SGVhZGVyQ2VsbFRlbXBsYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW9uIDMgLSBjaGVjayB0aGUgZ3JpZE9wdGlvbnMgZm9yIHRlbXBsYXRlRnVuY3Rpb25cbiAgICAgICAgaWYgKCF1c2VyUHJvdmlkZWRUZW1wbGF0ZSAmJiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRIZWFkZXJDZWxsVGVtcGxhdGVGdW5jKCkpIHtcbiAgICAgICAgICAgIHZhciBncmlkT3B0aW9uc0Z1bmMgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRIZWFkZXJDZWxsVGVtcGxhdGVGdW5jKCk7XG4gICAgICAgICAgICB1c2VyUHJvdmlkZWRUZW1wbGF0ZSA9IGdyaWRPcHRpb25zRnVuYyhwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmFsbHksIGlmIHN0aWxsIG5vIHRlbXBsYXRlLCB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgaWYgKCF1c2VyUHJvdmlkZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdXNlclByb3ZpZGVkVGVtcGxhdGUgPSB0aGlzLmNyZWF0ZURlZmF1bHRIZWFkZXJFbGVtZW50KGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVtcGxhdGUgY2FuIGJlIGEgc3RyaW5nIG9yIGEgZG9tIGVsZW1lbnQsIGlmIHN0cmluZyB3ZSBuZWVkIHRvIGNvbnZlcnQgdG8gYSBkb20gZWxlbWVudFxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJQcm92aWRlZFRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdXRpbHNfMS5VdGlscy5sb2FkVGVtcGxhdGUodXNlclByb3ZpZGVkVGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHV0aWxzXzEuVXRpbHMuaXNOb2RlT3JFbGVtZW50KHVzZXJQcm92aWRlZFRlbXBsYXRlKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdXNlclByb3ZpZGVkVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBoZWFkZXIgdGVtcGxhdGUgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBIVE1MIGVsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSGVhZGVyVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLmNyZWF0ZURlZmF1bHRIZWFkZXJFbGVtZW50ID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgZVRlbXBsYXRlID0gdXRpbHNfMS5VdGlscy5sb2FkVGVtcGxhdGUoSGVhZGVyVGVtcGxhdGVMb2FkZXJfMS5IRUFERVJfQ0VMTF9URU1QTEFURSk7XG4gICAgICAgIHRoaXMuYWRkSW5JY29uKGVUZW1wbGF0ZSwgJ3NvcnRBc2NlbmRpbmcnLCAnI2FnU29ydEFzYycsIGNvbHVtbik7XG4gICAgICAgIHRoaXMuYWRkSW5JY29uKGVUZW1wbGF0ZSwgJ3NvcnREZXNjZW5kaW5nJywgJyNhZ1NvcnREZXNjJywgY29sdW1uKTtcbiAgICAgICAgdGhpcy5hZGRJbkljb24oZVRlbXBsYXRlLCAnc29ydFVuU29ydCcsICcjYWdOb1NvcnQnLCBjb2x1bW4pO1xuICAgICAgICB0aGlzLmFkZEluSWNvbihlVGVtcGxhdGUsICdtZW51JywgJyNhZ01lbnUnLCBjb2x1bW4pO1xuICAgICAgICB0aGlzLmFkZEluSWNvbihlVGVtcGxhdGUsICdmaWx0ZXInLCAnI2FnRmlsdGVyJywgY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIGVUZW1wbGF0ZTtcbiAgICB9O1xuICAgIEhlYWRlclRlbXBsYXRlTG9hZGVyLnByb3RvdHlwZS5hZGRJbkljb24gPSBmdW5jdGlvbiAoZVRlbXBsYXRlLCBpY29uTmFtZSwgY3NzU2VsZWN0b3IsIGNvbHVtbikge1xuICAgICAgICB2YXIgZUljb24gPSB1dGlsc18xLlV0aWxzLmNyZWF0ZUljb25Ob1NwYW4oaWNvbk5hbWUsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBjb2x1bW4pO1xuICAgICAgICBlVGVtcGxhdGUucXVlcnlTZWxlY3Rvcihjc3NTZWxlY3RvcikuYXBwZW5kQ2hpbGQoZUljb24pO1xuICAgIH07XG4gICAgSGVhZGVyVGVtcGxhdGVMb2FkZXIuSEVBREVSX0NFTExfVEVNUExBVEUgPSAnPGRpdiBjbGFzcz1cImFnLWhlYWRlci1jZWxsXCI+JyArXG4gICAgICAgICcgIDxkaXYgaWQ9XCJhZ1Jlc2l6ZUJhclwiIGNsYXNzPVwiYWctaGVhZGVyLWNlbGwtcmVzaXplXCI+PC9kaXY+JyArXG4gICAgICAgICcgIDxzcGFuIGlkPVwiYWdNZW51XCIgY2xhc3M9XCJhZy1oZWFkZXItaWNvbiBhZy1oZWFkZXItY2VsbC1tZW51LWJ1dHRvblwiPjwvc3Bhbj4nICtcbiAgICAgICAgJyAgPGRpdiBpZD1cImFnSGVhZGVyQ2VsbExhYmVsXCIgY2xhc3M9XCJhZy1oZWFkZXItY2VsbC1sYWJlbFwiPicgK1xuICAgICAgICAnICAgIDxzcGFuIGlkPVwiYWdTb3J0QXNjXCIgY2xhc3M9XCJhZy1oZWFkZXItaWNvbiBhZy1zb3J0LWFzY2VuZGluZy1pY29uXCI+PC9zcGFuPicgK1xuICAgICAgICAnICAgIDxzcGFuIGlkPVwiYWdTb3J0RGVzY1wiIGNsYXNzPVwiYWctaGVhZGVyLWljb24gYWctc29ydC1kZXNjZW5kaW5nLWljb25cIj48L3NwYW4+JyArXG4gICAgICAgICcgICAgPHNwYW4gaWQ9XCJhZ05vU29ydFwiIGNsYXNzPVwiYWctaGVhZGVyLWljb24gYWctc29ydC1ub25lLWljb25cIj48L3NwYW4+JyArXG4gICAgICAgICcgICAgPHNwYW4gaWQ9XCJhZ0ZpbHRlclwiIGNsYXNzPVwiYWctaGVhZGVyLWljb24gYWctZmlsdGVyLWljb25cIj48L3NwYW4+JyArXG4gICAgICAgICcgICAgPHNwYW4gaWQ9XCJhZ1RleHRcIiBjbGFzcz1cImFnLWhlYWRlci1jZWxsLXRleHRcIj48L3NwYW4+JyArXG4gICAgICAgICcgIDwvZGl2PicgK1xuICAgICAgICAnPC9kaXY+JztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgSGVhZGVyVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIEhlYWRlclRlbXBsYXRlTG9hZGVyID0gSGVhZGVyVGVtcGxhdGVMb2FkZXJfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignaGVhZGVyVGVtcGxhdGVMb2FkZXInKVxuICAgIF0sIEhlYWRlclRlbXBsYXRlTG9hZGVyKTtcbiAgICByZXR1cm4gSGVhZGVyVGVtcGxhdGVMb2FkZXI7XG4gICAgdmFyIEhlYWRlclRlbXBsYXRlTG9hZGVyXzE7XG59KCkpO1xuZXhwb3J0cy5IZWFkZXJUZW1wbGF0ZUxvYWRlciA9IEhlYWRlclRlbXBsYXRlTG9hZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2RlcHJlY2F0ZWQvaGVhZGVyVGVtcGxhdGVMb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4uLy4uL2VudGl0aWVzL2NvbHVtblwiKTtcbnZhciBmaWx0ZXJNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vZmlsdGVyL2ZpbHRlck1hbmFnZXJcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBoZWFkZXJUZW1wbGF0ZUxvYWRlcl8xID0gcmVxdWlyZShcIi4vaGVhZGVyVGVtcGxhdGVMb2FkZXJcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGhvcml6b250YWxEcmFnU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2hvcml6b250YWxEcmFnU2VydmljZVwiKTtcbnZhciBncmlkQ29yZV8xID0gcmVxdWlyZShcIi4uLy4uL2dyaWRDb3JlXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY3NzQ2xhc3NBcHBsaWVyXzEgPSByZXF1aXJlKFwiLi4vY3NzQ2xhc3NBcHBsaWVyXCIpO1xudmFyIGRyYWdBbmREcm9wU2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2RyYWdBbmREcm9wL2RyYWdBbmREcm9wU2VydmljZVwiKTtcbnZhciBzb3J0Q29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL3NvcnRDb250cm9sbGVyXCIpO1xudmFyIHNldExlZnRGZWF0dXJlXzEgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyaW5nL2ZlYXR1cmVzL3NldExlZnRGZWF0dXJlXCIpO1xudmFyIHRvdWNoTGlzdGVuZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi93aWRnZXRzL3RvdWNoTGlzdGVuZXJcIik7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgYmVhbnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJpbmcvYmVhbnNcIik7XG52YXIgUmVuZGVyZWRIZWFkZXJDZWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVuZGVyZWRIZWFkZXJDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVkSGVhZGVyQ2VsbChjb2x1bW4sIGVSb290LCBkcmFnU291cmNlRHJvcFRhcmdldCwgcGlubmVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgX3RoaXMuZVJvb3QgPSBlUm9vdDtcbiAgICAgICAgX3RoaXMuZHJhZ1NvdXJjZURyb3BUYXJnZXQgPSBkcmFnU291cmNlRHJvcFRhcmdldDtcbiAgICAgICAgX3RoaXMucGlubmVkID0gcGlubmVkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUuZ2V0Q29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW47XG4gICAgfTtcbiAgICBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlR3VpID0gdGhpcy5oZWFkZXJUZW1wbGF0ZUxvYWRlci5jcmVhdGVIZWFkZXJFbGVtZW50KHRoaXMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5zZXRHdWkoZUd1aSk7XG4gICAgICAgIHRoaXMuY3JlYXRlU2NvcGUoKTtcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGNzc0NsYXNzQXBwbGllcl8xLkNzc0NsYXNzQXBwbGllci5hZGRIZWFkZXJDbGFzc2VzRnJvbUNvbERlZih0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKSwgZUd1aSwgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIHRoaXMuY29sdW1uLCBudWxsKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRDc3NDbGFzcyhlR3VpLCAnYWctaGVhZGVyLWNlbGwnKTtcbiAgICAgICAgLy8gbGFiZWwgZGl2XG4gICAgICAgIHZhciBlSGVhZGVyQ2VsbExhYmVsID0gZUd1aS5xdWVyeVNlbGVjdG9yKCcjYWdIZWFkZXJDZWxsTGFiZWwnKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXREaXNwbGF5TmFtZUZvckNvbHVtbih0aGlzLmNvbHVtbiwgJ2hlYWRlcicsIHRydWUpO1xuICAgICAgICB0aGlzLnNldHVwTW92aW5nQ3NzKCk7XG4gICAgICAgIHRoaXMuc2V0dXBUb29sdGlwKCk7XG4gICAgICAgIHRoaXMuc2V0dXBSZXNpemUoKTtcbiAgICAgICAgdGhpcy5zZXR1cFRhcCgpO1xuICAgICAgICB0aGlzLnNldHVwTW92ZShlSGVhZGVyQ2VsbExhYmVsKTtcbiAgICAgICAgdGhpcy5zZXR1cE1lbnUoKTtcbiAgICAgICAgdGhpcy5zZXR1cFNvcnQoZUhlYWRlckNlbGxMYWJlbCk7XG4gICAgICAgIHRoaXMuc2V0dXBGaWx0ZXJJY29uKCk7XG4gICAgICAgIHRoaXMuc2V0dXBUZXh0KCk7XG4gICAgICAgIHRoaXMuc2V0dXBXaWR0aCgpO1xuICAgICAgICB2YXIgc2V0TGVmdEZlYXR1cmUgPSBuZXcgc2V0TGVmdEZlYXR1cmVfMS5TZXRMZWZ0RmVhdHVyZSh0aGlzLmNvbHVtbiwgZUd1aSwgdGhpcy5iZWFucyk7XG4gICAgICAgIHNldExlZnRGZWF0dXJlLmluaXQoKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95RnVuYyhzZXRMZWZ0RmVhdHVyZS5kZXN0cm95LmJpbmQoc2V0TGVmdEZlYXR1cmUpKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUuc2V0dXBUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sRGVmID0gdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCk7XG4gICAgICAgIC8vIGFkZCB0b29sdGlwIGlmIGV4aXN0c1xuICAgICAgICBpZiAoY29sRGVmLmhlYWRlclRvb2x0aXApIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0R3VpKCkudGl0bGUgPSBjb2xEZWYuaGVhZGVyVG9vbHRpcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZS5zZXR1cFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2xEZWYgPSB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKTtcbiAgICAgICAgLy8gcmVuZGVyIHRoZSBjZWxsLCB1c2UgYSByZW5kZXJlciBpZiBvbmUgaXMgcHJvdmlkZWRcbiAgICAgICAgdmFyIGhlYWRlckNlbGxSZW5kZXJlcjtcbiAgICAgICAgaWYgKGNvbERlZi5oZWFkZXJDZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGhlYWRlckNlbGxSZW5kZXJlciA9IGNvbERlZi5oZWFkZXJDZWxsUmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0SGVhZGVyQ2VsbFJlbmRlcmVyKCkpIHtcbiAgICAgICAgICAgIGhlYWRlckNlbGxSZW5kZXJlciA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEhlYWRlckNlbGxSZW5kZXJlcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlVGV4dCA9IHRoaXMucXVlcnlGb3JIdG1sRWxlbWVudCgnI2FnVGV4dCcpO1xuICAgICAgICBpZiAoZVRleHQpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJDZWxsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZVJlbmRlcmVyKHRoaXMuZGlzcGxheU5hbWUsIGhlYWRlckNlbGxSZW5kZXJlciwgZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gcmVuZGVyZXIsIGRlZmF1bHQgdGV4dCByZW5kZXJcbiAgICAgICAgICAgICAgICBlVGV4dC5pbm5lckhUTUwgPSB0aGlzLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgIC8vIGkgZG9uJ3QgcmVtZW1iZXIgd2h5IHRoaXMgaXMgaGVyZSwgdGFrZSBpdCBvdXQ/Pz9cbiAgICAgICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZENzc0NsYXNzKGVUZXh0LCAnYWctaGVhZGVyLWNlbGwtdGV4dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLnNldHVwRmlsdGVySWNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lRmlsdGVySWNvbiA9IHRoaXMucXVlcnlGb3JIdG1sRWxlbWVudCgnI2FnRmlsdGVyJyk7XG4gICAgICAgIGlmICghdGhpcy5lRmlsdGVySWNvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuY29sdW1uLCBjb2x1bW5fMS5Db2x1bW4uRVZFTlRfRklMVEVSX0NIQU5HRUQsIHRoaXMub25GaWx0ZXJDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uRmlsdGVyQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZS5vbkZpbHRlckNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWx0ZXJQcmVzZW50ID0gdGhpcy5jb2x1bW4uaXNGaWx0ZXJBY3RpdmUoKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZ2V0R3VpKCksICdhZy1oZWFkZXItY2VsbC1maWx0ZXJlZCcsIGZpbHRlclByZXNlbnQpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5lRmlsdGVySWNvbiwgJ2FnLWhpZGRlbicsICFmaWx0ZXJQcmVzZW50KTtcbiAgICB9O1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUuc2V0dXBXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5jb2x1bW4sIGNvbHVtbl8xLkNvbHVtbi5FVkVOVF9XSURUSF9DSEFOR0VELCB0aGlzLm9uQ29sdW1uV2lkdGhDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uQ29sdW1uV2lkdGhDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLm9uQ29sdW1uV2lkdGhDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldEd1aSgpLnN0eWxlLndpZHRoID0gdGhpcy5jb2x1bW4uZ2V0QWN0dWFsV2lkdGgoKSArICdweCc7XG4gICAgfTtcbiAgICBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLmNyZWF0ZVNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNBbmd1bGFyQ29tcGlsZUhlYWRlcnMoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFNjb3BlID0gdGhpcy4kc2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZFNjb3BlLmNvbERlZiA9IHRoaXMuY29sdW1uLmdldENvbERlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZFNjb3BlLmNvbERlZldyYXBwZXIgPSB0aGlzLmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRTY29wZS5jb250ZXh0ID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95RnVuYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hpbGRTY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUuYWRkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRHdWkoKS5zZXRBdHRyaWJ1dGUoXCJjb2xJZFwiLCB0aGlzLmNvbHVtbi5nZXRDb2xJZCgpKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUuc2V0dXBNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZU1lbnUgPSB0aGlzLnF1ZXJ5Rm9ySHRtbEVsZW1lbnQoJyNhZ01lbnUnKTtcbiAgICAgICAgLy8gaWYgbm8gbWVudSBwcm92aWRlZCBpbiB0ZW1wbGF0ZSwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoIWVNZW51KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNraXBNZW51ID0gIXRoaXMubWVudUZhY3RvcnkuaXNNZW51RW5hYmxlZCh0aGlzLmNvbHVtbikgfHwgdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCkuc3VwcHJlc3NNZW51O1xuICAgICAgICBpZiAoc2tpcE1lbnUpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbVBhcmVudChlTWVudSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZU1lbnUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zaG93TWVudShlTWVudSk7IH0pO1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NNZW51SGlkZSgpKSB7XG4gICAgICAgICAgICBlTWVudS5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAgICAgdGhpcy5hZGRHdWlFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZU1lbnUuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRHdWlFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlTWVudS5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlID0gZU1lbnUuc3R5bGU7XG4gICAgICAgIHN0eWxlWyd0cmFuc2l0aW9uJ10gPSAnb3BhY2l0eSAwLjJzLCBib3JkZXIgMC4ycyc7XG4gICAgICAgIHN0eWxlWyctd2Via2l0LXRyYW5zaXRpb24nXSA9ICdvcGFjaXR5IDAuMnMsIGJvcmRlciAwLjJzJztcbiAgICB9O1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUuc2hvd01lbnUgPSBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5tZW51RmFjdG9yeS5zaG93TWVudUFmdGVyQnV0dG9uQ2xpY2sodGhpcy5jb2x1bW4sIGV2ZW50U291cmNlKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUuc2V0dXBNb3ZpbmdDc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuY29sdW1uLCBjb2x1bW5fMS5Db2x1bW4uRVZFTlRfTU9WSU5HX0NIQU5HRUQsIHRoaXMub25Db2x1bW5Nb3ZpbmdDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uQ29sdW1uTW92aW5nQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZS5vbkNvbHVtbk1vdmluZ0NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gYWRkcyBvciByZW1vdmVzIHRoZSBtb3ZpbmcgY3NzLCBiYXNlZCBvbiBpZiB0aGUgY29sIGlzIG1vdmluZy5cbiAgICAgICAgLy8gdGhpcyBpcyB3aGF0IG1ha2VzIHRoZSBoZWFkZXIgZ28gZGFyayB3aGVuIGl0IGlzIGJlZW4gbW92ZWQgKGdpdmVzIGltcHJlc3Npb24gdG9cbiAgICAgICAgLy8gdXNlciB0aGF0IHRoZSBjb2x1bW4gd2FzIHBpY2tlZCB1cCkuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5pc01vdmluZygpKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZENzc0NsYXNzKHRoaXMuZ2V0R3VpKCksICdhZy1oZWFkZXItY2VsbC1tb3ZpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlQ3NzQ2xhc3ModGhpcy5nZXRHdWkoKSwgJ2FnLWhlYWRlci1jZWxsLW1vdmluZycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLnNldHVwTW92ZSA9IGZ1bmN0aW9uIChlSGVhZGVyQ2VsbExhYmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdXBwcmVzc01vdmUgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzTW92YWJsZUNvbHVtbnMoKVxuICAgICAgICAgICAgfHwgdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCkuc3VwcHJlc3NNb3ZhYmxlXG4gICAgICAgICAgICB8fCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0ZvclByaW50KCk7XG4gICAgICAgIGlmIChzdXBwcmVzc01vdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZUhlYWRlckNlbGxMYWJlbCkge1xuICAgICAgICAgICAgdmFyIGRyYWdTb3VyY2VfMSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBkcmFnQW5kRHJvcFNlcnZpY2VfMS5EcmFnU291cmNlVHlwZS5IZWFkZXJDZWxsLFxuICAgICAgICAgICAgICAgIGVFbGVtZW50OiBlSGVhZGVyQ2VsbExhYmVsLFxuICAgICAgICAgICAgICAgIGRyYWdJdGVtQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZURyYWdJdGVtKCk7IH0sXG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1OYW1lOiB0aGlzLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgIGRyYWdTb3VyY2VEcm9wVGFyZ2V0OiB0aGlzLmRyYWdTb3VyY2VEcm9wVGFyZ2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kcmFnQW5kRHJvcFNlcnZpY2UuYWRkRHJhZ1NvdXJjZShkcmFnU291cmNlXzEsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95RnVuYyhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kcmFnQW5kRHJvcFNlcnZpY2UucmVtb3ZlRHJhZ1NvdXJjZShkcmFnU291cmNlXzEpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZS5jcmVhdGVEcmFnSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZpc2libGVTdGF0ZSA9IHt9O1xuICAgICAgICB2aXNpYmxlU3RhdGVbdGhpcy5jb2x1bW4uZ2V0SWQoKV0gPSB0aGlzLmNvbHVtbi5pc1Zpc2libGUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbnM6IFt0aGlzLmNvbHVtbl0sXG4gICAgICAgICAgICB2aXNpYmxlU3RhdGU6IHZpc2libGVTdGF0ZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZS5zZXR1cFRhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NUb3VjaCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdWNoTGlzdGVuZXIgPSBuZXcgdG91Y2hMaXN0ZW5lcl8xLlRvdWNoTGlzdGVuZXIodGhpcy5nZXRHdWkoKSk7XG4gICAgICAgIHZhciB0YXBMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuc29ydENvbnRyb2xsZXIucHJvZ3Jlc3NTb3J0KF90aGlzLmNvbHVtbiwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbG9uZ1RhcExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCkuc2hvd0NvbHVtbk1lbnVBZnRlck1vdXNlQ2xpY2soX3RoaXMuY29sdW1uLCBldmVudC50b3VjaFN0YXJ0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodG91Y2hMaXN0ZW5lciwgdG91Y2hMaXN0ZW5lcl8xLlRvdWNoTGlzdGVuZXIuRVZFTlRfVEFQLCB0YXBMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRvdWNoTGlzdGVuZXIsIHRvdWNoTGlzdGVuZXJfMS5Ub3VjaExpc3RlbmVyLkVWRU5UX0xPTkdfVEFQLCBsb25nVGFwTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lGdW5jKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvdWNoTGlzdGVuZXIuZGVzdHJveSgpOyB9KTtcbiAgICB9O1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUuc2V0dXBSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xEZWYgPSB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKTtcbiAgICAgICAgdmFyIGVSZXNpemUgPSB0aGlzLnF1ZXJ5Rm9ySHRtbEVsZW1lbnQoJyNhZ1Jlc2l6ZUJhcicpO1xuICAgICAgICAvLyBpZiBubyBlUmVzaXplIGluIHRlbXBsYXRlLCBkbyBub3RoaW5nXG4gICAgICAgIGlmICghZVJlc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZVdhbnRSZXNpemUgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZUNvbFJlc2l6ZSgpICYmICFjb2xEZWYuc3VwcHJlc3NSZXNpemU7XG4gICAgICAgIGlmICghd2VXYW50UmVzaXplKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUZyb21QYXJlbnQoZVJlc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3Jpem9udGFsRHJhZ1NlcnZpY2UuYWRkRHJhZ0hhbmRsaW5nKHtcbiAgICAgICAgICAgIGVEcmFnZ2FibGVFbGVtZW50OiBlUmVzaXplLFxuICAgICAgICAgICAgZUJvZHk6IHRoaXMuZVJvb3QsXG4gICAgICAgICAgICBjdXJzb3I6ICdjb2wtcmVzaXplJyxcbiAgICAgICAgICAgIHN0YXJ0QWZ0ZXJQaXhlbHM6IDAsXG4gICAgICAgICAgICBvbkRyYWdTdGFydDogdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb25EcmFnZ2luZzogdGhpcy5vbkRyYWdnaW5nLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB3ZVdhbnRBdXRvU2l6ZSA9ICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzQXV0b1NpemUoKSAmJiAhY29sRGVmLnN1cHByZXNzQXV0b1NpemU7XG4gICAgICAgIGlmICh3ZVdhbnRBdXRvU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoZVJlc2l6ZSwgJ2RibGNsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbHVtbkNvbnRyb2xsZXIuYXV0b1NpemVDb2x1bW4oX3RoaXMuY29sdW1uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLnVzZVJlbmRlcmVyID0gZnVuY3Rpb24gKGhlYWRlck5hbWVWYWx1ZSwgaGVhZGVyQ2VsbFJlbmRlcmVyLCBlVGV4dCkge1xuICAgICAgICAvLyByZW5kZXJlciBwcm92aWRlZCwgdXNlIGl0XG4gICAgICAgIHZhciBjZWxsUmVuZGVyZXJQYXJhbXMgPSB7XG4gICAgICAgICAgICBjb2xEZWY6IHRoaXMuY29sdW1uLmdldENvbERlZigpLFxuICAgICAgICAgICAgJHNjb3BlOiB0aGlzLmNoaWxkU2NvcGUsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICB2YWx1ZTogaGVhZGVyTmFtZVZhbHVlLFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBcGkoKSxcbiAgICAgICAgICAgIGVIZWFkZXJDZWxsOiB0aGlzLmdldEd1aSgpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjZWxsUmVuZGVyZXJSZXN1bHQgPSBoZWFkZXJDZWxsUmVuZGVyZXIoY2VsbFJlbmRlcmVyUGFyYW1zKTtcbiAgICAgICAgdmFyIGNoaWxkVG9BcHBlbmQ7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmlzTm9kZU9yRWxlbWVudChjZWxsUmVuZGVyZXJSZXN1bHQpKSB7XG4gICAgICAgICAgICAvLyBhIGRvbSBub2RlIG9yIGVsZW1lbnQgd2FzIHJldHVybmVkLCBzbyBhZGQgY2hpbGRcbiAgICAgICAgICAgIGNoaWxkVG9BcHBlbmQgPSBjZWxsUmVuZGVyZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYXNzdW1lIGl0IHdhcyBodG1sLCBzbyBqdXN0IGluc2VydFxuICAgICAgICAgICAgdmFyIGVUZXh0U3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZVRleHRTcGFuLmlubmVySFRNTCA9IGNlbGxSZW5kZXJlclJlc3VsdDtcbiAgICAgICAgICAgIGNoaWxkVG9BcHBlbmQgPSBlVGV4dFNwYW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5ndWxhciBjb21waWxlIGhlYWRlciBpZiBvcHRpb24gaXMgdHVybmVkIG9uXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0FuZ3VsYXJDb21waWxlSGVhZGVycygpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRUb0FwcGVuZENvbXBpbGVkID0gdGhpcy4kY29tcGlsZShjaGlsZFRvQXBwZW5kKSh0aGlzLmNoaWxkU2NvcGUpWzBdO1xuICAgICAgICAgICAgZVRleHQuYXBwZW5kQ2hpbGQoY2hpbGRUb0FwcGVuZENvbXBpbGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVUZXh0LmFwcGVuZENoaWxkKGNoaWxkVG9BcHBlbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLnNldHVwU29ydCA9IGZ1bmN0aW9uIChlSGVhZGVyQ2VsbExhYmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbmFibGVTb3J0aW5nID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVTb3J0aW5nKCkgJiYgIXRoaXMuY29sdW1uLmdldENvbERlZigpLnN1cHByZXNzU29ydGluZztcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEd1aSgpO1xuICAgICAgICBpZiAoIWVuYWJsZVNvcnRpbmcpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbVBhcmVudChlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhZ1NvcnRBc2MnKSk7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUZyb21QYXJlbnQoZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjYWdTb3J0RGVzYycpKTtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbVBhcmVudChlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhZ05vU29ydCcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgc29ydGFibGUgY2xhc3MgZm9yIHN0eWxpbmdcbiAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRDc3NDbGFzcyhlbGVtZW50LCAnYWctaGVhZGVyLWNlbGwtc29ydGFibGUnKTtcbiAgICAgICAgLy8gYWRkIHRoZSBldmVudCBvbiB0aGUgaGVhZGVyLCBzbyB3aGVuIGNsaWNrZWQsIHdlIGRvIHNvcnRpbmdcbiAgICAgICAgaWYgKGVIZWFkZXJDZWxsTGFiZWwpIHtcbiAgICAgICAgICAgIGVIZWFkZXJDZWxsTGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNvcnRDb250cm9sbGVyLnByb2dyZXNzU29ydChfdGhpcy5jb2x1bW4sIGV2ZW50LnNoaWZ0S2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBsaXN0ZW5lciBmb3Igc29ydCBjaGFuZ2luZywgYW5kIHVwZGF0ZSB0aGUgaWNvbnMgYWNjb3JkaW5nbHlcbiAgICAgICAgdGhpcy5lU29ydEFzYyA9IHRoaXMucXVlcnlGb3JIdG1sRWxlbWVudCgnI2FnU29ydEFzYycpO1xuICAgICAgICB0aGlzLmVTb3J0RGVzYyA9IHRoaXMucXVlcnlGb3JIdG1sRWxlbWVudCgnI2FnU29ydERlc2MnKTtcbiAgICAgICAgdGhpcy5lU29ydE5vbmUgPSB0aGlzLnF1ZXJ5Rm9ySHRtbEVsZW1lbnQoJyNhZ05vU29ydCcpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmNvbHVtbiwgY29sdW1uXzEuQ29sdW1uLkVWRU5UX1NPUlRfQ0hBTkdFRCwgdGhpcy5vblNvcnRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uU29ydENoYW5nZWQoKTtcbiAgICB9O1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUub25Tb3J0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZ2V0R3VpKCksICdhZy1oZWFkZXItY2VsbC1zb3J0ZWQtYXNjJywgdGhpcy5jb2x1bW4uaXNTb3J0QXNjZW5kaW5nKCkpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5nZXRHdWkoKSwgJ2FnLWhlYWRlci1jZWxsLXNvcnRlZC1kZXNjJywgdGhpcy5jb2x1bW4uaXNTb3J0RGVzY2VuZGluZygpKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZ2V0R3VpKCksICdhZy1oZWFkZXItY2VsbC1zb3J0ZWQtbm9uZScsIHRoaXMuY29sdW1uLmlzU29ydE5vbmUoKSk7XG4gICAgICAgIGlmICh0aGlzLmVTb3J0QXNjKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5lU29ydEFzYywgJ2FnLWhpZGRlbicsICF0aGlzLmNvbHVtbi5pc1NvcnRBc2NlbmRpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZVNvcnREZXNjKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5lU29ydERlc2MsICdhZy1oaWRkZW4nLCAhdGhpcy5jb2x1bW4uaXNTb3J0RGVzY2VuZGluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lU29ydE5vbmUpIHtcbiAgICAgICAgICAgIHZhciBhbHdheXNIaWRlTm9Tb3J0ID0gIXRoaXMuY29sdW1uLmdldENvbERlZigpLnVuU29ydEljb24gJiYgIXRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzVW5Tb3J0SWNvbigpO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZVNvcnROb25lLCAnYWctaGlkZGVuJywgYWx3YXlzSGlkZU5vU29ydCB8fCAhdGhpcy5jb2x1bW4uaXNTb3J0Tm9uZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGFydFdpZHRoID0gdGhpcy5jb2x1bW4uZ2V0QWN0dWFsV2lkdGgoKTtcbiAgICB9O1xuICAgIC8vIG9wdGlvbmFsbHkgaW52ZXJ0cyB0aGUgZHJhZywgZGVwZW5kaW5nIG9uIHBpbm5lZCBhbmQgUlRMXG4gICAgLy8gbm90ZSAtIHRoaXMgbWV0aG9kIGlzIGR1cGxpY2F0ZWQgaW4gUmVuZGVyZWRIZWFkZXJHcm91cENlbGwgLSBzaG91bGQgcmVmYWN0b3Igb3V0P1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUubm9ybWFsaXNlRHJhZ0NoYW5nZSA9IGZ1bmN0aW9uIChkcmFnQ2hhbmdlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkcmFnQ2hhbmdlO1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVSdGwoKSkge1xuICAgICAgICAgICAgLy8gZm9yIFJUTCwgZHJhZ2dpbmcgbGVmdCBtYWtlcyB0aGUgY29sIGJpZ2dlciwgZXhjZXB0IHdoZW4gcGlubmluZyBsZWZ0XG4gICAgICAgICAgICBpZiAodGhpcy5waW5uZWQgIT09IGNvbHVtbl8xLkNvbHVtbi5QSU5ORURfTEVGVCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvciBMVFIgKGllIG5vcm1hbCksIGRyYWdnaW5nIGxlZnQgbWFrZXMgdGhlIGNvbCBzbWFsbGVyLCBleGNlcHQgd2hlbiBwaW5uaW5nIHJpZ2h0XG4gICAgICAgICAgICBpZiAodGhpcy5waW5uZWQgPT09IGNvbHVtbl8xLkNvbHVtbi5QSU5ORURfUklHSFQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUub25EcmFnZ2luZyA9IGZ1bmN0aW9uIChkcmFnQ2hhbmdlLCBmaW5pc2hlZCkge1xuICAgICAgICB2YXIgZHJhZ0NoYW5nZU5vcm1hbGlzZWQgPSB0aGlzLm5vcm1hbGlzZURyYWdDaGFuZ2UoZHJhZ0NoYW5nZSk7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IHRoaXMuc3RhcnRXaWR0aCArIGRyYWdDaGFuZ2VOb3JtYWxpc2VkO1xuICAgICAgICB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuc2V0Q29sdW1uV2lkdGgodGhpcy5jb2x1bW4sIG5ld1dpZHRoLCBmaW5pc2hlZCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29udGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29udGV4dF8xLkNvbnRleHQpXG4gICAgXSwgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZpbHRlck1hbmFnZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGZpbHRlck1hbmFnZXJfMS5GaWx0ZXJNYW5hZ2VyKVxuICAgIF0sIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUsIFwiZmlsdGVyTWFuYWdlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5Db250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQ29udHJvbGxlcilcbiAgICBdLCBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnJGNvbXBpbGUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLCBcIiRjb21waWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRDb3JlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQ29yZV8xLkdyaWRDb3JlKVxuICAgIF0sIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUsIFwiZ3JpZENvcmVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnaGVhZGVyVGVtcGxhdGVMb2FkZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGhlYWRlclRlbXBsYXRlTG9hZGVyXzEuSGVhZGVyVGVtcGxhdGVMb2FkZXIpXG4gICAgXSwgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZSwgXCJoZWFkZXJUZW1wbGF0ZUxvYWRlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdob3Jpem9udGFsRHJhZ1NlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGhvcml6b250YWxEcmFnU2VydmljZV8xLkhvcml6b250YWxEcmFnU2VydmljZSlcbiAgICBdLCBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLCBcImhvcml6b250YWxEcmFnU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdtZW51RmFjdG9yeScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUsIFwibWVudUZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZHJhZ0FuZERyb3BTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBkcmFnQW5kRHJvcFNlcnZpY2VfMS5EcmFnQW5kRHJvcFNlcnZpY2UpXG4gICAgXSwgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZSwgXCJkcmFnQW5kRHJvcFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnc29ydENvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNvcnRDb250cm9sbGVyXzEuU29ydENvbnRyb2xsZXIpXG4gICAgXSwgUmVuZGVyZWRIZWFkZXJDZWxsLnByb3RvdHlwZSwgXCJzb3J0Q29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCckc2NvcGUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLCBcIiRzY29wZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdiZWFucycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgYmVhbnNfMS5CZWFucylcbiAgICBdLCBSZW5kZXJlZEhlYWRlckNlbGwucHJvdG90eXBlLCBcImJlYW5zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIFJlbmRlcmVkSGVhZGVyQ2VsbC5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICByZXR1cm4gUmVuZGVyZWRIZWFkZXJDZWxsO1xufShjb21wb25lbnRfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuUmVuZGVyZWRIZWFkZXJDZWxsID0gUmVuZGVyZWRIZWFkZXJDZWxsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2RlcHJlY2F0ZWQvcmVuZGVyZWRIZWFkZXJDZWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBCb3JkZXJMYXlvdXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvcmRlckxheW91dChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jZW50ZXJIZWlnaHRMYXN0VGltZSA9IC0xO1xuICAgICAgICB0aGlzLmNlbnRlcldpZHRoTGFzdFRpbWUgPSAtMTtcbiAgICAgICAgdGhpcy5jZW50ZXJMZWZ0TWFyZ2luTGFzdFRpbWUgPSAtMTtcbiAgICAgICAgdGhpcy52aXNpYmxlTGFzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXplQ2hhbmdlTGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuaXNMYXlvdXRQYW5lbCA9IHRydWU7XG4gICAgICAgIHRoaXMuZnVsbEhlaWdodCA9ICFwYXJhbXMubm9ydGggJiYgIXBhcmFtcy5zb3V0aDtcbiAgICAgICAgdmFyIHRlbXBsYXRlO1xuICAgICAgICBpZiAocGFyYW1zLmRvbnRGaWxsKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IEJvcmRlckxheW91dC5URU1QTEFURV9ET05UX0ZJTEw7XG4gICAgICAgICAgICB0aGlzLmhvcml6b250YWxMYXlvdXRBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudmVydGljYWxMYXlvdXRBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMuZmlsbEhvcml6b250YWxPbmx5KSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IEJvcmRlckxheW91dC5URU1QTEFURV9ET05UX0ZJTEw7XG4gICAgICAgICAgICB0aGlzLmhvcml6b250YWxMYXlvdXRBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbExheW91dEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnVsbEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gQm9yZGVyTGF5b3V0LlRFTVBMQVRFX0ZVTExfSEVJR0hUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBCb3JkZXJMYXlvdXQuVEVNUExBVEVfTk9STUFMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3Jpem9udGFsTGF5b3V0QWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmVydGljYWxMYXlvdXRBY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZUd1aSA9IHV0aWxzXzEuVXRpbHMubG9hZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgdGhpcy5pZCA9ICdib3JkZXJMYXlvdXQnO1xuICAgICAgICBpZiAocGFyYW1zLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgKz0gJ18nICsgcGFyYW1zLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lR3VpLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5jaGlsZFBhbmVscyA9IFtdO1xuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwUGFuZWxzKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGF5cyA9IHBhcmFtcy5vdmVybGF5cztcbiAgICAgICAgdGhpcy5zZXR1cE92ZXJsYXlzKCk7XG4gICAgfVxuICAgIEJvcmRlckxheW91dC5wcm90b3R5cGUuYWRkU2l6ZUNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc2l6ZUNoYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIEJvcmRlckxheW91dC5wcm90b3R5cGUuZmlyZVNpemVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNpemVDaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gdGhpcyBsb2dpYyBpcyBhbHNvIGluIENvbXBvbmVudC50cyAtIHRoZSBwbGFuIGlzIHNvbWV0aW1lIGluIHRoZSBmdXR1cmUsXG4gICAgLy8gdGhpcyBsYXlvdXQgcGFuZWwgbWF5IChvciBtYXkgbm90KSBleHRlbmQgdGhlIENvbXBvbmVudCBjbGFzcywgYW5kIHNvbWVob3dcbiAgICAvLyBhY3QgYXMgYSBjb21wb25lbnQuXG4gICAgQm9yZGVyTGF5b3V0LnByb3RvdHlwZS5nZXRSZWZFbGVtZW50ID0gZnVuY3Rpb24gKHJlZk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZUd1aS5xdWVyeVNlbGVjdG9yKCdbcmVmPVwiJyArIHJlZk5hbWUgKyAnXCJdJyk7XG4gICAgfTtcbiAgICBCb3JkZXJMYXlvdXQucHJvdG90eXBlLnNldHVwUGFuZWxzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLmVOb3J0aFdyYXBwZXIgPSB0aGlzLmdldFJlZkVsZW1lbnQoJ25vcnRoJyk7XG4gICAgICAgIHRoaXMuZVNvdXRoV3JhcHBlciA9IHRoaXMuZ2V0UmVmRWxlbWVudCgnc291dGgnKTtcbiAgICAgICAgdGhpcy5lRWFzdFdyYXBwZXIgPSB0aGlzLmdldFJlZkVsZW1lbnQoJ2Vhc3QnKTtcbiAgICAgICAgdGhpcy5lV2VzdFdyYXBwZXIgPSB0aGlzLmdldFJlZkVsZW1lbnQoJ3dlc3QnKTtcbiAgICAgICAgdGhpcy5lQ2VudGVyV3JhcHBlciA9IHRoaXMuZ2V0UmVmRWxlbWVudCgnY2VudGVyJyk7XG4gICAgICAgIHRoaXMuZU92ZXJsYXlXcmFwcGVyID0gdGhpcy5nZXRSZWZFbGVtZW50KCdvdmVybGF5Jyk7XG4gICAgICAgIHRoaXMuZUNlbnRlclJvdyA9IHRoaXMuZ2V0UmVmRWxlbWVudCgnY2VudGVyUm93Jyk7XG4gICAgICAgIHRoaXMuZU5vcnRoQ2hpbGRMYXlvdXQgPSB0aGlzLnNldHVwUGFuZWwocGFyYW1zLm5vcnRoLCB0aGlzLmVOb3J0aFdyYXBwZXIpO1xuICAgICAgICB0aGlzLmVTb3V0aENoaWxkTGF5b3V0ID0gdGhpcy5zZXR1cFBhbmVsKHBhcmFtcy5zb3V0aCwgdGhpcy5lU291dGhXcmFwcGVyKTtcbiAgICAgICAgdGhpcy5lRWFzdENoaWxkTGF5b3V0ID0gdGhpcy5zZXR1cFBhbmVsKHBhcmFtcy5lYXN0LCB0aGlzLmVFYXN0V3JhcHBlcik7XG4gICAgICAgIHRoaXMuZVdlc3RDaGlsZExheW91dCA9IHRoaXMuc2V0dXBQYW5lbChwYXJhbXMud2VzdCwgdGhpcy5lV2VzdFdyYXBwZXIpO1xuICAgICAgICB0aGlzLmVDZW50ZXJDaGlsZExheW91dCA9IHRoaXMuc2V0dXBQYW5lbChwYXJhbXMuY2VudGVyLCB0aGlzLmVDZW50ZXJXcmFwcGVyKTtcbiAgICB9O1xuICAgIEJvcmRlckxheW91dC5wcm90b3R5cGUuc2V0dXBQYW5lbCA9IGZ1bmN0aW9uIChjb250ZW50LCBlUGFuZWwpIHtcbiAgICAgICAgaWYgKCFlUGFuZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQuaXNMYXlvdXRQYW5lbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRQYW5lbHMucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgICAgICBlUGFuZWwuYXBwZW5kQ2hpbGQoY29udGVudC5nZXRHdWkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlUGFuZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlUGFuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlUGFuZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJvcmRlckxheW91dC5wcm90b3R5cGUuZ2V0R3VpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lR3VpO1xuICAgIH07XG4gICAgLy8gcmV0dXJucyB0cnVlIGlmIGFueSBpdGVtIGNoYW5nZWQgc2l6ZSwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2VcbiAgICBCb3JkZXJMYXlvdXQucHJvdG90eXBlLmRvTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaXNWaXNpYmxlID0gdXRpbHNfMS5VdGlscy5pc1Zpc2libGUodGhpcy5lR3VpKTtcbiAgICAgICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUxhc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0TGVhc3RPbmVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGVMYXN0VGltZSAhPT0gaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBhdExlYXN0T25lQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpYmxlTGFzdFRpbWUgPSB0cnVlO1xuICAgICAgICB2YXIgY2hpbGRMYXlvdXRzID0gW3RoaXMuZU5vcnRoQ2hpbGRMYXlvdXQsIHRoaXMuZVNvdXRoQ2hpbGRMYXlvdXQsIHRoaXMuZUVhc3RDaGlsZExheW91dCwgdGhpcy5lV2VzdENoaWxkTGF5b3V0XTtcbiAgICAgICAgY2hpbGRMYXlvdXRzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTGF5b3V0KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDaGFuZ2VkU2l6ZSA9IF90aGlzLmxheW91dENoaWxkKGNoaWxkTGF5b3V0KTtcbiAgICAgICAgICAgIGlmIChjaGlsZENoYW5nZWRTaXplKSB7XG4gICAgICAgICAgICAgICAgYXRMZWFzdE9uZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbExheW91dEFjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIG91cldpZHRoQ2hhbmdlZCA9IHRoaXMubGF5b3V0V2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChvdXJXaWR0aENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmVydGljYWxMYXlvdXRBY3RpdmUpIHtcbiAgICAgICAgICAgIHZhciBvdXJIZWlnaHRDaGFuZ2VkID0gdGhpcy5sYXlvdXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGlmIChvdXJIZWlnaHRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgYXRMZWFzdE9uZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjZW50ZXJDaGFuZ2VkID0gdGhpcy5sYXlvdXRDaGlsZCh0aGlzLmVDZW50ZXJDaGlsZExheW91dCk7XG4gICAgICAgIGlmIChjZW50ZXJDaGFuZ2VkKSB7XG4gICAgICAgICAgICBhdExlYXN0T25lQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0TGVhc3RPbmVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVTaXplQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdExlYXN0T25lQ2hhbmdlZDtcbiAgICB9O1xuICAgIEJvcmRlckxheW91dC5wcm90b3R5cGUubGF5b3V0Q2hpbGQgPSBmdW5jdGlvbiAoY2hpbGRQYW5lbCkge1xuICAgICAgICBpZiAoY2hpbGRQYW5lbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUGFuZWwuZG9MYXlvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQm9yZGVyTGF5b3V0LnByb3RvdHlwZS5sYXlvdXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZ1bGxIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dEhlaWdodEZ1bGxIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dEhlaWdodE5vcm1hbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBmdWxsIGhlaWdodCBuZXZlciBjaGFuZ2VzIHRoZSBoZWlnaHQsIGJlY2F1c2UgdGhlIGNlbnRlciBpcyBhbHdheXMgMTAwJSxcbiAgICAvLyBob3dldmVyIHdlIGRvIGNoZWNrIGZvciBjaGFuZ2UsIHRvIGluZm9ybSB0aGUgbGlzdGVuZXJzXG4gICAgQm9yZGVyTGF5b3V0LnByb3RvdHlwZS5sYXlvdXRIZWlnaHRGdWxsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VudGVySGVpZ2h0ID0gdXRpbHNfMS5VdGlscy5vZmZzZXRIZWlnaHQodGhpcy5lR3VpKTtcbiAgICAgICAgaWYgKGNlbnRlckhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGNlbnRlckhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2VudGVySGVpZ2h0TGFzdFRpbWUgIT09IGNlbnRlckhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJIZWlnaHRMYXN0VGltZSA9IGNlbnRlckhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCb3JkZXJMYXlvdXQucHJvdG90eXBlLmxheW91dEhlaWdodE5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gdXRpbHNfMS5VdGlscy5vZmZzZXRIZWlnaHQodGhpcy5lR3VpKTtcbiAgICAgICAgdmFyIG5vcnRoSGVpZ2h0ID0gdXRpbHNfMS5VdGlscy5vZmZzZXRIZWlnaHQodGhpcy5lTm9ydGhXcmFwcGVyKTtcbiAgICAgICAgdmFyIHNvdXRoSGVpZ2h0ID0gdXRpbHNfMS5VdGlscy5vZmZzZXRIZWlnaHQodGhpcy5lU291dGhXcmFwcGVyKTtcbiAgICAgICAgdmFyIGNlbnRlckhlaWdodCA9IHRvdGFsSGVpZ2h0IC0gbm9ydGhIZWlnaHQgLSBzb3V0aEhlaWdodDtcbiAgICAgICAgaWYgKGNlbnRlckhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGNlbnRlckhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2VudGVySGVpZ2h0TGFzdFRpbWUgIT09IGNlbnRlckhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5lQ2VudGVyUm93LnN0eWxlLmhlaWdodCA9IGNlbnRlckhlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmNlbnRlckhlaWdodExhc3RUaW1lID0gY2VudGVySGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHJldHVybiB0cnVlIGJlY2F1c2UgdGhlcmUgd2FzIGEgY2hhbmdlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJvcmRlckxheW91dC5wcm90b3R5cGUuZ2V0Q2VudHJlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXJIZWlnaHRMYXN0VGltZTtcbiAgICB9O1xuICAgIEJvcmRlckxheW91dC5wcm90b3R5cGUubGF5b3V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b3RhbFdpZHRoID0gdXRpbHNfMS5VdGlscy5vZmZzZXRXaWR0aCh0aGlzLmVHdWkpO1xuICAgICAgICB2YXIgZWFzdFdpZHRoID0gdXRpbHNfMS5VdGlscy5vZmZzZXRXaWR0aCh0aGlzLmVFYXN0V3JhcHBlcik7XG4gICAgICAgIHZhciB3ZXN0V2lkdGggPSB1dGlsc18xLlV0aWxzLm9mZnNldFdpZHRoKHRoaXMuZVdlc3RXcmFwcGVyKTtcbiAgICAgICAgdmFyIGNlbnRlcldpZHRoID0gdG90YWxXaWR0aCAtIGVhc3RXaWR0aCAtIHdlc3RXaWR0aDtcbiAgICAgICAgaWYgKGNlbnRlcldpZHRoIDwgMCkge1xuICAgICAgICAgICAgY2VudGVyV2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdExlYXN0T25lQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jZW50ZXJMZWZ0TWFyZ2luTGFzdFRpbWUgIT09IHdlc3RXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJMZWZ0TWFyZ2luTGFzdFRpbWUgPSB3ZXN0V2lkdGg7XG4gICAgICAgICAgICB0aGlzLmVDZW50ZXJXcmFwcGVyLnN0eWxlLm1hcmdpbkxlZnQgPSB3ZXN0V2lkdGggKyAncHgnO1xuICAgICAgICAgICAgYXRMZWFzdE9uZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNlbnRlcldpZHRoTGFzdFRpbWUgIT09IGNlbnRlcldpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlcldpZHRoTGFzdFRpbWUgPSBjZW50ZXJXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZUNlbnRlcldyYXBwZXIuc3R5bGUud2lkdGggPSBjZW50ZXJXaWR0aCArICdweCc7XG4gICAgICAgICAgICBhdExlYXN0T25lQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0TGVhc3RPbmVDaGFuZ2VkO1xuICAgIH07XG4gICAgQm9yZGVyTGF5b3V0LnByb3RvdHlwZS5zZXRFYXN0VmlzaWJsZSA9IGZ1bmN0aW9uICh2aXNpYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLmVFYXN0V3JhcHBlcikge1xuICAgICAgICAgICAgdGhpcy5lRWFzdFdyYXBwZXIuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvTGF5b3V0KCk7XG4gICAgfTtcbiAgICBCb3JkZXJMYXlvdXQucHJvdG90eXBlLnNldHVwT3ZlcmxheXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIG5vIG92ZXJsYXlzLCBqdXN0IHJlbW92ZSB0aGUgcGFuZWxcbiAgICAgICAgaWYgKCF0aGlzLm92ZXJsYXlzKSB7XG4gICAgICAgICAgICB0aGlzLmVPdmVybGF5V3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZU92ZXJsYXlXcmFwcGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgfTtcbiAgICBCb3JkZXJMYXlvdXQucHJvdG90eXBlLmhpZGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUFsbENoaWxkcmVuKHRoaXMuZU92ZXJsYXlXcmFwcGVyKTtcbiAgICAgICAgdGhpcy5lT3ZlcmxheVdyYXBwZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9O1xuICAgIEJvcmRlckxheW91dC5wcm90b3R5cGUuc2hvd092ZXJsYXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBvdmVybGF5ID0gdGhpcy5vdmVybGF5cyA/IHRoaXMub3ZlcmxheXNba2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUFsbENoaWxkcmVuKHRoaXMuZU92ZXJsYXlXcmFwcGVyKTtcbiAgICAgICAgICAgIHRoaXMuZU92ZXJsYXlXcmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICAgIHRoaXMuZU92ZXJsYXlXcmFwcGVyLmFwcGVuZENoaWxkKG92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FnLUdyaWQ6IHVua25vd24gb3ZlcmxheScpO1xuICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB0aGlzIGlzIHVzZWQgaWYgdGhlcmUgdXNlciBoYXMgbm90IHNwZWNpZmllZCBhbnkgbm9ydGggb3Igc291dGggcGFydHNcbiAgICBCb3JkZXJMYXlvdXQuVEVNUExBVEVfRlVMTF9IRUlHSFQgPSAnPGRpdiBjbGFzcz1cImFnLWJsIGFnLWJsLWZ1bGwtaGVpZ2h0XCI+JyArXG4gICAgICAgICcgIDxkaXYgY2xhc3M9XCJhZy1ibC13ZXN0IGFnLWJsLWZ1bGwtaGVpZ2h0LXdlc3RcIiByZWY9XCJ3ZXN0XCI+PC9kaXY+JyArXG4gICAgICAgICcgIDxkaXYgY2xhc3M9XCJhZy1ibC1lYXN0IGFnLWJsLWZ1bGwtaGVpZ2h0LWVhc3RcIiByZWY9XCJlYXN0XCI+PC9kaXY+JyArXG4gICAgICAgICcgIDxkaXYgY2xhc3M9XCJhZy1ibC1jZW50ZXIgYWctYmwtZnVsbC1oZWlnaHQtY2VudGVyXCIgcmVmPVwiY2VudGVyXCI+PC9kaXY+JyArXG4gICAgICAgICcgIDxkaXYgY2xhc3M9XCJhZy1ibC1vdmVybGF5XCIgcmVmPVwib3ZlcmxheVwiPjwvZGl2PicgK1xuICAgICAgICAnPC9kaXY+JztcbiAgICBCb3JkZXJMYXlvdXQuVEVNUExBVEVfTk9STUFMID0gJzxkaXYgY2xhc3M9XCJhZy1ibCBhZy1ibC1ub3JtYWxcIj4nICtcbiAgICAgICAgJyAgPGRpdiByZWY9XCJub3J0aFwiPjwvZGl2PicgK1xuICAgICAgICAnICA8ZGl2IGNsYXNzPVwiYWctYmwtY2VudGVyLXJvdyBhZy1ibC1ub3JtYWwtY2VudGVyLXJvd1wiIHJlZj1cImNlbnRlclJvd1wiPicgK1xuICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJhZy1ibC13ZXN0IGFnLWJsLW5vcm1hbC13ZXN0XCIgcmVmPVwid2VzdFwiPjwvZGl2PicgK1xuICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJhZy1ibC1lYXN0IGFnLWJsLW5vcm1hbC1lYXN0XCIgcmVmPVwiZWFzdFwiPjwvZGl2PicgK1xuICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJhZy1ibC1jZW50ZXIgYWctYmwtbm9ybWFsLWNlbnRlclwiIHJlZj1cImNlbnRlclwiPjwvZGl2PicgK1xuICAgICAgICAnICA8L2Rpdj4nICtcbiAgICAgICAgJyAgPGRpdiByZWY9XCJzb3V0aFwiPjwvZGl2PicgK1xuICAgICAgICAnICA8ZGl2IGNsYXNzPVwiYWctYmwtb3ZlcmxheVwiIHJlZj1cIm92ZXJsYXlcIj48L2Rpdj4nICtcbiAgICAgICAgJzwvZGl2Pic7XG4gICAgQm9yZGVyTGF5b3V0LlRFTVBMQVRFX0RPTlRfRklMTCA9ICc8ZGl2IGNsYXNzPVwiYWctYmwgYWctYmwtZG9udC1maWxsXCI+JyArXG4gICAgICAgICcgIDxkaXYgcmVmPVwibm9ydGhcIj48L2Rpdj4nICtcbiAgICAgICAgJyAgPGRpdiByZWY9XCJjZW50ZXJSb3dcIiBjbGFzcz1cImFnLWJsLWNlbnRlci1yb3cgYWctYmwtZG9udC1maWxsLWNlbnRlci1yb3dcIj4nICtcbiAgICAgICAgJyAgICA8ZGl2IHJlZj1cIndlc3RcIiBjbGFzcz1cImFnLWJsLXdlc3QgYWctYmwtZG9udC1maWxsLXdlc3RcIj48L2Rpdj4nICtcbiAgICAgICAgJyAgICA8ZGl2IHJlZj1cImVhc3RcIiBjbGFzcz1cImFnLWJsLWVhc3QgYWctYmwtZG9udC1maWxsLWVhc3RcIj48L2Rpdj4nICtcbiAgICAgICAgJyAgICA8ZGl2IHJlZj1cImNlbnRlclwiIGNsYXNzPVwiYWctYmwtY2VudGVyIGFnLWJsLWRvbnQtZmlsbC1jZW50ZXJcIj48L2Rpdj4nICtcbiAgICAgICAgJyAgPC9kaXY+JyArXG4gICAgICAgICcgIDxkaXYgcmVmPVwic291dGhcIj48L2Rpdj4nICtcbiAgICAgICAgJyAgPGRpdiBjbGFzcz1cImFnLWJsLW92ZXJsYXlcIiByZWY9XCJvdmVybGF5XCI+PC9kaXY+JyArXG4gICAgICAgICc8L2Rpdj4nO1xuICAgIHJldHVybiBCb3JkZXJMYXlvdXQ7XG59KCkpO1xuZXhwb3J0cy5Cb3JkZXJMYXlvdXQgPSBCb3JkZXJMYXlvdXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9sYXlvdXQvYm9yZGVyTGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJvd1JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9yb3dSZW5kZXJlclwiKTtcbnZhciBncmlkUGFuZWxfMSA9IHJlcXVpcmUoXCIuLi9ncmlkUGFuZWwvZ3JpZFBhbmVsXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29udGV4dF8yID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBoZWFkZXJSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uL2hlYWRlclJlbmRlcmluZy9oZWFkZXJSZW5kZXJlclwiKTtcbnZhciByZW5kZXJlZEhlYWRlckNlbGxfMSA9IHJlcXVpcmUoXCIuLi9oZWFkZXJSZW5kZXJpbmcvZGVwcmVjYXRlZC9yZW5kZXJlZEhlYWRlckNlbGxcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGhlYWRlcldyYXBwZXJDb21wXzEgPSByZXF1aXJlKFwiLi4vaGVhZGVyUmVuZGVyaW5nL2hlYWRlci9oZWFkZXJXcmFwcGVyQ29tcFwiKTtcbnZhciBBdXRvV2lkdGhDYWxjdWxhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRvV2lkdGhDYWxjdWxhdG9yKCkge1xuICAgIH1cbiAgICAvLyB0aGlzIGlzIHRoZSB0cmljazogd2UgY3JlYXRlIGEgZHVtbXkgY29udGFpbmVyIGFuZCBjbG9uZSBhbGwgdGhlIGNlbGxzXG4gICAgLy8gaW50byB0aGUgZHVtbXksIHRoZW4gY2hlY2sgdGhlIGR1bW15J3Mgd2lkdGguIHRoZW4gZGVzdHJveSB0aGUgZHVtbXlcbiAgICAvLyBhcyB3ZSBkb24ndCBuZWVkIGl0IGFueSBtb3JlLlxuICAgIC8vIGRyYXdiYWNrOiBvbmx5IHRoZSBjZWxscyB2aXNpYmxlIG9uIHRoZSBzY3JlZW4gYXJlIGNvbnNpZGVyZWRcbiAgICBBdXRvV2lkdGhDYWxjdWxhdG9yLnByb3RvdHlwZS5nZXRQcmVmZXJyZWRXaWR0aEZvckNvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIGVIZWFkZXJDZWxsID0gdGhpcy5nZXRIZWFkZXJDZWxsRm9yQ29sdW1uKGNvbHVtbik7XG4gICAgICAgIC8vIGNlbGwgaXNuJ3QgdmlzaWJsZVxuICAgICAgICBpZiAoIWVIZWFkZXJDZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVEdW1teUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgLy8gcG9zaXRpb24gZml4ZWQsIHNvIGl0IGlzbid0IHJlc3RyaWN0ZWQgdG8gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBhcmVudFxuICAgICAgICBlRHVtbXlDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICAvLyB3ZSBwdXQgdGhlIGR1bW15IGludG8gdGhlIGJvZHkgY29udGFpbmVyLCBzbyBpdCB3aWxsIGluaGVyaXQgYWxsIHRoZVxuICAgICAgICAvLyBjc3Mgc3R5bGVzIHRoYXQgdGhlIHJlYWwgY2VsbHMgYXJlIGluaGVyaXRpbmdcbiAgICAgICAgdmFyIGVCb2R5Q29udGFpbmVyID0gdGhpcy5ncmlkUGFuZWwuZ2V0Qm9keUNvbnRhaW5lcigpO1xuICAgICAgICBlQm9keUNvbnRhaW5lci5hcHBlbmRDaGlsZChlRHVtbXlDb250YWluZXIpO1xuICAgICAgICAvLyBnZXQgYWxsIHRoZSBjZWxscyB0aGF0IGFyZSBjdXJyZW50bHkgZGlzcGxheWVkICh0aGlzIG9ubHkgYnJpbmdzIGJhY2tcbiAgICAgICAgLy8gcmVuZGVyZWQgY2VsbHMsIHJvd3Mgbm90IHJlbmRlcmVkIGR1ZSB0byByb3cgdmlzdWFsaXNhdGlvbiB3aWxsIG5vdCBiZSBoZXJlKVxuICAgICAgICB0aGlzLnB1dFJvd0NlbGxzSW50b0R1bW15Q29udGFpbmVyKGNvbHVtbiwgZUR1bW15Q29udGFpbmVyKTtcbiAgICAgICAgLy8gYWxzbyBwdXQgaGVhZGVyIGNlbGwgaW5cbiAgICAgICAgLy8gd2Ugb25seSBjb25zaWRlciB0aGUgbG93ZXN0IGxldmVsIGNlbGwsIG5vdCB0aGUgZ3JvdXAgY2VsbC4gaW4gOTklIG9mIHRoZSB0aW1lLCB0aGlzXG4gICAgICAgIC8vIHdpbGwgYmUgZW5vdWdoLiBpZiB3ZSBjb25zaWRlciBncm91cHMsIHRoZW4gaXQgZ2V0cyB0byBjb21wbGljYXRlZCBmb3Igd2hhdCBpdCdzIHdvcnRoLFxuICAgICAgICAvLyBhcyB0aGUgZ3JvdXBzIGNhbiBzcGFuIGNvbHVtbnMgYW5kIHRoaXMgY2xhc3Mgb25seSBjb25zaWRlcnMgb25lIGNvbHVtbiBhdCBhIHRpbWUuXG4gICAgICAgIHRoaXMuY2xvbmVJdGVtSW50b0R1bW15KGVIZWFkZXJDZWxsLCBlRHVtbXlDb250YWluZXIpO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCBhbGwgdGhlIGNsb25lcyBhcmUgbGluZWQgdXAgdmVydGljYWxseSB3aXRoIG5hdHVyYWwgd2lkdGhzLiB0aGUgZHVtbXlcbiAgICAgICAgLy8gY29udGFpbmVyIHdpbGwgaGF2ZSBhIHdpZHRoIHdpZGUgZW5vdWdoIGp1c3QgdG8gZml0IHRoZSBsYXJnZXN0LlxuICAgICAgICB2YXIgZHVtbXlDb250YWluZXJXaWR0aCA9IGVEdW1teUNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgLy8gd2UgYXJlIGZpbmlzaGVkIHdpdGggdGhlIGR1bW15IGNvbnRhaW5lciwgc28gZ2V0IHJpZCBvZiBpdFxuICAgICAgICBlQm9keUNvbnRhaW5lci5yZW1vdmVDaGlsZChlRHVtbXlDb250YWluZXIpO1xuICAgICAgICAvLyB3ZSBhZGQgcGFkZGluZyBhcyBJIGZvdW5kIHdpdGhvdXQgaXQsIHRoZSBndWkgc3RpbGwgcHV0ICcuLi4nIGFmdGVyIHNvbWUgb2YgdGhlIHRleHRzXG4gICAgICAgIHZhciBhdXRvU2l6ZVBhZGRpbmcgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBdXRvU2l6ZVBhZGRpbmcoKTtcbiAgICAgICAgcmV0dXJuIGR1bW15Q29udGFpbmVyV2lkdGggKyBhdXRvU2l6ZVBhZGRpbmc7XG4gICAgfTtcbiAgICBBdXRvV2lkdGhDYWxjdWxhdG9yLnByb3RvdHlwZS5nZXRIZWFkZXJDZWxsRm9yQ29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgY29tcCA9IG51bGw7XG4gICAgICAgIC8vIGZpbmQgdGhlIHJlbmRlcmVkIGhlYWRlciBjZWxsXG4gICAgICAgIHRoaXMuaGVhZGVyUmVuZGVyZXIuZm9yRWFjaEhlYWRlckVsZW1lbnQoZnVuY3Rpb24gKGhlYWRlckVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJFbGVtZW50IGluc3RhbmNlb2YgcmVuZGVyZWRIZWFkZXJDZWxsXzEuUmVuZGVyZWRIZWFkZXJDZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDZWxsID0gaGVhZGVyRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENlbGwuZ2V0Q29sdW1uKCkgPT09IGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBjb21wID0gY3VycmVudENlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVhZGVyRWxlbWVudCBpbnN0YW5jZW9mIGhlYWRlcldyYXBwZXJDb21wXzEuSGVhZGVyV3JhcHBlckNvbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyV3JhcHBlckNvbXAgPSBoZWFkZXJFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJXcmFwcGVyQ29tcC5nZXRDb2x1bW4oKSA9PT0gY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSBoZWFkZXJXcmFwcGVyQ29tcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29tcCA/IGNvbXAuZ2V0R3VpKCkgOiBudWxsO1xuICAgIH07XG4gICAgQXV0b1dpZHRoQ2FsY3VsYXRvci5wcm90b3R5cGUucHV0Um93Q2VsbHNJbnRvRHVtbXlDb250YWluZXIgPSBmdW5jdGlvbiAoY29sdW1uLCBlRHVtbXlDb250YWluZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVDZWxscyA9IHRoaXMucm93UmVuZGVyZXIuZ2V0QWxsQ2VsbHNGb3JDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgZUNlbGxzLmZvckVhY2goZnVuY3Rpb24gKGVDZWxsKSB7IHJldHVybiBfdGhpcy5jbG9uZUl0ZW1JbnRvRHVtbXkoZUNlbGwsIGVEdW1teUNvbnRhaW5lcik7IH0pO1xuICAgIH07XG4gICAgQXV0b1dpZHRoQ2FsY3VsYXRvci5wcm90b3R5cGUuY2xvbmVJdGVtSW50b0R1bW15ID0gZnVuY3Rpb24gKGVDZWxsLCBlRHVtbXlDb250YWluZXIpIHtcbiAgICAgICAgLy8gbWFrZSBhIGRlZXAgY2xvbmUgb2YgdGhlIGNlbGxcbiAgICAgICAgdmFyIGVDZWxsQ2xvbmUgPSBlQ2VsbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBoYXMgYSBmaXhlZCB3aWR0aCwgd2UgcmVtb3ZlIHRoaXMgdG8gYWxsb3cgdGhlIG5hdHVyYWwgd2lkdGggYmFzZWQgb24gY29udGVudFxuICAgICAgICBlQ2VsbENsb25lLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBoYXMgcG9zaXRpb24gPSBhYnNvbHV0ZSwgd2UgbmVlZCB0byByZW1vdmUgdGhpcyBzbyBpdCdzIHBvc2l0aW9uZWQgbm9ybWFsbHlcbiAgICAgICAgZUNlbGxDbG9uZS5zdHlsZS5wb3NpdGlvbiA9ICdzdGF0aWMnO1xuICAgICAgICBlQ2VsbENsb25lLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgLy8gd2UgcHV0IHRoZSBjZWxsIGludG8gYSBjb250YWluaW5nIGRpdiwgYXMgb3RoZXJ3aXNlIHRoZSBjZWxscyB3b3VsZCBqdXN0IGxpbmUgdXBcbiAgICAgICAgLy8gb24gdGhlIHNhbWUgbGluZSwgc3RhbmRhcmQgZmxvdyBsYXlvdXQsIGJ5IHB1dHRpbmcgdGhlbSBpbnRvIGRpdnMsIHRoZXkgYXJlIGxhaWRcbiAgICAgICAgLy8gb3V0IG9uZSBwZXIgbGluZVxuICAgICAgICB2YXIgZUNsb25lUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vIHRhYmxlLXJvdywgc28gdGhhdCBlYWNoIGNlbGwgaXMgb24gYSByb3cuIGkgYWxzbyB0cmllZCBkaXNwbGF5PSdibG9jaycsIGJ1dCB0aGlzXG4gICAgICAgIC8vIGRpZG4ndCB3b3JrIGluIElFXG4gICAgICAgIGVDbG9uZVBhcmVudC5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlLXJvdyc7XG4gICAgICAgIC8vIHRoZSB0d2lnIG9uIHRoZSBicmFuY2gsIHRoZSBicmFuY2ggb24gdGhlIHRyZWUsIHRoZSB0cmVlIGluIHRoZSBob2xlLFxuICAgICAgICAvLyB0aGUgaG9sZSBpbiB0aGUgYm9nLCB0aGUgYm9nIGluIHRoZSBjbG9uZSwgdGhlIGNsb25lIGluIHRoZSBwYXJlbnQsXG4gICAgICAgIC8vIHRoZSBwYXJlbnQgaW4gdGhlIGR1bW15LCBhbmQgdGhlIGR1bW15IGRvd24gaW4gdGhlIHZhbGwtZS1vb28sIE9PT09PT09PTyEgT2ggcm93IHRoZSByYXR0bGluZyBib2cuLi4uXG4gICAgICAgIGVDbG9uZVBhcmVudC5hcHBlbmRDaGlsZChlQ2VsbENsb25lKTtcbiAgICAgICAgZUR1bW15Q29udGFpbmVyLmFwcGVuZENoaWxkKGVDbG9uZVBhcmVudCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8yLkF1dG93aXJlZCgncm93UmVuZGVyZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHJvd1JlbmRlcmVyXzEuUm93UmVuZGVyZXIpXG4gICAgXSwgQXV0b1dpZHRoQ2FsY3VsYXRvci5wcm90b3R5cGUsIFwicm93UmVuZGVyZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8yLkF1dG93aXJlZCgnaGVhZGVyUmVuZGVyZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGhlYWRlclJlbmRlcmVyXzEuSGVhZGVyUmVuZGVyZXIpXG4gICAgXSwgQXV0b1dpZHRoQ2FsY3VsYXRvci5wcm90b3R5cGUsIFwiaGVhZGVyUmVuZGVyZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8yLkF1dG93aXJlZCgnZ3JpZFBhbmVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkUGFuZWxfMS5HcmlkUGFuZWwpXG4gICAgXSwgQXV0b1dpZHRoQ2FsY3VsYXRvci5wcm90b3R5cGUsIFwiZ3JpZFBhbmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMi5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEF1dG9XaWR0aENhbGN1bGF0b3IucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIEF1dG9XaWR0aENhbGN1bGF0b3IgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2F1dG9XaWR0aENhbGN1bGF0b3InKVxuICAgIF0sIEF1dG9XaWR0aENhbGN1bGF0b3IpO1xuICAgIHJldHVybiBBdXRvV2lkdGhDYWxjdWxhdG9yO1xufSgpKTtcbmV4cG9ydHMuQXV0b1dpZHRoQ2FsY3VsYXRvciA9IEF1dG9XaWR0aENhbGN1bGF0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvYXV0b1dpZHRoQ2FsY3VsYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3dpZGdldHMvY29tcG9uZW50XCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIFBvcHVwRWRpdG9yV3JhcHBlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBvcHVwRWRpdG9yV3JhcHBlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3B1cEVkaXRvcldyYXBwZXIoY2VsbEVkaXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIjxkaXYgY2xhc3M9XFxcImFnLXBvcHVwLWVkaXRvclxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIi8+XCIpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmdldEd1aUNhbGxlZE9uQ2hpbGQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY2VsbEVkaXRvciA9IGNlbGxFZGl0b3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUG9wdXBFZGl0b3JXcmFwcGVyLnByb3RvdHlwZS5vbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMub25LZXlEb3duKGV2ZW50KTtcbiAgICB9O1xuICAgIFBvcHVwRWRpdG9yV3JhcHBlci5wcm90b3R5cGUuZ2V0R3VpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3ZSBjYWxsIGdldEd1aSgpIG9uIGNoaWxkIGhlcmUgKHJhdGhlciB0aGFuIGluIHRoZSBjb25zdHJ1Y3RvcilcbiAgICAgICAgLy8gYXMgd2Ugc2hvdWxkIHdhaXQgZm9yICdpbml0JyB0byBiZSBjYWxsZWQgb24gY2hpbGQgZmlyc3QuXG4gICAgICAgIGlmICghdGhpcy5nZXRHdWlDYWxsZWRPbkNoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuY2VsbEVkaXRvci5nZXRHdWkoKSk7XG4gICAgICAgICAgICB0aGlzLmdldEd1aUNhbGxlZE9uQ2hpbGQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmdldEd1aS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgUG9wdXBFZGl0b3JXcmFwcGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuc2V0RG9tRGF0YSh0aGlzLmdldEd1aSgpLCBQb3B1cEVkaXRvcldyYXBwZXIuRE9NX0tFWV9QT1BVUF9FRElUT1JfV1JBUFBFUiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveUZ1bmMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmNlbGxFZGl0b3IuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNlbGxFZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgJ3N1cGVyJyBhbmQgbm90ICd0aGlzJyBhcyBpZiB3ZSBjYWxsICd0aGlzJyxcbiAgICAgICAgLy8gaXQgZW5kcyB1cCBjYWxsZWQgJ2dldEd1aSgpJyBvbiB0aGUgY2hpbGQgYmVmb3JlICdpbml0JyB3YXMgY2FsbGVkLFxuICAgICAgICAvLyB3aGljaCBpcyBub3QgZ29vZFxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmdldEd1aS5jYWxsKHRoaXMpLCAna2V5ZG93bicsIHRoaXMub25LZXlEb3duLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgUG9wdXBFZGl0b3JXcmFwcGVyLnByb3RvdHlwZS5hZnRlckd1aUF0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yLmFmdGVyR3VpQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5hZnRlckd1aUF0dGFjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcHVwRWRpdG9yV3JhcHBlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxFZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICB9O1xuICAgIFBvcHVwRWRpdG9yV3JhcHBlci5wcm90b3R5cGUuaXNQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBQb3B1cEVkaXRvcldyYXBwZXIucHJvdG90eXBlLmlzQ2FuY2VsQmVmb3JlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IuaXNDYW5jZWxCZWZvcmVTdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbEVkaXRvci5pc0NhbmNlbEJlZm9yZVN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcHVwRWRpdG9yV3JhcHBlci5wcm90b3R5cGUuaXNDYW5jZWxBZnRlckVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvci5pc0NhbmNlbEFmdGVyRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsRWRpdG9yLmlzQ2FuY2VsQWZ0ZXJFbmQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wdXBFZGl0b3JXcmFwcGVyLnByb3RvdHlwZS5mb2N1c0luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yLmZvY3VzSW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5mb2N1c0luKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcHVwRWRpdG9yV3JhcHBlci5wcm90b3R5cGUuZm9jdXNPdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IuZm9jdXNPdXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5mb2N1c091dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3B1cEVkaXRvcldyYXBwZXIuRE9NX0tFWV9QT1BVUF9FRElUT1JfV1JBUFBFUiA9ICdwb3B1cEVkaXRvcldyYXBwZXInO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBQb3B1cEVkaXRvcldyYXBwZXIucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIHJldHVybiBQb3B1cEVkaXRvcldyYXBwZXI7XG59KGNvbXBvbmVudF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Qb3B1cEVkaXRvcldyYXBwZXIgPSBQb3B1cEVkaXRvcldyYXBwZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY2VsbEVkaXRvcnMvcG9wdXBFZGl0b3JXcmFwcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudHNcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgdmFsdWVGb3JtYXR0ZXJTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVGb3JtYXR0ZXJTZXJ2aWNlXCIpO1xudmFyIFNlbGVjdENlbGxFZGl0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWxlY3RDZWxsRWRpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlbGVjdENlbGxFZGl0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICc8ZGl2IGNsYXNzPVwiYWctY2VsbC1lZGl0LWlucHV0XCI+PHNlbGVjdCBjbGFzcz1cImFnLWNlbGwtZWRpdC1pbnB1dFwiLz48L2Rpdj4nKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lU2VsZWN0ID0gX3RoaXMuZ2V0R3VpKCkucXVlcnlTZWxlY3Rvcignc2VsZWN0Jyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2VsZWN0Q2VsbEVkaXRvci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQgPSBwYXJhbXMuY2VsbFN0YXJ0ZWRFZGl0O1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHBhcmFtcy52YWx1ZXMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogbm8gdmFsdWVzIGZvdW5kIGZvciBzZWxlY3QgY2VsbEVkaXRvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlRm9ybWF0dGVkID0gX3RoaXMudmFsdWVGb3JtYXR0ZXJTZXJ2aWNlLmZvcm1hdFZhbHVlKHBhcmFtcy5jb2x1bW4sIG51bGwsIG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlZEV4aXRzID0gdmFsdWVGb3JtYXR0ZWQgIT09IG51bGwgJiYgdmFsdWVGb3JtYXR0ZWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wdGlvbi50ZXh0ID0gdmFsdWVGb3JtYXR0ZWRFeGl0cyA/IHZhbHVlRm9ybWF0dGVkIDogdmFsdWU7XG4gICAgICAgICAgICBpZiAocGFyYW1zLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5lU2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGFkZCB0aGlzIGlmIGZ1bGwgcm93IGVkaXRpbmcsIG90aGVyd2lzZSBzZWxlY3Rpbmcgd2lsbCBzdG9wIHRoZVxuICAgICAgICAvLyBmdWxsIHJvdyBlZGl0aW5nLlxuICAgICAgICBpZiAoIXRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRnVsbFJvd0VkaXQoKSkge1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lU2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyYW1zLnN0b3BFZGl0aW5nKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZVNlbGVjdCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBpc05hdmlnYXRpb25LZXkgPSBldmVudC5rZXlDb2RlID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX1VQIHx8IGV2ZW50LmtleUNvZGUgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfRE9XTjtcbiAgICAgICAgICAgIGlmIChpc05hdmlnYXRpb25LZXkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZVNlbGVjdCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0Q2VsbEVkaXRvci5wcm90b3R5cGUuYWZ0ZXJHdWlBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNBZnRlckF0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVTZWxlY3QuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0Q2VsbEVkaXRvci5wcm90b3R5cGUuZm9jdXNJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lU2VsZWN0LmZvY3VzKCk7XG4gICAgfTtcbiAgICBTZWxlY3RDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZVNlbGVjdC52YWx1ZTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBTZWxlY3RDZWxsRWRpdG9yLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgndmFsdWVGb3JtYXR0ZXJTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB2YWx1ZUZvcm1hdHRlclNlcnZpY2VfMS5WYWx1ZUZvcm1hdHRlclNlcnZpY2UpXG4gICAgXSwgU2VsZWN0Q2VsbEVkaXRvci5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0ZXJTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFNlbGVjdENlbGxFZGl0b3I7XG59KGNvbXBvbmVudF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5TZWxlY3RDZWxsRWRpdG9yID0gU2VsZWN0Q2VsbEVkaXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsRWRpdG9ycy9zZWxlY3RDZWxsRWRpdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudHNcIik7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBUZXh0Q2VsbEVkaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRDZWxsRWRpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHRDZWxsRWRpdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgVGV4dENlbGxFZGl0b3IuVEVNUExBVEUpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRleHRDZWxsRWRpdG9yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdmFyIGVJbnB1dCA9IHRoaXMuZ2V0R3VpKCk7XG4gICAgICAgIHZhciBzdGFydFZhbHVlO1xuICAgICAgICAvLyBjZWxsU3RhcnRlZEVkaXQgaXMgb25seSBmYWxzZSBpZiB3ZSBhcmUgZG9pbmcgZnVsbFJvdyBlZGl0aW5nXG4gICAgICAgIGlmIChwYXJhbXMuY2VsbFN0YXJ0ZWRFZGl0KSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIga2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSA9IHBhcmFtcy5rZXlQcmVzcyA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9CQUNLU1BBQ0VcbiAgICAgICAgICAgICAgICB8fCBwYXJhbXMua2V5UHJlc3MgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfREVMRVRFO1xuICAgICAgICAgICAgaWYgKGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuY2hhclByZXNzKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZSA9IHBhcmFtcy5jaGFyUHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlID0gdGhpcy5nZXRTdGFydFZhbHVlKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5rZXlQcmVzcyAhPT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9GMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEFsbE9uRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNBZnRlckF0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzdGFydFZhbHVlID0gdGhpcy5nZXRTdGFydFZhbHVlKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHN0YXJ0VmFsdWUpKSB7XG4gICAgICAgICAgICBlSW5wdXQudmFsdWUgPSBzdGFydFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKGVJbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBpc05hdmlnYXRpb25LZXkgPSBldmVudC5rZXlDb2RlID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX0xFRlRcbiAgICAgICAgICAgICAgICB8fCBldmVudC5rZXlDb2RlID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX1JJR0hUXG4gICAgICAgICAgICAgICAgfHwgZXZlbnQua2V5Q29kZSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9VUFxuICAgICAgICAgICAgICAgIHx8IGV2ZW50LmtleUNvZGUgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfRE9XTlxuICAgICAgICAgICAgICAgIHx8IGV2ZW50LmtleUNvZGUgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfUEFHRV9ET1dOXG4gICAgICAgICAgICAgICAgfHwgZXZlbnQua2V5Q29kZSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9QQUdFX1VQXG4gICAgICAgICAgICAgICAgfHwgZXZlbnQua2V5Q29kZSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9QQUdFX0hPTUVcbiAgICAgICAgICAgICAgICB8fCBldmVudC5rZXlDb2RlID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX1BBR0VfRU5EO1xuICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbktleSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgc3RvcHMgdGhlIGdyaWQgZnJvbSBleGVjdXRpbmcga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICghKGV2ZW50LmtleUNvZGUgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfTEVGVCkgJiYgIShldmVudC5rZXlDb2RlID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX1JJR0hUKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHN0b3BzIHRoZSBicm93c2VyIGZyb20gc2Nyb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRleHRDZWxsRWRpdG9yLnByb3RvdHlwZS5hZnRlckd1aUF0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZm9jdXNBZnRlckF0dGFjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVJbnB1dCA9IHRoaXMuZ2V0R3VpKCk7XG4gICAgICAgIGVJbnB1dC5mb2N1cygpO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRBbGxPbkZvY3VzKSB7XG4gICAgICAgICAgICBlSW5wdXQuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIHN0YXJ0ZWQgZWRpdGluZywgd2Ugd2FudCB0aGUgY2Fyb3QgYXQgdGhlIGVuZCwgbm90IHRoZSBzdGFydC5cbiAgICAgICAgICAgIC8vIHRoaXMgY29tZXMgaW50byBwbGF5IGluIHR3byBzY2VuYXJpb3M6IGEpIHdoZW4gdXNlciBoaXRzIEYyIGFuZCBiKVxuICAgICAgICAgICAgLy8gd2hlbiB1c2VyIGhpdHMgYSBwcmludGFibGUgY2hhcmFjdGVyLCB0aGVuIG9uIElFIChhbmQgb25seSBJRSkgdGhlIGNhcm90XG4gICAgICAgICAgICAvLyB3YXMgcGxhY2VkIGFmdGVyIHRoZSBmaXJzdCBjaGFyYWN0ZXIsIHRodXMgJ2FwcGx5JyB3b3VsZCBlbmQgdXAgYXMgJ3BwbGVhJ1xuICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gZUlucHV0LnZhbHVlID8gZUlucHV0LnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBpZiAobGVuZ3RoXzEgPiAwKSB7XG4gICAgICAgICAgICAgICAgZUlucHV0LnNldFNlbGVjdGlvblJhbmdlKGxlbmd0aF8xLCBsZW5ndGhfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGdldHMgY2FsbGVkIHdoZW4gdGFiYmluZyB0cm91Z2ggY2VsbHMgYW5kIGluIGZ1bGwgcm93IGVkaXQgbW9kZVxuICAgIFRleHRDZWxsRWRpdG9yLnByb3RvdHlwZS5mb2N1c0luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZUlucHV0ID0gdGhpcy5nZXRHdWkoKTtcbiAgICAgICAgZUlucHV0LmZvY3VzKCk7XG4gICAgICAgIGVJbnB1dC5zZWxlY3QoKTtcbiAgICB9O1xuICAgIFRleHRDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVJbnB1dCA9IHRoaXMuZ2V0R3VpKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5wYXJzZVZhbHVlKGVJbnB1dC52YWx1ZSk7XG4gICAgfTtcbiAgICBUZXh0Q2VsbEVkaXRvci5wcm90b3R5cGUuZ2V0U3RhcnRWYWx1ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGZvcm1hdFZhbHVlID0gcGFyYW1zLnVzZUZvcm1hdHRlciB8fCBwYXJhbXMuY29sdW1uLmdldENvbERlZigpLnJlZkRhdGE7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZSA/IHBhcmFtcy5mb3JtYXRWYWx1ZShwYXJhbXMudmFsdWUpIDogcGFyYW1zLnZhbHVlO1xuICAgIH07XG4gICAgVGV4dENlbGxFZGl0b3IuVEVNUExBVEUgPSAnPGlucHV0IGNsYXNzPVwiYWctY2VsbC1lZGl0LWlucHV0XCIgdHlwZT1cInRleHRcIi8+JztcbiAgICByZXR1cm4gVGV4dENlbGxFZGl0b3I7XG59KGNvbXBvbmVudF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5UZXh0Q2VsbEVkaXRvciA9IFRleHRDZWxsRWRpdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxFZGl0b3JzL3RleHRDZWxsRWRpdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIGNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3dpZGdldHMvY29tcG9uZW50XCIpO1xudmFyIEFSUk9XX1VQID0gJyYjNjU1MTQ7JztcbnZhciBBUlJPV19ET1dOID0gJyYjNjU1MTY7JztcbnZhciBBbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFuaW1hdGVTaG93Q2hhbmdlQ2VsbFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFuaW1hdGVTaG93Q2hhbmdlQ2VsbFJlbmRlcmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBBbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlci5URU1QTEFURSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVmcmVzaENvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgLy8gdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuZVZhbHVlID0gdGhpcy5xdWVyeUZvckh0bWxFbGVtZW50KCcuYWctdmFsdWUtY2hhbmdlLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZURlbHRhID0gdGhpcy5xdWVyeUZvckh0bWxFbGVtZW50KCcuYWctdmFsdWUtY2hhbmdlLWRlbHRhJyk7XG4gICAgICAgIHRoaXMucmVmcmVzaChwYXJhbXMpO1xuICAgIH07XG4gICAgQW5pbWF0ZVNob3dDaGFuZ2VDZWxsUmVuZGVyZXIucHJvdG90eXBlLnNob3dEZWx0YSA9IGZ1bmN0aW9uIChwYXJhbXMsIGRlbHRhKSB7XG4gICAgICAgIHZhciBhYnNEZWx0YSA9IE1hdGguYWJzKGRlbHRhKTtcbiAgICAgICAgdmFyIHZhbHVlRm9ybWF0dGVkID0gcGFyYW1zLmZvcm1hdFZhbHVlKGFic0RlbHRhKTtcbiAgICAgICAgdmFyIHZhbHVlVG9Vc2UgPSB1dGlsc18xLlV0aWxzLmV4aXN0cyh2YWx1ZUZvcm1hdHRlZCkgPyB2YWx1ZUZvcm1hdHRlZCA6IGFic0RlbHRhO1xuICAgICAgICB2YXIgZGVsdGFVcCA9IChkZWx0YSA+PSAwKTtcbiAgICAgICAgaWYgKGRlbHRhVXApIHtcbiAgICAgICAgICAgIHRoaXMuZURlbHRhLmlubmVySFRNTCA9IEFSUk9XX1VQICsgdmFsdWVUb1VzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgbmVnYXRpdmUsIHVzZSBBQlMgdG8gcmVtb3ZlIHNpZ25cbiAgICAgICAgICAgIHRoaXMuZURlbHRhLmlubmVySFRNTCA9IEFSUk9XX0RPV04gKyB2YWx1ZVRvVXNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsYXNzIG1ha2VzIGl0IGdyZWVuIChpbiBhZy1mcmVzaClcbiAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZURlbHRhLCAnYWctdmFsdWUtY2hhbmdlLWRlbHRhLXVwJywgZGVsdGFVcCk7XG4gICAgICAgIC8vIGNsYXNzIG1ha2VzIGl0IHJlZCAoaW4gYWctZnJlc2gpXG4gICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkT3JSZW1vdmVDc3NDbGFzcyh0aGlzLmVEZWx0YSwgJ2FnLXZhbHVlLWNoYW5nZS1kZWx0YS1kb3duJywgIWRlbHRhVXApO1xuICAgIH07XG4gICAgQW5pbWF0ZVNob3dDaGFuZ2VDZWxsUmVuZGVyZXIucHJvdG90eXBlLnNldFRpbWVyVG9SZW1vdmVEZWx0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gdGhlIHJlZnJlc2hDb3VudCBtYWtlcyBzdXJlIHRoYXQgaWYgdGhlIHZhbHVlIHVwZGF0ZXMgYWdhaW4gd2hpbGVcbiAgICAgICAgLy8gdGhlIGJlbG93IHRpbWVyIGlzIHdhaXRpbmcsIHRoZW4gdGhlIGJlbG93IHRpbWVyIHdpbGwgcmVhbGlzZSBpdFxuICAgICAgICAvLyBpcyBub3QgdGhlIG1vc3QgcmVjZW50IGFuZCB3aWxsIG5vdCB0cnkgdG8gcmVtb3ZlIHRoZSBkZWx0YSB2YWx1ZS5cbiAgICAgICAgdGhpcy5yZWZyZXNoQ291bnQrKztcbiAgICAgICAgdmFyIHJlZnJlc2hDb3VudENvcHkgPSB0aGlzLnJlZnJlc2hDb3VudDtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmVmcmVzaENvdW50Q29weSA9PT0gX3RoaXMucmVmcmVzaENvdW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZURlbHRhVmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwMCk7XG4gICAgfTtcbiAgICBBbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlci5wcm90b3R5cGUuaGlkZURlbHRhVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlQ3NzQ2xhc3ModGhpcy5lVmFsdWUsICdhZy12YWx1ZS1jaGFuZ2UtdmFsdWUtaGlnaGxpZ2h0Jyk7XG4gICAgICAgIHRoaXMuZURlbHRhLmlubmVySFRNTCA9ICcnO1xuICAgIH07XG4gICAgQW5pbWF0ZVNob3dDaGFuZ2VDZWxsUmVuZGVyZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLmxhc3RWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhwYXJhbXMudmFsdWVGb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLmVWYWx1ZS5pbm5lckhUTUwgPSBwYXJhbXMudmFsdWVGb3JtYXR0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMocGFyYW1zLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5lVmFsdWUuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVWYWx1ZS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdGhpcy5sYXN0VmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB2YWx1ZSAtIHRoaXMubGFzdFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zaG93RGVsdGEocGFyYW1zLCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSBjdXJyZW50IHZhbHVlLCBidXQgb25seSBpZiBpdCdzIG5vdCBuZXcsIG90aGVyd2lzZSBpdFxuICAgICAgICAvLyB3b3VsZCBnZXQgaGlnaGxpZ2h0ZWQgZmlyc3QgdGltZSB0aGUgdmFsdWUgaXMgc2hvd25cbiAgICAgICAgaWYgKHRoaXMubGFzdFZhbHVlKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZENzc0NsYXNzKHRoaXMuZVZhbHVlLCAnYWctdmFsdWUtY2hhbmdlLXZhbHVlLWhpZ2hsaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VGltZXJUb1JlbW92ZURlbHRhKCk7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQW5pbWF0ZVNob3dDaGFuZ2VDZWxsUmVuZGVyZXIuVEVNUExBVEUgPSAnPHNwYW4+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImFnLXZhbHVlLWNoYW5nZS1kZWx0YVwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiYWctdmFsdWUtY2hhbmdlLXZhbHVlXCI+PC9zcGFuPicgK1xuICAgICAgICAnPC9zcGFuPic7XG4gICAgcmV0dXJuIEFuaW1hdGVTaG93Q2hhbmdlQ2VsbFJlbmRlcmVyO1xufShjb21wb25lbnRfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQW5pbWF0ZVNob3dDaGFuZ2VDZWxsUmVuZGVyZXIgPSBBbmltYXRlU2hvd0NoYW5nZUNlbGxSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsUmVuZGVyZXJzL2FuaW1hdGVTaG93Q2hhbmdlQ2VsbFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIGNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3dpZGdldHMvY29tcG9uZW50XCIpO1xudmFyIEFuaW1hdGVTbGlkZUNlbGxSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFuaW1hdGVTbGlkZUNlbGxSZW5kZXJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbmltYXRlU2xpZGVDZWxsUmVuZGVyZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIEFuaW1hdGVTbGlkZUNlbGxSZW5kZXJlci5URU1QTEFURSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVmcmVzaENvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuZUN1cnJlbnQgPSBfdGhpcy5xdWVyeUZvckh0bWxFbGVtZW50KCcuYWctdmFsdWUtc2xpZGUtY3VycmVudCcpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFuaW1hdGVTbGlkZUNlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMucmVmcmVzaChwYXJhbXMpO1xuICAgIH07XG4gICAgQW5pbWF0ZVNsaWRlQ2VsbFJlbmRlcmVyLnByb3RvdHlwZS5hZGRTbGlkZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZWZyZXNoQ291bnQrKztcbiAgICAgICAgLy8gYmVsb3cgd2Uga2VlcCBjaGVja2luZyB0aGlzLCBhbmQgc3RvcCB3b3JraW5nIG9uIHRoZSBhbmltYXRpb25cbiAgICAgICAgLy8gaWYgaXQgbm8gbG9uZ2VyIG1hdGNoZXMgLSB0aGlzIG1lYW5zIGFub3RoZXIgYW5pbWF0aW9uIGhhcyBzdGFydGVkXG4gICAgICAgIC8vIGFuZCB0aGlzIG9uZSBpcyBzdGFsZS5cbiAgICAgICAgdmFyIHJlZnJlc2hDb3VudENvcHkgPSB0aGlzLnJlZnJlc2hDb3VudDtcbiAgICAgICAgLy8gaWYgb2xkIGFuaW1hdGlvbiwgcmVtb3ZlIGl0XG4gICAgICAgIGlmICh0aGlzLmVQcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5nZXRHdWkoKS5yZW1vdmVDaGlsZCh0aGlzLmVQcmV2aW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lUHJldmlvdXMgPSB1dGlsc18xLlV0aWxzLmxvYWRUZW1wbGF0ZSgnPHNwYW4gY2xhc3M9XCJhZy12YWx1ZS1zbGlkZS1wcmV2aW91cyBhZy12YWx1ZS1zbGlkZS1vdXRcIj48L3NwYW4+Jyk7XG4gICAgICAgIHRoaXMuZVByZXZpb3VzLmlubmVySFRNTCA9IHRoaXMuZUN1cnJlbnQuaW5uZXJIVE1MO1xuICAgICAgICB0aGlzLmdldEd1aSgpLmluc2VydEJlZm9yZSh0aGlzLmVQcmV2aW91cywgdGhpcy5lQ3VycmVudCk7XG4gICAgICAgIC8vIGhhdmluZyB0aW1lb3V0IG9mIDAgYWxsb3dzIHVzZSB0byBza2lwIHRvIHRoZSBuZXh0IGNzcyB0dXJuLFxuICAgICAgICAvLyBzbyB3ZSBrbm93IHRoZSBwcmV2aW91cyBjc3MgY2xhc3NlcyBoYXZlIGJlZW4gYXBwbGllZC4gc28gdGhlXG4gICAgICAgIC8vIGNvbXBsZXggc2V0IG9mIHNldFRpbWVvdXQgYmVsb3cgY3JlYXRlcyB0aGUgYW5pbWF0aW9uXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJlZnJlc2hDb3VudENvcHkgIT09IF90aGlzLnJlZnJlc2hDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkQ3NzQ2xhc3MoX3RoaXMuZVByZXZpb3VzLCAnYWctdmFsdWUtc2xpZGUtb3V0LWVuZCcpO1xuICAgICAgICB9LCA1MCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJlZnJlc2hDb3VudENvcHkgIT09IF90aGlzLnJlZnJlc2hDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmdldEd1aSgpLnJlbW92ZUNoaWxkKF90aGlzLmVQcmV2aW91cyk7XG4gICAgICAgICAgICBfdGhpcy5lUHJldmlvdXMgPSBudWxsO1xuICAgICAgICB9LCAzMDAwKTtcbiAgICB9O1xuICAgIEFuaW1hdGVTbGlkZUNlbGxSZW5kZXJlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zLnZhbHVlO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMubGFzdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRTbGlkZUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMocGFyYW1zLnZhbHVlRm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgdGhpcy5lQ3VycmVudC5pbm5lckhUTUwgPSBwYXJhbXMudmFsdWVGb3JtYXR0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMocGFyYW1zLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5lQ3VycmVudC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZUN1cnJlbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBBbmltYXRlU2xpZGVDZWxsUmVuZGVyZXIuVEVNUExBVEUgPSAnPHNwYW4+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImFnLXZhbHVlLXNsaWRlLWN1cnJlbnRcIj48L3NwYW4+JyArXG4gICAgICAgICc8L3NwYW4+JztcbiAgICByZXR1cm4gQW5pbWF0ZVNsaWRlQ2VsbFJlbmRlcmVyO1xufShjb21wb25lbnRfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQW5pbWF0ZVNsaWRlQ2VsbFJlbmRlcmVyID0gQW5pbWF0ZVNsaWRlQ2VsbFJlbmRlcmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxSZW5kZXJlcnMvYW5pbWF0ZVNsaWRlQ2VsbFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGV4cHJlc3Npb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vdmFsdWVTZXJ2aWNlL2V4cHJlc3Npb25TZXJ2aWNlXCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2V2ZW50U2VydmljZVwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudHNcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3dpZGdldHMvY29tcG9uZW50XCIpO1xudmFyIHJvd05vZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnRpdGllcy9yb3dOb2RlXCIpO1xudmFyIGNlbGxSZW5kZXJlclNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9jZWxsUmVuZGVyZXJTZXJ2aWNlXCIpO1xudmFyIHZhbHVlRm9ybWF0dGVyU2VydmljZV8xID0gcmVxdWlyZShcIi4uL3ZhbHVlRm9ybWF0dGVyU2VydmljZVwiKTtcbnZhciBjaGVja2JveFNlbGVjdGlvbkNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4uL2NoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50XCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgY29sdW1uXzEgPSByZXF1aXJlKFwiLi4vLi4vZW50aXRpZXMvY29sdW1uXCIpO1xudmFyIGNvbXBvbmVudEFubm90YXRpb25zXzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRBbm5vdGF0aW9uc1wiKTtcbnZhciBtb3VzZUV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2dyaWRQYW5lbC9tb3VzZUV2ZW50U2VydmljZVwiKTtcbnZhciBHcm91cENlbGxSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwQ2VsbFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwQ2VsbFJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgR3JvdXBDZWxsUmVuZGVyZXIuVEVNUExBVEUpIHx8IHRoaXM7XG4gICAgfVxuICAgIEdyb3VwQ2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdmFyIGVtYmVkZGVkUm93TWlzbWF0Y2ggPSB0aGlzLmlzRW1iZWRkZWRSb3dNaXNtYXRjaCgpO1xuICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3IgZW1wdHkgc3RyaW5ncyB0byBhcHBlYXIgYXMgZ3JvdXBzIHNpbmNlXG4gICAgICAgIC8vIGl0IHdpbGwgb25seSByZXR1cm4gZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgICAgICB2YXIgY2VsbElzRW1wdHkgPSBwYXJhbXMudmFsdWUgPT0gbnVsbDtcbiAgICAgICAgdGhpcy5jZWxsSXNCbGFuayA9IGVtYmVkZGVkUm93TWlzbWF0Y2ggfHwgY2VsbElzRW1wdHk7XG4gICAgICAgIGlmICh0aGlzLmNlbGxJc0JsYW5rKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR1cERyYWdPcGVuUGFyZW50cygpO1xuICAgICAgICB0aGlzLmFkZEV4cGFuZEFuZENvbnRyYWN0KCk7XG4gICAgICAgIHRoaXMuYWRkQ2hlY2tib3hJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLmFkZFZhbHVlRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmFkZFBhZGRpbmcoKTtcbiAgICB9O1xuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBlbWJlZGRlZCBmdWxsIHdpZHRoIHJvd3MsIHdlIG9ubHkgc2hvdyB0aGUgcmVuZGVyZXIgd2hlblxuICAgIC8vIGluIHRoZSBib2R5LCBvciBpZiBwaW5uaW5nIGluIHRoZSBwaW5uZWQgc2VjdGlvbiwgb3IgaWYgcGlubmluZyBhbmQgUlRMLFxuICAgIC8vIGluIHRoZSByaWdodCBzZWN0aW9uLiBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0aGUgY2VsbCByZXBlYXRlZCBpbiBlYWNoIHNlY3Rpb24uXG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLmlzRW1iZWRkZWRSb3dNaXNtYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW1iZWRGdWxsV2lkdGhSb3dzKCkpIHtcbiAgICAgICAgICAgIHZhciBwaW5uZWRMZWZ0Q2VsbCA9IHRoaXMucGFyYW1zLnBpbm5lZCA9PT0gY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9MRUZUO1xuICAgICAgICAgICAgdmFyIHBpbm5lZFJpZ2h0Q2VsbCA9IHRoaXMucGFyYW1zLnBpbm5lZCA9PT0gY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9SSUdIVDtcbiAgICAgICAgICAgIHZhciBib2R5Q2VsbCA9ICFwaW5uZWRMZWZ0Q2VsbCAmJiAhcGlubmVkUmlnaHRDZWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGlubmluZ0xlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXBpbm5lZFJpZ2h0Q2VsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhYm9keUNlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uQ29udHJvbGxlci5pc1Bpbm5pbmdMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFwaW5uZWRMZWZ0Q2VsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhYm9keUNlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUuc2V0UGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzR3JvdXBIaWRlT3BlblBhcmVudHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgICAgdmFyIHJvd05vZGUgPSBwYXJhbXMubm9kZTtcbiAgICAgICAgdmFyIHBhZGRpbmdQeDtcbiAgICAgICAgLy8gbmV2ZXIgYW55IHBhZGRpbmcgb24gdG9wIGxldmVsIG5vZGVzXG4gICAgICAgIGlmIChyb3dOb2RlLnVpTGV2ZWwgPD0gMCkge1xuICAgICAgICAgICAgcGFkZGluZ1B4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nRmFjdG9yID0gKHBhcmFtcy5wYWRkaW5nID49IDApID8gcGFyYW1zLnBhZGRpbmcgOiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRHcm91cFBhZGRpbmdTaXplKCk7XG4gICAgICAgICAgICBwYWRkaW5nUHggPSByb3dOb2RlLnVpTGV2ZWwgKiBwYWRkaW5nRmFjdG9yO1xuICAgICAgICAgICAgdmFyIHJlZHVjZWRMZWFmTm9kZSA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5pc1Bpdm90TW9kZSgpICYmIHBhcmFtcy5ub2RlLmxlYWZHcm91cDtcbiAgICAgICAgICAgIGlmIChyb3dOb2RlLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdQeCArPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRGb290ZXJQYWRkaW5nQWRkaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFyb3dOb2RlLmlzRXhwYW5kYWJsZSgpIHx8IHJlZHVjZWRMZWFmTm9kZSkge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdQeCArPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRMZWFmTm9kZVBhZGRpbmdBZGRpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVJ0bCgpKSB7XG4gICAgICAgICAgICAvLyBpZiBkb2luZyBydGwsIHBhZGRpbmcgaXMgb24gdGhlIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmdldEd1aSgpLnN0eWxlLnBhZGRpbmdSaWdodCA9IHBhZGRpbmdQeCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaXQgaXMgb24gdGhlIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZ2V0R3VpKCkuc3R5bGUucGFkZGluZ0xlZnQgPSBwYWRkaW5nUHggKyAncHgnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUuYWRkUGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gb25seSBkbyB0aGlzIGlmIGFuIGluZGVudCAtIGFzIHRoaXMgb3ZlcndyaXRlcyB0aGUgcGFkZGluZyB0aGF0XG4gICAgICAgIC8vIHRoZSB0aGVtZSBzZXQsIHdoaWNoIHdpbGwgbWFrZSB0aGluZ3MgbG9vayAnbm90IGFsaWduZWQnIGZvciB0aGVcbiAgICAgICAgLy8gZmlyc3QgZ3JvdXAgbGV2ZWwuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5wYXJhbXMubm9kZTtcbiAgICAgICAgdmFyIHN1cHByZXNzUGFkZGluZyA9IHRoaXMucGFyYW1zLnN1cHByZXNzUGFkZGluZztcbiAgICAgICAgaWYgKCFzdXBwcmVzc1BhZGRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKG5vZGUsIHJvd05vZGVfMS5Sb3dOb2RlLkVWRU5UX1VJX0xFVkVMX0NIQU5HRUQsIHRoaXMuc2V0UGFkZGluZy5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFkZGluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUuYWRkVmFsdWVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICAgIHZhciByb3dOb2RlID0gdGhpcy5kaXNwbGF5ZWRHcm91cDtcbiAgICAgICAgaWYgKHJvd05vZGUuZm9vdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZvb3RlckNlbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3dOb2RlLmhhc0NoaWxkcmVuKCkgfHxcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuZ2V0KHBhcmFtcy5jb2xEZWYsICdjZWxsUmVuZGVyZXJQYXJhbXMuaW5uZXJSZW5kZXJlcicsIG51bGwpIHx8XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmdldChwYXJhbXMuY29sRGVmLCAnY2VsbFJlbmRlcmVyUGFyYW1zLmlubmVyUmVuZGVyZXJGcmFtZXdvcmsnLCBudWxsKSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVHcm91cENlbGwoKTtcbiAgICAgICAgICAgIGlmIChyb3dOb2RlLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlTGVhZkNlbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUZvb3RlckNlbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb290ZXJWYWx1ZTtcbiAgICAgICAgdmFyIGZvb3RlclZhbHVlR2V0dGVyID0gdGhpcy5wYXJhbXMuZm9vdGVyVmFsdWVHZXR0ZXI7XG4gICAgICAgIGlmIChmb290ZXJWYWx1ZUdldHRlcikge1xuICAgICAgICAgICAgLy8gcGFyYW1zIGlzIHNhbWUgYXMgd2Ugd2VyZSBnaXZlbiwgZXhjZXB0IHdlIHNldCB0aGUgdmFsdWUgYXMgdGhlIGl0ZW0gdG8gZGlzcGxheVxuICAgICAgICAgICAgdmFyIHBhcmFtc0Nsb25lID0gdXRpbHNfMS5VdGlscy5jbG9uZU9iamVjdCh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBwYXJhbXNDbG9uZS52YWx1ZSA9IHRoaXMucGFyYW1zLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb290ZXJWYWx1ZUdldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGZvb3RlclZhbHVlID0gZm9vdGVyVmFsdWVHZXR0ZXIocGFyYW1zQ2xvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZvb3RlclZhbHVlR2V0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZvb3RlclZhbHVlID0gdGhpcy5leHByZXNzaW9uU2VydmljZS5ldmFsdWF0ZShmb290ZXJWYWx1ZUdldHRlciwgcGFyYW1zQ2xvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBmb290ZXJWYWx1ZUdldHRlciBzaG91bGQgYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcgKGV4cHJlc3Npb24pJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb290ZXJWYWx1ZSA9ICdUb3RhbCAnICsgdGhpcy5wYXJhbXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lVmFsdWUuaW5uZXJIVE1MID0gZm9vdGVyVmFsdWU7XG4gICAgfTtcbiAgICBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlR3JvdXBDZWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICAgIHZhciByb3dHcm91cENvbHVtbiA9IHRoaXMuZGlzcGxheWVkR3JvdXAucm93R3JvdXBDb2x1bW47XG4gICAgICAgIC8vIHdlIHRyeSBhbmQgdXNlIHRoZSBjZWxsUmVuZGVyZXIgb2YgdGhlIGNvbHVtbiB1c2VkIGZvciB0aGUgZ3JvdXBpbmcgaWYgd2UgY2FuXG4gICAgICAgIHZhciBjb2x1bW5Ub1VzZSA9IHJvd0dyb3VwQ29sdW1uID8gcm93R3JvdXBDb2x1bW4gOiBwYXJhbXMuY29sdW1uO1xuICAgICAgICB2YXIgZ3JvdXBOYW1lID0gdGhpcy5wYXJhbXMudmFsdWU7XG4gICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlZCA9IGNvbHVtblRvVXNlID9cbiAgICAgICAgICAgIHRoaXMudmFsdWVGb3JtYXR0ZXJTZXJ2aWNlLmZvcm1hdFZhbHVlKGNvbHVtblRvVXNlLCBwYXJhbXMubm9kZSwgcGFyYW1zLnNjb3BlLCBncm91cE5hbWUpIDogbnVsbDtcbiAgICAgICAgcGFyYW1zLnZhbHVlRm9ybWF0dGVkID0gdmFsdWVGb3JtYXR0ZWQ7XG4gICAgICAgIGlmIChwYXJhbXMuZnVsbFdpZHRoID09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbFJlbmRlcmVyU2VydmljZS51c2VGdWxsV2lkdGhHcm91cFJvd0lubmVyQ2VsbFJlbmRlcmVyKHRoaXMuZVZhbHVlLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jZWxsUmVuZGVyZXJTZXJ2aWNlLnVzZUlubmVyQ2VsbFJlbmRlcmVyKHRoaXMucGFyYW1zLmNvbERlZi5jZWxsUmVuZGVyZXJQYXJhbXMsIGNvbHVtblRvVXNlLmdldENvbERlZigpLCB0aGlzLmVWYWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLmFkZENoaWxkQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG9ubHkgaW5jbHVkZSB0aGUgY2hpbGQgY291bnQgaWYgaXQncyBpbmNsdWRlZCwgZWcgaWYgdXNlciBkb2luZyBjdXN0b20gYWdncmVnYXRpb24sXG4gICAgICAgIC8vIHRoZW4gdGhpcyBjb3VsZCBiZSBsZWZ0IG91dCwgb3Igc2V0IHRvIC0xLCBpZSBubyBjaGlsZCBjb3VudFxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuc3VwcHJlc3NDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZGlzcGxheWVkR3JvdXAsIHJvd05vZGVfMS5Sb3dOb2RlLkVWRU5UX0FMTF9DSElMRFJFTl9DT1VOVF9DSEFOR0VELCB0aGlzLnVwZGF0ZUNoaWxkQ291bnQuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIGZpbHRlcmluZyBjaGFuZ2VzIHRoZSBjaGlsZCBjb3VudCwgc28gbmVlZCB0byBjYXRlciBmb3IgaXRcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZENvdW50KCk7XG4gICAgfTtcbiAgICBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlQ2hpbGRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsbENoaWxkcmVuQ291bnQgPSB0aGlzLmRpc3BsYXllZEdyb3VwLmFsbENoaWxkcmVuQ291bnQ7XG4gICAgICAgIHRoaXMuZUNoaWxkQ291bnQuaW5uZXJIVE1MID0gYWxsQ2hpbGRyZW5Db3VudCA+PSAwID8gXCIoXCIgKyBhbGxDaGlsZHJlbkNvdW50ICsgXCIpXCIgOiBcIlwiO1xuICAgIH07XG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUxlYWZDZWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHModGhpcy5wYXJhbXMudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmVWYWx1ZS5pbm5lckhUTUwgPSB0aGlzLnBhcmFtcy52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLmlzVXNlcldhbnRzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJhbXNDaGVja2JveCA9IHRoaXMucGFyYW1zLmNoZWNrYm94O1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc0NoZWNrYm94ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zQ2hlY2tib3godGhpcy5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtc0NoZWNrYm94ID09PSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUuYWRkQ2hlY2tib3hJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd05vZGUgPSB0aGlzLnBhcmFtcy5ub2RlO1xuICAgICAgICB2YXIgY2hlY2tib3hOZWVkZWQgPSB0aGlzLmlzVXNlcldhbnRzU2VsZWN0ZWQoKVxuICAgICAgICAgICAgJiYgIXJvd05vZGUuZm9vdGVyXG4gICAgICAgICAgICAmJiAhcm93Tm9kZS5yb3dQaW5uZWRcbiAgICAgICAgICAgICYmICFyb3dOb2RlLmZsb3dlcjtcbiAgICAgICAgaWYgKGNoZWNrYm94TmVlZGVkKSB7XG4gICAgICAgICAgICB2YXIgY2JTZWxlY3Rpb25Db21wb25lbnRfMSA9IG5ldyBjaGVja2JveFNlbGVjdGlvbkNvbXBvbmVudF8xLkNoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50KCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQud2lyZUJlYW4oY2JTZWxlY3Rpb25Db21wb25lbnRfMSk7XG4gICAgICAgICAgICBjYlNlbGVjdGlvbkNvbXBvbmVudF8xLmluaXQoeyByb3dOb2RlOiByb3dOb2RlLCBjb2x1bW46IHRoaXMucGFyYW1zLmNvbHVtbiB9KTtcbiAgICAgICAgICAgIHRoaXMuZUNoZWNrYm94LmFwcGVuZENoaWxkKGNiU2VsZWN0aW9uQ29tcG9uZW50XzEuZ2V0R3VpKCkpO1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95RnVuYyhmdW5jdGlvbiAoKSB7IHJldHVybiBjYlNlbGVjdGlvbkNvbXBvbmVudF8xLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyb3VwQ2VsbFJlbmRlcmVyLnByb3RvdHlwZS5hZGRFeHBhbmRBbmRDb250cmFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgICAgICB2YXIgZUdyb3VwQ2VsbCA9IHBhcmFtcy5lR3JpZENlbGw7XG4gICAgICAgIHZhciBlRXhwYW5kZWRJY29uID0gdXRpbHNfMS5VdGlscy5jcmVhdGVJY29uTm9TcGFuKCdncm91cEV4cGFuZGVkJywgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIG51bGwpO1xuICAgICAgICB2YXIgZUNvbnRyYWN0ZWRJY29uID0gdXRpbHNfMS5VdGlscy5jcmVhdGVJY29uTm9TcGFuKCdncm91cENvbnRyYWN0ZWQnLCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgbnVsbCk7XG4gICAgICAgIHRoaXMuZUV4cGFuZGVkLmFwcGVuZENoaWxkKGVFeHBhbmRlZEljb24pO1xuICAgICAgICB0aGlzLmVDb250cmFjdGVkLmFwcGVuZENoaWxkKGVDb250cmFjdGVkSWNvbik7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZUV4cGFuZGVkLCAnY2xpY2snLCB0aGlzLm9uRXhwYW5kQ2xpY2tlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lQ29udHJhY3RlZCwgJ2NsaWNrJywgdGhpcy5vbkV4cGFuZENsaWNrZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIGV4cGFuZCAvIGNvbnRyYWN0IGFzIHRoZSB1c2VyIGhpdHMgZW50ZXJcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoZUdyb3VwQ2VsbCwgJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIocGFyYW1zLm5vZGUsIHJvd05vZGVfMS5Sb3dOb2RlLkVWRU5UX0VYUEFOREVEX0NIQU5HRUQsIHRoaXMuc2hvd0V4cGFuZEFuZENvbnRyYWN0SWNvbnMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc2hvd0V4cGFuZEFuZENvbnRyYWN0SWNvbnMoKTtcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzaG93IHRoZSBleHBhbmQgLyBjb250cmFjdCB3aGVuIHRoZXJlIGFyZSBubyBjaGlsZHJlbiwgd2UgbmVlZCB0byBjaGVjayBldmVyeSB0aW1lXG4gICAgICAgIC8vIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gY2hhbmdlLlxuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmRpc3BsYXllZEdyb3VwLCByb3dOb2RlXzEuUm93Tm9kZS5FVkVOVF9BTExfQ0hJTERSRU5fQ09VTlRfQ0hBTkdFRCwgdGhpcy5zaG93RXhwYW5kQW5kQ29udHJhY3RJY29ucy5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gaWYgZWRpdGluZyBncm91cHMsIHRoZW4gZG91YmxlIGNsaWNrIGlzIHRvIHN0YXJ0IGVkaXRpbmdcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZUdyb3VwRWRpdCgpICYmIHRoaXMuaXNFeHBhbmRhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKGVHcm91cENlbGwsICdkYmxjbGljaycsIHRoaXMub25DZWxsRGJsQ2xpY2tlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLm9uS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5pc0tleVByZXNzZWQoZXZlbnQsIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfRU5URVIpKSB7XG4gICAgICAgICAgICB2YXIgY2VsbEVkaXRhYmxlID0gdGhpcy5wYXJhbXMuY29sdW1uLmlzQ2VsbEVkaXRhYmxlKHRoaXMucGFyYW1zLm5vZGUpO1xuICAgICAgICAgICAgaWYgKGNlbGxFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm9uRXhwYW5kT3JDb250cmFjdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUuc2V0dXBEcmFnT3BlblBhcmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnBhcmFtcy5jb2x1bW47XG4gICAgICAgIHZhciByb3dOb2RlID0gdGhpcy5wYXJhbXMubm9kZTtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwSGlkZU9wZW5QYXJlbnRzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZEZyb21IaWRlT3BlblBhcmVudHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcm93Tm9kZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgYW5kIHdlIGFyZSBub3QgYSBncm91cCwgdGhlbiB3ZSBtdXN0IG9mIGJlZW4gZHJhZ2dlZCBkb3duLFxuICAgICAgICAgICAgLy8gYXMgb3RoZXJ3aXNlIHRoZSBjZWxsIHdvdWxkIGJlIGJsYW5rLCBhbmQgaWYgY2VsbCBpcyBibGFuaywgdGhpcyBtZXRob2QgaXMgbmV2ZXIgY2FsbGVkLlxuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkRnJvbUhpZGVPcGVuUGFyZW50cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcm93R3JvdXBDb2x1bW4gPSByb3dOb2RlLnJvd0dyb3VwQ29sdW1uO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGRpc3BsYXlHcm91cCBjb2x1bW4gZm9yIHRoaXMgY29sIG1hdGNoZXMgdGhlIHJvd0dyb3VwQ29sdW1uIHdlIGdyb3VwZWQgYnkgZm9yIHRoaXMgbm9kZSxcbiAgICAgICAgICAgIC8vIHRoZW4gbm90aGluZyB3YXMgZHJhZ2dlZCBkb3duXG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRGcm9tSGlkZU9wZW5QYXJlbnRzID0gIWNvbHVtbi5pc1Jvd0dyb3VwRGlzcGxheWVkKHJvd0dyb3VwQ29sdW1uLmdldElkKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWRGcm9tSGlkZU9wZW5QYXJlbnRzKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9IHJvd05vZGUucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5taXNzaW5nKHBvaW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlci5yb3dHcm91cENvbHVtbiAmJiBjb2x1bW4uaXNSb3dHcm91cERpc3BsYXllZChwb2ludGVyLnJvd0dyb3VwQ29sdW1uLmdldElkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkR3JvdXAgPSBwb2ludGVyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgZGlzcGxheWVkIGdyb3VwLCBzZXQgaXQgdG8gdGhlIHJvdyBub2RlXG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5kaXNwbGF5ZWRHcm91cCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkR3JvdXAgPSByb3dOb2RlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUub25FeHBhbmRDbGlja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uRXhwYW5kT3JDb250cmFjdCgpO1xuICAgIH07XG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLm9uQ2VsbERibENsaWNrZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBhdm9pZCBhY3Rpbmcgb24gZG91YmxlIGNsaWNrIGV2ZW50cyBvbiB0aGUgZXhwYW5kIC8gY29udHJhY3QgaWNvbixcbiAgICAgICAgLy8gYXMgdGhhdCBpY29ucyBhbHJlYWR5IGhhcyBleHBhbmQgLyBjb2xsYXBzZSBmdW5jdGlvbmFsaXR5IG9uIGl0LiBvdGhlcndpc2UgaWZcbiAgICAgICAgLy8gdGhlIGljb24gd2FzIGRvdWJsZSBjbGlja2VkLCB3ZSB3b3VsZCBnZXQgJ2NsaWNrJywgJ2NsaWNrJywgJ2RibGNsaWNrJyB3aGljaFxuICAgICAgICAvLyBpcyBvcGVuLT5jbG9zZS0+b3BlbiwgaG93ZXZlciBkb3VibGUgY2xpY2sgc2hvdWxkIGJlIG9wZW4tPmNsb3NlIG9ubHkuXG4gICAgICAgIHZhciB0YXJnZXRJc0V4cGFuZEljb24gPSB1dGlsc18xLlV0aWxzLmlzRWxlbWVudEluRXZlbnRQYXRoKHRoaXMuZUV4cGFuZGVkLCBldmVudClcbiAgICAgICAgICAgIHx8IHV0aWxzXzEuVXRpbHMuaXNFbGVtZW50SW5FdmVudFBhdGgodGhpcy5lQ29udHJhY3RlZCwgZXZlbnQpO1xuICAgICAgICBpZiAoIXRhcmdldElzRXhwYW5kSWNvbikge1xuICAgICAgICAgICAgdGhpcy5vbkV4cGFuZE9yQ29udHJhY3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLm9uRXhwYW5kT3JDb250cmFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbXVzdCB1c2UgdGhlIGRpc3BsYXllZEdyb3VwLCBzbyBpZiBkYXRhIHdhcyBkcmFnZ2VkIGRvd24sIHdlIGV4cGFuZCB0aGUgcGFyZW50LCBub3QgdGhpcyByb3dcbiAgICAgICAgdmFyIHJvd05vZGUgPSB0aGlzLmRpc3BsYXllZEdyb3VwO1xuICAgICAgICByb3dOb2RlLnNldEV4cGFuZGVkKCFyb3dOb2RlLmV4cGFuZGVkKTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzR3JvdXBJbmNsdWRlRm9vdGVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmFwaS5yZWRyYXdSb3dzKHsgcm93Tm9kZXM6IFtyb3dOb2RlXSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLmlzRXhwYW5kYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd05vZGUgPSB0aGlzLnBhcmFtcy5ub2RlO1xuICAgICAgICB2YXIgcmVkdWNlZExlYWZOb2RlID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGl2b3RNb2RlKCkgJiYgcm93Tm9kZS5sZWFmR3JvdXA7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdnZWRGcm9tSGlkZU9wZW5QYXJlbnRzIHx8XG4gICAgICAgICAgICAocm93Tm9kZS5pc0V4cGFuZGFibGUoKSAmJiAhcm93Tm9kZS5mb290ZXIgJiYgIXJlZHVjZWRMZWFmTm9kZSk7XG4gICAgfTtcbiAgICBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUuc2hvd0V4cGFuZEFuZENvbnRyYWN0SWNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dOb2RlID0gdGhpcy5wYXJhbXMubm9kZTtcbiAgICAgICAgaWYgKHRoaXMuaXNFeHBhbmRhYmxlKCkpIHtcbiAgICAgICAgICAgIC8vIGlmIGV4cGFuZGFibGUsIHNob3cgb25lIGJhc2VkIG9uIGV4cGFuZCBzdGF0ZS5cbiAgICAgICAgICAgIC8vIGlmIHdlIHdlcmUgZHJhZ2dlZCBkb3duLCBtZWFucyBvdXIgcGFyZW50IGlzIGFsd2F5cyBleHBhbmRlZFxuICAgICAgICAgICAgdmFyIGV4cGFuZGVkID0gdGhpcy5kcmFnZ2VkRnJvbUhpZGVPcGVuUGFyZW50cyA/IHRydWUgOiByb3dOb2RlLmV4cGFuZGVkO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5zZXRWaXNpYmxlKHRoaXMuZUNvbnRyYWN0ZWQsICFleHBhbmRlZCk7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnNldFZpc2libGUodGhpcy5lRXhwYW5kZWQsIGV4cGFuZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0IG5vdCBleHBhbmRhYmxlLCBzaG93IG5laXRoZXJcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuc2V0VmlzaWJsZSh0aGlzLmVFeHBhbmRlZCwgZmFsc2UpO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5zZXRWaXNpYmxlKHRoaXMuZUNvbnRyYWN0ZWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEdyb3VwQ2VsbFJlbmRlcmVyLlRFTVBMQVRFID0gJzxzcGFuPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJhZy1ncm91cC1leHBhbmRlZFwiIHJlZj1cImVFeHBhbmRlZFwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiYWctZ3JvdXAtY29udHJhY3RlZFwiIHJlZj1cImVDb250cmFjdGVkXCI+PC9zcGFuPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJhZy1ncm91cC1jaGVja2JveFwiIHJlZj1cImVDaGVja2JveFwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiYWctZ3JvdXAtdmFsdWVcIiByZWY9XCJlVmFsdWVcIj48L3NwYW4+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImFnLWdyb3VwLWNoaWxkLWNvdW50XCIgcmVmPVwiZUNoaWxkQ291bnRcIj48L3NwYW4+JyArXG4gICAgICAgICc8L3NwYW4+JztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdleHByZXNzaW9uU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXhwcmVzc2lvblNlcnZpY2VfMS5FeHByZXNzaW9uU2VydmljZSlcbiAgICBdLCBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUsIFwiZXhwcmVzc2lvblNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgR3JvdXBDZWxsUmVuZGVyZXIucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjZWxsUmVuZGVyZXJTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjZWxsUmVuZGVyZXJTZXJ2aWNlXzEuQ2VsbFJlbmRlcmVyU2VydmljZSlcbiAgICBdLCBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUsIFwiY2VsbFJlbmRlcmVyU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCd2YWx1ZUZvcm1hdHRlclNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHZhbHVlRm9ybWF0dGVyU2VydmljZV8xLlZhbHVlRm9ybWF0dGVyU2VydmljZSlcbiAgICBdLCBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0ZXJTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIEdyb3VwQ2VsbFJlbmRlcmVyLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIEdyb3VwQ2VsbFJlbmRlcmVyLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ21vdXNlRXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBtb3VzZUV2ZW50U2VydmljZV8xLk1vdXNlRXZlbnRTZXJ2aWNlKVxuICAgIF0sIEdyb3VwQ2VsbFJlbmRlcmVyLnByb3RvdHlwZSwgXCJtb3VzZUV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdlRXhwYW5kZWQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEdyb3VwQ2VsbFJlbmRlcmVyLnByb3RvdHlwZSwgXCJlRXhwYW5kZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5SZWZTZWxlY3RvcignZUNvbnRyYWN0ZWQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEdyb3VwQ2VsbFJlbmRlcmVyLnByb3RvdHlwZSwgXCJlQ29udHJhY3RlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdlQ2hlY2tib3gnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEdyb3VwQ2VsbFJlbmRlcmVyLnByb3RvdHlwZSwgXCJlQ2hlY2tib3hcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5SZWZTZWxlY3RvcignZVZhbHVlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MRWxlbWVudClcbiAgICBdLCBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUsIFwiZVZhbHVlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2VDaGlsZENvdW50JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MRWxlbWVudClcbiAgICBdLCBHcm91cENlbGxSZW5kZXJlci5wcm90b3R5cGUsIFwiZUNoaWxkQ291bnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gR3JvdXBDZWxsUmVuZGVyZXI7XG59KGNvbXBvbmVudF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5Hcm91cENlbGxSZW5kZXJlciA9IEdyb3VwQ2VsbFJlbmRlcmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxSZW5kZXJlcnMvZ3JvdXBDZWxsUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuLi93aWRnZXRzL2NvbXBvbmVudFwiKTtcbnZhciByb3dOb2RlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvcm93Tm9kZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4uL2V2ZW50c1wiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgZ3JpZEFwaV8xID0gcmVxdWlyZShcIi4uL2dyaWRBcGlcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBDaGVja2JveFNlbGVjdGlvbkNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCI8c3BhbiBjbGFzcz1cXFwiYWctc2VsZWN0aW9uLWNoZWNrYm94XFxcIi8+XCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVBbmRBZGRJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lQ2hlY2tlZEljb24gPSB1dGlsc18xLlV0aWxzLmNyZWF0ZUljb25Ob1NwYW4oJ2NoZWNrYm94Q2hlY2tlZCcsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCB0aGlzLmNvbHVtbik7XG4gICAgICAgIHRoaXMuZVVuY2hlY2tlZEljb24gPSB1dGlsc18xLlV0aWxzLmNyZWF0ZUljb25Ob1NwYW4oJ2NoZWNrYm94VW5jaGVja2VkJywgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIHRoaXMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lSW5kZXRlcm1pbmF0ZUljb24gPSB1dGlsc18xLlV0aWxzLmNyZWF0ZUljb25Ob1NwYW4oJ2NoZWNrYm94SW5kZXRlcm1pbmF0ZScsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCB0aGlzLmNvbHVtbik7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRHdWkoKTtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmVDaGVja2VkSWNvbik7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5lVW5jaGVja2VkSWNvbik7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5lSW5kZXRlcm1pbmF0ZUljb24pO1xuICAgIH07XG4gICAgQ2hlY2tib3hTZWxlY3Rpb25Db21wb25lbnQucHJvdG90eXBlLm9uU2VsZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5yb3dOb2RlLmlzU2VsZWN0ZWQoKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5zZXRWaXNpYmxlKHRoaXMuZUNoZWNrZWRJY29uLCBzdGF0ZSA9PT0gdHJ1ZSk7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuc2V0VmlzaWJsZSh0aGlzLmVVbmNoZWNrZWRJY29uLCBzdGF0ZSA9PT0gZmFsc2UpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLnNldFZpc2libGUodGhpcy5lSW5kZXRlcm1pbmF0ZUljb24sIHR5cGVvZiBzdGF0ZSAhPT0gJ2Jvb2xlYW4nKTtcbiAgICB9O1xuICAgIENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5vbkNoZWNrZWRDbGlja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXBTZWxlY3RzRmlsdGVyZWQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwU2VsZWN0c0ZpbHRlcmVkKCk7XG4gICAgICAgIHZhciB1cGRhdGVkQ291bnQgPSB0aGlzLnJvd05vZGUuc2V0U2VsZWN0ZWRQYXJhbXMoeyBuZXdWYWx1ZTogZmFsc2UsIGdyb3VwU2VsZWN0c0ZpbHRlcmVkOiBncm91cFNlbGVjdHNGaWx0ZXJlZCB9KTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRDb3VudDtcbiAgICB9O1xuICAgIENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5vblVuY2hlY2tlZENsaWNrZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyb3VwU2VsZWN0c0ZpbHRlcmVkID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNHcm91cFNlbGVjdHNGaWx0ZXJlZCgpO1xuICAgICAgICB2YXIgdXBkYXRlZENvdW50ID0gdGhpcy5yb3dOb2RlLnNldFNlbGVjdGVkUGFyYW1zKHsgbmV3VmFsdWU6IHRydWUsIHJhbmdlU2VsZWN0OiBldmVudC5zaGlmdEtleSwgZ3JvdXBTZWxlY3RzRmlsdGVyZWQ6IGdyb3VwU2VsZWN0c0ZpbHRlcmVkIH0pO1xuICAgICAgICByZXR1cm4gdXBkYXRlZENvdW50O1xuICAgIH07XG4gICAgQ2hlY2tib3hTZWxlY3Rpb25Db21wb25lbnQucHJvdG90eXBlLm9uSW5kZXRlcm1pbmF0ZUNsaWNrZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMub25VbmNoZWNrZWRDbGlja2VkKGV2ZW50KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vbkNoZWNrZWRDbGlja2VkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnJvd05vZGUgPSBwYXJhbXMucm93Tm9kZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBwYXJhbXMuY29sdW1uO1xuICAgICAgICB0aGlzLnZpc2libGVGdW5jID0gcGFyYW1zLnZpc2libGVGdW5jO1xuICAgICAgICB0aGlzLmNyZWF0ZUFuZEFkZEljb25zKCk7XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHJvdyBjbGlja2VkIGV2ZW50IHRvIGZpcmUgd2hlbiBzZWxlY3RpbmcgdGhlIGNoZWNrYm94LCBvdGhlcndpc2UgdGhlIHJvd1xuICAgICAgICAvLyB3b3VsZCBwb3NzaWJseSBnZXQgc2VsZWN0ZWQgdHdpY2VcbiAgICAgICAgdGhpcy5hZGRHdWlFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IH0pO1xuICAgICAgICAvLyBsaWtld2lzZSB3ZSBkb24ndCB3YW50IGRvdWJsZSBjbGljayBvbiB0aGlzIGljb24gdG8gb3BlbiBhIGdyb3VwXG4gICAgICAgIHRoaXMuYWRkR3VpRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyB9KTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lQ2hlY2tlZEljb24sICdjbGljaycsIHRoaXMub25DaGVja2VkQ2xpY2tlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lVW5jaGVja2VkSWNvbiwgJ2NsaWNrJywgdGhpcy5vblVuY2hlY2tlZENsaWNrZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZUluZGV0ZXJtaW5hdGVJY29uLCAnY2xpY2snLCB0aGlzLm9uSW5kZXRlcm1pbmF0ZUNsaWNrZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMucm93Tm9kZSwgcm93Tm9kZV8xLlJvd05vZGUuRVZFTlRfUk9XX1NFTEVDVEVELCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZUZ1bmMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfRElTUExBWUVEX0NPTFVNTlNfQ0hBTkdFRCwgdGhpcy5zaG93T3JIaWRlU2VsZWN0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5zaG93T3JIaWRlU2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5zaG93T3JIaWRlU2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5jcmVhdGVQYXJhbXMoKTtcbiAgICAgICAgdmFyIHZpc2libGUgPSB0aGlzLnZpc2libGVGdW5jKHBhcmFtcyk7XG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9O1xuICAgIENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBub2RlOiB0aGlzLnJvd05vZGUsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLnJvd05vZGUuZGF0YSxcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICBjb2xEZWY6IHRoaXMuY29sdW1uLmdldENvbERlZigpLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgQ2hlY2tib3hTZWxlY3Rpb25Db21wb25lbnQucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdldmVudFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSlcbiAgICBdLCBDaGVja2JveFNlbGVjdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRBcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRBcGlfMS5HcmlkQXBpKVxuICAgIF0sIENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkFwaSlcbiAgICBdLCBDaGVja2JveFNlbGVjdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uQXBpXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIENoZWNrYm94U2VsZWN0aW9uQ29tcG9uZW50O1xufShjb21wb25lbnRfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuQ2hlY2tib3hTZWxlY3Rpb25Db21wb25lbnQgPSBDaGVja2JveFNlbGVjdGlvbkNvbXBvbmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9jaGVja2JveFNlbGVjdGlvbkNvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBncmlkUGFuZWxfMSA9IHJlcXVpcmUoXCIuLi9ncmlkUGFuZWwvZ3JpZFBhbmVsXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgQ29sdW1uQW5pbWF0aW9uU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sdW1uQW5pbWF0aW9uU2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5leGVjdXRlTmV4dEZ1bmNzID0gW107XG4gICAgICAgIHRoaXMuZXhlY3V0ZUxhdGVyRnVuY3MgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25UaHJlYWRDb3VudCA9IDA7XG4gICAgfVxuICAgIENvbHVtbkFuaW1hdGlvblNlcnZpY2UucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgfTtcbiAgICBDb2x1bW5BbmltYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NDb2x1bW5Nb3ZlQW5pbWF0aW9uKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBkb2luZyBSVEwsIHdlIGRvbid0IGFuaW1hdGUgb3BlbiAvIGNsb3NlIGFzIGR1ZSB0byBob3cgdGhlIHBpeGVscyBhcmUgaW52ZXJ0ZWQsXG4gICAgICAgIC8vIHRoZSBhbmltYXRpb24gbW92ZXMgYWxsIHRoZSByb3cgdGhlIHRoZSByaWdodCByYXRoZXIgdGhhbiB0byB0aGUgbGVmdCAoaWUgaXQncyB0aGUgc3RhdGljXG4gICAgICAgIC8vIGNvbHVtbnMgdGhhdCBhY3R1YWxseSBnZXQgdGhlaXIgY29vcmRpbmF0ZXMgdXBkYXRlZClcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuc3VyZUFuaW1hdGlvbkNzc0NsYXNzUHJlc2VudCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfTtcbiAgICBDb2x1bW5BbmltYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfTtcbiAgICBDb2x1bW5BbmltYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5leGVjdXRlTmV4dFZNVHVybiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5leGVjdXRlTmV4dEZ1bmNzLnB1c2goZnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbkFuaW1hdGlvblNlcnZpY2UucHJvdG90eXBlLmV4ZWN1dGVMYXRlclZNVHVybiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5leGVjdXRlTGF0ZXJGdW5jcy5wdXNoKGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5BbmltYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5lbnN1cmVBbmltYXRpb25Dc3NDbGFzc1ByZXNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIHVwIHRoZSBjb3VudCwgc28gd2UgY2FuIHRlbGwgaWYgc29tZW9uZSBlbHNlIGhhcyB1cGRhdGVkIHRoZSBjb3VudFxuICAgICAgICAvLyBieSB0aGUgdGltZSB0aGUgJ3dhaXQnIGZ1bmMgZXhlY3V0ZXNcbiAgICAgICAgdGhpcy5hbmltYXRpb25UaHJlYWRDb3VudCsrO1xuICAgICAgICB2YXIgYW5pbWF0aW9uVGhyZWFkQ291bnRDb3B5ID0gdGhpcy5hbmltYXRpb25UaHJlYWRDb3VudDtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRDc3NDbGFzcyh0aGlzLmdyaWRQYW5lbC5nZXRSb290KCksICdhZy1jb2x1bW4tbW92aW5nJyk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZUxhdGVyRnVuY3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHJlbW92ZSB0aGUgY2xhc3MgaWYgdGhpcyB0aHJlYWQgd2FzIHRoZSBsYXN0IG9uZSB0byB1cGRhdGUgaXRcbiAgICAgICAgICAgIGlmIChfdGhpcy5hbmltYXRpb25UaHJlYWRDb3VudCA9PT0gYW5pbWF0aW9uVGhyZWFkQ291bnRDb3B5KSB7XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVDc3NDbGFzcyhfdGhpcy5ncmlkUGFuZWwuZ2V0Um9vdCgpLCAnYWctY29sdW1uLW1vdmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbHVtbkFuaW1hdGlvblNlcnZpY2UucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm93RnVuY3MgPSB0aGlzLmV4ZWN1dGVOZXh0RnVuY3M7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU5leHRGdW5jcyA9IFtdO1xuICAgICAgICB2YXIgd2FpdEZ1bmNzID0gdGhpcy5leGVjdXRlTGF0ZXJGdW5jcztcbiAgICAgICAgdGhpcy5leGVjdXRlTGF0ZXJGdW5jcyA9IFtdO1xuICAgICAgICBpZiAobm93RnVuY3MubGVuZ3RoID09PSAwICYmIHdhaXRGdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vd0Z1bmNzLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIGZ1bmMoKTsgfSk7IH0sIDApO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdhaXRGdW5jcy5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7IHJldHVybiBmdW5jKCk7IH0pOyB9LCAzMDApO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIENvbHVtbkFuaW1hdGlvblNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkUGFuZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRQYW5lbF8xLkdyaWRQYW5lbClcbiAgICBdLCBDb2x1bW5BbmltYXRpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJncmlkUGFuZWxcIiwgdm9pZCAwKTtcbiAgICBDb2x1bW5BbmltYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdjb2x1bW5BbmltYXRpb25TZXJ2aWNlJylcbiAgICBdLCBDb2x1bW5BbmltYXRpb25TZXJ2aWNlKTtcbiAgICByZXR1cm4gQ29sdW1uQW5pbWF0aW9uU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkNvbHVtbkFuaW1hdGlvblNlcnZpY2UgPSBDb2x1bW5BbmltYXRpb25TZXJ2aWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NvbHVtbkFuaW1hdGlvblNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi9ldmVudHNcIik7XG52YXIgYmVhblN0dWJfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2JlYW5TdHViXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgZ3JpZEFwaV8xID0gcmVxdWlyZShcIi4uL2dyaWRBcGlcIik7XG52YXIgQ29sdW1uSG92ZXJTZXJ2aWNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sdW1uSG92ZXJTZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbHVtbkhvdmVyU2VydmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDb2x1bW5Ib3ZlclNlcnZpY2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfQ0VMTF9NT1VTRV9PVkVSLCB0aGlzLm9uQ2VsbE1vdXNlT3Zlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DRUxMX01PVVNFX09VVCwgdGhpcy5vbkNlbGxNb3VzZU91dC5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIENvbHVtbkhvdmVyU2VydmljZS5wcm90b3R5cGUub25DZWxsTW91c2VPdmVyID0gZnVuY3Rpb24gKGNlbGxFdmVudCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRseVNlbGVjdGVkQ29sdW1uID0gY2VsbEV2ZW50LmNvbHVtbjtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9IT1ZFUl9DSEFOR0VELFxuICAgICAgICAgICAgYXBpOiB0aGlzLmdyaWRBcGksXG4gICAgICAgICAgICBjb2x1bW5BcGk6IHRoaXMuY29sdW1uQXBpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgQ29sdW1uSG92ZXJTZXJ2aWNlLnByb3RvdHlwZS5vbkNlbGxNb3VzZU91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50bHlTZWxlY3RlZENvbHVtbiA9IG51bGw7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fSE9WRVJfQ0hBTkdFRCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIENvbHVtbkhvdmVyU2VydmljZS5wcm90b3R5cGUuaXNIb3ZlcmVkID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gY29sdW1uID09IHRoaXMuY3VycmVudGx5U2VsZWN0ZWRDb2x1bW47XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgQ29sdW1uSG92ZXJTZXJ2aWNlLnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIENvbHVtbkhvdmVyU2VydmljZS5wcm90b3R5cGUsIFwiY29sdW1uQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRBcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRBcGlfMS5HcmlkQXBpKVxuICAgIF0sIENvbHVtbkhvdmVyU2VydmljZS5wcm90b3R5cGUsIFwiZ3JpZEFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBDb2x1bW5Ib3ZlclNlcnZpY2UucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgQ29sdW1uSG92ZXJTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdjb2x1bW5Ib3ZlclNlcnZpY2UnKVxuICAgIF0sIENvbHVtbkhvdmVyU2VydmljZSk7XG4gICAgcmV0dXJuIENvbHVtbkhvdmVyU2VydmljZTtcbn0oYmVhblN0dWJfMS5CZWFuU3R1YikpO1xuZXhwb3J0cy5Db2x1bW5Ib3ZlclNlcnZpY2UgPSBDb2x1bW5Ib3ZlclNlcnZpY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yZW5kZXJpbmcvY29sdW1uSG92ZXJTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIGJlYW5TdHViXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9iZWFuU3R1YlwiKTtcbnZhciByb3dOb2RlQmxvY2tfMSA9IHJlcXVpcmUoXCIuL3Jvd05vZGVCbG9ja1wiKTtcbnZhciBSb3dOb2RlQ2FjaGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb3dOb2RlQ2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm93Tm9kZUNhY2hlKGNhY2hlUGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1heFJvd0ZvdW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmJsb2NrcyA9IHt9O1xuICAgICAgICBfdGhpcy5ibG9ja0NvdW50ID0gMDtcbiAgICAgICAgX3RoaXMudmlydHVhbFJvd0NvdW50ID0gY2FjaGVQYXJhbXMuaW5pdGlhbFJvd0NvdW50O1xuICAgICAgICBfdGhpcy5jYWNoZVBhcmFtcyA9IGNhY2hlUGFyYW1zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZm9yRWFjaEJsb2NrSW5PcmRlcihmdW5jdGlvbiAoYmxvY2spIHsgcmV0dXJuIF90aGlzLmRlc3Ryb3lCbG9jayhibG9jayk7IH0pO1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveUZ1bmMoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWN0aXZlID0gZmFsc2U7IH0pO1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5nZXRWaXJ0dWFsUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpcnR1YWxSb3dDb3VudDtcbiAgICB9O1xuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUuaGFja19zZXRWaXJ0dWFsUm93Q291bnQgPSBmdW5jdGlvbiAodmlydHVhbFJvd0NvdW50KSB7XG4gICAgICAgIHRoaXMudmlydHVhbFJvd0NvdW50ID0gdmlydHVhbFJvd0NvdW50O1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5pc01heFJvd0ZvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhSb3dGb3VuZDtcbiAgICB9O1xuICAgIC8vIGxpc3RlbmVyIG9uIEVWRU5UX0xPQURfQ09NUExFVEVcbiAgICBSb3dOb2RlQ2FjaGUucHJvdG90eXBlLm9uUGFnZUxvYWRlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IGFjdGl2ZSwgdGhlbiB3ZSBpZ25vcmUgYWxsIGV2ZW50cywgb3RoZXJ3aXNlIHdlIGNvdWxkIGVuZCB1cCBnZXR0aW5nIHRoZVxuICAgICAgICAvLyBncmlkIHRvIHJlZnJlc2ggZXZlbiB0aG91Z2ggd2UgYXJlIG5vIGxvbmdlciB0aGUgYWN0aXZlIGNhY2hlXG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwib25QYWdlTG9hZGVkOiBwYWdlID0gXCIgKyBldmVudC5wYWdlLmdldEJsb2NrTnVtYmVyKCkgKyBcIiwgbGFzdFJvdyA9IFwiICsgZXZlbnQubGFzdFJvdyk7XG4gICAgICAgIHRoaXMuY2FjaGVQYXJhbXMucm93Tm9kZUJsb2NrTG9hZGVyLmxvYWRDb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmNoZWNrQmxvY2tUb0xvYWQoKTtcbiAgICAgICAgaWYgKGV2ZW50LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWaXJ0dWFsUm93Q291bnQoZXZlbnQucGFnZSwgZXZlbnQubGFzdFJvdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUucHVyZ2VCbG9ja3NJZk5lZWRlZCA9IGZ1bmN0aW9uIChibG9ja1RvRXhjbHVkZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBubyBwdXJnZSBpZiB1c2VyIGRpZG4ndCBnaXZlIG1heEJsb2Nrc0luQ2FjaGVcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyh0aGlzLmNhY2hlUGFyYW1zLm1heEJsb2Nrc0luQ2FjaGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gcHVyZ2UgaWYgYmxvY2sgY291bnQgaXMgbGVzcyB0aGFuIG1heCBhbGxvd2VkXG4gICAgICAgIGlmICh0aGlzLmJsb2NrQ291bnQgPD0gdGhpcy5jYWNoZVBhcmFtcy5tYXhCbG9ja3NJbkNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHV0IGFsbCBjYW5kaWRhdGUgYmxvY2tzIGludG8gYSBsaXN0IGZvciBzb3J0aW5nXG4gICAgICAgIHZhciBibG9ja3NGb3JQdXJnaW5nID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaEJsb2NrSW5PcmRlcihmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgIC8vIHdlIGV4Y2x1ZGUgY2hlY2tpbmcgZm9yIHRoZSBwYWdlIGp1c3QgY3JlYXRlZCwgYXMgdGhpcyBoYXMgeWV0IHRvIGJlIGFjY2Vzc2VkIGFuZCBoZW5jZVxuICAgICAgICAgICAgLy8gdGhlIGxhc3RBY2Nlc3NlZCBzdGFtcCB3aWxsIG5vdCBiZSB1cGRhdGVkIGZvciB0aGUgZmlyc3QgdGltZSB5ZXRcbiAgICAgICAgICAgIGlmIChibG9jayA9PT0gYmxvY2tUb0V4Y2x1ZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja3NGb3JQdXJnaW5nLnB1c2goYmxvY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdG9kbzogbmVlZCB0byB2ZXJpZnkgdGhhdCB0aGlzIHNvcnRzIGl0ZW1zIGluIHRoZSByaWdodCBvcmRlclxuICAgICAgICBibG9ja3NGb3JQdXJnaW5nLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIuZ2V0TGFzdEFjY2Vzc2VkKCkgLSBhLmdldExhc3RBY2Nlc3NlZCgpOyB9KTtcbiAgICAgICAgLy8gd2UgcmVtb3ZlIChtYXhCbG9ja3NJbkNhY2hlIC0gMSkgYXMgd2UgYWxyZWFkeSBleGNsdWRlZCB0aGUgJ2p1c3QgY3JlYXRlZCcgcGFnZS5cbiAgICAgICAgLy8gaW4gb3RoZXIgd29yZHMsIGFmdGVyIHRoZSBzcGxpY2Ugb3BlcmF0aW9uIGJlbG93LCB3ZSBoYXZlIHRha2VuIG91dCB0aGUgYmxvY2tzXG4gICAgICAgIC8vIHdlIHdhbnQgdG8ga2VlcCwgd2hpY2ggbWVhbnMgd2UgYXJlIGxlZnQgd2l0aCBibG9ja3MgdGhhdCB3ZSBjYW4gcG90ZW50aWFsbHkgcHVyZ2VcbiAgICAgICAgdmFyIGJsb2Nrc1RvS2VlcCA9IHRoaXMuY2FjaGVQYXJhbXMubWF4QmxvY2tzSW5DYWNoZSAtIDE7XG4gICAgICAgIGJsb2Nrc0ZvclB1cmdpbmcuc3BsaWNlKDAsIGJsb2Nrc1RvS2VlcCk7XG4gICAgICAgIC8vIHRyeSBhbmQgcHVyZ2UgZWFjaCBibG9ja1xuICAgICAgICBibG9ja3NGb3JQdXJnaW5nLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZXZlciBwdXJnZSBibG9ja3MgaWYgdGhleSBhcmUgb3BlbiwgYXMgcHVyZ2luZyB0aGVtIHdvdWxkIG1lc3MgdXAgd2l0aFxuICAgICAgICAgICAgLy8gb3VyIGluZGV4ZXMsIGl0IHdvdWxkIGJlIHZlcnkgbWVzc3kgdG8gcmVzdG9yZSB0aGUgcHVyZ2VkIGJsb2NrIHRvIGl0J3NcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHN0YXRlIGlmIGl0IGhhZCBvcGVuIGNoaWxkcmVuIChhbmQgd2hhdCBpZiBvcGVuIGNoaWxkcmVuIG9mIG9wZW5cbiAgICAgICAgICAgIC8vIGNoaWxkcmVuLCBqZWVlZXN1cywganVzdCB0aGlua2luZyBhYm91dCBpdCBmcmVha3MgbWUgb3V0KSBzbyBiZXN0IGlzIGhhdmUgYVxuICAgICAgICAgICAgLy8gcnVsZSwgaWYgYmxvY2sgaXMgb3Blbiwgd2UgbmV2ZXIgcHVyZ2UuXG4gICAgICAgICAgICBpZiAoYmxvY2suaXNBbnlOb2RlT3BlbihfdGhpcy52aXJ0dWFsUm93Q291bnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCwgYmxvY2sgaXMgbm90IG5lZWRlZCwgYW5kIG5vIG9wZW4gbm9kZXMsIHNvIGJ1cm4gYmFieSBidXJuXG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVCbG9ja0Zyb21DYWNoZShibG9jayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5wb3N0Q3JlYXRlQmxvY2sgPSBmdW5jdGlvbiAobmV3QmxvY2spIHtcbiAgICAgICAgbmV3QmxvY2suYWRkRXZlbnRMaXN0ZW5lcihyb3dOb2RlQmxvY2tfMS5Sb3dOb2RlQmxvY2suRVZFTlRfTE9BRF9DT01QTEVURSwgdGhpcy5vblBhZ2VMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc2V0QmxvY2sobmV3QmxvY2suZ2V0QmxvY2tOdW1iZXIoKSwgbmV3QmxvY2spO1xuICAgICAgICB0aGlzLnB1cmdlQmxvY2tzSWZOZWVkZWQobmV3QmxvY2spO1xuICAgICAgICB0aGlzLmNoZWNrQmxvY2tUb0xvYWQoKTtcbiAgICB9O1xuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUucmVtb3ZlQmxvY2tGcm9tQ2FjaGUgPSBmdW5jdGlvbiAocGFnZVRvUmVtb3ZlKSB7XG4gICAgICAgIGlmICghcGFnZVRvUmVtb3ZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95QmxvY2socGFnZVRvUmVtb3ZlKTtcbiAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gcmVtb3ZlIHRoZSAnbG9hZGVkJyBldmVudCBsaXN0ZW5lciwgYXMgdGhlXG4gICAgICAgIC8vIGNvbmN1cnJlbnQgbG9hZHMgY291bnQgbmVlZHMgdG8gYmUgdXBkYXRlZCB3aGVuIHRoZSBsb2FkIGlzIGNvbXBsZXRlXG4gICAgICAgIC8vIGlmIHRoZSBwdXJnZWQgcGFnZSBpcyBpbiBsb2FkaW5nIHN0YXRlXG4gICAgfTtcbiAgICAvLyBnZXRzIGNhbGxlZCBhZnRlcjogMSkgYmxvY2sgbG9hZGVkIDIpIGJsb2NrIGNyZWF0ZWQgMykgY2FjaGUgcmVmcmVzaFxuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUuY2hlY2tCbG9ja1RvTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYWNoZVBhcmFtcy5yb3dOb2RlQmxvY2tMb2FkZXIuY2hlY2tCbG9ja1RvTG9hZCgpO1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5jaGVja1ZpcnR1YWxSb3dDb3VudCA9IGZ1bmN0aW9uIChibG9jaywgbGFzdFJvdykge1xuICAgICAgICAvLyBpZiBjbGllbnQgcHJvdmlkZWQgYSBsYXN0IHJvdywgd2UgYWx3YXlzIHVzZSBpdCwgYXMgaXQgY291bGQgY2hhbmdlIGJldHdlZW4gc2VydmVyIGNhbGxzXG4gICAgICAgIC8vIGlmIHVzZXIgZGVsZXRlZCBkYXRhIGFuZCB0aGVuIGNhbGxlZCByZWZyZXNoIG9uIHRoZSBncmlkLlxuICAgICAgICBpZiAodHlwZW9mIGxhc3RSb3cgPT09ICdudW1iZXInICYmIGxhc3RSb3cgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUm93Q291bnQgPSBsYXN0Um93O1xuICAgICAgICAgICAgdGhpcy5tYXhSb3dGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9uQ2FjaGVVcGRhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMubWF4Um93Rm91bmQpIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgc2VlIGlmIHdlIG5lZWQgdG8gYWRkIHNvbWUgdmlydHVhbCByb3dzXG4gICAgICAgICAgICB2YXIgbGFzdFJvd0luZGV4ID0gKGJsb2NrLmdldEJsb2NrTnVtYmVyKCkgKyAxKSAqIHRoaXMuY2FjaGVQYXJhbXMuYmxvY2tTaXplO1xuICAgICAgICAgICAgdmFyIGxhc3RSb3dJbmRleFBsdXNPdmVyZmxvdyA9IGxhc3RSb3dJbmRleCArIHRoaXMuY2FjaGVQYXJhbXMub3ZlcmZsb3dTaXplO1xuICAgICAgICAgICAgaWYgKHRoaXMudmlydHVhbFJvd0NvdW50IDwgbGFzdFJvd0luZGV4UGx1c092ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXJ0dWFsUm93Q291bnQgPSBsYXN0Um93SW5kZXhQbHVzT3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNhY2hlVXBkYXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jYWNoZVBhcmFtcy5keW5hbWljUm93SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9ubHkgb3RoZXIgdGltZSBpcyBpZiBkeW5hbWljIHJvdyBoZWlnaHQsIGFzIGxvYWRpbmcgcm93c1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgY2hhbmdlIHRoZSBoZWlnaHQgb2YgdGhlIGJsb2NrLCBnaXZlbiB0aGUgaGVpZ2h0IG9mIHRoZSByb3dzXG4gICAgICAgICAgICAgICAgLy8gaXMgb25seSBrbm93biBhZnRlciB0aGUgcm93IGlzIGxvYWRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2FjaGVVcGRhdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUuc2V0VmlydHVhbFJvd0NvdW50ID0gZnVuY3Rpb24gKHJvd0NvdW50LCBtYXhSb3dGb3VuZCkge1xuICAgICAgICB0aGlzLnZpcnR1YWxSb3dDb3VudCA9IHJvd0NvdW50O1xuICAgICAgICAvLyBpZiB1bmRlZmluZWQgaXMgcGFzc2VkLCB3ZSBkbyBub3Qgc2V0IHRoaXMgdmFsdWUsIGlmIG9uZSBvZiB7dHJ1ZSxmYWxzZX1cbiAgICAgICAgLy8gaXMgcGFzc2VkLCB3ZSBkbyBzZXQgdGhlIHZhbHVlLlxuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMobWF4Um93Rm91bmQpKSB7XG4gICAgICAgICAgICB0aGlzLm1heFJvd0ZvdW5kID0gbWF4Um93Rm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgYXJlIHN0aWxsIHNlYXJjaGluZywgdGhlbiB0aGUgcm93IGNvdW50IG11c3Qgbm90IGVuZCBhdCB0aGUgZW5kXG4gICAgICAgIC8vIG9mIGEgcGFydGljdWxhciBwYWdlLCBvdGhlcndpc2UgdGhlIHNlYXJjaGluZyB3aWxsIG5vdCBwb3AgaW50byB0aGVcbiAgICAgICAgLy8gbmV4dCBwYWdlXG4gICAgICAgIGlmICghdGhpcy5tYXhSb3dGb3VuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlydHVhbFJvd0NvdW50ICUgdGhpcy5jYWNoZVBhcmFtcy5ibG9ja1NpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxSb3dDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DYWNoZVVwZGF0ZWQoKTtcbiAgICB9O1xuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUuZm9yRWFjaE5vZGVEZWVwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzZXF1ZW5jZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZvckVhY2hCbG9ja0luT3JkZXIoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICBibG9jay5mb3JFYWNoTm9kZURlZXAoY2FsbGJhY2ssIHNlcXVlbmNlLCBfdGhpcy52aXJ0dWFsUm93Q291bnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUuZm9yRWFjaEJsb2NrSW5PcmRlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5nZXRCbG9ja0lkc1NvcnRlZCgpO1xuICAgICAgICB0aGlzLmZvckVhY2hCbG9ja0lkKGlkcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5mb3JFYWNoQmxvY2tJblJldmVyc2VPcmRlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5nZXRCbG9ja0lkc1NvcnRlZCgpLnJldmVyc2UoKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoQmxvY2tJZChpZHMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUuZm9yRWFjaEJsb2NrSWQgPSBmdW5jdGlvbiAoaWRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IF90aGlzLmJsb2Nrc1tpZF07XG4gICAgICAgICAgICBjYWxsYmFjayhibG9jaywgaWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUuZ2V0QmxvY2tJZHNTb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGdldCBhbGwgcGFnZSBpZCdzIGFzIE5VTUJFUlMgKG5vdCBzdHJpbmdzLCBhcyB3ZSBuZWVkIHRvIHNvcnQgYXMgbnVtYmVycykgYW5kIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgdmFyIG51bWJlckNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH07IC8vIGRlZmF1bHQgY29tcGFyYXRvciBmb3IgYXJyYXkgaXMgc3RyaW5nIGNvbXBhcmlzb25cbiAgICAgICAgdmFyIGJsb2NrSWRzID0gT2JqZWN0LmtleXModGhpcy5ibG9ja3MpLm1hcChmdW5jdGlvbiAoaWRTdHIpIHsgcmV0dXJuIHBhcnNlSW50KGlkU3RyKTsgfSkuc29ydChudW1iZXJDb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIGJsb2NrSWRzO1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5nZXRCbG9jayA9IGZ1bmN0aW9uIChibG9ja0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2Nrc1tibG9ja0lkXTtcbiAgICB9O1xuICAgIFJvd05vZGVDYWNoZS5wcm90b3R5cGUuc2V0QmxvY2sgPSBmdW5jdGlvbiAoaWQsIGJsb2NrKSB7XG4gICAgICAgIHRoaXMuYmxvY2tzW2lkXSA9IGJsb2NrO1xuICAgICAgICB0aGlzLmJsb2NrQ291bnQrKztcbiAgICAgICAgdGhpcy5jYWNoZVBhcmFtcy5yb3dOb2RlQmxvY2tMb2FkZXIuYWRkQmxvY2soYmxvY2spO1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5kZXN0cm95QmxvY2sgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYmxvY2tzW2Jsb2NrLmdldEJsb2NrTnVtYmVyKCldO1xuICAgICAgICBibG9jay5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuYmxvY2tDb3VudC0tO1xuICAgICAgICB0aGlzLmNhY2hlUGFyYW1zLnJvd05vZGVCbG9ja0xvYWRlci5yZW1vdmVCbG9jayhibG9jayk7XG4gICAgfTtcbiAgICAvLyBnZXRzIGNhbGxlZCAxKSByb3cgY291bnQgY2hhbmdlZCAyKSBjYWNoZSBwdXJnZWQgMykgaXRlbXMgaW5zZXJ0ZWRcbiAgICBSb3dOb2RlQ2FjaGUucHJvdG90eXBlLm9uQ2FjaGVVcGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHJlc3VsdHMgaW4gYm90aCByb3cgbW9kZWxzIChpbmZpbml0ZSBhbmQgZW50ZXJwcmlzZSkgZmlyaW5nIE1vZGVsVXBkYXRlZCxcbiAgICAgICAgICAgIC8vIGhvd2V2ZXIgZW50ZXJwcmlzZSBhbHNvIHVwZGF0ZXMgdGhlIHJvdyBpbmRleGVzIGZpcnN0XG4gICAgICAgICAgICB2YXIgZXZlbnRfMSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBSb3dOb2RlQ2FjaGUuRVZFTlRfQ0FDSEVfVVBEQVRFRFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudF8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLnByb3RvdHlwZS5wdXJnZUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZvckVhY2hCbG9ja0luT3JkZXIoZnVuY3Rpb24gKGJsb2NrKSB7IHJldHVybiBfdGhpcy5yZW1vdmVCbG9ja0Zyb21DYWNoZShibG9jayk7IH0pO1xuICAgICAgICB0aGlzLm9uQ2FjaGVVcGRhdGVkKCk7XG4gICAgfTtcbiAgICBSb3dOb2RlQ2FjaGUucHJvdG90eXBlLmdldFJvd05vZGVzSW5SYW5nZSA9IGZ1bmN0aW9uIChmaXJzdEluUmFuZ2UsIGxhc3RJblJhbmdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGxhc3RCbG9ja0lkID0gLTE7XG4gICAgICAgIHZhciBpbkFjdGl2ZVJhbmdlID0gZmFsc2U7XG4gICAgICAgIHZhciBudW1iZXJTZXF1ZW5jZSA9IG5ldyB1dGlsc18xLk51bWJlclNlcXVlbmNlKCk7XG4gICAgICAgIC8vIGlmIG9ubHkgb25lIG5vZGUgcGFzc2VkLCB3ZSBzdGFydCB0aGUgc2VsZWN0aW9uIGF0IHRoZSB0b3BcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyhmaXJzdEluUmFuZ2UpKSB7XG4gICAgICAgICAgICBpbkFjdGl2ZVJhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm91bmRHYXBJblNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvckVhY2hCbG9ja0luT3JkZXIoZnVuY3Rpb24gKGJsb2NrLCBpZCkge1xuICAgICAgICAgICAgaWYgKGZvdW5kR2FwSW5TZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGluQWN0aXZlUmFuZ2UgJiYgKGxhc3RCbG9ja0lkICsgMSAhPT0gaWQpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRHYXBJblNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEJsb2NrSWQgPSBpZDtcbiAgICAgICAgICAgIGJsb2NrLmZvckVhY2hOb2RlU2hhbGxvdyhmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBoaXRGaXJzdE9yTGFzdCA9IHJvd05vZGUgPT09IGZpcnN0SW5SYW5nZSB8fCByb3dOb2RlID09PSBsYXN0SW5SYW5nZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5BY3RpdmVSYW5nZSB8fCBoaXRGaXJzdE9yTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyb3dOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpdEZpcnN0T3JMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluQWN0aXZlUmFuZ2UgPSAhaW5BY3RpdmVSYW5nZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBudW1iZXJTZXF1ZW5jZSwgX3RoaXMudmlydHVhbFJvd0NvdW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGluQWN0aXZlUmFuZ2Ugd2lsbCBiZSBzdGlsbCB0cnVlIGlmIHdlIG5ldmVyIGhpdCB0aGUgc2Vjb25kIHJvd05vZGVcbiAgICAgICAgdmFyIGludmFsaWRSYW5nZSA9IGZvdW5kR2FwSW5TZWxlY3Rpb24gfHwgaW5BY3RpdmVSYW5nZTtcbiAgICAgICAgcmV0dXJuIGludmFsaWRSYW5nZSA/IFtdIDogcmVzdWx0O1xuICAgIH07XG4gICAgUm93Tm9kZUNhY2hlLkVWRU5UX0NBQ0hFX1VQREFURUQgPSAnY2FjaGVVcGRhdGVkJztcbiAgICByZXR1cm4gUm93Tm9kZUNhY2hlO1xufShiZWFuU3R1Yl8xLkJlYW5TdHViKSk7XG5leHBvcnRzLlJvd05vZGVDYWNoZSA9IFJvd05vZGVDYWNoZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9jYWNoZS9yb3dOb2RlQ2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDaGFuZ2VkUGF0aCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbmdlZFBhdGgoa2VlcGluZ0NvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5ub2RlSWRzVG9Cb29sZWFuID0ge307XG4gICAgICAgIHRoaXMubm9kZUlkc1RvQ29sdW1ucyA9IHt9O1xuICAgICAgICB0aGlzLmtlZXBpbmdDb2x1bW5zID0ga2VlcGluZ0NvbHVtbnM7XG4gICAgfVxuICAgIENoYW5nZWRQYXRoLnByb3RvdHlwZS5hZGRQYXJlbnROb2RlID0gZnVuY3Rpb24gKHJvd05vZGUsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHBvaW50ZXIgPSByb3dOb2RlO1xuICAgICAgICB3aGlsZSAocG9pbnRlcikge1xuICAgICAgICAgICAgLy8gYWRkIHRoaXMgaXRlbSB0byB0aGUgcGF0aCwgYWxsIHRoZSB3YXkgdG8gcGFyZW50XG4gICAgICAgICAgICB0aGlzLm5vZGVJZHNUb0Jvb2xlYW5bcG9pbnRlci5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gaWYgY29sdW1ucywgYWRkIHRoZSBjb2x1bW5zIGluIGFsbCB0aGUgd2F5IHRvIHBhcmVudCwgbWVyZ2luZ1xuICAgICAgICAgICAgLy8gaW4gYW55IG90aGVyIGNvbHVtbnMgdGhhdCBtaWdodCBiZSB0aGVyZSBhbHJlYWR5XG4gICAgICAgICAgICBpZiAodGhpcy5rZWVwaW5nQ29sdW1ucyAmJiBjb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm5vZGVJZHNUb0NvbHVtbnNbcG9pbnRlci5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlSWRzVG9Db2x1bW5zW3BvaW50ZXIuaWRdID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7IHJldHVybiBfdGhpcy5ub2RlSWRzVG9Db2x1bW5zW3BvaW50ZXIuaWRdW2NvbC5nZXRJZCgpXSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIucGFyZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFuZ2VkUGF0aC5wcm90b3R5cGUuaXNJblBhdGggPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlSWRzVG9Cb29sZWFuW3Jvd05vZGUuaWRdO1xuICAgIH07XG4gICAgQ2hhbmdlZFBhdGgucHJvdG90eXBlLmdldFZhbHVlQ29sdW1uc0Zvck5vZGUgPSBmdW5jdGlvbiAocm93Tm9kZSwgdmFsdWVDb2x1bW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5rZWVwaW5nQ29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlQ29sdW1ucztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sc0ZvclRoaXNOb2RlID0gdGhpcy5ub2RlSWRzVG9Db2x1bW5zW3Jvd05vZGUuaWRdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWVDb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoY29sKSB7IHJldHVybiBjb2xzRm9yVGhpc05vZGVbY29sLmdldElkKCldOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENoYW5nZWRQYXRoLnByb3RvdHlwZS5nZXROb3RWYWx1ZUNvbHVtbnNGb3JOb2RlID0gZnVuY3Rpb24gKHJvd05vZGUsIHZhbHVlQ29sdW1ucykge1xuICAgICAgICBpZiAoIXRoaXMua2VlcGluZ0NvbHVtbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xzRm9yVGhpc05vZGUgPSB0aGlzLm5vZGVJZHNUb0NvbHVtbnNbcm93Tm9kZS5pZF07XG4gICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZUNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2wpIHsgcmV0dXJuICFjb2xzRm9yVGhpc05vZGVbY29sLmdldElkKCldOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBDaGFuZ2VkUGF0aDtcbn0oKSk7XG5leHBvcnRzLkNoYW5nZWRQYXRoID0gQ2hhbmdlZFBhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dNb2RlbHMvaW5NZW1vcnkvY2hhbmdlZFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByb3dOb2RlXzEgPSByZXF1aXJlKFwiLi4vLi4vZW50aXRpZXMvcm93Tm9kZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIEluTWVtb3J5Tm9kZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluTWVtb3J5Tm9kZU1hbmFnZXIocm9vdE5vZGUsIGdyaWRPcHRpb25zV3JhcHBlciwgY29udGV4dCwgZXZlbnRTZXJ2aWNlLCBjb2x1bW5Db250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMubmV4dElkID0gMDtcbiAgICAgICAgLy8gd2hlbiB1c2VyIGlzIHByb3ZpZGUgdGhlIGlkJ3MsIHdlIGFsc28ga2VlcCBhIG1hcCBvZiBpZHMgdG8gcm93IG5vZGVzIGZvciBjb252ZW5pZW5jZVxuICAgICAgICB0aGlzLmFsbE5vZGVzTWFwID0ge307XG4gICAgICAgIHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTtcbiAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIgPSBncmlkT3B0aW9uc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlID0gZXZlbnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbHVtbkNvbnRyb2xsZXIgPSBjb2x1bW5Db250cm9sbGVyO1xuICAgICAgICB0aGlzLnJvb3ROb2RlLmdyb3VwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb290Tm9kZS5sZXZlbCA9IC0xO1xuICAgICAgICB0aGlzLnJvb3ROb2RlLmlkID0gSW5NZW1vcnlOb2RlTWFuYWdlci5ST09UX05PREVfSUQ7XG4gICAgICAgIHRoaXMucm9vdE5vZGUuYWxsTGVhZkNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlckdyb3VwID0gW107XG4gICAgICAgIHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlclNvcnQgPSBbXTtcbiAgICAgICAgdGhpcy5yb290Tm9kZS5jaGlsZHJlbkFmdGVyRmlsdGVyID0gW107XG4gICAgfVxuICAgIEluTWVtb3J5Tm9kZU1hbmFnZXIucHJvdG90eXBlLmdldENvcHlPZk5vZGVzTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdXRpbHNfMS5VdGlscy5jbG9uZU9iamVjdCh0aGlzLmFsbE5vZGVzTWFwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEluTWVtb3J5Tm9kZU1hbmFnZXIucHJvdG90eXBlLmdldFJvd05vZGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsTm9kZXNNYXBbaWRdO1xuICAgIH07XG4gICAgSW5NZW1vcnlOb2RlTWFuYWdlci5wcm90b3R5cGUuc2V0Um93RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlckZpbHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlckdyb3VwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yb290Tm9kZS5jaGlsZHJlbkFmdGVyU29ydCA9IG51bGw7XG4gICAgICAgIHRoaXMucm9vdE5vZGUuY2hpbGRyZW5NYXBwZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRJZCA9IDA7XG4gICAgICAgIHRoaXMuYWxsTm9kZXNNYXAgPSB7fTtcbiAgICAgICAgaWYgKCFyb3dEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZS5jaGlsZHJlbkFmdGVyR3JvdXAgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBmdW5jIGJlbG93IGRvZXNuJ3QgaGF2ZSAndGhpcycgcG9pbnRlciwgc28gbmVlZCB0byBwdWxsIG91dCB0aGVzZSBiaXRzXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUNoaWxkRGV0YWlscyA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldE5vZGVDaGlsZERldGFpbHNGdW5jKCk7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NQYXJlbnRzSW5Sb3dOb2RlcyA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NQYXJlbnRzSW5Sb3dOb2RlcygpO1xuICAgICAgICB0aGlzLmRvZXNEYXRhRmxvd2VyID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RG9lc0RhdGFGbG93ZXJGdW5jKCk7XG4gICAgICAgIHZhciBkb2luZ0xlZ2FjeVRyZWVEYXRhID0gdXRpbHNfMS5VdGlscy5leGlzdHModGhpcy5nZXROb2RlQ2hpbGREZXRhaWxzKTtcbiAgICAgICAgLy8ga2ljayBvZmYgcmVjdXJzaW9uXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlY3Vyc2l2ZUZ1bmN0aW9uKHJvd0RhdGEsIG51bGwsIEluTWVtb3J5Tm9kZU1hbmFnZXIuVE9QX0xFVkVMKTtcbiAgICAgICAgaWYgKGRvaW5nTGVnYWN5VHJlZURhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlckdyb3VwID0gcmVzdWx0O1xuICAgICAgICAgICAgdGhpcy5zZXRMZWFmQ2hpbGRyZW4odGhpcy5yb290Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbiA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlOb2RlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlUm93RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhVHJhbiwgcm93Tm9kZU9yZGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzTGVnYWN5VHJlZURhdGEoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZCA9IHJvd0RhdGFUcmFuLmFkZCwgYWRkSW5kZXggPSByb3dEYXRhVHJhbi5hZGRJbmRleCwgcmVtb3ZlID0gcm93RGF0YVRyYW4ucmVtb3ZlLCB1cGRhdGUgPSByb3dEYXRhVHJhbi51cGRhdGU7XG4gICAgICAgIHZhciByb3dOb2RlVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICByZW1vdmU6IFtdLFxuICAgICAgICAgICAgdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGFkZDogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKGFkZCkpIHtcbiAgICAgICAgICAgIHZhciB1c2VJbmRleCA9IHR5cGVvZiBhZGRJbmRleCA9PT0gJ251bWJlcicgJiYgYWRkSW5kZXggPj0gMDtcbiAgICAgICAgICAgIGlmICh1c2VJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIGl0ZW1zIGdldCBpbnNlcnRlZCBpbiByZXZlcnNlIG9yZGVyIGZvciBpbmRleCBpbnNlcnRpb25cbiAgICAgICAgICAgICAgICBhZGQucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Jvd05vZGUgPSBfdGhpcy5hZGRSb3dOb2RlKGl0ZW0sIGFkZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcm93Tm9kZVRyYW5zYWN0aW9uLmFkZC5wdXNoKG5ld1Jvd05vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Jvd05vZGUgPSBfdGhpcy5hZGRSb3dOb2RlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICByb3dOb2RlVHJhbnNhY3Rpb24uYWRkLnB1c2gobmV3Um93Tm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHJlbW92ZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRSb3dOb2RlID0gX3RoaXMudXBkYXRlZFJvd05vZGUoaXRlbSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkUm93Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByb3dOb2RlVHJhbnNhY3Rpb24ucmVtb3ZlLnB1c2gocmVtb3ZlZFJvd05vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyh1cGRhdGUpKSB7XG4gICAgICAgICAgICB1cGRhdGUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkUm93Tm9kZSA9IF90aGlzLnVwZGF0ZWRSb3dOb2RlKGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkUm93Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByb3dOb2RlVHJhbnNhY3Rpb24udXBkYXRlLnB1c2godXBkYXRlZFJvd05vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3dOb2RlT3JkZXIpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuc29ydFJvd05vZGVzQnlPcmRlcih0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbiwgcm93Tm9kZU9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93Tm9kZVRyYW5zYWN0aW9uO1xuICAgIH07XG4gICAgSW5NZW1vcnlOb2RlTWFuYWdlci5wcm90b3R5cGUuYWRkUm93Tm9kZSA9IGZ1bmN0aW9uIChkYXRhLCBpbmRleCkge1xuICAgICAgICB2YXIgbmV3Tm9kZSA9IHRoaXMuY3JlYXRlTm9kZShkYXRhLCBudWxsLCBJbk1lbW9yeU5vZGVNYW5hZ2VyLlRPUF9MRVZFTCk7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhpbmRleCkpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuaW5zZXJ0SW50b0FycmF5KHRoaXMucm9vdE5vZGUuYWxsTGVhZkNoaWxkcmVuLCBuZXdOb2RlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH07XG4gICAgSW5NZW1vcnlOb2RlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlZFJvd05vZGUgPSBmdW5jdGlvbiAoZGF0YSwgdXBkYXRlKSB7XG4gICAgICAgIHZhciByb3dOb2RlSWRGdW5jID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Um93Tm9kZUlkRnVuYygpO1xuICAgICAgICB2YXIgcm93Tm9kZTtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHJvd05vZGVJZEZ1bmMpKSB7XG4gICAgICAgICAgICAvLyBmaW5kIHJvd05vZGUgdXMgaWRcbiAgICAgICAgICAgIHZhciBpZCA9IHJvd05vZGVJZEZ1bmMoZGF0YSk7XG4gICAgICAgICAgICByb3dOb2RlID0gdGhpcy5hbGxOb2Rlc01hcFtpZF07XG4gICAgICAgICAgICBpZiAoIXJvd05vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYWctR3JpZDogY291bGQgbm90IGZpbmQgcm93IGlkPVwiICsgaWQgKyBcIiwgZGF0YSBpdGVtIHdhcyBub3QgZm91bmQgZm9yIHRoaXMgaWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmaW5kIHJvd05vZGUgdXNpbmcgb2JqZWN0IHJlZmVyZW5jZXNcbiAgICAgICAgICAgIHJvd05vZGUgPSB1dGlsc18xLlV0aWxzLmZpbmQodGhpcy5yb290Tm9kZS5hbGxMZWFmQ2hpbGRyZW4sIGZ1bmN0aW9uIChyb3dOb2RlKSB7IHJldHVybiByb3dOb2RlLmRhdGEgPT09IGRhdGE7IH0pO1xuICAgICAgICAgICAgaWYgKCFyb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImFnLUdyaWQ6IGNvdWxkIG5vdCBmaW5kIGRhdGEgaXRlbSBhcyBvYmplY3Qgd2FzIG5vdCBmb3VuZFwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBkbyB1cGRhdGVcbiAgICAgICAgICAgIHJvd05vZGUudXBkYXRlRGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRvIGRlbGV0ZVxuICAgICAgICAgICAgcm93Tm9kZS5zZXRTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUZyb21BcnJheSh0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbiwgcm93Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLmFsbE5vZGVzTWFwW3Jvd05vZGUuaWRdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dOb2RlO1xuICAgIH07XG4gICAgSW5NZW1vcnlOb2RlTWFuYWdlci5wcm90b3R5cGUucmVjdXJzaXZlRnVuY3Rpb24gPSBmdW5jdGlvbiAocm93RGF0YSwgcGFyZW50LCBsZXZlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHJvd0RhdGEgaXMgYW4gYXJyYXkgYW5kIG5vdCBhIHN0cmluZyBvZiBqc29uIC0gdGhpcyB3YXMgYSBjb21tb25seSByZXBvcnRlZCBwcm9ibGVtIG9uIHRoZSBmb3J1bVxuICAgICAgICBpZiAodHlwZW9mIHJvd0RhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IHJvd0RhdGEgbXVzdCBiZSBhbiBhcnJheSwgaG93ZXZlciB5b3UgcGFzc2VkIGluIGEgc3RyaW5nLiBJZiB5b3UgYXJlIGxvYWRpbmcgSlNPTiwgbWFrZSBzdXJlIHlvdSBjb252ZXJ0IHRoZSBKU09OIHN0cmluZyB0byBKYXZhU2NyaXB0IG9iamVjdHMgZmlyc3QnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm93Tm9kZXMgPSBbXTtcbiAgICAgICAgcm93RGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5jcmVhdGVOb2RlKGRhdGFJdGVtLCBwYXJlbnQsIGxldmVsKTtcbiAgICAgICAgICAgIHJvd05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm93Tm9kZXM7XG4gICAgfTtcbiAgICBJbk1lbW9yeU5vZGVNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKGRhdGFJdGVtLCBwYXJlbnQsIGxldmVsKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IHJvd05vZGVfMS5Sb3dOb2RlKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC53aXJlQmVhbihub2RlKTtcbiAgICAgICAgdmFyIGRvaW5nVHJlZURhdGEgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1RyZWVEYXRhKCk7XG4gICAgICAgIHZhciBkb2luZ0xlZ2FjeVRyZWVEYXRhID0gIWRvaW5nVHJlZURhdGEgJiYgdXRpbHNfMS5VdGlscy5leGlzdHModGhpcy5nZXROb2RlQ2hpbGREZXRhaWxzKTtcbiAgICAgICAgdmFyIG5vZGVDaGlsZERldGFpbHMgPSBkb2luZ0xlZ2FjeVRyZWVEYXRhID8gdGhpcy5nZXROb2RlQ2hpbGREZXRhaWxzKGRhdGFJdGVtKSA6IG51bGw7XG4gICAgICAgIGlmIChub2RlQ2hpbGREZXRhaWxzICYmIG5vZGVDaGlsZERldGFpbHMuZ3JvdXApIHtcbiAgICAgICAgICAgIG5vZGUuZ3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbkFmdGVyR3JvdXAgPSB0aGlzLnJlY3Vyc2l2ZUZ1bmN0aW9uKG5vZGVDaGlsZERldGFpbHMuY2hpbGRyZW4sIG5vZGUsIGxldmVsICsgMSk7XG4gICAgICAgICAgICBub2RlLmV4cGFuZGVkID0gbm9kZUNoaWxkRGV0YWlscy5leHBhbmRlZCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUuZmllbGQgPSBub2RlQ2hpbGREZXRhaWxzLmZpZWxkO1xuICAgICAgICAgICAgbm9kZS5rZXkgPSBub2RlQ2hpbGREZXRhaWxzLmtleTtcbiAgICAgICAgICAgIG5vZGUuY2FuRmxvd2VyID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBwdWxsIG91dCBhbGwgdGhlIGxlYWYgY2hpbGRyZW4gYW5kIGFkZCB0byBvdXIgbm9kZVxuICAgICAgICAgICAgdGhpcy5zZXRMZWFmQ2hpbGRyZW4obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmdyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZG9pbmdUcmVlRGF0YSkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2FuRmxvd2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gIHRoaXMgaXMgdGhlIGRlZmF1bHQsIGZvciB3aGVuIGRvaW5nIGdyaWQgZGF0YVxuICAgICAgICAgICAgICAgIG5vZGUuY2FuRmxvd2VyID0gdGhpcy5kb2VzRGF0YUZsb3dlciA/IHRoaXMuZG9lc0RhdGFGbG93ZXIoZGF0YUl0ZW0pIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2FuRmxvd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZXhwYW5kZWQgPSB0aGlzLmlzRXhwYW5kZWQobGV2ZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50ICYmICF0aGlzLnN1cHByZXNzUGFyZW50c0luUm93Tm9kZXMpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgbm9kZS5zZXREYXRhQW5kSWQoZGF0YUl0ZW0sIHRoaXMubmV4dElkLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLmFsbE5vZGVzTWFwW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgdGhpcy5uZXh0SWQrKztcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBJbk1lbW9yeU5vZGVNYW5hZ2VyLnByb3RvdHlwZS5pc0V4cGFuZGVkID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIHZhciBleHBhbmRCeURlZmF1bHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRHcm91cERlZmF1bHRFeHBhbmRlZCgpO1xuICAgICAgICBpZiAoZXhwYW5kQnlEZWZhdWx0ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWwgPCBleHBhbmRCeURlZmF1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHRoaXMgaXMgb25seSB1c2VkIGZvciBkb2luZyBsZWdhY3kgdHJlZSBkYXRhXG4gICAgSW5NZW1vcnlOb2RlTWFuYWdlci5wcm90b3R5cGUuc2V0TGVhZkNoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5hbGxMZWFmQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW5BZnRlckdyb3VwKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuQWZ0ZXJHcm91cC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZEFmdGVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRBZnRlckdyb3VwLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEFmdGVyR3JvdXAuYWxsTGVhZkNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEFmdGVyR3JvdXAuYWxsTGVhZkNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGxlYWZDaGlsZCkgeyByZXR1cm4gbm9kZS5hbGxMZWFmQ2hpbGRyZW4ucHVzaChsZWFmQ2hpbGQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hbGxMZWFmQ2hpbGRyZW4ucHVzaChjaGlsZEFmdGVyR3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeU5vZGVNYW5hZ2VyLnByb3RvdHlwZS5pbnNlcnRJdGVtc0F0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIHJvd0RhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMZWdhY3lUcmVlRGF0YSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZUxpc3QgPSB0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbjtcbiAgICAgICAgaWYgKGluZGV4ID4gbm9kZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1HcmlkOiBpbnZhbGlkIGluZGV4IFwiICsgaW5kZXggKyBcIiwgbWF4IGluZGV4IGlzIFwiICsgbm9kZUxpc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgaXRlbXMgYmFja3dhcmRzLCBvdGhlcndpc2UgdGhleSBnZXQgYWRkZWQgaW4gcmV2ZXJzZSBvcmRlclxuICAgICAgICBmb3IgKHZhciBpID0gcm93RGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByb3dEYXRhW2ldO1xuICAgICAgICAgICAgdmFyIG5ld05vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoZGF0YSwgbnVsbCwgSW5NZW1vcnlOb2RlTWFuYWdlci5UT1BfTEVWRUwpO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5pbnNlcnRJbnRvQXJyYXkobm9kZUxpc3QsIG5ld05vZGUsIGluZGV4KTtcbiAgICAgICAgICAgIG5ld05vZGVzLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld05vZGVzLmxlbmd0aCA+IDAgPyBuZXdOb2RlcyA6IG51bGw7XG4gICAgfTtcbiAgICBJbk1lbW9yeU5vZGVNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVJdGVtcyA9IGZ1bmN0aW9uIChyb3dOb2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pc0xlZ2FjeVRyZWVEYXRhKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZUxpc3QgPSB0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbjtcbiAgICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IFtdO1xuICAgICAgICByb3dOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3dOb2RlKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhPZk5vZGUgPSBub2RlTGlzdC5pbmRleE9mKHJvd05vZGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4T2ZOb2RlID49IDApIHtcbiAgICAgICAgICAgICAgICByb3dOb2RlLnNldFNlbGVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBub2RlTGlzdC5zcGxpY2UoaW5kZXhPZk5vZGUsIDEpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFsbE5vZGVzTWFwW3Jvd05vZGUuaWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlZE5vZGVzLnB1c2gocm93Tm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVtb3ZlZE5vZGVzLmxlbmd0aCA+IDAgPyByZW1vdmVkTm9kZXMgOiBudWxsO1xuICAgIH07XG4gICAgSW5NZW1vcnlOb2RlTWFuYWdlci5wcm90b3R5cGUuYWRkSXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgdmFyIG5vZGVMaXN0ID0gdGhpcy5yb290Tm9kZS5hbGxMZWFmQ2hpbGRyZW47XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydEl0ZW1zQXRJbmRleChub2RlTGlzdC5sZW5ndGgsIGl0ZW1zKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Tm9kZU1hbmFnZXIucHJvdG90eXBlLmlzTGVnYWN5VHJlZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dzQWxyZWFkeUdyb3VwZWQgPSB1dGlsc18xLlV0aWxzLmV4aXN0cyh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXROb2RlQ2hpbGREZXRhaWxzRnVuYygpKTtcbiAgICAgICAgaWYgKHJvd3NBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBhZGRpbmcgYW5kIHJlbW92aW5nIHJvd3MgaXMgbm90IHN1cHBvcnRlZCB3aGVuIHVzaW5nIG5vZGVDaGlsZERldGFpbHNGdW5jLCBpZSBpdCBpcyBub3QgJyArXG4gICAgICAgICAgICAgICAgJ3N1cHBvcnRlZCBmb3IgbGVnYWN5IHRyZWUgZGF0YS4gUGxlYXNlIHNlZSB0aGUgZG9jcyBvbiB0aGUgbmV3IHByZWZlcnJlZCB3YXkgb2YgcHJvdmlkaW5nIHRyZWUgZGF0YSB0aGF0IHdvcmtzIHdpdGggZGVsdGEgdXBkYXRlcy4nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeU5vZGVNYW5hZ2VyLlRPUF9MRVZFTCA9IDA7XG4gICAgSW5NZW1vcnlOb2RlTWFuYWdlci5ST09UX05PREVfSUQgPSAnUk9PVF9OT0RFX0lEJztcbiAgICByZXR1cm4gSW5NZW1vcnlOb2RlTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLkluTWVtb3J5Tm9kZU1hbmFnZXIgPSBJbk1lbW9yeU5vZGVNYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2luTWVtb3J5L2luTWVtb3J5Tm9kZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBleHByZXNzaW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4uL3ZhbHVlU2VydmljZS9leHByZXNzaW9uU2VydmljZVwiKTtcbnZhciBTdHlsaW5nU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGluZ1NlcnZpY2UoKSB7XG4gICAgfVxuICAgIFN0eWxpbmdTZXJ2aWNlLnByb3RvdHlwZS5wcm9jZXNzQWxsQ2VsbENsYXNzZXMgPSBmdW5jdGlvbiAoY29sRGVmLCBwYXJhbXMsIG9uQXBwbGljYWJsZUNsYXNzLCBvbk5vdEFwcGxpY2FibGVDbGFzcykge1xuICAgICAgICB0aGlzLnByb2Nlc3NDbGFzc1J1bGVzKGNvbERlZi5jZWxsQ2xhc3NSdWxlcywgcGFyYW1zLCBvbkFwcGxpY2FibGVDbGFzcywgb25Ob3RBcHBsaWNhYmxlQ2xhc3MpO1xuICAgICAgICB0aGlzLnByb2Nlc3NTdGF0aWNDZWxsQ2xhc3Nlcyhjb2xEZWYsIHBhcmFtcywgb25BcHBsaWNhYmxlQ2xhc3MpO1xuICAgIH07XG4gICAgU3R5bGluZ1NlcnZpY2UucHJvdG90eXBlLnByb2Nlc3NDbGFzc1J1bGVzID0gZnVuY3Rpb24gKGNsYXNzUnVsZXMsIHBhcmFtcywgb25BcHBsaWNhYmxlQ2xhc3MsIG9uTm90QXBwbGljYWJsZUNsYXNzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NSdWxlcyA9PT0gJ29iamVjdCcgJiYgY2xhc3NSdWxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBPYmplY3Qua2V5cyhjbGFzc1J1bGVzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBydWxlID0gY2xhc3NSdWxlc1tjbGFzc05hbWVdO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRPZlJ1bGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPZlJ1bGUgPSB0aGlzLmV4cHJlc3Npb25TZXJ2aWNlLmV2YWx1YXRlKHJ1bGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBydWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE9mUnVsZSA9IHJ1bGUocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdE9mUnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBvbkFwcGxpY2FibGVDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbk5vdEFwcGxpY2FibGVDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBvbk5vdEFwcGxpY2FibGVDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R5bGluZ1NlcnZpY2UucHJvdG90eXBlLnByb2Nlc3NTdGF0aWNDZWxsQ2xhc3NlcyA9IGZ1bmN0aW9uIChjb2xEZWYsIHBhcmFtcywgb25BcHBsaWNhYmxlQ2xhc3MpIHtcbiAgICAgICAgdmFyIGNlbGxDbGFzcyA9IGNvbERlZi5jZWxsQ2xhc3M7XG4gICAgICAgIGlmIChjZWxsQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc09yQ2xhc3NlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sRGVmLmNlbGxDbGFzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsQ2xhc3NGdW5jID0gY29sRGVmLmNlbGxDbGFzcztcbiAgICAgICAgICAgICAgICBjbGFzc09yQ2xhc3NlcyA9IGNlbGxDbGFzc0Z1bmMocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsYXNzT3JDbGFzc2VzID0gY29sRGVmLmNlbGxDbGFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xhc3NPckNsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgb25BcHBsaWNhYmxlQ2xhc3MoY2xhc3NPckNsYXNzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjbGFzc09yQ2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICBjbGFzc09yQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjc3NDbGFzc0l0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgb25BcHBsaWNhYmxlQ2xhc3MoY3NzQ2xhc3NJdGVtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V4cHJlc3Npb25TZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBleHByZXNzaW9uU2VydmljZV8xLkV4cHJlc3Npb25TZXJ2aWNlKVxuICAgIF0sIFN0eWxpbmdTZXJ2aWNlLnByb3RvdHlwZSwgXCJleHByZXNzaW9uU2VydmljZVwiLCB2b2lkIDApO1xuICAgIFN0eWxpbmdTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdzdHlsaW5nU2VydmljZScpXG4gICAgXSwgU3R5bGluZ1NlcnZpY2UpO1xuICAgIHJldHVybiBTdHlsaW5nU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlN0eWxpbmdTZXJ2aWNlID0gU3R5bGluZ1NlcnZpY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9zdHlsaW5nL3N0eWxpbmdTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSkoMTUyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLXJlZHV4L2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYWctZ3JpZC1yZWFjdCB2MTQuMC4wXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0RnJhbWV3b3JrQ29tcG9uZW50V3JhcHBlcl8xID0gcmVxdWlyZShcIi4vcmVhY3RGcmFtZXdvcmtDb21wb25lbnRXcmFwcGVyXCIpO1xudmFyIERPTSA9IHJlcXVpcmUoXCJyZWFjdC1kb20tZmFjdG9yaWVzXCIpO1xudmFyIHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZShcInByb3AtdHlwZXNcIik7XG52YXIgQWdHcmlkID0gcmVxdWlyZShcImFnLWdyaWRcIik7XG52YXIgQWdHcmlkUmVhY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZ0dyaWRSZWFjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZ0dyaWRSZWFjdChwcm9wcywgc3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMsIHN0YXRlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFnR3JpZFJlYWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBET00uZGl2KHtcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLmNyZWF0ZVN0eWxlRm9yRGl2KCksXG4gICAgICAgICAgICByZWY6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZUdyaWREaXYgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFnR3JpZFJlYWN0LnByb3RvdHlwZS5jcmVhdGVTdHlsZUZvckRpdiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlID0geyBoZWlnaHQ6ICcxMDAlJyB9O1xuICAgICAgICAvLyBhbGxvdyB1c2VyIHRvIG92ZXJyaWRlIHN0eWxlc1xuICAgICAgICB2YXIgY29udGFpbmVyU3R5bGUgPSB0aGlzLnByb3BzLmNvbnRhaW5lclN0eWxlO1xuICAgICAgICBpZiAoY29udGFpbmVyU3R5bGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRhaW5lclN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVtrZXldID0gY29udGFpbmVyU3R5bGVba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9O1xuICAgIEFnR3JpZFJlYWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyaWRQYXJhbXMgPSB7XG4gICAgICAgICAgICBzZWVkQmVhbkluc3RhbmNlczoge1xuICAgICAgICAgICAgICAgIGFnR3JpZFJlYWN0OiB0aGlzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ3JpZE9wdGlvbnMgPSBBZ0dyaWQuQ29tcG9uZW50VXRpbC5jb3B5QXR0cmlidXRlc1RvR3JpZE9wdGlvbnModGhpcy5wcm9wcy5ncmlkT3B0aW9ucywgdGhpcy5wcm9wcyk7XG4gICAgICAgIEFnR3JpZC5HcmlkLnNldEZyYW1ld29ya0JlYW5zKFtyZWFjdEZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXJfMS5SZWFjdEZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXJdKTtcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgIG5ldyBBZ0dyaWQuR3JpZCh0aGlzLmVHcmlkRGl2LCB0aGlzLmdyaWRPcHRpb25zLCBncmlkUGFyYW1zKTtcbiAgICAgICAgdGhpcy5hcGkgPSB0aGlzLmdyaWRPcHRpb25zLmFwaTtcbiAgICAgICAgdGhpcy5jb2x1bW5BcGkgPSB0aGlzLmdyaWRPcHRpb25zLmNvbHVtbkFwaTtcbiAgICB9O1xuICAgIEFnR3JpZFJlYWN0LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdlIHdhbnQgZnVsbCBjb250cm9sIG9mIHRoZSBkb20sIGFzIGFnLUdyaWQgZG9lc24ndCB1c2UgUmVhY3QgaW50ZXJuYWxseSxcbiAgICAgICAgLy8gc28gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgd2UgdGVsbCBSZWFjdCB3ZSBkb24ndCBuZWVkIHJlbmRlciBjYWxsZWQgYWZ0ZXJcbiAgICAgICAgLy8gcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQWdHcmlkUmVhY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZWJ1Z0xvZ2dpbmcgPSAhIW5leHRQcm9wcy5kZWJ1ZztcbiAgICAgICAgLy8ga2VlcGluZyBjb25zaXN0ZW50IHdpdGggd2ViIGNvbXBvbmVudHMsIHB1dCBjaGFuZ2luZ1xuICAgICAgICAvLyB2YWx1ZXMgaW4gY3VycmVudFZhbHVlIGFuZCBwcmV2aW91c1ZhbHVlIHBhaXJzIGFuZFxuICAgICAgICAvLyBub3QgaW5jbHVkZSBpdGVtcyB0aGF0IGhhdmUgbm90IGNoYW5nZWQuXG4gICAgICAgIHZhciBjaGFuZ2VzID0ge307XG4gICAgICAgIEFnR3JpZC5Db21wb25lbnRVdGlsLkFMTF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3BLZXkpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuYXJlRXF1aXZhbGVudChfdGhpcy5wcm9wc1twcm9wS2V5XSwgbmV4dFByb3BzW3Byb3BLZXldKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1Z0xvZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZ0dyaWRSZWFjdDogW1wiICsgcHJvcEtleSArIFwiXSBwcm9wZXJ0eSBjaGFuZ2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VzW3Byb3BLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBfdGhpcy5wcm9wc1twcm9wS2V5XSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiBuZXh0UHJvcHNbcHJvcEtleV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgQWdHcmlkLkNvbXBvbmVudFV0aWwuZ2V0RXZlbnRDYWxsYmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jTmFtZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzW2Z1bmNOYW1lXSAhPT0gbmV4dFByb3BzW2Z1bmNOYW1lXSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1Z0xvZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZ0dyaWRSZWFjdDogW1wiICsgZnVuY05hbWUgKyBcIl0gZXZlbnQgY2FsbGJhY2sgY2hhbmdlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlc1tmdW5jTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IF90aGlzLnByb3BzW2Z1bmNOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiBuZXh0UHJvcHNbZnVuY05hbWVdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIEFnR3JpZC5Db21wb25lbnRVdGlsLnByb2Nlc3NPbkNoYW5nZShjaGFuZ2VzLCB0aGlzLmdyaWRPcHRpb25zLCB0aGlzLmFwaSwgdGhpcy5jb2x1bW5BcGkpO1xuICAgIH07XG4gICAgQWdHcmlkUmVhY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hcGkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBpLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcbiAgICAgKiBkZWVwZXIgb2JqZWN0IGNvbXBhcmlzb24gLSB0YWtlbiBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNjg4MzQvb2JqZWN0LWNvbXBhcmlzb24taW4tamF2YXNjcmlwdFxuICAgICAqL1xuICAgIEFnR3JpZFJlYWN0LnVud3JhcFN0cmluZ09yTnVtYmVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIE51bWJlciB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmdcbiAgICAgICAgICAgID8gb2JqLnZhbHVlT2YoKVxuICAgICAgICAgICAgOiBvYmopO1xuICAgIH07XG4gICAgLy8gc2lnaCwgaGVyZSBmb3IgaWUgY29tcGF0aWJpbGl0eVxuICAgIEFnR3JpZFJlYWN0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBhbnl0aGluZyB3aXRob3V0IGtleXMgKGJvb2xlYW4sIHN0cmluZyBldGMpLlxuICAgICAgICAvLyBPYmplY3Qua2V5cyAtIGNocm9tZSB3aWxsIHN3YWxsb3cgdGhlbSwgSUUgd2lsbCBmYWlsIChjb3JyZWN0bHksIGltaG8pXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3t9LCB2YWx1ZV0ucmVkdWNlKGZ1bmN0aW9uIChyLCBvKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgcltrXSA9IG9ba107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBBZ0dyaWRSZWFjdC5wcm90b3R5cGUuYXJlRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBBZ0dyaWRSZWFjdC5hcmVFcXVpdmFsZW50KHRoaXMuY29weShhKSwgdGhpcy5jb3B5KGIpKTtcbiAgICB9O1xuICAgIEFnR3JpZFJlYWN0LmFyZUVxdWl2YWxlbnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBhID0gQWdHcmlkUmVhY3QudW53cmFwU3RyaW5nT3JOdW1iZXIoYSk7XG4gICAgICAgIGIgPSBBZ0dyaWRSZWFjdC51bndyYXBTdHJpbmdPck51bWJlcihiKTtcbiAgICAgICAgaWYgKGEgPT09IGIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy9lLmcuIGEgYW5kIGIgYm90aCBudWxsXG4gICAgICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwgfHwgdHlwZW9mIChhKSAhPT0gdHlwZW9mIChiKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gYiBpbnN0YW5jZW9mIERhdGUgJiYgYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhID09IGI7IC8vZm9yIGJvb2xlYW4sIG51bWJlciwgc3RyaW5nLCBmdW5jdGlvbiwgeG1sXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0EgPSAoYS5hcmVFcXVpdmFsZW50X0VxXzkxXzJfMzQgPT09IHVuZGVmaW5lZCksIG5ld0IgPSAoYi5hcmVFcXVpdmFsZW50X0VxXzkxXzJfMzQgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChuZXdBKSB7XG4gICAgICAgICAgICAgICAgYS5hcmVFcXVpdmFsZW50X0VxXzkxXzJfMzQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEuYXJlRXF1aXZhbGVudF9FcV85MV8yXzM0LnNvbWUoZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID09PSBiO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAobmV3Qikge1xuICAgICAgICAgICAgICAgIGIuYXJlRXF1aXZhbGVudF9FcV85MV8yXzM0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLmFyZUVxdWl2YWxlbnRfRXFfOTFfMl8zNC5zb21lKGZ1bmN0aW9uIChvdGhlcikgeyByZXR1cm4gb3RoZXIgPT09IGE7IH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLmFyZUVxdWl2YWxlbnRfRXFfOTFfMl8zNC5wdXNoKGIpO1xuICAgICAgICAgICAgYi5hcmVFcXVpdmFsZW50X0VxXzkxXzJfMzQucHVzaChhKTtcbiAgICAgICAgICAgIHZhciB0bXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBhKVxuICAgICAgICAgICAgICAgIGlmIChwcm9wICE9IFwiYXJlRXF1aXZhbGVudF9FcV85MV8yXzM0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wW3Byb3BdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gYilcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPSBcImFyZUVxdWl2YWxlbnRfRXFfOTFfMl8zNFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFtwcm9wXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChwcm9wIGluIHRtcCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hcmVFcXVpdmFsZW50KGFbcHJvcF0sIGJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChuZXdBKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhLmFyZUVxdWl2YWxlbnRfRXFfOTFfMl8zNDtcbiAgICAgICAgICAgIGlmIChuZXdCKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBiLmFyZUVxdWl2YWxlbnRfRXFfOTFfMl8zNDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFnR3JpZFJlYWN0O1xufShyZWFjdF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5BZ0dyaWRSZWFjdCA9IEFnR3JpZFJlYWN0O1xuQWdHcmlkUmVhY3QucHJvcFR5cGVzID0ge1xuICAgIGdyaWRPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxufTtcbmFkZFByb3BlcnRpZXMoQWdHcmlkLkNvbXBvbmVudFV0aWwuZ2V0RXZlbnRDYWxsYmFja3MoKSwgUHJvcFR5cGVzLmZ1bmMpO1xuYWRkUHJvcGVydGllcyhBZ0dyaWQuQ29tcG9uZW50VXRpbC5CT09MRUFOX1BST1BFUlRJRVMsIFByb3BUeXBlcy5ib29sKTtcbmFkZFByb3BlcnRpZXMoQWdHcmlkLkNvbXBvbmVudFV0aWwuU1RSSU5HX1BST1BFUlRJRVMsIFByb3BUeXBlcy5zdHJpbmcpO1xuYWRkUHJvcGVydGllcyhBZ0dyaWQuQ29tcG9uZW50VXRpbC5PQkpFQ1RfUFJPUEVSVElFUywgUHJvcFR5cGVzLm9iamVjdCk7XG5hZGRQcm9wZXJ0aWVzKEFnR3JpZC5Db21wb25lbnRVdGlsLkFSUkFZX1BST1BFUlRJRVMsIFByb3BUeXBlcy5hcnJheSk7XG5hZGRQcm9wZXJ0aWVzKEFnR3JpZC5Db21wb25lbnRVdGlsLk5VTUJFUl9QUk9QRVJUSUVTLCBQcm9wVHlwZXMubnVtYmVyKTtcbmFkZFByb3BlcnRpZXMoQWdHcmlkLkNvbXBvbmVudFV0aWwuRlVOQ1RJT05fUFJPUEVSVElFUywgUHJvcFR5cGVzLmZ1bmMpO1xuZnVuY3Rpb24gYWRkUHJvcGVydGllcyhsaXN0T2ZQcm9wcywgcHJvcFR5cGUpIHtcbiAgICBsaXN0T2ZQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wS2V5KSB7XG4gICAgICAgIEFnR3JpZFJlYWN0W3Byb3BLZXldID0gcHJvcFR5cGU7XG4gICAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC1yZWFjdC9saWIvYWdHcmlkUmVhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBUaGUgYmFzZSBmcmFtZXdvcmtzLCBlZyBSZWFjdCAmIEFuZ3VsYXIgMiwgb3ZlcnJpZGUgdGhpcyBiZWFuIHdpdGggaW1wbGVtZW50YXRpb25zIHNwZWNpZmljIHRvIHRoZWlyIHJlcXVpcmVtZW50LiAqL1xudmFyIEJhc2VGcmFtZXdvcmtGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlRnJhbWV3b3JrRmFjdG9yeSgpIHtcbiAgICB9XG4gICAgQmFzZUZyYW1ld29ya0ZhY3RvcnkucHJvdG90eXBlLmRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoZ3JpZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGdyaWRPcHRpb25zLmRhdGVDb21wb25lbnQ7XG4gICAgfTtcbiAgICBCYXNlRnJhbWV3b3JrRmFjdG9yeS5wcm90b3R5cGUuY29sRGVmRmxvYXRpbmdDZWxsUmVuZGVyZXIgPSBmdW5jdGlvbiAoY29sRGVmKSB7XG4gICAgICAgIHJldHVybiBjb2xEZWYucGlubmVkUm93Q2VsbFJlbmRlcmVyO1xuICAgIH07XG4gICAgQmFzZUZyYW1ld29ya0ZhY3RvcnkucHJvdG90eXBlLmNvbERlZkNlbGxSZW5kZXJlciA9IGZ1bmN0aW9uIChjb2xEZWYpIHtcbiAgICAgICAgcmV0dXJuIGNvbERlZi5jZWxsUmVuZGVyZXI7XG4gICAgfTtcbiAgICBCYXNlRnJhbWV3b3JrRmFjdG9yeS5wcm90b3R5cGUuY29sRGVmQ2VsbEVkaXRvciA9IGZ1bmN0aW9uIChjb2xEZWYpIHtcbiAgICAgICAgcmV0dXJuIGNvbERlZi5jZWxsRWRpdG9yO1xuICAgIH07XG4gICAgQmFzZUZyYW1ld29ya0ZhY3RvcnkucHJvdG90eXBlLmNvbERlZkZpbHRlciA9IGZ1bmN0aW9uIChjb2xEZWYpIHtcbiAgICAgICAgcmV0dXJuIGNvbERlZi5maWx0ZXI7XG4gICAgfTtcbiAgICBCYXNlRnJhbWV3b3JrRmFjdG9yeS5wcm90b3R5cGUuZ3JpZE9wdGlvbnNGdWxsV2lkdGhDZWxsUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ3JpZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGdyaWRPcHRpb25zLmZ1bGxXaWR0aENlbGxSZW5kZXJlcjtcbiAgICB9O1xuICAgIEJhc2VGcmFtZXdvcmtGYWN0b3J5LnByb3RvdHlwZS5ncmlkT3B0aW9uc0dyb3VwUm93UmVuZGVyZXIgPSBmdW5jdGlvbiAoZ3JpZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGdyaWRPcHRpb25zLmdyb3VwUm93UmVuZGVyZXI7XG4gICAgfTtcbiAgICBCYXNlRnJhbWV3b3JrRmFjdG9yeS5wcm90b3R5cGUuZ3JpZE9wdGlvbnNHcm91cFJvd0lubmVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ3JpZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGdyaWRPcHRpb25zLmdyb3VwUm93SW5uZXJSZW5kZXJlcjtcbiAgICB9O1xuICAgIEJhc2VGcmFtZXdvcmtGYWN0b3J5LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGFjdGlvbiwgdGltZW91dCkge1xuICAgICAgICBzZXRUaW1lb3V0KGFjdGlvbiwgdGltZW91dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZUZyYW1ld29ya0ZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5CYXNlRnJhbWV3b3JrRmFjdG9yeSA9IEJhc2VGcmFtZXdvcmtGYWN0b3J5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvYmFzZUZyYW1ld29ya0ZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb2x1bW5fMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9jb2x1bW5cIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4vY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBBdXRvR3JvdXBDb2xTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRvR3JvdXBDb2xTZXJ2aWNlKCkge1xuICAgIH1cbiAgICBBdXRvR3JvdXBDb2xTZXJ2aWNlXzEgPSBBdXRvR3JvdXBDb2xTZXJ2aWNlO1xuICAgIEF1dG9Hcm91cENvbFNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZUF1dG9Hcm91cENvbHVtbnMgPSBmdW5jdGlvbiAocm93R3JvdXBDb2x1bW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBncm91cEF1dG9Db2x1bW5zID0gW107XG4gICAgICAgIHZhciBkb2luZ1RyZWVEYXRhID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNUcmVlRGF0YSgpO1xuICAgICAgICB2YXIgZG9pbmdNdWx0aUF1dG9Db2x1bW4gPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwTXVsdGlBdXRvQ29sdW1uKCk7XG4gICAgICAgIGlmIChkb2luZ1RyZWVEYXRhICYmIGRvaW5nTXVsdGlBdXRvQ29sdW1uKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWctR3JpZDogeW91IGNhbm5vdCBtaXggZ3JvdXBNdWx0aUF1dG9Db2x1bW4gd2l0aCB0cmVlRGF0YSwgb25seSBvbmUgY29sdW1uIGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgZ3JvdXBzIHdoZW4gZG9pbmcgdHJlZSBkYXRhJyk7XG4gICAgICAgICAgICBkb2luZ011bHRpQXV0b0NvbHVtbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGRvaW5nIGdyb3VwTXVsdGlBdXRvQ29sdW1uLCB0aGVuIHdlIGNhbGwgdGhlIG1ldGhvZCBtdWx0aXBsZSB0aW1lcywgb25jZVxuICAgICAgICAvLyBmb3IgZWFjaCBjb2x1bW4gd2UgYXJlIGdyb3VwaW5nIGJ5XG4gICAgICAgIGlmIChkb2luZ011bHRpQXV0b0NvbHVtbikge1xuICAgICAgICAgICAgcm93R3JvdXBDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKHJvd0dyb3VwQ29sLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGdyb3VwQXV0b0NvbHVtbnMucHVzaChfdGhpcy5jcmVhdGVPbmVBdXRvR3JvdXBDb2x1bW4ocm93R3JvdXBDb2wsIGluZGV4KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdyb3VwQXV0b0NvbHVtbnMucHVzaCh0aGlzLmNyZWF0ZU9uZUF1dG9Hcm91cENvbHVtbihudWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwQXV0b0NvbHVtbnM7XG4gICAgfTtcbiAgICAvLyByb3dHcm91cENvbCBhbmQgaW5kZXggYXJlIG1pc3NpbmcgaWYgZ3JvdXBNdWx0aUF1dG9Db2x1bW49ZmFsc2VcbiAgICBBdXRvR3JvdXBDb2xTZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGVPbmVBdXRvR3JvdXBDb2x1bW4gPSBmdW5jdGlvbiAocm93R3JvdXBDb2wsIGluZGV4KSB7XG4gICAgICAgIC8vIGlmIG9uZSBwcm92aWRlZCBieSB1c2VyLCB1c2UgaXQsIG90aGVyd2lzZSBjcmVhdGUgb25lXG4gICAgICAgIHZhciBkZWZhdWx0QXV0b0NvbERlZiA9IHRoaXMuZ2VuZXJhdGVEZWZhdWx0Q29sRGVmKHJvd0dyb3VwQ29sLCBpbmRleCk7XG4gICAgICAgIHZhciB1c2VyQXV0b0NvbERlZiA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEF1dG9Hcm91cENvbHVtbkRlZigpO1xuICAgICAgICAvLyBpZiBkb2luZyBtdWx0aSwgc2V0IHRoZSBmaWVsZFxuICAgICAgICB2YXIgY29sSWQ7XG4gICAgICAgIGlmIChyb3dHcm91cENvbCkge1xuICAgICAgICAgICAgY29sSWQgPSBBdXRvR3JvdXBDb2xTZXJ2aWNlXzEuR1JPVVBfQVVUT19DT0xVTU5fSUQgKyBcIi1cIiArIHJvd0dyb3VwQ29sLmdldElkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xJZCA9IEF1dG9Hcm91cENvbFNlcnZpY2VfMS5HUk9VUF9BVVRPX0NPTFVNTl9CVU5ETEVfSUQ7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbHNfMS5fLm1lcmdlRGVlcChkZWZhdWx0QXV0b0NvbERlZiwgdXNlckF1dG9Db2xEZWYpO1xuICAgICAgICBkZWZhdWx0QXV0b0NvbERlZi5jb2xJZCA9IGNvbElkO1xuICAgICAgICB2YXIgbm9Vc2VyRmlsdGVyUHJlZmVyZW5jZXMgPSB1c2VyQXV0b0NvbERlZiA9PSBudWxsIHx8IHVzZXJBdXRvQ29sRGVmLnN1cHByZXNzRmlsdGVyID09IG51bGw7XG4gICAgICAgIGlmIChub1VzZXJGaWx0ZXJQcmVmZXJlbmNlcyAmJiAhdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNUcmVlRGF0YSgpKSB7XG4gICAgICAgICAgICB2YXIgcHJvZHVjZUxlYWZOb2RlVmFsdWVzID0gZGVmYXVsdEF1dG9Db2xEZWYuZmllbGQgIT0gbnVsbCB8fCBkZWZhdWx0QXV0b0NvbERlZi52YWx1ZUdldHRlciAhPSBudWxsO1xuICAgICAgICAgICAgZGVmYXVsdEF1dG9Db2xEZWYuc3VwcHJlc3NGaWx0ZXIgPSAhcHJvZHVjZUxlYWZOb2RlVmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHNob3dpbmcgbWFueSBjb2xzLCB3ZSBkb24ndCB3YW50IHRvIHNob3cgbW9yZSB0aGFuIG9uZSB3aXRoIGEgY2hlY2tib3ggZm9yIHNlbGVjdGlvblxuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBkZWZhdWx0QXV0b0NvbERlZi5oZWFkZXJDaGVja2JveFNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdDb2wgPSBuZXcgY29sdW1uXzEuQ29sdW1uKGRlZmF1bHRBdXRvQ29sRGVmLCBjb2xJZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC53aXJlQmVhbihuZXdDb2wpO1xuICAgICAgICByZXR1cm4gbmV3Q29sO1xuICAgIH07XG4gICAgQXV0b0dyb3VwQ29sU2VydmljZS5wcm90b3R5cGUuZ2VuZXJhdGVEZWZhdWx0Q29sRGVmID0gZnVuY3Rpb24gKHJvd0dyb3VwQ29sLCBpbmRleCkge1xuICAgICAgICB2YXIgbG9jYWxlVGV4dEZ1bmMgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRMb2NhbGVUZXh0RnVuYygpO1xuICAgICAgICB2YXIgZGVmYXVsdEF1dG9Db2xEZWYgPSB7XG4gICAgICAgICAgICBoZWFkZXJOYW1lOiBsb2NhbGVUZXh0RnVuYygnZ3JvdXAnLCAnR3JvdXAnKSxcbiAgICAgICAgICAgIGNlbGxSZW5kZXJlcjogJ2dyb3VwJ1xuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBuZXZlciBhbGxvdyBtb3ZpbmcgdGhlIGdyb3VwIGNvbHVtblxuICAgICAgICBkZWZhdWx0QXV0b0NvbERlZi5zdXBwcmVzc01vdmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAocm93R3JvdXBDb2wpIHtcbiAgICAgICAgICAgIHZhciByb3dHcm91cENvbERlZiA9IHJvd0dyb3VwQ29sLmdldENvbERlZigpO1xuICAgICAgICAgICAgdXRpbHNfMS5fLmFzc2lnbihkZWZhdWx0QXV0b0NvbERlZiwge1xuICAgICAgICAgICAgICAgIC8vIGNlbGxSZW5kZXJlclBhcmFtcy5ncm91cEtleTogY29sRGVmVG9Db3B5LmZpZWxkO1xuICAgICAgICAgICAgICAgIGhlYWRlck5hbWU6IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXREaXNwbGF5TmFtZUZvckNvbHVtbihyb3dHcm91cENvbCwgJ2hlYWRlcicpLFxuICAgICAgICAgICAgICAgIGhlYWRlclZhbHVlR2V0dGVyOiByb3dHcm91cENvbERlZi5oZWFkZXJWYWx1ZUdldHRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocm93R3JvdXBDb2xEZWYuY2VsbFJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5fLmFzc2lnbihkZWZhdWx0QXV0b0NvbERlZiwge1xuICAgICAgICAgICAgICAgICAgICBjZWxsUmVuZGVyZXJQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyUmVuZGVyZXI6IHJvd0dyb3VwQ29sRGVmLmNlbGxSZW5kZXJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyUmVuZGVyZXJQYXJhbXM6IHJvd0dyb3VwQ29sRGVmLmNlbGxSZW5kZXJlclBhcmFtc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0QXV0b0NvbERlZi5zaG93Um93R3JvdXAgPSByb3dHcm91cENvbC5nZXRDb2xJZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdEF1dG9Db2xEZWYuc2hvd1Jvd0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdEF1dG9Db2xEZWY7XG4gICAgfTtcbiAgICBBdXRvR3JvdXBDb2xTZXJ2aWNlLkdST1VQX0FVVE9fQ09MVU1OX0lEID0gJ2FnLUdyaWQtQXV0b0NvbHVtbic7XG4gICAgQXV0b0dyb3VwQ29sU2VydmljZS5HUk9VUF9BVVRPX0NPTFVNTl9CVU5ETEVfSUQgPSBBdXRvR3JvdXBDb2xTZXJ2aWNlXzEuR1JPVVBfQVVUT19DT0xVTU5fSUQ7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEF1dG9Hcm91cENvbFNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBBdXRvR3JvdXBDb2xTZXJ2aWNlLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIEF1dG9Hcm91cENvbFNlcnZpY2UucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBBdXRvR3JvdXBDb2xTZXJ2aWNlID0gQXV0b0dyb3VwQ29sU2VydmljZV8xID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdhdXRvR3JvdXBDb2xTZXJ2aWNlJylcbiAgICBdLCBBdXRvR3JvdXBDb2xTZXJ2aWNlKTtcbiAgICByZXR1cm4gQXV0b0dyb3VwQ29sU2VydmljZTtcbiAgICB2YXIgQXV0b0dyb3VwQ29sU2VydmljZV8xO1xufSgpKTtcbmV4cG9ydHMuQXV0b0dyb3VwQ29sU2VydmljZSA9IEF1dG9Hcm91cENvbFNlcnZpY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9jb2x1bW5Db250cm9sbGVyL2F1dG9Hcm91cENvbFNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGNsYXNzIHJldHVybnMgYSB1bmlxdWUgaWQgdG8gdXNlIGZvciB0aGUgY29sdW1uLiBpdCBjaGVja3MgdGhlIGV4aXN0aW5nIGNvbHVtbnMsIGFuZCBpZiB0aGUgcmVxdWVzdGVkXG4vLyBpZCBpcyBhbHJlYWR5IHRha2VuLCBpdCB3aWxsIHN0YXJ0IGFwcGVuZGluZyBudW1iZXJzIHVudGlsIGl0IGdldHMgYSB1bmlxdWUgaWQuXG4vLyBlZywgaWYgdGhlIGNvbCBmaWVsZCBpcyAnbmFtZScsIGl0IHdpbGwgdHJ5IGlkczoge25hbWUsIG5hbWVfMSwgbmFtZV8yLi4ufVxuLy8gaWYgbm8gZmllbGQgb3IgaWQgcHJvdmlkZWQgaW4gdGhlIGNvbCwgaXQgd2lsbCB0cnkgdGhlIGlkcyBvZiBuYXR1cmFsIG51bWJlcnNcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIENvbHVtbktleUNyZWF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbHVtbktleUNyZWF0b3IoKSB7XG4gICAgICAgIHRoaXMuZXhpc3RpbmdLZXlzID0gW107XG4gICAgfVxuICAgIENvbHVtbktleUNyZWF0b3IucHJvdG90eXBlLmdldFVuaXF1ZUtleSA9IGZ1bmN0aW9uIChjb2xJZCwgY29sRmllbGQpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB1c2VyIHBhc3NlZCBpbiBudW1iZXIgZm9yIGNvbElkLCBjb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICBjb2xJZCA9IHV0aWxzXzEuVXRpbHMudG9TdHJpbmdPck51bGwoY29sSWQpO1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGlkVG9UcnkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoY29sSWQpIHtcbiAgICAgICAgICAgICAgICBpZFRvVHJ5ID0gY29sSWQ7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkVG9UcnkgKz0gJ18nICsgY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29sRmllbGQpIHtcbiAgICAgICAgICAgICAgICBpZFRvVHJ5ID0gY29sRmllbGQ7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkVG9UcnkgKz0gJ18nICsgY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWRUb1RyeSA9ICcnICsgY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5leGlzdGluZ0tleXMuaW5kZXhPZihpZFRvVHJ5KSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4aXN0aW5nS2V5cy5wdXNoKGlkVG9UcnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZFRvVHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbHVtbktleUNyZWF0b3I7XG59KCkpO1xuZXhwb3J0cy5Db2x1bW5LZXlDcmVhdG9yID0gQ29sdW1uS2V5Q3JlYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uS2V5Q3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21wb25lbnRSZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50UmVzb2x2ZXJcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb21wb25lbnRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50UHJvdmlkZXJcIik7XG52YXIgYWdDb21wb25lbnRVdGlsc18xID0gcmVxdWlyZShcIi4vYWdDb21wb25lbnRVdGlsc1wiKTtcbnZhciBOYW1lZENvbXBvbmVudFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYW1lZENvbXBvbmVudFJlc29sdmVyKCkge1xuICAgIH1cbiAgICBOYW1lZENvbXBvbmVudFJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgY29tcG9uZW50TmFtZU9wdCkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWVPcHQgIT0gbnVsbCA/IGNvbXBvbmVudE5hbWVPcHQgOiBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIHZhciByZWdpc3RlcmVkQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRQcm92aWRlci5yZXRyaWV2ZShjb21wb25lbnROYW1lKTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRDb21wb25lbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvL0lmIGl0IGlzIGEgRlcgaXQgaGFzIHRvIGJlIHJlZ2lzdGVyZWQgYXMgYSBjb21wb25lbnRcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRDb21wb25lbnQudHlwZSA9PSBjb21wb25lbnRSZXNvbHZlcl8xLkNvbXBvbmVudFR5cGUuRlJBTUVXT1JLKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVnaXN0ZXJlZENvbXBvbmVudC5jb21wb25lbnQsXG4gICAgICAgICAgICAgICAgdHlwZTogY29tcG9uZW50UmVzb2x2ZXJfMS5Db21wb25lbnRUeXBlLkZSQU1FV09SSyxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGNvbXBvbmVudFJlc29sdmVyXzEuQ29tcG9uZW50U291cmNlLlJFR0lTVEVSRURfQllfTkFNRVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvL0lmIGl0IGlzIEpTIGl0IG1heSBiZSBhIGZ1bmN0aW9uIG9yIGEgY29tcG9uZW50XG4gICAgICAgIGlmICh0aGlzLmFnQ29tcG9uZW50VXRpbHMuZG9lc0ltcGxlbWVudElDb21wb25lbnQocmVnaXN0ZXJlZENvbXBvbmVudC5jb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcmVnaXN0ZXJlZENvbXBvbmVudC5jb21wb25lbnQsXG4gICAgICAgICAgICAgICAgdHlwZTogY29tcG9uZW50UmVzb2x2ZXJfMS5Db21wb25lbnRUeXBlLkFHX0dSSUQsXG4gICAgICAgICAgICAgICAgc291cmNlOiAocmVnaXN0ZXJlZENvbXBvbmVudC5zb3VyY2UgPT0gY29tcG9uZW50UHJvdmlkZXJfMS5SZWdpc3RlcmVkQ29tcG9uZW50U291cmNlLlJFR0lTVEVSRUQpID8gY29tcG9uZW50UmVzb2x2ZXJfMS5Db21wb25lbnRTb3VyY2UuUkVHSVNURVJFRF9CWV9OQU1FIDogY29tcG9uZW50UmVzb2x2ZXJfMS5Db21wb25lbnRTb3VyY2UuREVGQVVMVFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIGEgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIHRoaXMuYWdDb21wb25lbnRVdGlscy5hZGFwdEZ1bmN0aW9uKHByb3BlcnR5TmFtZSwgcmVnaXN0ZXJlZENvbXBvbmVudC5jb21wb25lbnQsIHJlZ2lzdGVyZWRDb21wb25lbnQudHlwZSwgKHJlZ2lzdGVyZWRDb21wb25lbnQuc291cmNlID09IGNvbXBvbmVudFByb3ZpZGVyXzEuUmVnaXN0ZXJlZENvbXBvbmVudFNvdXJjZS5SRUdJU1RFUkVEKSA/IGNvbXBvbmVudFJlc29sdmVyXzEuQ29tcG9uZW50U291cmNlLlJFR0lTVEVSRURfQllfTkFNRSA6IGNvbXBvbmVudFJlc29sdmVyXzEuQ29tcG9uZW50U291cmNlLkRFRkFVTFQpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoXCJjb21wb25lbnRQcm92aWRlclwiKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbXBvbmVudFByb3ZpZGVyXzEuQ29tcG9uZW50UHJvdmlkZXIpXG4gICAgXSwgTmFtZWRDb21wb25lbnRSZXNvbHZlci5wcm90b3R5cGUsIFwiY29tcG9uZW50UHJvdmlkZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZChcImFnQ29tcG9uZW50VXRpbHNcIiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBhZ0NvbXBvbmVudFV0aWxzXzEuQWdDb21wb25lbnRVdGlscylcbiAgICBdLCBOYW1lZENvbXBvbmVudFJlc29sdmVyLnByb3RvdHlwZSwgXCJhZ0NvbXBvbmVudFV0aWxzXCIsIHZvaWQgMCk7XG4gICAgTmFtZWRDb21wb25lbnRSZXNvbHZlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbihcIm5hbWVkQ29tcG9uZW50UmVzb2x2ZXJcIilcbiAgICBdLCBOYW1lZENvbXBvbmVudFJlc29sdmVyKTtcbiAgICByZXR1cm4gTmFtZWRDb21wb25lbnRSZXNvbHZlcjtcbn0oKSk7XG5leHBvcnRzLk5hbWVkQ29tcG9uZW50UmVzb2x2ZXIgPSBOYW1lZENvbXBvbmVudFJlc29sdmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29tcG9uZW50cy9mcmFtZXdvcmsvbmFtZWRDb21wb25lbnRSZXNvbHZlci5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgY29tcG9uZW50QW5ub3RhdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi93aWRnZXRzL2NvbXBvbmVudEFubm90YXRpb25zXCIpO1xudmFyIGJhc2VGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2Jhc2VGaWx0ZXJcIik7XG52YXIgTnVtYmVyRmlsdGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVtYmVyRmlsdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bWJlckZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOdW1iZXJGaWx0ZXIucHJvdG90eXBlLm1vZGVsRnJvbUZsb2F0aW5nRmlsdGVyID0gZnVuY3Rpb24gKGZyb20pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZmlsdGVyLFxuICAgICAgICAgICAgZmlsdGVyOiBOdW1iZXIoZnJvbSksXG4gICAgICAgICAgICBmaWx0ZXJUbzogdGhpcy5maWx0ZXJOdW1iZXJUbyxcbiAgICAgICAgICAgIGZpbHRlclR5cGU6ICdudW1iZXInXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBOdW1iZXJGaWx0ZXIucHJvdG90eXBlLmdldEFwcGxpY2FibGVGaWx0ZXJUeXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtiYXNlRmlsdGVyXzEuQmFzZUZpbHRlci5FUVVBTFMsIGJhc2VGaWx0ZXJfMS5CYXNlRmlsdGVyLk5PVF9FUVVBTCwgYmFzZUZpbHRlcl8xLkJhc2VGaWx0ZXIuTEVTU19USEFOLCBiYXNlRmlsdGVyXzEuQmFzZUZpbHRlci5MRVNTX1RIQU5fT1JfRVFVQUwsXG4gICAgICAgICAgICBiYXNlRmlsdGVyXzEuQmFzZUZpbHRlci5HUkVBVEVSX1RIQU4sIGJhc2VGaWx0ZXJfMS5CYXNlRmlsdGVyLkdSRUFURVJfVEhBTl9PUl9FUVVBTCwgYmFzZUZpbHRlcl8xLkJhc2VGaWx0ZXIuSU5fUkFOR0VdO1xuICAgIH07XG4gICAgTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5ib2R5VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJhZy1maWx0ZXItYm9keVxcXCI+XFxuICAgICAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJhZy1maWx0ZXItZmlsdGVyXFxcIiBpZD1cXFwiZmlsdGVyVGV4dFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIlwiICsgdHJhbnNsYXRlKCdmaWx0ZXJPb28nKSArIFwiXFxcIi8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImFnLWZpbHRlci1udW1iZXItdG9cXFwiIGlkPVxcXCJmaWx0ZXJOdW1iZXJUb1BhbmVsXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJhZy1maWx0ZXItZmlsdGVyXFxcIiBpZD1cXFwiZmlsdGVyVG9UZXh0XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiXCIgKyB0cmFuc2xhdGUoJ2ZpbHRlck9vbycpICsgXCJcXFwiLz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlwiO1xuICAgIH07XG4gICAgTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5pbml0aWFsaXNlRmlsdGVyQm9keVVpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZpbHRlck51bWJlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZUZpbHRlclRleHRGaWVsZCA9IHRoaXMucXVlcnlGb3JIdG1sSW5wdXRFbGVtZW50KFwiI2ZpbHRlclRleHRcIik7XG4gICAgICAgIHZhciBkZWJvdW5jZU1zID0gdGhpcy5maWx0ZXJQYXJhbXMuZGVib3VuY2VNcyAhPSBudWxsID8gdGhpcy5maWx0ZXJQYXJhbXMuZGVib3VuY2VNcyA6IDUwMDtcbiAgICAgICAgdmFyIHRvRGVib3VuY2UgPSB1dGlsc18xLlV0aWxzLmRlYm91bmNlKHRoaXMub25UZXh0RmllbGRzQ2hhbmdlZC5iaW5kKHRoaXMpLCBkZWJvdW5jZU1zKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lRmlsdGVyVGV4dEZpZWxkLCBcImlucHV0XCIsIHRvRGVib3VuY2UpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVGaWx0ZXJUb1RleHRGaWVsZCwgXCJpbnB1dFwiLCB0b0RlYm91bmNlKTtcbiAgICB9O1xuICAgIE51bWJlckZpbHRlci5wcm90b3R5cGUuYWZ0ZXJHdWlBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lRmlsdGVyVGV4dEZpZWxkLmZvY3VzKCk7XG4gICAgfTtcbiAgICBOdW1iZXJGaWx0ZXIucHJvdG90eXBlLmNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSByaWdodClcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsZWZ0IDwgcmlnaHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAobGVmdCA+IHJpZ2h0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE51bWJlckZpbHRlci5wcm90b3R5cGUub25UZXh0RmllbGRzQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0ZpbHRlciA9IHRoaXMuc3RyaW5nVG9GbG9hdCh0aGlzLmVGaWx0ZXJUZXh0RmllbGQudmFsdWUpO1xuICAgICAgICB2YXIgbmV3RmlsdGVyVG8gPSB0aGlzLnN0cmluZ1RvRmxvYXQodGhpcy5lRmlsdGVyVG9UZXh0RmllbGQudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJOdW1iZXIgIT09IG5ld0ZpbHRlciB8fCB0aGlzLmZpbHRlck51bWJlclRvICE9PSBuZXdGaWx0ZXJUbykge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJOdW1iZXIgPSBuZXdGaWx0ZXI7XG4gICAgICAgICAgICB0aGlzLmZpbHRlck51bWJlclRvID0gbmV3RmlsdGVyVG87XG4gICAgICAgICAgICB0aGlzLm9uRmlsdGVyQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOdW1iZXJGaWx0ZXIucHJvdG90eXBlLmZpbHRlclZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyICE9PSBiYXNlRmlsdGVyXzEuQmFzZUZpbHRlci5JTl9SQU5HRSA/XG4gICAgICAgICAgICB0aGlzLmFzTnVtYmVyKHRoaXMuZmlsdGVyTnVtYmVyKSA6XG4gICAgICAgICAgICBbdGhpcy5hc051bWJlcih0aGlzLmZpbHRlck51bWJlciksIHRoaXMuYXNOdW1iZXIodGhpcy5maWx0ZXJOdW1iZXJUbyldO1xuICAgIH07XG4gICAgTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5hc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5VdGlscy5pc051bWVyaWModmFsdWUpID8gdmFsdWUgOiBudWxsO1xuICAgIH07XG4gICAgTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5zdHJpbmdUb0Zsb2F0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWx0ZXJUZXh0ID0gdXRpbHNfMS5VdGlscy5tYWtlTnVsbCh2YWx1ZSk7XG4gICAgICAgIGlmIChmaWx0ZXJUZXh0ICYmIGZpbHRlclRleHQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgZmlsdGVyVGV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0ZpbHRlcjtcbiAgICAgICAgaWYgKGZpbHRlclRleHQgIT09IG51bGwgJiYgZmlsdGVyVGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdGaWx0ZXIgPSBwYXJzZUZsb2F0KGZpbHRlclRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RmlsdGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RmlsdGVyO1xuICAgIH07XG4gICAgTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIGZpbHRlciA9IHV0aWxzXzEuVXRpbHMubWFrZU51bGwoZmlsdGVyKTtcbiAgICAgICAgaWYgKGZpbHRlciAhPT0gbnVsbCAmJiAhKHR5cGVvZiBmaWx0ZXIgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgZmlsdGVyID0gcGFyc2VGbG9hdChmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyTnVtYmVyID0gZmlsdGVyO1xuICAgICAgICB0aGlzLmVGaWx0ZXJUZXh0RmllbGQudmFsdWUgPSBmaWx0ZXI7XG4gICAgfTtcbiAgICBOdW1iZXJGaWx0ZXIucHJvdG90eXBlLnNldEZpbHRlclRvID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICBmaWx0ZXIgPSB1dGlsc18xLlV0aWxzLm1ha2VOdWxsKGZpbHRlcik7XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IG51bGwgJiYgISh0eXBlb2YgZmlsdGVyID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IHBhcnNlRmxvYXQoZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlck51bWJlclRvID0gZmlsdGVyO1xuICAgICAgICB0aGlzLmVGaWx0ZXJUb1RleHRGaWVsZC52YWx1ZSA9IGZpbHRlcjtcbiAgICB9O1xuICAgIE51bWJlckZpbHRlci5wcm90b3R5cGUuZ2V0RmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJOdW1iZXI7XG4gICAgfTtcbiAgICBOdW1iZXJGaWx0ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZmlsdGVyID8gdGhpcy5maWx0ZXIgOiB0aGlzLmRlZmF1bHRGaWx0ZXIsXG4gICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyTnVtYmVyLFxuICAgICAgICAgICAgZmlsdGVyVG86IHRoaXMuZmlsdGVyTnVtYmVyVG8sXG4gICAgICAgICAgICBmaWx0ZXJUeXBlOiAnbnVtYmVyJ1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB0aGlzLnNldEZpbHRlclR5cGUobW9kZWwudHlwZSk7XG4gICAgICAgIHRoaXMuc2V0RmlsdGVyKG1vZGVsLmZpbHRlcik7XG4gICAgICAgIHRoaXMuc2V0RmlsdGVyVG8obW9kZWwuZmlsdGVyVG8pO1xuICAgIH07XG4gICAgTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5yZWZyZXNoRmlsdGVyQm9keVVpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuZmlsdGVyID09PSBOdW1iZXJGaWx0ZXIuSU5fUkFOR0U7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuc2V0VmlzaWJsZSh0aGlzLmVOdW1iZXJUb1BhbmVsLCB2aXNpYmxlKTtcbiAgICB9O1xuICAgIE51bWJlckZpbHRlci5wcm90b3R5cGUucmVzZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRGaWx0ZXJUeXBlKHRoaXMuZGVmYXVsdEZpbHRlcik7XG4gICAgICAgIHRoaXMuc2V0RmlsdGVyKG51bGwpO1xuICAgICAgICB0aGlzLnNldEZpbHRlclRvKG51bGwpO1xuICAgIH07XG4gICAgTnVtYmVyRmlsdGVyLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24gKGZpbHRlclR5cGUpIHtcbiAgICAgICAgdGhpcy5zZXRGaWx0ZXJUeXBlKGZpbHRlclR5cGUpO1xuICAgIH07XG4gICAgTnVtYmVyRmlsdGVyLkxFU1NfVEhBTiA9ICdsZXNzVGhhbic7IC8vMztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5RdWVyeVNlbGVjdG9yKCcjZmlsdGVyTnVtYmVyVG9QYW5lbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgTnVtYmVyRmlsdGVyLnByb3RvdHlwZSwgXCJlTnVtYmVyVG9QYW5lbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlF1ZXJ5U2VsZWN0b3IoJyNmaWx0ZXJUb1RleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxJbnB1dEVsZW1lbnQpXG4gICAgXSwgTnVtYmVyRmlsdGVyLnByb3RvdHlwZSwgXCJlRmlsdGVyVG9UZXh0RmllbGRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gTnVtYmVyRmlsdGVyO1xufShiYXNlRmlsdGVyXzEuU2NhbGFyQmFzZUZpbHRlcikpO1xuZXhwb3J0cy5OdW1iZXJGaWx0ZXIgPSBOdW1iZXJGaWx0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9maWx0ZXIvbnVtYmVyRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBiYXNlRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9iYXNlRmlsdGVyXCIpO1xudmFyIGNvbXBvbmVudEFubm90YXRpb25zXzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9jb21wb25lbnRBbm5vdGF0aW9uc1wiKTtcbnZhciBUZXh0RmlsdGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dEZpbHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRleHRGaWx0ZXIucHJvdG90eXBlLmdldERlZmF1bHRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmFzZUZpbHRlcl8xLkJhc2VGaWx0ZXIuQ09OVEFJTlM7XG4gICAgfTtcbiAgICBUZXh0RmlsdGVyLnByb3RvdHlwZS5jdXN0b21Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSB0aGlzLmZpbHRlclBhcmFtcy50ZXh0Q3VzdG9tQ29tcGFyYXRvciA/IHRoaXMuZmlsdGVyUGFyYW1zLnRleHRDdXN0b21Db21wYXJhdG9yIDogVGV4dEZpbHRlci5ERUZBVUxUX0NPTVBBUkFUT1I7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVyID1cbiAgICAgICAgICAgIHRoaXMuZmlsdGVyUGFyYW1zLnRleHRGb3JtYXR0ZXIgPyB0aGlzLmZpbHRlclBhcmFtcy50ZXh0Rm9ybWF0dGVyIDpcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlclBhcmFtcy5jYXNlU2Vuc2l0aXZlID09IHRydWUgPyBUZXh0RmlsdGVyLkRFRkFVTFRfRk9STUFUVEVSIDpcbiAgICAgICAgICAgICAgICAgICAgVGV4dEZpbHRlci5ERUZBVUxUX0xPV0VSQ0FTRV9GT1JNQVRURVI7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuY3VzdG9tSW5pdC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgVGV4dEZpbHRlci5wcm90b3R5cGUubW9kZWxGcm9tRmxvYXRpbmdGaWx0ZXIgPSBmdW5jdGlvbiAoZnJvbSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5maWx0ZXIsXG4gICAgICAgICAgICBmaWx0ZXI6IGZyb20sXG4gICAgICAgICAgICBmaWx0ZXJUeXBlOiAndGV4dCdcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRleHRGaWx0ZXIucHJvdG90eXBlLmdldEFwcGxpY2FibGVGaWx0ZXJUeXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtiYXNlRmlsdGVyXzEuQmFzZUZpbHRlci5FUVVBTFMsIGJhc2VGaWx0ZXJfMS5CYXNlRmlsdGVyLk5PVF9FUVVBTCwgYmFzZUZpbHRlcl8xLkJhc2VGaWx0ZXIuU1RBUlRTX1dJVEgsIGJhc2VGaWx0ZXJfMS5CYXNlRmlsdGVyLkVORFNfV0lUSCxcbiAgICAgICAgICAgIGJhc2VGaWx0ZXJfMS5CYXNlRmlsdGVyLkNPTlRBSU5TLCBiYXNlRmlsdGVyXzEuQmFzZUZpbHRlci5OT1RfQ09OVEFJTlNdO1xuICAgIH07XG4gICAgVGV4dEZpbHRlci5wcm90b3R5cGUuYm9keVRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiYWctZmlsdGVyLWJvZHlcXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiYWctZmlsdGVyLWZpbHRlclxcXCIgaWQ9XFxcImZpbHRlclRleHRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJcIiArIHRyYW5zbGF0ZSgnZmlsdGVyT29vJywgJ0ZpbHRlci4uLicpICsgXCJcXFwiLz5cXG4gICAgICAgIDwvZGl2PlwiO1xuICAgIH07XG4gICAgVGV4dEZpbHRlci5wcm90b3R5cGUuaW5pdGlhbGlzZUZpbHRlckJvZHlVaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0aWFsaXNlRmlsdGVyQm9keVVpLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBkZWJvdW5jZU1zID0gdGhpcy5maWx0ZXJQYXJhbXMuZGVib3VuY2VNcyAhPSBudWxsID8gdGhpcy5maWx0ZXJQYXJhbXMuZGVib3VuY2VNcyA6IDUwMDtcbiAgICAgICAgdmFyIHRvRGVib3VuY2UgPSB1dGlsc18xLlV0aWxzLmRlYm91bmNlKHRoaXMub25GaWx0ZXJUZXh0RmllbGRDaGFuZ2VkLmJpbmQodGhpcyksIGRlYm91bmNlTXMpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVGaWx0ZXJUZXh0RmllbGQsICdpbnB1dCcsIHRvRGVib3VuY2UpO1xuICAgIH07XG4gICAgVGV4dEZpbHRlci5wcm90b3R5cGUucmVmcmVzaEZpbHRlckJvZHlVaSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBUZXh0RmlsdGVyLnByb3RvdHlwZS5hZnRlckd1aUF0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVGaWx0ZXJUZXh0RmllbGQuZm9jdXMoKTtcbiAgICB9O1xuICAgIFRleHRGaWx0ZXIucHJvdG90eXBlLmZpbHRlclZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyVGV4dDtcbiAgICB9O1xuICAgIFRleHRGaWx0ZXIucHJvdG90eXBlLmRvZXNGaWx0ZXJQYXNzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5maWx0ZXJQYXJhbXMudmFsdWVHZXR0ZXIocGFyYW1zLm5vZGUpO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIgPT09IGJhc2VGaWx0ZXJfMS5CYXNlRmlsdGVyLk5PVF9FUVVBTCB8fCB0aGlzLmZpbHRlciA9PT0gYmFzZUZpbHRlcl8xLkJhc2VGaWx0ZXIuTk9UX0NPTlRBSU5TKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gdmFsdWUsIGJ1dCB0aGUgZmlsdGVyIHR5cGUgd2FzICdub3QgZXF1YWxzJyxcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGl0IHNob3VsZCBwYXNzLCBhcyBhIG1pc3NpbmcgdmFsdWUgaXMgbm90IGVxdWFsIHdoYXRldmVyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIgaXMgZmlsdGVyaW5nIG9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBzb21lIHR5cGUgb2YgY29tcGFyaXNvbiwgdG8gd2hpY2ggZW1wdHkgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGFsd2F5cyBmYWlsXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0dGVyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyYXRvcih0aGlzLmZpbHRlciwgdmFsdWVGb3JtYXR0ZWQsIHRoaXMuZmlsdGVyVGV4dCk7XG4gICAgfTtcbiAgICBUZXh0RmlsdGVyLnByb3RvdHlwZS5vbkZpbHRlclRleHRGaWVsZENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWx0ZXJUZXh0ID0gdXRpbHNfMS5VdGlscy5tYWtlTnVsbCh0aGlzLmVGaWx0ZXJUZXh0RmllbGQudmFsdWUpO1xuICAgICAgICBpZiAoZmlsdGVyVGV4dCAmJiBmaWx0ZXJUZXh0LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIGZpbHRlclRleHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbHRlclRleHQgIT09IGZpbHRlclRleHQpIHtcbiAgICAgICAgICAgIHZhciBuZXdMb3dlckNhc2UgPSBmaWx0ZXJUZXh0ICYmIHRoaXMuZmlsdGVyUGFyYW1zLmNhc2VTZW5zaXRpdmUgIT0gdHJ1ZSA/IGZpbHRlclRleHQudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0xvd2VyQ2FzZSA9IHRoaXMuZmlsdGVyVGV4dCAmJiB0aGlzLmZpbHRlclBhcmFtcy5jYXNlU2Vuc2l0aXZlICE9IHRydWUgPyB0aGlzLmZpbHRlclRleHQudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJUZXh0O1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJUZXh0ID0gdGhpcy5mb3JtYXR0ZXIoZmlsdGVyVGV4dCk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNMb3dlckNhc2UgIT09IG5ld0xvd2VyQ2FzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25GaWx0ZXJDaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRGaWx0ZXIucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgZmlsdGVyID0gdXRpbHNfMS5VdGlscy5tYWtlTnVsbChmaWx0ZXIpO1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlclRleHQgPSB0aGlzLmZvcm1hdHRlcihmaWx0ZXIpO1xuICAgICAgICAgICAgdGhpcy5lRmlsdGVyVGV4dEZpZWxkLnZhbHVlID0gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJUZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZUZpbHRlclRleHRGaWVsZC52YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRGaWx0ZXIucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyVGV4dDtcbiAgICB9O1xuICAgIFRleHRGaWx0ZXIucHJvdG90eXBlLnJlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsdGVyKG51bGwpO1xuICAgICAgICB0aGlzLnNldEZpbHRlclR5cGUodGhpcy5kZWZhdWx0RmlsdGVyKTtcbiAgICB9O1xuICAgIFRleHRGaWx0ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZmlsdGVyID8gdGhpcy5maWx0ZXIgOiB0aGlzLmRlZmF1bHRGaWx0ZXIsXG4gICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyVGV4dCxcbiAgICAgICAgICAgIGZpbHRlclR5cGU6ICd0ZXh0J1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGV4dEZpbHRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdGhpcy5zZXRGaWx0ZXJUeXBlKG1vZGVsLnR5cGUpO1xuICAgICAgICB0aGlzLnNldEZpbHRlcihtb2RlbC5maWx0ZXIpO1xuICAgIH07XG4gICAgVGV4dEZpbHRlci5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uIChmaWx0ZXJUeXBlKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsdGVyVHlwZShmaWx0ZXJUeXBlKTtcbiAgICB9O1xuICAgIFRleHRGaWx0ZXIuREVGQVVMVF9GT1JNQVRURVIgPSBmdW5jdGlvbiAoZnJvbSkge1xuICAgICAgICByZXR1cm4gZnJvbTtcbiAgICB9O1xuICAgIFRleHRGaWx0ZXIuREVGQVVMVF9MT1dFUkNBU0VfRk9STUFUVEVSID0gZnVuY3Rpb24gKGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gZnJvbS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgfTtcbiAgICBUZXh0RmlsdGVyLkRFRkFVTFRfQ09NUEFSQVRPUiA9IGZ1bmN0aW9uIChmaWx0ZXIsIHZhbHVlLCBmaWx0ZXJUZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZmlsdGVyKSB7XG4gICAgICAgICAgICBjYXNlIFRleHRGaWx0ZXIuQ09OVEFJTlM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsdGVyVGV4dCkgPj0gMDtcbiAgICAgICAgICAgIGNhc2UgVGV4dEZpbHRlci5OT1RfQ09OVEFJTlM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsdGVyVGV4dCkgPT09IC0xO1xuICAgICAgICAgICAgY2FzZSBUZXh0RmlsdGVyLkVRVUFMUzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZpbHRlclRleHQ7XG4gICAgICAgICAgICBjYXNlIFRleHRGaWx0ZXIuTk9UX0VRVUFMOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBmaWx0ZXJUZXh0O1xuICAgICAgICAgICAgY2FzZSBUZXh0RmlsdGVyLlNUQVJUU19XSVRIOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlclRleHQpID09PSAwO1xuICAgICAgICAgICAgY2FzZSBUZXh0RmlsdGVyLkVORFNfV0lUSDpcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB2YWx1ZS5sYXN0SW5kZXhPZihmaWx0ZXJUZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA9PT0gKHZhbHVlLmxlbmd0aCAtIGZpbHRlclRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaW52YWxpZCBmaWx0ZXIgdHlwZSAnICsgZmlsdGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlF1ZXJ5U2VsZWN0b3IoJyNmaWx0ZXJUZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MSW5wdXRFbGVtZW50KVxuICAgIF0sIFRleHRGaWx0ZXIucHJvdG90eXBlLCBcImVGaWx0ZXJUZXh0RmllbGRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gVGV4dEZpbHRlcjtcbn0oYmFzZUZpbHRlcl8xLkNvbXBhcmFibGVCYXNlRmlsdGVyKSk7XG5leHBvcnRzLlRleHRGaWx0ZXIgPSBUZXh0RmlsdGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZmlsdGVyL3RleHRGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBncmlkQ2VsbF8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2dyaWRDZWxsXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBtb3VzZUV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4vbW91c2VFdmVudFNlcnZpY2VcIik7XG52YXIgcGFnaW5hdGlvblByb3h5XzEgPSByZXF1aXJlKFwiLi4vcm93TW9kZWxzL3BhZ2luYXRpb25Qcm94eVwiKTtcbnZhciBmb2N1c2VkQ2VsbENvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9mb2N1c2VkQ2VsbENvbnRyb2xsZXJcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBncmlkUGFuZWxfMSA9IHJlcXVpcmUoXCIuL2dyaWRQYW5lbFwiKTtcbnZhciBhbmltYXRpb25GcmFtZVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9taXNjL2FuaW1hdGlvbkZyYW1lU2VydmljZVwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBOYXZpZ2F0aW9uU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvblNlcnZpY2UoKSB7XG4gICAgfVxuICAgIE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFdpZHRoID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0U2Nyb2xsYmFyV2lkdGgoKTtcbiAgICB9O1xuICAgIE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5oYW5kbGVQYWdlU2Nyb2xsaW5nS2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlO1xuICAgICAgICB2YXIgYWx0ID0gZXZlbnQuYWx0S2V5O1xuICAgICAgICB2YXIgY3RybCA9IGV2ZW50LmN0cmxLZXk7XG4gICAgICAgIHZhciBjdXJyZW50Q2VsbCA9IHRoaXMubW91c2VFdmVudFNlcnZpY2UuZ2V0R3JpZENlbGxGb3JFdmVudChldmVudCkuZ2V0R3JpZENlbGxEZWYoKTtcbiAgICAgICAgaWYgKCFjdXJyZW50Q2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9QQUdFX0hPTUU6XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfUEFHRV9FTkQ6XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGhvbWUgYW5kIGVuZCB3aGVuIGN0cmwgJiBhbHQgYXJlIE5PVCBwcmVzc2VkXG4gICAgICAgICAgICAgICAgaWYgKCFjdHJsICYmICFhbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkhvbWVPckVuZEtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9MRUZUOlxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX1JJR0hUOlxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBsZWZ0IGFuZCByaWdodCB3aGVuIGN0cmwgaXMgcHJlc3NlZCBvbmx5XG4gICAgICAgICAgICAgICAgaWYgKGN0cmwgJiYgIWFsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ3RybExlZnRPclJpZ2h0KGtleSwgY3VycmVudENlbGwpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9VUDpcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9ET1dOOlxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB1cCBhbmQgZG93biB3aGVuIGN0cmwgaXMgcHJlc3NlZCBvbmx5XG4gICAgICAgICAgICAgICAgaWYgKGN0cmwgJiYgIWFsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ3RybFVwT3JEb3duKGtleSwgY3VycmVudENlbGwpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9QQUdFX0RPV046XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHBhZ2UgdXAgYW5kIHBhZ2UgZG93biB3aGVuIGN0cmwgJiBhbHQgYXJlIE5PVCBwcmVzc2VkXG4gICAgICAgICAgICAgICAgaWYgKCFjdHJsICYmICFhbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblBhZ2VEb3duKGN1cnJlbnRDZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfUEFHRV9VUDpcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgcGFnZSB1cCBhbmQgcGFnZSBkb3duIHdoZW4gY3RybCAmIGFsdCBhcmUgTk9UIHByZXNzZWRcbiAgICAgICAgICAgICAgICBpZiAoIWN0cmwgJiYgIWFsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFnZVVwKGN1cnJlbnRDZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3NlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgIH07XG4gICAgTmF2aWdhdGlvblNlcnZpY2UucHJvdG90eXBlLm9uUGFnZURvd24gPSBmdW5jdGlvbiAoZ3JpZENlbGwpIHtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5ncmlkUGFuZWwuZ2V0UHJpbWFyeVNjcm9sbFZpZXdwb3J0KCk7XG4gICAgICAgIHZhciBwaXhlbHNJbk9uZVBhZ2UgPSB2aWV3cG9ydC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmdyaWRQYW5lbC5pc0hvcml6b250YWxTY3JvbGxTaG93aW5nKCkpIHtcbiAgICAgICAgICAgIHBpeGVsc0luT25lUGFnZSAtPSB0aGlzLnNjcm9sbFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWdpbmdQaXhlbE9mZnNldCA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFBpeGVsT2Zmc2V0KCk7XG4gICAgICAgIHZhciBjdXJyZW50UGFnZUJvdHRvbVBpeGVsID0gdmlld3BvcnQuc2Nyb2xsVG9wICsgcGl4ZWxzSW5PbmVQYWdlO1xuICAgICAgICB2YXIgY3VycmVudFBhZ2VCb3R0b21Sb3cgPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRSb3dJbmRleEF0UGl4ZWwoY3VycmVudFBhZ2VCb3R0b21QaXhlbCArIHBhZ2luZ1BpeGVsT2Zmc2V0KTtcbiAgICAgICAgdmFyIHNjcm9sbEluZGV4ID0gY3VycmVudFBhZ2VCb3R0b21Sb3c7XG4gICAgICAgIHZhciBjdXJyZW50Q2VsbFBpeGVsID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0Um93KGdyaWRDZWxsLnJvd0luZGV4KS5yb3dUb3A7XG4gICAgICAgIHZhciBuZXh0Q2VsbFBpeGVsID0gY3VycmVudENlbGxQaXhlbCArIHBpeGVsc0luT25lUGFnZSAtIHBhZ2luZ1BpeGVsT2Zmc2V0O1xuICAgICAgICB2YXIgZm9jdXNJbmRleCA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFJvd0luZGV4QXRQaXhlbChuZXh0Q2VsbFBpeGVsICsgcGFnaW5nUGl4ZWxPZmZzZXQpO1xuICAgICAgICB2YXIgcGFnZUxhc3RSb3cgPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRQYWdlTGFzdFJvdygpO1xuICAgICAgICBpZiAoZm9jdXNJbmRleCA+IHBhZ2VMYXN0Um93KSB7XG4gICAgICAgICAgICBmb2N1c0luZGV4ID0gcGFnZUxhc3RSb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbEluZGV4ID4gcGFnZUxhc3RSb3cpIHtcbiAgICAgICAgICAgIHNjcm9sbEluZGV4ID0gcGFnZUxhc3RSb3c7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYXZpZ2F0ZVRvKHNjcm9sbEluZGV4LCAndG9wJywgbnVsbCwgZm9jdXNJbmRleCwgZ3JpZENlbGwuY29sdW1uKTtcbiAgICB9O1xuICAgIE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vblBhZ2VVcCA9IGZ1bmN0aW9uIChncmlkQ2VsbCkge1xuICAgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLmdyaWRQYW5lbC5nZXRQcmltYXJ5U2Nyb2xsVmlld3BvcnQoKTtcbiAgICAgICAgdmFyIHBpeGVsc0luT25lUGFnZSA9IHZpZXdwb3J0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZFBhbmVsLmlzSG9yaXpvbnRhbFNjcm9sbFNob3dpbmcoKSkge1xuICAgICAgICAgICAgcGl4ZWxzSW5PbmVQYWdlIC09IHRoaXMuc2Nyb2xsV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZ2luZ1BpeGVsT2Zmc2V0ID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0UGl4ZWxPZmZzZXQoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRQYWdlVG9wUGl4ZWwgPSB2aWV3cG9ydC5zY3JvbGxUb3A7XG4gICAgICAgIHZhciBjdXJyZW50UGFnZVRvcFJvdyA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFJvd0luZGV4QXRQaXhlbChjdXJyZW50UGFnZVRvcFBpeGVsICsgcGFnaW5nUGl4ZWxPZmZzZXQpO1xuICAgICAgICB2YXIgc2Nyb2xsSW5kZXggPSBjdXJyZW50UGFnZVRvcFJvdztcbiAgICAgICAgdmFyIGN1cnJlbnRSb3dOb2RlID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0Um93KGdyaWRDZWxsLnJvd0luZGV4KTtcbiAgICAgICAgdmFyIG5leHRDZWxsUGl4ZWwgPSBjdXJyZW50Um93Tm9kZS5yb3dUb3AgKyBjdXJyZW50Um93Tm9kZS5yb3dIZWlnaHQgLSBwaXhlbHNJbk9uZVBhZ2UgLSBwYWdpbmdQaXhlbE9mZnNldDtcbiAgICAgICAgdmFyIGZvY3VzSW5kZXggPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRSb3dJbmRleEF0UGl4ZWwobmV4dENlbGxQaXhlbCArIHBhZ2luZ1BpeGVsT2Zmc2V0KTtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0UGFnZUZpcnN0Um93KCk7XG4gICAgICAgIGlmIChmb2N1c0luZGV4IDwgZmlyc3RSb3cpIHtcbiAgICAgICAgICAgIGZvY3VzSW5kZXggPSBmaXJzdFJvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsSW5kZXggPCBmaXJzdFJvdykge1xuICAgICAgICAgICAgc2Nyb2xsSW5kZXggPSBmaXJzdFJvdztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRlVG8oc2Nyb2xsSW5kZXgsICdib3R0b20nLCBudWxsLCBmb2N1c0luZGV4LCBncmlkQ2VsbC5jb2x1bW4pO1xuICAgIH07XG4gICAgLy8gY29tbW9uIGxvZ2ljIHRvIG5hdmlnYXRlLiB0YWtlcyBwYXJhbWV0ZXJzOlxuICAgIC8vIHNjcm9sbEluZGV4IC0gd2hhdCByb3cgdG8gdmVydGljYWxseSBzY3JvbGwgdG9cbiAgICAvLyBzY3JvbGxUeXBlIC0gd2hhdCBwb3NpdGlvbiB0byBwdXQgc2Nyb2xsIGluZGV4IGllIHRvcC9ib3R0b21cbiAgICAvLyBzY3JvbGxDb2x1bW4gLSB3aGF0IGNvbHVtbiB0byBob3Jpem9udGFsbHkgc2Nyb2xsIHRvXG4gICAgLy8gZm9jdXNJbmRleCAvIGZvY3VzQ29sdW1uIC0gZm9yIHBhZ2UgdXAgLyBkb3duLCB3ZSB3YW50IHRvIHNjcm9sbCB0byBvbmUgcm93L2NvbHVtbiwgYnV0IGZvY3VzIGFub3RoZXJcbiAgICBOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUubmF2aWdhdGVUbyA9IGZ1bmN0aW9uIChzY3JvbGxJbmRleCwgc2Nyb2xsVHlwZSwgc2Nyb2xsQ29sdW1uLCBmb2N1c0luZGV4LCBmb2N1c0NvbHVtbikge1xuICAgICAgICBpZiAodXRpbHNfMS5fLmV4aXN0cyhzY3JvbGxDb2x1bW4pKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRQYW5lbC5lbnN1cmVDb2x1bW5WaXNpYmxlKHNjcm9sbENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzXzEuXy5leGlzdHMoc2Nyb2xsSW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRQYW5lbC5lbnN1cmVJbmRleFZpc2libGUoc2Nyb2xsSW5kZXgsIHNjcm9sbFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgY2VsbCBpcyByZW5kZXJlZCwgbmVlZGVkIGlmIHdlIGFyZSB0byBmb2N1c1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lU2VydmljZS5mbHVzaEFsbEZyYW1lcygpO1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCBkbyB0aGlzLCB0aGUgcmFuZ2Ugd2lsbCBiZSBsZWZ0IG9uIHRoZSBsYXN0IGNlbGwsIHdoaWNoIHdpbGwgbGVhdmUgdGhlIGxhc3QgZm9jdXNlZCBjZWxsXG4gICAgICAgIC8vIGhpZ2hsaWdodGVkLlxuICAgICAgICB0aGlzLmZvY3VzZWRDZWxsQ29udHJvbGxlci5zZXRGb2N1c2VkQ2VsbChmb2N1c0luZGV4LCBmb2N1c0NvbHVtbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIGdyaWRDZWxsID0gbmV3IGdyaWRDZWxsXzEuR3JpZENlbGwoeyByb3dJbmRleDogZm9jdXNJbmRleCwgZmxvYXRpbmc6IG51bGwsIGNvbHVtbjogZm9jdXNDb2x1bW4gfSk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlQ29udHJvbGxlci5zZXRSYW5nZVRvQ2VsbChncmlkQ2VsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGN0cmwgKyB1cC9kb3duIHdpbGwgYnJpbmcgZm9jdXMgdG8gc2FtZSBjb2x1bW4sIGZpcnN0L2xhc3Qgcm93LiBubyBob3Jpem9udGFsIHNjcm9sbGluZy5cbiAgICBOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUub25DdHJsVXBPckRvd24gPSBmdW5jdGlvbiAoa2V5LCBncmlkQ2VsbCkge1xuICAgICAgICB2YXIgdXBLZXkgPSBrZXkgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfVVA7XG4gICAgICAgIHZhciByb3dJbmRleFRvU2Nyb2xsVG8gPSB1cEtleSA/IDAgOiB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRQYWdlTGFzdFJvdygpO1xuICAgICAgICB0aGlzLm5hdmlnYXRlVG8ocm93SW5kZXhUb1Njcm9sbFRvLCBudWxsLCBncmlkQ2VsbC5jb2x1bW4sIHJvd0luZGV4VG9TY3JvbGxUbywgZ3JpZENlbGwuY29sdW1uKTtcbiAgICB9O1xuICAgIC8vIGN0cmwgKyBsZWZ0L3JpZ2h0IHdpbGwgYnJpbmcgZm9jdXMgdG8gc2FtZSByb3csIGZpcnN0L2xhc3QgY2VsbC4gbm8gdmVydGljYWwgc2Nyb2xsaW5nLlxuICAgIE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkN0cmxMZWZ0T3JSaWdodCA9IGZ1bmN0aW9uIChrZXksIGdyaWRDZWxsKSB7XG4gICAgICAgIHZhciBsZWZ0S2V5ID0ga2V5ID09PSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX0xFRlQ7XG4gICAgICAgIHZhciBhbGxDb2x1bW5zID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldEFsbERpc3BsYXllZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIGNvbHVtblRvU2VsZWN0ID0gbGVmdEtleSA/IGFsbENvbHVtbnNbMF0gOiBhbGxDb2x1bW5zW2FsbENvbHVtbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMubmF2aWdhdGVUbyhncmlkQ2VsbC5yb3dJbmRleCwgbnVsbCwgY29sdW1uVG9TZWxlY3QsIGdyaWRDZWxsLnJvd0luZGV4LCBjb2x1bW5Ub1NlbGVjdCk7XG4gICAgfTtcbiAgICAvLyBob21lIGJyaW5ncyBmb2N1cyB0byB0b3AgbGVmdCBjZWxsLCBlbmQgYnJpbmdzIGZvY3VzIHRvIGJvdHRvbSByaWdodCwgZ3JpZCBzY3JvbGxlZCB0byBicmluZ1xuICAgIC8vIHNhbWUgY2VsbCBpbnRvIHZpZXcgKHdoaWNoIG1lYW5zIGVpdGhlciBzY3JvbGwgYWxsIHRoZSB3YXkgdXAsIG9yIGFsbCB0aGUgd2F5IGRvd24pLlxuICAgIE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkhvbWVPckVuZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGhvbWVLZXkgPSBrZXkgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfUEFHRV9IT01FO1xuICAgICAgICB2YXIgYWxsQ29sdW1ucyA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgICAgIHZhciBjb2x1bW5Ub1NlbGVjdCA9IGhvbWVLZXkgPyBhbGxDb2x1bW5zWzBdIDogYWxsQ29sdW1uc1thbGxDb2x1bW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcm93SW5kZXhUb1Njcm9sbFRvID0gaG9tZUtleSA/IDAgOiB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRQYWdlTGFzdFJvdygpO1xuICAgICAgICB0aGlzLm5hdmlnYXRlVG8ocm93SW5kZXhUb1Njcm9sbFRvLCBudWxsLCBjb2x1bW5Ub1NlbGVjdCwgcm93SW5kZXhUb1Njcm9sbFRvLCBjb2x1bW5Ub1NlbGVjdCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZFBhbmVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkUGFuZWxfMS5HcmlkUGFuZWwpXG4gICAgXSwgTmF2aWdhdGlvblNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRQYW5lbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdtb3VzZUV2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgbW91c2VFdmVudFNlcnZpY2VfMS5Nb3VzZUV2ZW50U2VydmljZSlcbiAgICBdLCBOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUsIFwibW91c2VFdmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncGFnaW5hdGlvblByb3h5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBwYWdpbmF0aW9uUHJveHlfMS5QYWdpbmF0aW9uUHJveHkpXG4gICAgXSwgTmF2aWdhdGlvblNlcnZpY2UucHJvdG90eXBlLCBcInBhZ2luYXRpb25Qcm94eVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdmb2N1c2VkQ2VsbENvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGZvY3VzZWRDZWxsQ29udHJvbGxlcl8xLkZvY3VzZWRDZWxsQ29udHJvbGxlcilcbiAgICBdLCBOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUsIFwiZm9jdXNlZENlbGxDb250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2FuaW1hdGlvbkZyYW1lU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgYW5pbWF0aW9uRnJhbWVTZXJ2aWNlXzEuQW5pbWF0aW9uRnJhbWVTZXJ2aWNlKVxuICAgIF0sIE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJhbmltYXRpb25GcmFtZVNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLk9wdGlvbmFsKCdyYW5nZUNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUsIFwicmFuZ2VDb250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgTmF2aWdhdGlvblNlcnZpY2UucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgTmF2aWdhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ25hdmlnYXRpb25TZXJ2aWNlJylcbiAgICBdLCBOYXZpZ2F0aW9uU2VydmljZSk7XG4gICAgcmV0dXJuIE5hdmlnYXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuTmF2aWdhdGlvblNlcnZpY2UgPSBOYXZpZ2F0aW9uU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2dyaWRQYW5lbC9uYXZpZ2F0aW9uU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkcmFnQW5kRHJvcFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9kcmFnQW5kRHJvcC9kcmFnQW5kRHJvcFNlcnZpY2VcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBCb2R5RHJvcFBpdm90VGFyZ2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb2R5RHJvcFBpdm90VGFyZ2V0KHBpbm5lZCkge1xuICAgICAgICB0aGlzLmNvbHVtbnNUb0FnZ3JlZ2F0ZSA9IFtdO1xuICAgICAgICB0aGlzLmNvbHVtbnNUb0dyb3VwID0gW107XG4gICAgICAgIHRoaXMuY29sdW1uc1RvUGl2b3QgPSBbXTtcbiAgICAgICAgdGhpcy5waW5uZWQgPSBwaW5uZWQ7XG4gICAgfVxuICAgIC8qKiBDYWxsYmFjayBmb3Igd2hlbiBkcmFnIGVudGVycyAqL1xuICAgIEJvZHlEcm9wUGl2b3RUYXJnZXQucHJvdG90eXBlLm9uRHJhZ0VudGVyID0gZnVuY3Rpb24gKGRyYWdnaW5nRXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGVhckNvbHVtbnNMaXN0KCk7XG4gICAgICAgIC8vIGluIHBpdm90IG1vZGUsIHdlIGRvbid0IGFjY2VwdCBhbnkgZHJvcHMgaWYgZnVuY3Rpb25zIGFyZSByZWFkIG9ubHlcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRnVuY3Rpb25zUmVhZE9ubHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmFnQ29sdW1ucyA9IGRyYWdnaW5nRXZlbnQuZHJhZ0l0ZW0uY29sdW1ucztcbiAgICAgICAgZHJhZ0NvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBhbGxvdyBhZGRpbmcgc2Vjb25kYXJ5IGNvbHVtbnNcbiAgICAgICAgICAgIGlmICghY29sdW1uLmlzUHJpbWFyeSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbi5pc0FueUZ1bmN0aW9uQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sdW1uLmlzQWxsb3dWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uc1RvQWdncmVnYXRlLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbi5pc0FsbG93Um93R3JvdXAoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbHVtbnNUb0dyb3VwLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbi5pc0FsbG93Um93R3JvdXAoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbHVtbnNUb1Bpdm90LnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCb2R5RHJvcFBpdm90VGFyZ2V0LnByb3RvdHlwZS5nZXRJY29uTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvdGFsQ29sdW1ucyA9IHRoaXMuY29sdW1uc1RvQWdncmVnYXRlLmxlbmd0aCArIHRoaXMuY29sdW1uc1RvR3JvdXAubGVuZ3RoICsgdGhpcy5jb2x1bW5zVG9QaXZvdC5sZW5ndGg7XG4gICAgICAgIGlmICh0b3RhbENvbHVtbnMgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5waW5uZWQgPyBkcmFnQW5kRHJvcFNlcnZpY2VfMS5EcmFnQW5kRHJvcFNlcnZpY2UuSUNPTl9QSU5ORUQgOiBkcmFnQW5kRHJvcFNlcnZpY2VfMS5EcmFnQW5kRHJvcFNlcnZpY2UuSUNPTl9NT1ZFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBDYWxsYmFjayBmb3Igd2hlbiBkcmFnIGxlYXZlcyAqL1xuICAgIEJvZHlEcm9wUGl2b3RUYXJnZXQucHJvdG90eXBlLm9uRHJhZ0xlYXZlID0gZnVuY3Rpb24gKGRyYWdnaW5nRXZlbnQpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIHRha2luZyBjb2x1bW5zIG91dCBvZiB0aGUgY2VudGVyLCB0aGVuIHdlIHJlbW92ZSB0aGVtIGZyb20gdGhlIHJlcG9ydFxuICAgICAgICB0aGlzLmNsZWFyQ29sdW1uc0xpc3QoKTtcbiAgICB9O1xuICAgIEJvZHlEcm9wUGl2b3RUYXJnZXQucHJvdG90eXBlLmNsZWFyQ29sdW1uc0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sdW1uc1RvQWdncmVnYXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uc1RvR3JvdXAubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5zVG9QaXZvdC5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgLyoqIENhbGxiYWNrIGZvciB3aGVuIGRyYWdnaW5nICovXG4gICAgQm9keURyb3BQaXZvdFRhcmdldC5wcm90b3R5cGUub25EcmFnZ2luZyA9IGZ1bmN0aW9uIChkcmFnZ2luZ0V2ZW50KSB7XG4gICAgfTtcbiAgICAvKiogQ2FsbGJhY2sgZm9yIHdoZW4gZHJhZyBzdG9wcyAqL1xuICAgIEJvZHlEcm9wUGl2b3RUYXJnZXQucHJvdG90eXBlLm9uRHJhZ1N0b3AgPSBmdW5jdGlvbiAoZHJhZ2dpbmdFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5zVG9BZ2dyZWdhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5Db250cm9sbGVyLmFkZFZhbHVlQ29sdW1ucyh0aGlzLmNvbHVtbnNUb0FnZ3JlZ2F0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uc1RvR3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5Db250cm9sbGVyLmFkZFJvd0dyb3VwQ29sdW1ucyh0aGlzLmNvbHVtbnNUb0dyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2x1bW5zVG9QaXZvdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuYWRkUGl2b3RDb2x1bW5zKHRoaXMuY29sdW1uc1RvUGl2b3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgQm9keURyb3BQaXZvdFRhcmdldC5wcm90b3R5cGUsIFwiY29sdW1uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBCb2R5RHJvcFBpdm90VGFyZ2V0LnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQm9keURyb3BQaXZvdFRhcmdldDtcbn0oKSk7XG5leHBvcnRzLkJvZHlEcm9wUGl2b3RUYXJnZXQgPSBCb2R5RHJvcFBpdm90VGFyZ2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2JvZHlEcm9wUGl2b3RUYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRyYWdBbmREcm9wU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2RyYWdBbmREcm9wL2RyYWdBbmREcm9wU2VydmljZVwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIG1vdmVDb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9tb3ZlQ29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBjb2x1bW5fMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9jb2x1bW5cIik7XG52YXIgZ3JpZFBhbmVsXzEgPSByZXF1aXJlKFwiLi4vZ3JpZFBhbmVsL2dyaWRQYW5lbFwiKTtcbnZhciBib2R5RHJvcFBpdm90VGFyZ2V0XzEgPSByZXF1aXJlKFwiLi9ib2R5RHJvcFBpdm90VGFyZ2V0XCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgQm9keURyb3BUYXJnZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvZHlEcm9wVGFyZ2V0KHBpbm5lZCwgZUNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnBpbm5lZCA9IHBpbm5lZDtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyID0gZUNvbnRhaW5lcjtcbiAgICB9XG4gICAgQm9keURyb3BUYXJnZXQucHJvdG90eXBlLmdldFNlY29uZGFyeUNvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVTZWNvbmRhcnlDb250YWluZXJzO1xuICAgIH07XG4gICAgQm9keURyb3BUYXJnZXQucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZUNvbnRhaW5lcjtcbiAgICB9O1xuICAgIEJvZHlEcm9wVGFyZ2V0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmVDb2x1bW5Db250cm9sbGVyID0gbmV3IG1vdmVDb2x1bW5Db250cm9sbGVyXzEuTW92ZUNvbHVtbkNvbnRyb2xsZXIodGhpcy5waW5uZWQsIHRoaXMuZUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuY29udGV4dC53aXJlQmVhbih0aGlzLm1vdmVDb2x1bW5Db250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5ib2R5RHJvcFBpdm90VGFyZ2V0ID0gbmV3IGJvZHlEcm9wUGl2b3RUYXJnZXRfMS5Cb2R5RHJvcFBpdm90VGFyZ2V0KHRoaXMucGlubmVkKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LndpcmVCZWFuKHRoaXMuYm9keURyb3BQaXZvdFRhcmdldCk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5waW5uZWQpIHtcbiAgICAgICAgICAgIGNhc2UgY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9MRUZUOlxuICAgICAgICAgICAgICAgIHRoaXMuZVNlY29uZGFyeUNvbnRhaW5lcnMgPSB0aGlzLmdyaWRQYW5lbC5nZXREcm9wVGFyZ2V0TGVmdENvbnRhaW5lcnMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9SSUdIVDpcbiAgICAgICAgICAgICAgICB0aGlzLmVTZWNvbmRhcnlDb250YWluZXJzID0gdGhpcy5ncmlkUGFuZWwuZ2V0RHJvcFRhcmdldFBpbm5lZFJpZ2h0Q29udGFpbmVycygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmVTZWNvbmRhcnlDb250YWluZXJzID0gdGhpcy5ncmlkUGFuZWwuZ2V0RHJvcFRhcmdldEJvZHlDb250YWluZXJzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnQW5kRHJvcFNlcnZpY2UuYWRkRHJvcFRhcmdldCh0aGlzKTtcbiAgICB9O1xuICAgIEJvZHlEcm9wVGFyZ2V0LnByb3RvdHlwZS5nZXRJY29uTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERyb3BMaXN0ZW5lci5nZXRJY29uTmFtZSgpO1xuICAgIH07XG4gICAgLy8gd2Ugd2FudCB0byB1c2UgdGhlIGJvZHlQaXZvdFRhcmdldCBpZiB0aGUgdXNlciBpcyBkcmFnZ2luZyBjb2x1bW5zIGluIGZyb20gdGhlIHRvb2xQYW5lbFxuICAgIC8vIGFuZCB3ZSBhcmUgaW4gcGl2b3QgbW9kZSwgYXMgaXQgaGFzIHRvIGxvZ2ljIHRvIHNldCBwaXZvdC92YWx1ZS9ncm91cCBvbiB0aGUgY29sdW1ucyB3aGVuXG4gICAgLy8gZHJvcHBlZCBpbnRvIHRoZSBncmlkJ3MgYm9keS5cbiAgICBCb2R5RHJvcFRhcmdldC5wcm90b3R5cGUuaXNVc2VCb2R5RHJvcFBpdm90VGFyZ2V0ID0gZnVuY3Rpb24gKGRyYWdnaW5nRXZlbnQpIHtcbiAgICAgICAgLy8gaWYgbm90IGluIHBpdm90IG1vZGUsIHRoZW4gd2UgbmV2ZXIgdXNlIHRoZSBwaXZvdCBkcm9wIHRhcmdldFxuICAgICAgICBpZiAoIXRoaXMuY29sdW1uQ29udHJvbGxlci5pc1Bpdm90TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHVzZSB0aGUgZHJvcCB0YXJnZXQgaWYgdGhlIGNvbHVtbiBjYW1lIGZyb20gdGhlIHRvb2xQYW5lbCAoaWUgbm90IHJlb3JkZXJpbmcpXG4gICAgICAgIHJldHVybiBkcmFnZ2luZ0V2ZW50LmRyYWdTb3VyY2UudHlwZSA9PT0gZHJhZ0FuZERyb3BTZXJ2aWNlXzEuRHJhZ1NvdXJjZVR5cGUuVG9vbFBhbmVsO1xuICAgIH07XG4gICAgQm9keURyb3BUYXJnZXQucHJvdG90eXBlLm9uRHJhZ0VudGVyID0gZnVuY3Rpb24gKGRyYWdnaW5nRXZlbnQpIHtcbiAgICAgICAgLy8gd2UgcGljayB0aGUgZHJvcCBsaXN0ZW5lciBkZXBlbmRpbmcgb24gd2hldGhlciB3ZSBhcmUgaW4gcGl2b3QgbW9kZSBhcmUgbm90LiBpZiB3ZSBhcmVcbiAgICAgICAgLy8gaW4gcGl2b3QgbW9kZSwgdGhlbiBkcm9wcGluZyBjb2xzIGNoYW5nZXMgdGhlIHJvdyBncm91cCwgcGl2b3QsIHZhbHVlIHN0YXRzLiBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgY2hhbmdlIHZpc2liaWxpdHkgc3RhdGUgYW5kIHBvc2l0aW9uLlxuICAgICAgICAvLyBpZiAodGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGl2b3RNb2RlKCkpIHtcbiAgICAgICAgdmFyIHVzZUJvZHlEcm9wUGl2b3RUYXJnZXQgPSB0aGlzLmlzVXNlQm9keURyb3BQaXZvdFRhcmdldChkcmFnZ2luZ0V2ZW50KTtcbiAgICAgICAgaWYgKHVzZUJvZHlEcm9wUGl2b3RUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyb3BMaXN0ZW5lciA9IHRoaXMuYm9keURyb3BQaXZvdFRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyb3BMaXN0ZW5lciA9IHRoaXMubW92ZUNvbHVtbkNvbnRyb2xsZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50RHJvcExpc3RlbmVyLm9uRHJhZ0VudGVyKGRyYWdnaW5nRXZlbnQpO1xuICAgIH07XG4gICAgQm9keURyb3BUYXJnZXQucHJvdG90eXBlLm9uRHJhZ0xlYXZlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLmN1cnJlbnREcm9wTGlzdGVuZXIub25EcmFnTGVhdmUocGFyYW1zKTtcbiAgICB9O1xuICAgIEJvZHlEcm9wVGFyZ2V0LnByb3RvdHlwZS5vbkRyYWdnaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLmN1cnJlbnREcm9wTGlzdGVuZXIub25EcmFnZ2luZyhwYXJhbXMpO1xuICAgIH07XG4gICAgQm9keURyb3BUYXJnZXQucHJvdG90eXBlLm9uRHJhZ1N0b3AgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERyb3BMaXN0ZW5lci5vbkRyYWdTdG9wKHBhcmFtcyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29udGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29udGV4dF8xLkNvbnRleHQpXG4gICAgXSwgQm9keURyb3BUYXJnZXQucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZFBhbmVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkUGFuZWxfMS5HcmlkUGFuZWwpXG4gICAgXSwgQm9keURyb3BUYXJnZXQucHJvdG90eXBlLCBcImdyaWRQYW5lbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdkcmFnQW5kRHJvcFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdBbmREcm9wU2VydmljZSlcbiAgICBdLCBCb2R5RHJvcFRhcmdldC5wcm90b3R5cGUsIFwiZHJhZ0FuZERyb3BTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIEJvZHlEcm9wVGFyZ2V0LnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEJvZHlEcm9wVGFyZ2V0LnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIHJldHVybiBCb2R5RHJvcFRhcmdldDtcbn0oKSk7XG5leHBvcnRzLkJvZHlEcm9wVGFyZ2V0ID0gQm9keURyb3BUYXJnZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvYm9keURyb3BUYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZHJhZ0FuZERyb3BTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZHJhZ0FuZERyb3AvZHJhZ0FuZERyb3BTZXJ2aWNlXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgZ3JpZFBhbmVsXzEgPSByZXF1aXJlKFwiLi4vZ3JpZFBhbmVsL2dyaWRQYW5lbFwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xudmFyIGhlYWRlclJvd0NvbXBfMSA9IHJlcXVpcmUoXCIuL2hlYWRlclJvd0NvbXBcIik7XG52YXIgYm9keURyb3BUYXJnZXRfMSA9IHJlcXVpcmUoXCIuL2JvZHlEcm9wVGFyZ2V0XCIpO1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2NvbHVtblwiKTtcbnZhciBzY3JvbGxWaXNpYmxlU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2dyaWRQYW5lbC9zY3JvbGxWaXNpYmxlU2VydmljZVwiKTtcbnZhciBIZWFkZXJDb250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYWRlckNvbnRhaW5lcihlQ29udGFpbmVyLCBlVmlld3BvcnQsIGVSb290LCBwaW5uZWQpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJSb3dDb21wcyA9IFtdO1xuICAgICAgICB0aGlzLmVDb250YWluZXIgPSBlQ29udGFpbmVyO1xuICAgICAgICB0aGlzLmVSb290ID0gZVJvb3Q7XG4gICAgICAgIHRoaXMucGlubmVkID0gcGlubmVkO1xuICAgICAgICB0aGlzLmVWaWV3cG9ydCA9IGVWaWV3cG9ydDtcbiAgICB9XG4gICAgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZS5mb3JFYWNoSGVhZGVyRWxlbWVudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmhlYWRlclJvd0NvbXBzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlclJvd0NvbXApIHsgcmV0dXJuIGhlYWRlclJvd0NvbXAuZm9yRWFjaEhlYWRlckVsZW1lbnQoY2FsbGJhY2spOyB9KTtcbiAgICB9O1xuICAgIEhlYWRlckNvbnRhaW5lci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXR1cERyYWdBbmREcm9wKCk7XG4gICAgICAgIC8vIGlmIHZhbHVlIGNoYW5nZXMsIHRoZW4gaWYgbm90IHBpdm90aW5nLCB3ZSBhdCBsZWFzdCBuZWVkIHRvIGNoYW5nZSB0aGUgbGFiZWwgZWcgZnJvbSBzdW0oKSB0byBhdmcoKSxcbiAgICAgICAgLy8gaWYgcGl2b3RpbmcsIHRoZW4gdGhlIGNvbHVtbnMgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9WQUxVRV9DSEFOR0VELCB0aGlzLm9uQ29sdW1uVmFsdWVDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUk9XX0dST1VQX0NIQU5HRUQsIHRoaXMub25Db2x1bW5Sb3dHcm91cENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0dSSURfQ09MVU1OU19DSEFOR0VELCB0aGlzLm9uR3JpZENvbHVtbnNDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9TQ1JPTExfVklTSUJJTElUWV9DSEFOR0VELCB0aGlzLm9uU2Nyb2xsVmlzaWJpbGl0eUNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0NPTFVNTl9SRVNJWkVELCB0aGlzLm9uQ29sdW1uUmVzaXplZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfRElTUExBWUVEX0NPTFVNTlNfQ0hBTkdFRCwgdGhpcy5vbkRpc3BsYXllZENvbHVtbnNDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgLy8gaWYgcm93IGdyb3VwIGNoYW5nZXMsIHRoYXQgbWVhbnMgd2UgbWF5IG5lZWQgdG8gYWRkIGFnZ0Z1bmMncyB0byB0aGUgY29sdW1uIGhlYWRlcnMsXG4gICAgLy8gaWYgdGhlIGdyaWQgZ29lcyBmcm9tIG5vIGFnZ3JlZ2F0aW9uIChpZSBubyBncm91cGluZykgdG8gZ3JvdXBpbmdcbiAgICBIZWFkZXJDb250YWluZXIucHJvdG90eXBlLm9uQ29sdW1uUm93R3JvdXBDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uR3JpZENvbHVtbnNDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICAvLyBpZiB0aGUgYWdnIGZ1bmMgb2YgYSBjb2x1bW4gY2hhbmdlcywgdGhlbiB3ZSBtYXkgbmVlZCB0byB1cGRhdGUgdGhlIGFnZyBmdW5jIGluIGNvbHVtbnMgaGVhZGVyXG4gICAgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZS5vbkNvbHVtblZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbkdyaWRDb2x1bW5zQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZS5vbkNvbHVtblJlc2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0V2lkdGhJZlBpbm5lZENvbnRhaW5lcigpO1xuICAgIH07XG4gICAgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZS5vbkRpc3BsYXllZENvbHVtbnNDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFdpZHRoSWZQaW5uZWRDb250YWluZXIoKTtcbiAgICB9O1xuICAgIEhlYWRlckNvbnRhaW5lci5wcm90b3R5cGUub25TY3JvbGxWaXNpYmlsaXR5Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRXaWR0aElmUGlubmVkQ29udGFpbmVyKCk7XG4gICAgfTtcbiAgICBIZWFkZXJDb250YWluZXIucHJvdG90eXBlLnNldFdpZHRoSWZQaW5uZWRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpbm5lZCA9PT0gY29sdW1uXzEuQ29sdW1uLlBJTk5FRF9MRUZUKSB7XG4gICAgICAgICAgICB2YXIgcGlubmVkTGVmdFdpZHRoV2l0aFNjcm9sbCA9IHRoaXMuc2Nyb2xsVmlzaWJsZVNlcnZpY2UuZ2V0UGlubmVkTGVmdFdpdGhTY3JvbGxXaWR0aCgpO1xuICAgICAgICAgICAgdGhpcy5lQ29udGFpbmVyLnN0eWxlLndpZHRoID0gcGlubmVkTGVmdFdpZHRoV2l0aFNjcm9sbCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5waW5uZWQgPT09IGNvbHVtbl8xLkNvbHVtbi5QSU5ORURfUklHSFQpIHtcbiAgICAgICAgICAgIHZhciBwaW5uZWRSaWdodFdpZHRoV2l0aFNjcm9sbCA9IHRoaXMuc2Nyb2xsVmlzaWJsZVNlcnZpY2UuZ2V0UGlubmVkUmlnaHRXaXRoU2Nyb2xsV2lkdGgoKTtcbiAgICAgICAgICAgIHRoaXMuZUNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHBpbm5lZFJpZ2h0V2lkdGhXaXRoU2Nyb2xsICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUhlYWRlclJvd0NvbXBzKCk7XG4gICAgfTtcbiAgICAvLyBncmlkIGNvbHMgaGF2ZSBjaGFuZ2VkIC0gdGhpcyBhbHNvIG1lYW5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgaGVhZGVyIGNhbiBoYXZlXG4gICAgLy8gY2hhbmdlZC4gc28gd2UgcmVtb3ZlIGFsbCB0aGUgb2xkIHJvd3MgYW5kIGluc2VydCBuZXcgb25lcyBmb3IgYSBjb21wbGV0ZSByZWZyZXNoXG4gICAgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZS5vbkdyaWRDb2x1bW5zQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIZWFkZXJSb3dDb21wcygpO1xuICAgICAgICB0aGlzLmNyZWF0ZUhlYWRlclJvd0NvbXBzKCk7XG4gICAgfTtcbiAgICAvLyB3ZSBleHBvc2UgdGhpcyBmb3IgZ3JpZE9wdGlvbnMuYXBpLnJlZnJlc2hIZWFkZXIoKSB0byBjYWxsXG4gICAgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uR3JpZENvbHVtbnNDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBIZWFkZXJDb250YWluZXIucHJvdG90eXBlLnNldHVwRHJhZ0FuZERyb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkcm9wQ29udGFpbmVyID0gdGhpcy5lVmlld3BvcnQgPyB0aGlzLmVWaWV3cG9ydCA6IHRoaXMuZUNvbnRhaW5lcjtcbiAgICAgICAgdmFyIGJvZHlEcm9wVGFyZ2V0ID0gbmV3IGJvZHlEcm9wVGFyZ2V0XzEuQm9keURyb3BUYXJnZXQodGhpcy5waW5uZWQsIGRyb3BDb250YWluZXIpO1xuICAgICAgICB0aGlzLmNvbnRleHQud2lyZUJlYW4oYm9keURyb3BUYXJnZXQpO1xuICAgIH07XG4gICAgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVIZWFkZXJSb3dDb21wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJSb3dDb21wcy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXJSb3dDb21wKSB7XG4gICAgICAgICAgICBoZWFkZXJSb3dDb21wLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGVhZGVyUm93Q29tcHMubGVuZ3RoID0gMDtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVBbGxDaGlsZHJlbih0aGlzLmVDb250YWluZXIpO1xuICAgIH07XG4gICAgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZS5jcmVhdGVIZWFkZXJSb3dDb21wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIGRpc3BsYXlpbmcgaGVhZGVyIGdyb3VwcywgdGhlbiB3ZSBoYXZlIG1hbnkgcm93cyBoZXJlLlxuICAgICAgICAvLyBnbyB0aHJvdWdoIGVhY2ggcm93IG9mIHRoZSBoZWFkZXIsIG9uZSBieSBvbmUuXG4gICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICBmb3IgKHZhciBkZXB0ID0gMDsgZGVwdCA8IHJvd0NvdW50OyBkZXB0KyspIHtcbiAgICAgICAgICAgIHZhciBncm91cFJvdyA9IGRlcHQgIT09IChyb3dDb3VudCAtIDEpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBncm91cFJvdyA/IGhlYWRlclJvd0NvbXBfMS5IZWFkZXJSb3dUeXBlLkNPTFVNTl9HUk9VUCA6IGhlYWRlclJvd0NvbXBfMS5IZWFkZXJSb3dUeXBlLkNPTFVNTjtcbiAgICAgICAgICAgIHZhciBoZWFkZXJSb3dDb21wID0gbmV3IGhlYWRlclJvd0NvbXBfMS5IZWFkZXJSb3dDb21wKGRlcHQsIHR5cGUsIHRoaXMucGlubmVkLCB0aGlzLmVSb290LCB0aGlzLmRyb3BUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LndpcmVCZWFuKGhlYWRlclJvd0NvbXApO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJSb3dDb21wcy5wdXNoKGhlYWRlclJvd0NvbXApO1xuICAgICAgICAgICAgdGhpcy5lQ29udGFpbmVyLmFwcGVuZENoaWxkKGhlYWRlclJvd0NvbXAuZ2V0R3VpKCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmNsdWRlRmxvYXRpbmdGaWx0ZXJSb3cgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0Zsb2F0aW5nRmlsdGVyKCkgJiYgIXRoaXMuY29sdW1uQ29udHJvbGxlci5pc1Bpdm90TW9kZSgpO1xuICAgICAgICBpZiAoaW5jbHVkZUZsb2F0aW5nRmlsdGVyUm93KSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyUm93Q29tcCA9IG5ldyBoZWFkZXJSb3dDb21wXzEuSGVhZGVyUm93Q29tcChyb3dDb3VudCwgaGVhZGVyUm93Q29tcF8xLkhlYWRlclJvd1R5cGUuRkxPQVRJTkdfRklMVEVSLCB0aGlzLnBpbm5lZCwgdGhpcy5lUm9vdCwgdGhpcy5kcm9wVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC53aXJlQmVhbihoZWFkZXJSb3dDb21wKTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyUm93Q29tcHMucHVzaChoZWFkZXJSb3dDb21wKTtcbiAgICAgICAgICAgIHRoaXMuZUNvbnRhaW5lci5hcHBlbmRDaGlsZChoZWFkZXJSb3dDb21wLmdldEd1aSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEhlYWRlckNvbnRhaW5lci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIEhlYWRlckNvbnRhaW5lci5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCckc2NvcGUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWFkZXJDb250YWluZXIucHJvdG90eXBlLCBcIiRzY29wZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdkcmFnQW5kRHJvcFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdBbmREcm9wU2VydmljZSlcbiAgICBdLCBIZWFkZXJDb250YWluZXIucHJvdG90eXBlLCBcImRyYWdBbmREcm9wU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5Db250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQ29udHJvbGxlcilcbiAgICBdLCBIZWFkZXJDb250YWluZXIucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZFBhbmVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkUGFuZWxfMS5HcmlkUGFuZWwpXG4gICAgXSwgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZSwgXCJncmlkUGFuZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnc2Nyb2xsVmlzaWJsZVNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNjcm9sbFZpc2libGVTZXJ2aWNlXzEuU2Nyb2xsVmlzaWJsZVNlcnZpY2UpXG4gICAgXSwgSGVhZGVyQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzY3JvbGxWaXNpYmxlU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBIZWFkZXJDb250YWluZXIucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIEhlYWRlckNvbnRhaW5lcjtcbn0oKSk7XG5leHBvcnRzLkhlYWRlckNvbnRhaW5lciA9IEhlYWRlckNvbnRhaW5lcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9oZWFkZXJDb250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBjb2x1bW5fMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9jb2x1bW5cIik7XG52YXIgcmVuZGVyZWRIZWFkZXJDZWxsXzEgPSByZXF1aXJlKFwiLi9kZXByZWNhdGVkL3JlbmRlcmVkSGVhZGVyQ2VsbFwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgaGVhZGVyV3JhcHBlckNvbXBfMSA9IHJlcXVpcmUoXCIuL2hlYWRlci9oZWFkZXJXcmFwcGVyQ29tcFwiKTtcbnZhciBoZWFkZXJHcm91cFdyYXBwZXJDb21wXzEgPSByZXF1aXJlKFwiLi9oZWFkZXJHcm91cC9oZWFkZXJHcm91cFdyYXBwZXJDb21wXCIpO1xudmFyIGZpbHRlck1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuLi9maWx0ZXIvZmlsdGVyTWFuYWdlclwiKTtcbnZhciBjb21wb25lbnRSZWNpcGVzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UmVjaXBlc1wiKTtcbnZhciBIZWFkZXJSb3dUeXBlO1xuKGZ1bmN0aW9uIChIZWFkZXJSb3dUeXBlKSB7XG4gICAgSGVhZGVyUm93VHlwZVtIZWFkZXJSb3dUeXBlW1wiQ09MVU1OX0dST1VQXCJdID0gMF0gPSBcIkNPTFVNTl9HUk9VUFwiO1xuICAgIEhlYWRlclJvd1R5cGVbSGVhZGVyUm93VHlwZVtcIkNPTFVNTlwiXSA9IDFdID0gXCJDT0xVTU5cIjtcbiAgICBIZWFkZXJSb3dUeXBlW0hlYWRlclJvd1R5cGVbXCJGTE9BVElOR19GSUxURVJcIl0gPSAyXSA9IFwiRkxPQVRJTkdfRklMVEVSXCI7XG59KShIZWFkZXJSb3dUeXBlID0gZXhwb3J0cy5IZWFkZXJSb3dUeXBlIHx8IChleHBvcnRzLkhlYWRlclJvd1R5cGUgPSB7fSkpO1xudmFyIEhlYWRlclJvd0NvbXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkZXJSb3dDb21wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRlclJvd0NvbXAoZGVwdCwgdHlwZSwgcGlubmVkLCBlUm9vdCwgZHJvcFRhcmdldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIjxkaXYgY2xhc3M9XFxcImFnLWhlYWRlci1yb3dcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCIvPlwiKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oZWFkZXJDb21wUHJvbWlzZXMgPSB7fTtcbiAgICAgICAgX3RoaXMud2FybmVkVXNlck9uT2xkSGVhZGVyVGVtcGxhdGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuZGVwdCA9IGRlcHQ7XG4gICAgICAgIF90aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBfdGhpcy5waW5uZWQgPSBwaW5uZWQ7XG4gICAgICAgIF90aGlzLmVSb290ID0gZVJvb3Q7XG4gICAgICAgIF90aGlzLmRyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEhlYWRlclJvd0NvbXAucHJvdG90eXBlLmZvckVhY2hIZWFkZXJFbGVtZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmhlYWRlckNvbXBQcm9taXNlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKF90aGlzLmhlYWRlckNvbXBQcm9taXNlc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHV0aWxzXzEuUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGNvbWJpbmVkKSB7IHJldHVybiBjb21iaW5lZC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXJFbGVtZW50KSB7IHJldHVybiBjYWxsYmFjayhoZWFkZXJFbGVtZW50KTsgfSk7IH0pO1xuICAgIH07XG4gICAgSGVhZGVyUm93Q29tcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkc09mQWxsQ2hpbGRyZW4gPSBPYmplY3Qua2V5cyh0aGlzLmhlYWRlckNvbXBQcm9taXNlcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQW5kRGVzdHJveUNoaWxkQ29tcG9uZW50cyhpZHNPZkFsbENoaWxkcmVuKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBIZWFkZXJSb3dDb21wLnByb3RvdHlwZS5yZW1vdmVBbmREZXN0cm95Q2hpbGRDb21wb25lbnRzID0gZnVuY3Rpb24gKGlkc1RvRGVzdHJveSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZHNUb0Rlc3Ryb3kuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIF90aGlzLmhlYWRlckNvbXBQcm9taXNlc1tpZF0udGhlbihmdW5jdGlvbiAoY2hpbGRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZ2V0R3VpKCkucmVtb3ZlQ2hpbGQoY2hpbGRQcm9taXNlLmdldEd1aSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRQcm9taXNlLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9taXNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLmhlYWRlckNvbXBQcm9taXNlc1tpZF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWFkZXJSb3dDb21wLnByb3RvdHlwZS5vblJvd0hlaWdodENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgc2l6ZXMgPSBbXTtcbiAgICAgICAgdmFyIG51bWJlck9mRmxvYXRpbmcgPSAwO1xuICAgICAgICB2YXIgZ3JvdXBIZWlnaHQ7XG4gICAgICAgIHZhciBoZWFkZXJIZWlnaHQ7XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGl2b3RNb2RlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0Zsb2F0aW5nRmlsdGVyKCkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJSb3dDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyT2ZGbG9hdGluZyA9ICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0Zsb2F0aW5nRmlsdGVyKCkpID8gMSA6IDA7XG4gICAgICAgICAgICBncm91cEhlaWdodCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEdyb3VwSGVhZGVySGVpZ2h0KCk7XG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRIZWFkZXJIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG51bWJlck9mRmxvYXRpbmcgPSAwO1xuICAgICAgICAgICAgZ3JvdXBIZWlnaHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRQaXZvdEdyb3VwSGVhZGVySGVpZ2h0KCk7XG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRQaXZvdEhlYWRlckhlaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1iZXJPZk5vbkdyb3VwcyA9IDEgKyBudW1iZXJPZkZsb2F0aW5nO1xuICAgICAgICB2YXIgbnVtYmVyT2ZHcm91cHMgPSBoZWFkZXJSb3dDb3VudCAtIG51bWJlck9mTm9uR3JvdXBzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mR3JvdXBzOyBpKyspXG4gICAgICAgICAgICBzaXplcy5wdXNoKGdyb3VwSGVpZ2h0KTtcbiAgICAgICAgc2l6ZXMucHVzaChoZWFkZXJIZWlnaHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mRmxvYXRpbmc7IGkrKylcbiAgICAgICAgICAgIHNpemVzLnB1c2godGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0RmxvYXRpbmdGaWx0ZXJzSGVpZ2h0KCkpO1xuICAgICAgICB2YXIgcm93SGVpZ2h0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRlcHQ7IGkrKylcbiAgICAgICAgICAgIHJvd0hlaWdodCArPSBzaXplc1tpXTtcbiAgICAgICAgdGhpcy5nZXRHdWkoKS5zdHlsZS50b3AgPSByb3dIZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmdldEd1aSgpLnN0eWxlLmhlaWdodCA9IHNpemVzW3RoaXMuZGVwdF0gKyAncHgnO1xuICAgIH07XG4gICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRMb2NhbFN5bWJvbHNcbiAgICBIZWFkZXJSb3dDb21wLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uUm93SGVpZ2h0Q2hhbmdlZCgpO1xuICAgICAgICB0aGlzLm9uVmlydHVhbENvbHVtbnNDaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMuc2V0V2lkdGgoKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlci5QUk9QX0hFQURFUl9IRUlHSFQsIHRoaXMub25Sb3dIZWlnaHRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfUElWT1RfSEVBREVSX0hFSUdIVCwgdGhpcy5vblJvd0hlaWdodENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIuUFJPUF9HUk9VUF9IRUFERVJfSEVJR0hULCB0aGlzLm9uUm93SGVpZ2h0Q2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlci5QUk9QX1BJVk9UX0dST1VQX0hFQURFUl9IRUlHSFQsIHRoaXMub25Sb3dIZWlnaHRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfRkxPQVRJTkdfRklMVEVSU19IRUlHSFQsIHRoaXMub25Sb3dIZWlnaHRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1ZJUlRVQUxfQ09MVU1OU19DSEFOR0VELCB0aGlzLm9uVmlydHVhbENvbHVtbnNDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0RJU1BMQVlFRF9DT0xVTU5TX0NIQU5HRUQsIHRoaXMub25EaXNwbGF5ZWRDb2x1bW5zQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUkVTSVpFRCwgdGhpcy5vbkNvbHVtblJlc2l6ZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfR1JJRF9DT0xVTU5TX0NIQU5HRUQsIHRoaXMub25HcmlkQ29sdW1uc0NoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICBIZWFkZXJSb3dDb21wLnByb3RvdHlwZS5vbkNvbHVtblJlc2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0V2lkdGgoKTtcbiAgICB9O1xuICAgIEhlYWRlclJvd0NvbXAucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFpblJvd1dpZHRoID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldENvbnRhaW5lcldpZHRoKHRoaXMucGlubmVkKSArICdweCc7XG4gICAgICAgIHRoaXMuZ2V0R3VpKCkuc3R5bGUud2lkdGggPSBtYWluUm93V2lkdGg7XG4gICAgfTtcbiAgICBIZWFkZXJSb3dDb21wLnByb3RvdHlwZS5vbkdyaWRDb2x1bW5zQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbmREZXN0cm95QWxsQ2hpbGRDb21wb25lbnRzKCk7XG4gICAgfTtcbiAgICBIZWFkZXJSb3dDb21wLnByb3RvdHlwZS5yZW1vdmVBbmREZXN0cm95QWxsQ2hpbGRDb21wb25lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzT2ZBbGxDaGlsZHJlbiA9IE9iamVjdC5rZXlzKHRoaXMuaGVhZGVyQ29tcFByb21pc2VzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbmREZXN0cm95Q2hpbGRDb21wb25lbnRzKGlkc09mQWxsQ2hpbGRyZW4pO1xuICAgIH07XG4gICAgSGVhZGVyUm93Q29tcC5wcm90b3R5cGUub25EaXNwbGF5ZWRDb2x1bW5zQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vblZpcnR1YWxDb2x1bW5zQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLnNldFdpZHRoKCk7XG4gICAgfTtcbiAgICBIZWFkZXJSb3dDb21wLnByb3RvdHlwZS5vblZpcnR1YWxDb2x1bW5zQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGN1cnJlbnRDaGlsZElkcyA9IE9iamVjdC5rZXlzKHRoaXMuaGVhZGVyQ29tcFByb21pc2VzKTtcbiAgICAgICAgdmFyIGl0ZW1zQXREZXB0aCA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRWaXJ0dWFsSGVhZGVyR3JvdXBSb3codGhpcy5waW5uZWQsIHRoaXMudHlwZSA9PSBIZWFkZXJSb3dUeXBlLkZMT0FUSU5HX0ZJTFRFUiA/XG4gICAgICAgICAgICB0aGlzLmRlcHQgLSAxIDpcbiAgICAgICAgICAgIHRoaXMuZGVwdCk7XG4gICAgICAgIHZhciBlbnN1cmVEb21PcmRlciA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5zdXJlRG9tT3JkZXIoKTtcbiAgICAgICAgdmFyIGVCZWZvcmU7XG4gICAgICAgIGl0ZW1zQXREZXB0aC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgLy8gc2tpcCBncm91cHMgdGhhdCBoYXZlIG5vIGRpc3BsYXllZCBjaGlsZHJlbi4gdGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIGdyb3VwIGlzIGJyb2tlbixcbiAgICAgICAgICAgIC8vIGFuZCB0aGlzIHNlY3Rpb24gaGFwcGVucyB0byBoYXZlIG5vdGhpbmcgdG8gZGlzcGxheSBmb3IgdGhlIG9wZW4gLyBjbG9zZWQgc3RhdGUuXG4gICAgICAgICAgICAvLyAoYSBicm9rZW4gZ3JvdXAgaXMgb25lIHRoYXQgaXMgc3BsaXQsIGllIGNvbHVtbnMgaW4gdGhlIGdyb3VwIGhhdmUgYSBub24tZ3JvdXAgY29sdW1uXG4gICAgICAgICAgICAvLyBpbiBiZXR3ZWVuIHRoZW0pXG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNFbXB0eUdyb3VwKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWRPZkNoaWxkID0gY2hpbGQuZ2V0VW5pcXVlSWQoKTtcbiAgICAgICAgICAgIHZhciBlUGFyZW50Q29udGFpbmVyID0gX3RoaXMuZ2V0R3VpKCk7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhpcyBjZWxsIHJlbmRlcmVkLCBkbyBub3RoaW5nXG4gICAgICAgICAgICB2YXIgY29sQWxyZWFkeUluRG9tID0gY3VycmVudENoaWxkSWRzLmluZGV4T2YoaWRPZkNoaWxkKSA+PSAwO1xuICAgICAgICAgICAgdmFyIGhlYWRlckNvbXBQcm9taXNlO1xuICAgICAgICAgICAgdmFyIGVIZWFkZXJDb21wR3VpO1xuICAgICAgICAgICAgaWYgKGNvbEFscmVhZHlJbkRvbSkge1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbUFycmF5KGN1cnJlbnRDaGlsZElkcywgaWRPZkNoaWxkKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJDb21wUHJvbWlzZSA9IF90aGlzLmhlYWRlckNvbXBQcm9taXNlc1tpZE9mQ2hpbGRdO1xuICAgICAgICAgICAgICAgIGhlYWRlckNvbXBQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGhlYWRlckNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgZUJlZm9yZSA9IGVIZWFkZXJDb21wR3VpO1xuICAgICAgICAgICAgICAgICAgICBlSGVhZGVyQ29tcEd1aSA9IGhlYWRlckNvbXAuZ2V0R3VpKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnN1cmVEb21PcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5lbnN1cmVEb21PcmRlcihlUGFyZW50Q29udGFpbmVyLCBlSGVhZGVyQ29tcEd1aSwgZUJlZm9yZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlckNvbXBQcm9taXNlID0gX3RoaXMuY3JlYXRlSGVhZGVyQ29tcChjaGlsZCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGVhZGVyQ29tcFByb21pc2VzW2lkT2ZDaGlsZF0gPSBoZWFkZXJDb21wUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBoZWFkZXJDb21wUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChoZWFkZXJDb21wKSB7XG4gICAgICAgICAgICAgICAgICAgIGVCZWZvcmUgPSBlSGVhZGVyQ29tcEd1aTtcbiAgICAgICAgICAgICAgICAgICAgZUhlYWRlckNvbXBHdWkgPSBoZWFkZXJDb21wLmdldEd1aSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5zdXJlRG9tT3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuaW5zZXJ0V2l0aERvbU9yZGVyKGVQYXJlbnRDb250YWluZXIsIGVIZWFkZXJDb21wR3VpLCBlQmVmb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQYXJlbnRDb250YWluZXIuYXBwZW5kQ2hpbGQoZUhlYWRlckNvbXBHdWkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCBhbnl0aGluZyBsZWZ0IGluIGN1cnJlbnRDaGlsZElkcyBpcyBhbiBlbGVtZW50IHRoYXQgaXMgbm8gbG9uZ2VyIGluIHRoZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLnJlbW92ZUFuZERlc3Ryb3lDaGlsZENvbXBvbmVudHMoY3VycmVudENoaWxkSWRzKTtcbiAgICB9O1xuICAgIC8vIGNoZWNrIGlmIHVzZXIgaXMgdXNpbmcgdGhlIGRlcHJlY2F0ZWRcbiAgICBIZWFkZXJSb3dDb21wLnByb3RvdHlwZS5pc1VzaW5nT2xkSGVhZGVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHZhciBjb2xEZWYgPSBjb2x1bW4uZ2V0Q29sRGVmKCk7XG4gICAgICAgIHZhciB1c2luZ09sZEhlYWRlclJlbmRlcmVyID0gdXRpbHNfMS5VdGlscy5hbnlFeGlzdHMoW1xuICAgICAgICAgICAgLy8gaGVhZGVyIHRlbXBsYXRlXG4gICAgICAgICAgICB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRIZWFkZXJDZWxsVGVtcGxhdGVGdW5jKCksXG4gICAgICAgICAgICB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRIZWFkZXJDZWxsVGVtcGxhdGUoKSxcbiAgICAgICAgICAgIGNvbERlZi5oZWFkZXJDZWxsVGVtcGxhdGUsXG4gICAgICAgICAgICAvLyBoZWFkZXIgY2VsbFJlbmRlcmVyXG4gICAgICAgICAgICBjb2xEZWYuaGVhZGVyQ2VsbFJlbmRlcmVyLFxuICAgICAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0SGVhZGVyQ2VsbFJlbmRlcmVyKClcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICh1c2luZ09sZEhlYWRlclJlbmRlcmVyICYmICF0aGlzLndhcm5lZFVzZXJPbk9sZEhlYWRlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0SGVhZGVyQ2VsbFRlbXBsYXRlKCkgfHwgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0SGVhZGVyQ2VsbFRlbXBsYXRlRnVuYygpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiBTaW5jZSBhZy1HcmlkIHYxNCB5b3UgY2FuIG5vdyBzcGVjaWZ5IGEgdGVtcGxhdGUgZm9yIHRoZSBkZWZhdWx0IGhlYWRlciBjb21wb25lbnQuIFRoZSBhYmlsaXR5IHRvIHNwZWNpZnkgaGVhZGVyIHRlbXBsYXRlIHVzaW5nIGNvbERlZi5oZWFkZXJDZWxsVGVtcGxhdGUgaXMgbm93IGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MTUuIFBsZWFzZSBjaGFuZ2UgeW91ciBjb2RlIHRvIHNwZWNpZnkgdGhlIHRlbXBsYXRlIGFzIGNvbERlZi5oZWFkZXJDb21wb25lbnRQYXJhbXMudGVtcGxhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRIZWFkZXJDZWxsUmVuZGVyZXIoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogVXNpbmcgaGVhZGVyQ2VsbFJlbmRlcmVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhZy1HcmlkIHYxNS4gUGxlYXNlIHVzZSBIZWFkZXIgQ29tcG9uZW50IGluc3RlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndhcm5lZFVzZXJPbk9sZEhlYWRlclRlbXBsYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNpbmdPbGRIZWFkZXJSZW5kZXJlcjtcbiAgICB9O1xuICAgIEhlYWRlclJvd0NvbXAucHJvdG90eXBlLmNyZWF0ZUhlYWRlckNvbXAgPSBmdW5jdGlvbiAoY29sdW1uR3JvdXBDaGlsZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0UHJvbWlzZTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgSGVhZGVyUm93VHlwZS5DT0xVTU46XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNVc2luZ09sZEhlYWRlclJlbmRlcmVyKGNvbHVtbkdyb3VwQ2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSB1dGlsc18xLlByb21pc2UucmVzb2x2ZShuZXcgcmVuZGVyZWRIZWFkZXJDZWxsXzEuUmVuZGVyZWRIZWFkZXJDZWxsKGNvbHVtbkdyb3VwQ2hpbGQsIHRoaXMuZVJvb3QsIHRoaXMuZHJvcFRhcmdldCwgdGhpcy5waW5uZWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSB1dGlsc18xLlByb21pc2UucmVzb2x2ZShuZXcgaGVhZGVyV3JhcHBlckNvbXBfMS5IZWFkZXJXcmFwcGVyQ29tcChjb2x1bW5Hcm91cENoaWxkLCB0aGlzLmVSb290LCB0aGlzLmRyb3BUYXJnZXQsIHRoaXMucGlubmVkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIZWFkZXJSb3dUeXBlLkNPTFVNTl9HUk9VUDpcbiAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlID0gdXRpbHNfMS5Qcm9taXNlLnJlc29sdmUobmV3IGhlYWRlckdyb3VwV3JhcHBlckNvbXBfMS5IZWFkZXJHcm91cFdyYXBwZXJDb21wKGNvbHVtbkdyb3VwQ2hpbGQsIHRoaXMuZVJvb3QsIHRoaXMuZHJvcFRhcmdldCwgdGhpcy5waW5uZWQpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSGVhZGVyUm93VHlwZS5GTE9BVElOR19GSUxURVI6XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbkdyb3VwQ2hpbGQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IHRoaXMuY3JlYXRlRmxvYXRpbmdGaWx0ZXJXcmFwcGVyKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0UHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIF90aGlzLmNvbnRleHQud2lyZUJlYW4ocmVzdWx0KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH07XG4gICAgSGVhZGVyUm93Q29tcC5wcm90b3R5cGUuY3JlYXRlRmxvYXRpbmdGaWx0ZXJXcmFwcGVyID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmxvYXRpbmdGaWx0ZXJQYXJhbXMgPSB0aGlzLmNyZWF0ZUZsb2F0aW5nRmlsdGVyUGFyYW1zKGNvbHVtbik7XG4gICAgICAgIHZhciBmbG9hdGluZ0ZpbHRlcldyYXBwZXJQcm9taXNlID0gdGhpcy5jb21wb25lbnRSZWNpcGVzLm5ld0Zsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXBvbmVudChjb2x1bW4sIGZsb2F0aW5nRmlsdGVyUGFyYW1zKTtcbiAgICAgICAgZmxvYXRpbmdGaWx0ZXJXcmFwcGVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChmbG9hdGluZ0ZpbHRlcldyYXBwZXIpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcihjb2x1bW4sIGNvbHVtbl8xLkNvbHVtbi5FVkVOVF9GSUxURVJfQ0hBTkdFRCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJDb21wb25lbnRQcm9taXNlID0gX3RoaXMuZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJDb21wb25lbnQoY29sdW1uKTtcbiAgICAgICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcldyYXBwZXIub25QYXJlbnRNb2RlbENoYW5nZWQoZmlsdGVyQ29tcG9uZW50UHJvbWlzZS5yZXNvbHZlTm93KG51bGwsIGZ1bmN0aW9uIChmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlci5nZXRNb2RlbCgpOyB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjYWNoZWRGaWx0ZXIgPSBfdGhpcy5maWx0ZXJNYW5hZ2VyLmNhY2hlZEZpbHRlcihjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNhY2hlZEZpbHRlcikge1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJDb21wb25lbnRQcm9taXNlID0gX3RoaXMuZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJDb21wb25lbnQoY29sdW1uKTtcbiAgICAgICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcldyYXBwZXIub25QYXJlbnRNb2RlbENoYW5nZWQoZmlsdGVyQ29tcG9uZW50UHJvbWlzZS5yZXNvbHZlTm93KG51bGwsIGZ1bmN0aW9uIChmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlci5nZXRNb2RlbCgpOyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmxvYXRpbmdGaWx0ZXJXcmFwcGVyUHJvbWlzZTtcbiAgICB9O1xuICAgIEhlYWRlclJvd0NvbXAucHJvdG90eXBlLmNyZWF0ZUZsb2F0aW5nRmlsdGVyUGFyYW1zID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXZSBhbHdheXMgZ2V0IHRoZSBmcmVzaGVzdCByZWZlcmVuY2UgdG8gdGhlIGJhc2VGaWx0ZXIgYmVjYXVzZSB0aGUgZmlsdGVycyBnZXQgc29tZXRpbWVzIGNyZWF0ZWRcbiAgICAgICAgLy8gYW5kIGRlc3Ryb3llZCBiZXR3ZWVuIGNhbGxzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGxldCBmaWx0ZXJDb21wb25lbnQ6QmFzZUZpbHRlcjxhbnksIGFueSwgYW55PiA9IDxhbnk+dGhpcy5maWx0ZXJNYW5hZ2VyLmdldEZpbHRlckNvbXBvbmVudChjb2x1bW4pO1xuICAgICAgICAvL1xuICAgICAgICB2YXIgYmFzZVBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgY3VycmVudFBhcmVudE1vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlckNvbXBvbmVudFByb21pc2UgPSBfdGhpcy5maWx0ZXJNYW5hZ2VyLmdldEZpbHRlckNvbXBvbmVudChjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJDb21wb25lbnRQcm9taXNlLnJlc29sdmVOb3cobnVsbCwgZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGZpbHRlci5nZXROdWxsYWJsZU1vZGVsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuZ2V0TnVsbGFibGVNb2RlbCgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5nZXRNb2RlbCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRmxvYXRpbmdGaWx0ZXJDaGFuZ2VkOiBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcHR1cmVNb2RlbENoYW5nZWRSZXNvbHZlRnVuYztcbiAgICAgICAgICAgICAgICB2YXIgbW9kZWxDaGFuZ2VkID0gbmV3IHV0aWxzXzEuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlTW9kZWxDaGFuZ2VkUmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJDb21wb25lbnRQcm9taXNlID0gX3RoaXMuZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJDb21wb25lbnQoY29sdW1uKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJDb21wb25lbnRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGZpbHRlckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyQ29tcG9uZW50Lm9uRmxvYXRpbmdGaWx0ZXJDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0lmIGdvaW5nIHRocm91Z2ggdGhpcyBicmFuY2ggb2YgY29kZSB0aGUgdXNlciBNVVNUXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2JlIHBhc3NpbmcgYW4gb2JqZWN0IG9mIHR5cGUgY2hhbmdlIHRoYXQgY29udGFpbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYSBtb2RlbCBwcm9wZXJ5IGluc2lkZSBhbmQgc29tZSBvdGhlciBzdHVmZlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZpbHRlckNvbXBvbmVudC5vbkZsb2F0aW5nRmlsdGVyQ2hhbmdlZChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZU1vZGVsQ2hhbmdlZFJlc29sdmVGdW5jKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0lmIGdvaW5nIHRocm91Z2ggdGhpcyBicmFuY2ggb2YgY29kZSB0aGUgdXNlciBNVVNUXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2JlIHBhc3NpbmcgdGhlIHBsYWluIG1vZGVsIGFuZCBkZWxlZ2F0aW5nIHRvIGFnLUdyaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIHJlc3BvbnNpYmlsaXR5IHRvIHNldCB0aGUgcGFyZW50IG1vZGVsIGFuZCByZWZyZXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDb21wb25lbnQuc2V0TW9kZWwoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbHRlck1hbmFnZXIub25GaWx0ZXJDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlTW9kZWxDaGFuZ2VkUmVzb2x2ZUZ1bmModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxDaGFuZ2VkLnJlc29sdmVOb3codHJ1ZSwgZnVuY3Rpb24gKG1vZGVsQ2hhbmdlZCkgeyByZXR1cm4gbW9kZWxDaGFuZ2VkOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1RoaXMgb25lIG1pZ2h0IGJlIG92ZXJyaWRlbiBmcm9tIHRoZSBjb2xEZWZcbiAgICAgICAgICAgIHN1cHByZXNzRmlsdGVyQnV0dG9uOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYmFzZVBhcmFtcztcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBIZWFkZXJSb3dDb21wLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgSGVhZGVyUm93Q29tcC5wcm90b3R5cGUsIFwiY29sdW1uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBIZWFkZXJSb3dDb21wLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIEhlYWRlclJvd0NvbXAucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdmaWx0ZXJNYW5hZ2VyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBmaWx0ZXJNYW5hZ2VyXzEuRmlsdGVyTWFuYWdlcilcbiAgICBdLCBIZWFkZXJSb3dDb21wLnByb3RvdHlwZSwgXCJmaWx0ZXJNYW5hZ2VyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbXBvbmVudFJlY2lwZXMnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbXBvbmVudFJlY2lwZXNfMS5Db21wb25lbnRSZWNpcGVzKVxuICAgIF0sIEhlYWRlclJvd0NvbXAucHJvdG90eXBlLCBcImNvbXBvbmVudFJlY2lwZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgSGVhZGVyUm93Q29tcC5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICByZXR1cm4gSGVhZGVyUm93Q29tcDtcbn0oY29tcG9uZW50XzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkhlYWRlclJvd0NvbXAgPSBIZWFkZXJSb3dDb21wO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2hlYWRlclJvd0NvbXAuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb2x1bW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnRpdGllcy9jb2x1bW5cIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBkcmFnQW5kRHJvcFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9kcmFnQW5kRHJvcC9kcmFnQW5kRHJvcFNlcnZpY2VcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBob3Jpem9udGFsRHJhZ1NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ob3Jpem9udGFsRHJhZ1NlcnZpY2VcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGNzc0NsYXNzQXBwbGllcl8xID0gcmVxdWlyZShcIi4uL2Nzc0NsYXNzQXBwbGllclwiKTtcbnZhciBzZXRMZWZ0RmVhdHVyZV8xID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmluZy9mZWF0dXJlcy9zZXRMZWZ0RmVhdHVyZVwiKTtcbnZhciBncmlkQXBpXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JpZEFwaVwiKTtcbnZhciBzb3J0Q29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL3NvcnRDb250cm9sbGVyXCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2V2ZW50U2VydmljZVwiKTtcbnZhciBjb21wb25lbnRSZWNpcGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcG9uZW50cy9mcmFtZXdvcmsvY29tcG9uZW50UmVjaXBlc1wiKTtcbnZhciBhZ0NoZWNrYm94XzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9hZ0NoZWNrYm94XCIpO1xudmFyIGNvbXBvbmVudEFubm90YXRpb25zXzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRBbm5vdGF0aW9uc1wiKTtcbnZhciBzZWxlY3RBbGxGZWF0dXJlXzEgPSByZXF1aXJlKFwiLi9zZWxlY3RBbGxGZWF0dXJlXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4uLy4uL2V2ZW50c1wiKTtcbnZhciBjb2x1bW5Ib3ZlclNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJpbmcvY29sdW1uSG92ZXJTZXJ2aWNlXCIpO1xudmFyIGJlYW5zXzEgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyaW5nL2JlYW5zXCIpO1xudmFyIEhlYWRlcldyYXBwZXJDb21wID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGVhZGVyV3JhcHBlckNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGVyV3JhcHBlckNvbXAoY29sdW1uLCBlUm9vdCwgZHJhZ1NvdXJjZURyb3BUYXJnZXQsIHBpbm5lZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBIZWFkZXJXcmFwcGVyQ29tcC5URU1QTEFURSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICBfdGhpcy5lUm9vdCA9IGVSb290O1xuICAgICAgICBfdGhpcy5kcmFnU291cmNlRHJvcFRhcmdldCA9IGRyYWdTb3VyY2VEcm9wVGFyZ2V0O1xuICAgICAgICBfdGhpcy5waW5uZWQgPSBwaW5uZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLmdldENvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uO1xuICAgIH07XG4gICAgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGUodGhpcy5jb250ZXh0KTtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldERpc3BsYXlOYW1lRm9yQ29sdW1uKHRoaXMuY29sdW1uLCAnaGVhZGVyJywgdHJ1ZSk7XG4gICAgICAgIHZhciBlbmFibGVTb3J0aW5nID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVTb3J0aW5nKCkgJiYgIXRoaXMuY29sdW1uLmdldENvbERlZigpLnN1cHByZXNzU29ydGluZztcbiAgICAgICAgdmFyIGVuYWJsZU1lbnUgPSB0aGlzLm1lbnVGYWN0b3J5LmlzTWVudUVuYWJsZWQodGhpcy5jb2x1bW4pICYmICF0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKS5zdXBwcmVzc01lbnU7XG4gICAgICAgIHRoaXMuYXBwZW5kSGVhZGVyQ29tcChkaXNwbGF5TmFtZSwgZW5hYmxlU29ydGluZywgZW5hYmxlTWVudSk7XG4gICAgICAgIHRoaXMuc2V0dXBXaWR0aCgpO1xuICAgICAgICB0aGlzLnNldHVwTW92aW5nQ3NzKCk7XG4gICAgICAgIHRoaXMuc2V0dXBUb29sdGlwKCk7XG4gICAgICAgIHRoaXMuc2V0dXBSZXNpemUoKTtcbiAgICAgICAgdGhpcy5zZXR1cE1lbnVDbGFzcygpO1xuICAgICAgICB0aGlzLnNldHVwU29ydGFibGVDbGFzcyhlbmFibGVTb3J0aW5nKTtcbiAgICAgICAgdGhpcy5hZGRDb2x1bW5Ib3Zlckxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuY29sdW1uLCBjb2x1bW5fMS5Db2x1bW4uRVZFTlRfRklMVEVSX0FDVElWRV9DSEFOR0VELCB0aGlzLm9uRmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbkZpbHRlckNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKHRoaXMuY29udGV4dCwgbmV3IHNlbGVjdEFsbEZlYXR1cmVfMS5TZWxlY3RBbGxGZWF0dXJlKHRoaXMuY2JTZWxlY3RBbGwsIHRoaXMuY29sdW1uKSk7XG4gICAgICAgIHZhciBzZXRMZWZ0RmVhdHVyZSA9IG5ldyBzZXRMZWZ0RmVhdHVyZV8xLlNldExlZnRGZWF0dXJlKHRoaXMuY29sdW1uLCB0aGlzLmdldEd1aSgpLCB0aGlzLmJlYW5zKTtcbiAgICAgICAgc2V0TGVmdEZlYXR1cmUuaW5pdCgpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lGdW5jKHNldExlZnRGZWF0dXJlLmRlc3Ryb3kuYmluZChzZXRMZWZ0RmVhdHVyZSkpO1xuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgY3NzQ2xhc3NBcHBsaWVyXzEuQ3NzQ2xhc3NBcHBsaWVyLmFkZEhlYWRlckNsYXNzZXNGcm9tQ29sRGVmKHRoaXMuY29sdW1uLmdldENvbERlZigpLCB0aGlzLmdldEd1aSgpLCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgdGhpcy5jb2x1bW4sIG51bGwpO1xuICAgIH07XG4gICAgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLmFkZENvbHVtbkhvdmVyTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX0hPVkVSX0NIQU5HRUQsIHRoaXMub25Db2x1bW5Ib3Zlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbkNvbHVtbkhvdmVyKCk7XG4gICAgfTtcbiAgICBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUub25Db2x1bW5Ib3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlzSG92ZXJlZCA9IHRoaXMuY29sdW1uSG92ZXJTZXJ2aWNlLmlzSG92ZXJlZCh0aGlzLmNvbHVtbik7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkT3JSZW1vdmVDc3NDbGFzcyh0aGlzLmdldEd1aSgpLCAnYWctY29sdW1uLWhvdmVyJywgaXNIb3ZlcmVkKTtcbiAgICB9O1xuICAgIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5zZXR1cFNvcnRhYmxlQ2xhc3MgPSBmdW5jdGlvbiAoZW5hYmxlU29ydGluZykge1xuICAgICAgICBpZiAoZW5hYmxlU29ydGluZykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEd1aSgpO1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRDc3NDbGFzcyhlbGVtZW50LCAnYWctaGVhZGVyLWNlbGwtc29ydGFibGUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLm9uRmlsdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpbHRlclByZXNlbnQgPSB0aGlzLmNvbHVtbi5pc0ZpbHRlckFjdGl2ZSgpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5nZXRHdWkoKSwgJ2FnLWhlYWRlci1jZWxsLWZpbHRlcmVkJywgZmlsdGVyUHJlc2VudCk7XG4gICAgfTtcbiAgICBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUuYXBwZW5kSGVhZGVyQ29tcCA9IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSwgZW5hYmxlU29ydGluZywgZW5hYmxlTWVudSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIGVuYWJsZVNvcnRpbmc6IGVuYWJsZVNvcnRpbmcsXG4gICAgICAgICAgICBlbmFibGVNZW51OiBlbmFibGVNZW51LFxuICAgICAgICAgICAgc2hvd0NvbHVtbk1lbnU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ncmlkQXBpLnNob3dDb2x1bW5NZW51QWZ0ZXJCdXR0b25DbGljayhfdGhpcy5jb2x1bW4sIHNvdXJjZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvZ3Jlc3NTb3J0OiBmdW5jdGlvbiAobXVsdGlTb3J0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc29ydENvbnRyb2xsZXIucHJvZ3Jlc3NTb3J0KF90aGlzLmNvbHVtbiwgISFtdWx0aVNvcnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFNvcnQ6IGZ1bmN0aW9uIChzb3J0LCBtdWx0aVNvcnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zb3J0Q29udHJvbGxlci5zZXRTb3J0Rm9yQ29sdW1uKF90aGlzLmNvbHVtbiwgc29ydCwgISFtdWx0aVNvcnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldENvbnRleHQoKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmFmdGVySGVhZGVyQ29tcENyZWF0ZWQuYmluZCh0aGlzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVjaXBlcy5uZXdIZWFkZXJDb21wb25lbnQocGFyYW1zKS50aGVuKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5hZnRlckhlYWRlckNvbXBDcmVhdGVkID0gZnVuY3Rpb24gKGRpc3BsYXlOYW1lLCBoZWFkZXJDb21wKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaGVhZGVyQ29tcCk7XG4gICAgICAgIHRoaXMuc2V0dXBNb3ZlKGhlYWRlckNvbXAuZ2V0R3VpKCksIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgaWYgKGhlYWRlckNvbXAuZGVzdHJveSkge1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95RnVuYyhoZWFkZXJDb21wLmRlc3Ryb3kuYmluZChoZWFkZXJDb21wKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5vbkNvbHVtbk1vdmluZ0NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gYWRkcyBvciByZW1vdmVzIHRoZSBtb3ZpbmcgY3NzLCBiYXNlZCBvbiBpZiB0aGUgY29sIGlzIG1vdmluZy5cbiAgICAgICAgLy8gdGhpcyBpcyB3aGF0IG1ha2VzIHRoZSBoZWFkZXIgZ28gZGFyayB3aGVuIGl0IGlzIGJlZW4gbW92ZWQgKGdpdmVzIGltcHJlc3Npb24gdG9cbiAgICAgICAgLy8gdXNlciB0aGF0IHRoZSBjb2x1bW4gd2FzIHBpY2tlZCB1cCkuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5pc01vdmluZygpKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZENzc0NsYXNzKHRoaXMuZ2V0R3VpKCksICdhZy1oZWFkZXItY2VsbC1tb3ZpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlQ3NzQ2xhc3ModGhpcy5nZXRHdWkoKSwgJ2FnLWhlYWRlci1jZWxsLW1vdmluZycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUuc2V0dXBNb3ZlID0gZnVuY3Rpb24gKGVIZWFkZXJDZWxsTGFiZWwsIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdXBwcmVzc01vdmUgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzTW92YWJsZUNvbHVtbnMoKVxuICAgICAgICAgICAgfHwgdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCkuc3VwcHJlc3NNb3ZhYmxlXG4gICAgICAgICAgICB8fCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0ZvclByaW50KCk7XG4gICAgICAgIGlmIChzdXBwcmVzc01vdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZUhlYWRlckNlbGxMYWJlbCkge1xuICAgICAgICAgICAgdmFyIGRyYWdTb3VyY2VfMSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBkcmFnQW5kRHJvcFNlcnZpY2VfMS5EcmFnU291cmNlVHlwZS5IZWFkZXJDZWxsLFxuICAgICAgICAgICAgICAgIGVFbGVtZW50OiBlSGVhZGVyQ2VsbExhYmVsLFxuICAgICAgICAgICAgICAgIGRyYWdJdGVtQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZURyYWdJdGVtKCk7IH0sXG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1OYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICBkcmFnU291cmNlRHJvcFRhcmdldDogdGhpcy5kcmFnU291cmNlRHJvcFRhcmdldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0FuZERyb3BTZXJ2aWNlLmFkZERyYWdTb3VyY2UoZHJhZ1NvdXJjZV8xLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveUZ1bmMoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZHJhZ0FuZERyb3BTZXJ2aWNlLnJlbW92ZURyYWdTb3VyY2UoZHJhZ1NvdXJjZV8xKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5jcmVhdGVEcmFnSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZpc2libGVTdGF0ZSA9IHt9O1xuICAgICAgICB2aXNpYmxlU3RhdGVbdGhpcy5jb2x1bW4uZ2V0SWQoKV0gPSB0aGlzLmNvbHVtbi5pc1Zpc2libGUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbnM6IFt0aGlzLmNvbHVtbl0sXG4gICAgICAgICAgICB2aXNpYmxlU3RhdGU6IHZpc2libGVTdGF0ZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLnNldHVwUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29sRGVmID0gdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCk7XG4gICAgICAgIC8vIGlmIG5vIGVSZXNpemUgaW4gdGVtcGxhdGUsIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLmVSZXNpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29sdW1uLmlzUmVzaXphYmxlKCkpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbVBhcmVudCh0aGlzLmVSZXNpemUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbERyYWdTZXJ2aWNlLmFkZERyYWdIYW5kbGluZyh7XG4gICAgICAgICAgICBlRHJhZ2dhYmxlRWxlbWVudDogdGhpcy5lUmVzaXplLFxuICAgICAgICAgICAgZUJvZHk6IHRoaXMuZVJvb3QsXG4gICAgICAgICAgICBjdXJzb3I6ICdjb2wtcmVzaXplJyxcbiAgICAgICAgICAgIHN0YXJ0QWZ0ZXJQaXhlbHM6IDAsXG4gICAgICAgICAgICBvbkRyYWdTdGFydDogdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb25EcmFnZ2luZzogdGhpcy5vbkRyYWdnaW5nLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB3ZVdhbnRBdXRvU2l6ZSA9ICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzQXV0b1NpemUoKSAmJiAhY29sRGVmLnN1cHByZXNzQXV0b1NpemU7XG4gICAgICAgIGlmICh3ZVdhbnRBdXRvU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lUmVzaXplLCAnZGJsY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uQ29udHJvbGxlci5hdXRvU2l6ZUNvbHVtbihfdGhpcy5jb2x1bW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5vbkRyYWdnaW5nID0gZnVuY3Rpb24gKGRyYWdDaGFuZ2UsIGZpbmlzaGVkKSB7XG4gICAgICAgIHZhciBkcmFnQ2hhbmdlTm9ybWFsaXNlZCA9IHRoaXMubm9ybWFsaXNlRHJhZ0NoYW5nZShkcmFnQ2hhbmdlKTtcbiAgICAgICAgdmFyIG5ld1dpZHRoID0gdGhpcy5zdGFydFdpZHRoICsgZHJhZ0NoYW5nZU5vcm1hbGlzZWQ7XG4gICAgICAgIHRoaXMuY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5XaWR0aCh0aGlzLmNvbHVtbiwgbmV3V2lkdGgsIGZpbmlzaGVkKTtcbiAgICB9O1xuICAgIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGFydFdpZHRoID0gdGhpcy5jb2x1bW4uZ2V0QWN0dWFsV2lkdGgoKTtcbiAgICB9O1xuICAgIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5zZXR1cFRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2xEZWYgPSB0aGlzLmNvbHVtbi5nZXRDb2xEZWYoKTtcbiAgICAgICAgLy8gYWRkIHRvb2x0aXAgaWYgZXhpc3RzXG4gICAgICAgIGlmIChjb2xEZWYuaGVhZGVyVG9vbHRpcCkge1xuICAgICAgICAgICAgdGhpcy5nZXRHdWkoKS50aXRsZSA9IGNvbERlZi5oZWFkZXJUb29sdGlwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUuc2V0dXBNb3ZpbmdDc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuY29sdW1uLCBjb2x1bW5fMS5Db2x1bW4uRVZFTlRfTU9WSU5HX0NIQU5HRUQsIHRoaXMub25Db2x1bW5Nb3ZpbmdDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uQ29sdW1uTW92aW5nQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLmFkZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ2V0R3VpKCkuc2V0QXR0cmlidXRlKFwiY29sLWlkXCIsIHRoaXMuY29sdW1uLmdldENvbElkKCkpO1xuICAgIH07XG4gICAgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLnNldHVwV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuY29sdW1uLCBjb2x1bW5fMS5Db2x1bW4uRVZFTlRfV0lEVEhfQ0hBTkdFRCwgdGhpcy5vbkNvbHVtbldpZHRoQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbkNvbHVtbldpZHRoQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLnNldHVwTWVudUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmNvbHVtbiwgY29sdW1uXzEuQ29sdW1uLkVWRU5UX01FTlVfVklTSUJMRV9DSEFOR0VELCB0aGlzLm9uTWVudVZpc2libGUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub25Db2x1bW5XaWR0aENoYW5nZWQoKTtcbiAgICB9O1xuICAgIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5vbk1lbnVWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3MoJ2FnLWNvbHVtbi1tZW51LXZpc2libGUnLCB0aGlzLmNvbHVtbi5pc01lbnVWaXNpYmxlKCkpO1xuICAgIH07XG4gICAgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLm9uQ29sdW1uV2lkdGhDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldEd1aSgpLnN0eWxlLndpZHRoID0gdGhpcy5jb2x1bW4uZ2V0QWN0dWFsV2lkdGgoKSArICdweCc7XG4gICAgfTtcbiAgICAvLyBvcHRpb25hbGx5IGludmVydHMgdGhlIGRyYWcsIGRlcGVuZGluZyBvbiBwaW5uZWQgYW5kIFJUTFxuICAgIC8vIG5vdGUgLSB0aGlzIG1ldGhvZCBpcyBkdXBsaWNhdGVkIGluIFJlbmRlcmVkSGVhZGVyR3JvdXBDZWxsIC0gc2hvdWxkIHJlZmFjdG9yIG91dD9cbiAgICBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUubm9ybWFsaXNlRHJhZ0NoYW5nZSA9IGZ1bmN0aW9uIChkcmFnQ2hhbmdlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkcmFnQ2hhbmdlO1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVSdGwoKSkge1xuICAgICAgICAgICAgLy8gZm9yIFJUTCwgZHJhZ2dpbmcgbGVmdCBtYWtlcyB0aGUgY29sIGJpZ2dlciwgZXhjZXB0IHdoZW4gcGlubmluZyBsZWZ0XG4gICAgICAgICAgICBpZiAodGhpcy5waW5uZWQgIT09IGNvbHVtbl8xLkNvbHVtbi5QSU5ORURfTEVGVCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvciBMVFIgKGllIG5vcm1hbCksIGRyYWdnaW5nIGxlZnQgbWFrZXMgdGhlIGNvbCBzbWFsbGVyLCBleGNlcHQgd2hlbiBwaW5uaW5nIHJpZ2h0XG4gICAgICAgICAgICBpZiAodGhpcy5waW5uZWQgPT09IGNvbHVtbl8xLkNvbHVtbi5QSU5ORURfUklHSFQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEhlYWRlcldyYXBwZXJDb21wLlRFTVBMQVRFID0gJzxkaXYgY2xhc3M9XCJhZy1oZWFkZXItY2VsbFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiA+JyArXG4gICAgICAgICc8ZGl2IHJlZj1cImVSZXNpemVcIiBjbGFzcz1cImFnLWhlYWRlci1jZWxsLXJlc2l6ZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L2Rpdj4nICtcbiAgICAgICAgJzxhZy1jaGVja2JveCByZWY9XCJjYlNlbGVjdEFsbFwiIGNsYXNzPVwiYWctaGVhZGVyLXNlbGVjdC1hbGxcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+PC9hZy1jaGVja2JveD4nICtcbiAgICAgICAgLy8gPGlubmVyIGNvbXBvbmVudCBnb2VzIGhlcmU+XG4gICAgICAgICc8L2Rpdj4nO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2RyYWdBbmREcm9wU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZHJhZ0FuZERyb3BTZXJ2aWNlXzEuRHJhZ0FuZERyb3BTZXJ2aWNlKVxuICAgIF0sIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJkcmFnQW5kRHJvcFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnaG9yaXpvbnRhbERyYWdTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBob3Jpem9udGFsRHJhZ1NlcnZpY2VfMS5Ib3Jpem9udGFsRHJhZ1NlcnZpY2UpXG4gICAgXSwgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImhvcml6b250YWxEcmFnU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdtZW51RmFjdG9yeScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJtZW51RmFjdG9yeVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUsIFwiZ3JpZEFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5BcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5BcGkpXG4gICAgXSwgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdzb3J0Q29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgc29ydENvbnRyb2xsZXJfMS5Tb3J0Q29udHJvbGxlcilcbiAgICBdLCBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUsIFwic29ydENvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb21wb25lbnRSZWNpcGVzJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb21wb25lbnRSZWNpcGVzXzEuQ29tcG9uZW50UmVjaXBlcylcbiAgICBdLCBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUsIFwiY29tcG9uZW50UmVjaXBlc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5Ib3ZlclNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkhvdmVyU2VydmljZV8xLkNvbHVtbkhvdmVyU2VydmljZSlcbiAgICBdLCBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUsIFwiY29sdW1uSG92ZXJTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2JlYW5zJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBiZWFuc18xLkJlYW5zKVxuICAgIF0sIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJiZWFuc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdlUmVzaXplJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MRWxlbWVudClcbiAgICBdLCBIZWFkZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUsIFwiZVJlc2l6ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdjYlNlbGVjdEFsbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgYWdDaGVja2JveF8xLkFnQ2hlY2tib3gpXG4gICAgXSwgSGVhZGVyV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImNiU2VsZWN0QWxsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEhlYWRlcldyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIHJldHVybiBIZWFkZXJXcmFwcGVyQ29tcDtcbn0oY29tcG9uZW50XzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkhlYWRlcldyYXBwZXJDb21wID0gSGVhZGVyV3JhcHBlckNvbXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyL2hlYWRlcldyYXBwZXJDb21wLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2NvbHVtblwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGRyYWdBbmREcm9wU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2RyYWdBbmREcm9wL2RyYWdBbmREcm9wU2VydmljZVwiKTtcbnZhciBncmlkUGFuZWxfMSA9IHJlcXVpcmUoXCIuLi9ncmlkUGFuZWwvZ3JpZFBhbmVsXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBNb3ZlQ29sdW1uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW92ZUNvbHVtbkNvbnRyb2xsZXIocGlubmVkLCBlQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMubmVlZFRvTW92ZUxlZnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZWVkVG9Nb3ZlUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waW5uZWQgPSBwaW5uZWQ7XG4gICAgICAgIHRoaXMuZUNvbnRhaW5lciA9IGVDb250YWluZXI7XG4gICAgICAgIHRoaXMuY2VudGVyQ29udGFpbmVyID0gIXV0aWxzXzEuVXRpbHMuZXhpc3RzKHBpbm5lZCk7XG4gICAgfVxuICAgIE1vdmVDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IHRoaXMubG9nZ2VyRmFjdG9yeS5jcmVhdGUoJ01vdmVDb2x1bW5Db250cm9sbGVyJyk7XG4gICAgfTtcbiAgICBNb3ZlQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0SWNvbk5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbm5lZCA/IGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdBbmREcm9wU2VydmljZS5JQ09OX1BJTk5FRCA6IGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdBbmREcm9wU2VydmljZS5JQ09OX01PVkU7XG4gICAgfTtcbiAgICBNb3ZlQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUub25EcmFnRW50ZXIgPSBmdW5jdGlvbiAoZHJhZ2dpbmdFdmVudCkge1xuICAgICAgICAvLyB3ZSBkbyBkdW1teSBkcmFnLCBzbyBtYWtlIHN1cmUgY29sdW1uIGFwcGVhcnMgaW4gdGhlIHJpZ2h0IGxvY2F0aW9uIHdoZW4gZmlyc3QgcGxhY2VkXG4gICAgICAgIHZhciBjb2x1bW5zID0gZHJhZ2dpbmdFdmVudC5kcmFnSXRlbS5jb2x1bW5zO1xuICAgICAgICB2YXIgZHJhZ0NhbWVGcm9tVG9vbFBhbmVsID0gZHJhZ2dpbmdFdmVudC5kcmFnU291cmNlLnR5cGUgPT09IGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdTb3VyY2VUeXBlLlRvb2xQYW5lbDtcbiAgICAgICAgaWYgKGRyYWdDYW1lRnJvbVRvb2xQYW5lbCkge1xuICAgICAgICAgICAgLy8gdGhlIGlmIHN0YXRlbWVudCBkb2Vzbid0IHdvcmsgaWYgZHJhZyBsZWF2ZXMgZ3JpZCwgdGhlbiBlbnRlcnMgYWdhaW5cbiAgICAgICAgICAgIHRoaXMuY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5zVmlzaWJsZShjb2x1bW5zLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc3RhdGUgb2YgdmlzaWJsZSBjb2x1bW5zIHVwb24gcmUtZW50ZXJpbmdcbiAgICAgICAgICAgIHZhciB2aXNpYmxlU3RhdGVfMSA9IGRyYWdnaW5nRXZlbnQuZHJhZ0l0ZW0udmlzaWJsZVN0YXRlO1xuICAgICAgICAgICAgdmFyIHZpc2libGVDb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gdmlzaWJsZVN0YXRlXzFbY29sdW1uLmdldElkKCldOyB9KTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5zVmlzaWJsZSh2aXNpYmxlQ29sdW1ucywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5Db250cm9sbGVyLnNldENvbHVtbnNQaW5uZWQoY29sdW1ucywgdGhpcy5waW5uZWQpO1xuICAgICAgICB0aGlzLm9uRHJhZ2dpbmcoZHJhZ2dpbmdFdmVudCwgdHJ1ZSk7XG4gICAgfTtcbiAgICBNb3ZlQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUub25EcmFnTGVhdmUgPSBmdW5jdGlvbiAoZHJhZ2dpbmdFdmVudCkge1xuICAgICAgICB2YXIgaGlkZUNvbHVtbk9uRXhpdCA9ICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1N1cHByZXNzRHJhZ0xlYXZlSGlkZXNDb2x1bW5zKCkgJiYgIWRyYWdnaW5nRXZlbnQuZnJvbU51ZGdlO1xuICAgICAgICBpZiAoaGlkZUNvbHVtbk9uRXhpdCkge1xuICAgICAgICAgICAgdmFyIGRyYWdJdGVtID0gZHJhZ2dpbmdFdmVudC5kcmFnU291cmNlLmRyYWdJdGVtQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gZHJhZ0l0ZW0uY29sdW1ucztcbiAgICAgICAgICAgIHRoaXMuY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5zVmlzaWJsZShjb2x1bW5zLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnN1cmVJbnRlcnZhbENsZWFyZWQoKTtcbiAgICB9O1xuICAgIE1vdmVDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5vbkRyYWdTdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVuc3VyZUludGVydmFsQ2xlYXJlZCgpO1xuICAgIH07XG4gICAgTW92ZUNvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLm5vcm1hbGlzZVggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAvLyBmbGlwIHRoZSBjb29yZGluYXRlIGlmIGRvaW5nIFJUTFxuICAgICAgICB2YXIgZmxpcEhvcml6b250YWxseUZvclJ0bCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCk7XG4gICAgICAgIGlmIChmbGlwSG9yaXpvbnRhbGx5Rm9yUnRsKSB7XG4gICAgICAgICAgICB2YXIgY2xpZW50V2lkdGggPSB0aGlzLmVDb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB4ID0gY2xpZW50V2lkdGggLSB4O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkanVzdCBmb3Igc2Nyb2xsIG9ubHkgaWYgY2VudHJlIGNvbnRhaW5lciAodGhlIHBpbm5lZCBjb250YWluZXJzIGRvbnQgc2Nyb2xsKVxuICAgICAgICB2YXIgYWRqdXN0Rm9yU2Nyb2xsID0gdGhpcy5jZW50ZXJDb250YWluZXI7XG4gICAgICAgIGlmIChhZGp1c3RGb3JTY3JvbGwpIHtcbiAgICAgICAgICAgIHggKz0gdGhpcy5ncmlkUGFuZWwuZ2V0Qm9keVZpZXdwb3J0U2Nyb2xsTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgTW92ZUNvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmNoZWNrQ2VudGVyRm9yU2Nyb2xsaW5nID0gZnVuY3Rpb24gKHhBZGp1c3RlZEZvclNjcm9sbCkge1xuICAgICAgICBpZiAodGhpcy5jZW50ZXJDb250YWluZXIpIHtcbiAgICAgICAgICAgIC8vIHNjcm9sbCBpZiB0aGUgbW91c2UgaGFzIGdvbmUgb3V0c2lkZSB0aGUgZ3JpZCAob3IganVzdCBvdXRzaWRlIHRoZSBzY3JvbGxhYmxlIHBhcnQgaWYgcGlubmluZylcbiAgICAgICAgICAgIC8vIHB1dHRpbmcgaW4gNTAgYnVmZmVyLCBzbyBldmVuIGlmIHVzZXIgZ2V0cyB0byBlZGdlIG9mIGdyaWQsIGEgc2Nyb2xsIHdpbGwgaGFwcGVuXG4gICAgICAgICAgICB2YXIgZmlyc3RWaXNpYmxlUGl4ZWwgPSB0aGlzLmdyaWRQYW5lbC5nZXRCb2R5Vmlld3BvcnRTY3JvbGxMZWZ0KCk7XG4gICAgICAgICAgICB2YXIgbGFzdFZpc2libGVQaXhlbCA9IGZpcnN0VmlzaWJsZVBpeGVsICsgdGhpcy5ncmlkUGFuZWwuZ2V0Q2VudGVyV2lkdGgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVJ0bCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkVG9Nb3ZlUmlnaHQgPSB4QWRqdXN0ZWRGb3JTY3JvbGwgPCAoZmlyc3RWaXNpYmxlUGl4ZWwgKyA1MCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkVG9Nb3ZlTGVmdCA9IHhBZGp1c3RlZEZvclNjcm9sbCA+IChsYXN0VmlzaWJsZVBpeGVsIC0gNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkVG9Nb3ZlTGVmdCA9IHhBZGp1c3RlZEZvclNjcm9sbCA8IChmaXJzdFZpc2libGVQaXhlbCArIDUwKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRUb01vdmVSaWdodCA9IHhBZGp1c3RlZEZvclNjcm9sbCA+IChsYXN0VmlzaWJsZVBpeGVsIC0gNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmVlZFRvTW92ZUxlZnQgfHwgdGhpcy5uZWVkVG9Nb3ZlUmlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZUludGVydmFsU3RhcnRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVJbnRlcnZhbENsZWFyZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTW92ZUNvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLm9uRHJhZ2dpbmcgPSBmdW5jdGlvbiAoZHJhZ2dpbmdFdmVudCwgZnJvbUVudGVyKSB7XG4gICAgICAgIGlmIChmcm9tRW50ZXIgPT09IHZvaWQgMCkgeyBmcm9tRW50ZXIgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmxhc3REcmFnZ2luZ0V2ZW50ID0gZHJhZ2dpbmdFdmVudDtcbiAgICAgICAgLy8gaWYgbW92aW5nIHVwIG9yIGRvd24gKGllIG5vdCBsZWZ0IG9yIHJpZ2h0KSB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyhkcmFnZ2luZ0V2ZW50LmhEaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHhOb3JtYWxpc2VkID0gdGhpcy5ub3JtYWxpc2VYKGRyYWdnaW5nRXZlbnQueCk7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGlzIGRyYWdnaW5nIGludG8gdGhlIHBhbmVsLCBpZSBjb21pbmcgZnJvbSB0aGUgc2lkZSBwYW5lbCBpbnRvIHRoZSBtYWluIGdyaWQsXG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gc2Nyb2xsIHRoZSBncmlkIHRoaXMgdGltZSwgaXQgd291bGQgYXBwZWFyIGxpa2UgdGhlIHRhYmxlIGlzIGp1bXBpbmdcbiAgICAgICAgLy8gZWFjaCB0aW1lIGEgY29sdW1uIGlzIGRyYWdnZWQgaW4uXG4gICAgICAgIGlmICghZnJvbUVudGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ2VudGVyRm9yU2Nyb2xsaW5nKHhOb3JtYWxpc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaERpcmVjdGlvbk5vcm1hbGlzZWQgPSB0aGlzLm5vcm1hbGlzZURpcmVjdGlvbihkcmFnZ2luZ0V2ZW50LmhEaXJlY3Rpb24pO1xuICAgICAgICB2YXIgZHJhZ1NvdXJjZVR5cGUgPSBkcmFnZ2luZ0V2ZW50LmRyYWdTb3VyY2UudHlwZTtcbiAgICAgICAgdmFyIGNvbHVtbnNUb01vdmUgPSBkcmFnZ2luZ0V2ZW50LmRyYWdTb3VyY2UuZHJhZ0l0ZW1DYWxsYmFjaygpLmNvbHVtbnM7XG4gICAgICAgIHRoaXMuYXR0ZW1wdE1vdmVDb2x1bW5zKGRyYWdTb3VyY2VUeXBlLCBjb2x1bW5zVG9Nb3ZlLCBoRGlyZWN0aW9uTm9ybWFsaXNlZCwgeE5vcm1hbGlzZWQsIGZyb21FbnRlcik7XG4gICAgfTtcbiAgICBNb3ZlQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUubm9ybWFsaXNlRGlyZWN0aW9uID0gZnVuY3Rpb24gKGhEaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgZHJhZ0FuZERyb3BTZXJ2aWNlXzEuSERpcmVjdGlvbi5MZWZ0OiByZXR1cm4gZHJhZ0FuZERyb3BTZXJ2aWNlXzEuSERpcmVjdGlvbi5SaWdodDtcbiAgICAgICAgICAgICAgICBjYXNlIGRyYWdBbmREcm9wU2VydmljZV8xLkhEaXJlY3Rpb24uUmlnaHQ6IHJldHVybiBkcmFnQW5kRHJvcFNlcnZpY2VfMS5IRGlyZWN0aW9uLkxlZnQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogY29uc29sZS5lcnJvcihcImFnLUdyaWQ6IFVua25vd24gZGlyZWN0aW9uIFwiICsgaERpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaERpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNvbHVtbiBpbiB0aGUgbGlzdCBPTkxZIGlmIHRoZSBjb2xzIGFyZSBhbGwgYmVzaWRlXG4gICAgLy8gZWFjaCBvdGhlci4gaWYgdGhlIGNvbHMgYXJlIG5vdCBiZXNpZGUgZWFjaCBvdGhlciwgdGhlbiByZXR1cm5zIG51bGxcbiAgICBNb3ZlQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUuY2FsY3VsYXRlT2xkSW5kZXggPSBmdW5jdGlvbiAobW92aW5nQ29scykge1xuICAgICAgICB2YXIgZ3JpZENvbHMgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0QWxsR3JpZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICAgICAgbW92aW5nQ29scy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHsgcmV0dXJuIGluZGV4ZXMucHVzaChncmlkQ29scy5pbmRleE9mKGNvbCkpOyB9KTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5zb3J0TnVtYmVyQXJyYXkoaW5kZXhlcyk7XG4gICAgICAgIHZhciBmaXJzdEluZGV4ID0gaW5kZXhlc1swXTtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IGluZGV4ZXNbaW5kZXhlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHNwcmVhZCA9IGxhc3RJbmRleCAtIGZpcnN0SW5kZXg7XG4gICAgICAgIHZhciBnYXBzRXhpc3QgPSBzcHJlYWQgIT09IGluZGV4ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGdhcHNFeGlzdCA/IG51bGwgOiBmaXJzdEluZGV4O1xuICAgIH07XG4gICAgTW92ZUNvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmF0dGVtcHRNb3ZlQ29sdW1ucyA9IGZ1bmN0aW9uIChkcmFnU291cmNlVHlwZSwgYWxsTW92aW5nQ29sdW1ucywgaERpcmVjdGlvbiwgeEFkanVzdGVkLCBmcm9tRW50ZXIpIHtcbiAgICAgICAgdmFyIGRyYWdnaW5nTGVmdCA9IGhEaXJlY3Rpb24gPT09IGRyYWdBbmREcm9wU2VydmljZV8xLkhEaXJlY3Rpb24uTGVmdDtcbiAgICAgICAgdmFyIGRyYWdnaW5nUmlnaHQgPSBoRGlyZWN0aW9uID09PSBkcmFnQW5kRHJvcFNlcnZpY2VfMS5IRGlyZWN0aW9uLlJpZ2h0O1xuICAgICAgICB2YXIgdmFsaWRNb3ZlcyA9IHRoaXMuY2FsY3VsYXRlVmFsaWRNb3ZlcyhhbGxNb3ZpbmdDb2x1bW5zLCBkcmFnZ2luZ1JpZ2h0LCB4QWRqdXN0ZWQpO1xuICAgICAgICAvLyBpZiBjb2xzIGFyZSBub3QgYWRqYWNlbnQsIHRoZW4gdGhpcyByZXR1cm5zIG51bGwuIHdoZW4gbW92aW5nLCB3ZSBjb25zdHJhaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbW92ZVxuICAgICAgICAvLyAoaWUgbGVmdCBvciByaWdodCkgdG8gdGhlIG1vdXNlIGRpcmVjdGlvbi4gaG93ZXZlclxuICAgICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmNhbGN1bGF0ZU9sZEluZGV4KGFsbE1vdmluZ0NvbHVtbnMpO1xuICAgICAgICAvLyBmcm9tRW50ZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxpZE1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3SW5kZXggPSB2YWxpZE1vdmVzW2ldO1xuICAgICAgICAgICAgLy8gdGhlIHR3byBjaGVjayBiZWxvdyBzdG9wIGFuIGVycm9yIHdoZW4gdGhlIHVzZXIgZ3JhYnMgYSBncm91cCBteSBhIG1pZGRsZSBjb2x1bW4sIHRoZW5cbiAgICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoZSBtb3VzZSBwb2ludGVyIGlzIHRvIHRoZSByaWdodCBvZiBhIGNvbHVtbiB3aGlsZSBiZWVuIGRyYWdnZWQgbGVmdC5cbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIG1vdXNlIHBvaW50ZXIgaXMgYWN0dWFsbHkgbGVmdCBvZiB0aGUgbGVmdCBtb3N0IGNvbHVtblxuICAgICAgICAgICAgLy8gaWYgbW92aW5nIGxlZnQsIGFuZCByaWdodCBvZiB0aGUgcmlnaHQgbW9zdCBjb2x1bW4gaWYgbW92aW5nIHJpZ2h0XG4gICAgICAgICAgICAvLyB3ZSBjaGVjayAnZnJvbUVudGVyJyBiZWxvdyBzbyB3ZSBtb3ZlIHRoZSBjb2x1bW4gdG8gdGhlIG5ldyBzcG90IGlmIHRoZSBtb3VzZSBpcyBjb21pbmcgZnJvbVxuICAgICAgICAgICAgLy8gb3V0c2lkZSB0aGUgZ3JpZCwgZWcgaWYgdGhlIGNvbHVtbiBpcyBtb3ZpbmcgZnJvbSBzaWRlIHBhbmVsLCBtb3VzZSBpcyBtb3ZpbmcgbGVmdCwgdGhlbiB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIHBsYWNlIHRoZSBjb2x1bW4gdG8gdGhlIFJIUyBldmVuIGlmIHRoZSBtb3VzZSBpcyBtb3ZpbmcgbGVmdCBhbmQgdGhlIGNvbHVtbiBpcyBhbHJlYWR5IG9uXG4gICAgICAgICAgICAvLyB0aGUgTEhTLiBvdGhlcndpc2Ugd2Ugc3RpY2sgdG8gdGhlIHJ1bGUgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbkRpcmVjdGlvbiA9IG9sZEluZGV4ICE9PSBudWxsICYmICFmcm9tRW50ZXI7XG4gICAgICAgICAgICAvLyBkb24ndCBjb25zaWRlciAnZnJvbUVudGVyJyB3aGVuIGRyYWdnaW5nIGhlYWRlciBjZWxscywgb3RoZXJ3aXNlIGdyb3VwIGNhbiBqdW1wIHRvIG9wcG9zaXRlIGRpcmVjdGlvbiBvZiBkcmFnXG4gICAgICAgICAgICBpZiAoZHJhZ1NvdXJjZVR5cGUgPT0gZHJhZ0FuZERyb3BTZXJ2aWNlXzEuRHJhZ1NvdXJjZVR5cGUuSGVhZGVyQ2VsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbkRpcmVjdGlvbiA9IG9sZEluZGV4ICE9PSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbkRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWxsb3cgbGVmdCBkcmFnIGlmIHRoaXMgY29sdW1uIGlzIG1vdmluZyBsZWZ0XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdnaW5nTGVmdCAmJiBuZXdJbmRleCA+PSBvbGRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyByaWdodCBkcmFnIGlmIHRoaXMgY29sdW1uIGlzIG1vdmluZyByaWdodFxuICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZ1JpZ2h0ICYmIG5ld0luZGV4IDw9IG9sZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jb2x1bW5Db250cm9sbGVyLmRvZXNNb3ZlUGFzc1J1bGVzKGFsbE1vdmluZ0NvbHVtbnMsIG5ld0luZGV4KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2x1bW5Db250cm9sbGVyLm1vdmVDb2x1bW5zKGFsbE1vdmluZ0NvbHVtbnMsIG5ld0luZGV4KTtcbiAgICAgICAgICAgIC8vIGltcG9ydGFudCB0byByZXR1cm4gaGVyZSwgc28gb25jZSB3ZSBkbyB0aGUgZmlyc3QgdmFsaWQgbW92ZSwgd2UgZG9uJ3QgdHJ5IGRvIGFueSBtb3JlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vdmVDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5jYWxjdWxhdGVWYWxpZE1vdmVzID0gZnVuY3Rpb24gKG1vdmluZ0NvbHMsIGRyYWdnaW5nUmlnaHQsIHgpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgbGlzdCBvZiBjb2xzIG9uIHRoZSBzY3JlZW4sIHNvIGl0J3MgdGhlc2Ugd2UgdXNlIHdoZW4gY29tcGFyaW5nIHRoZSB4IG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIHZhciBhbGxEaXNwbGF5ZWRDb2xzID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldERpc3BsYXllZENvbHVtbnModGhpcy5waW5uZWQpO1xuICAgICAgICAvLyBidXQgdGhpcyBsaXN0IGlzIHRoZSBsaXN0IG9mIGFsbCBjb2xzLCB3aGVuIHdlIG1vdmUgYSBjb2wgaXQncyB0aGUgaW5kZXggd2l0aGluIHRoaXMgbGlzdCB0aGF0IGdldHMgdXNlZCxcbiAgICAgICAgLy8gc28gdGhlIHJlc3VsdCB3ZSByZXR1cm4gaGFzIHRvIGJlIGFuZCBpbmRleCBsb2NhdGlvbiBmb3IgdGhpcyBsaXN0XG4gICAgICAgIHZhciBhbGxHcmlkQ29scyA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRBbGxHcmlkQ29sdW1ucygpO1xuICAgICAgICB2YXIgY29sSXNNb3ZpbmdGdW5jID0gZnVuY3Rpb24gKGNvbCkgeyByZXR1cm4gbW92aW5nQ29scy5pbmRleE9mKGNvbCkgPj0gMDsgfTtcbiAgICAgICAgdmFyIGNvbElzTm90TW92aW5nRnVuYyA9IGZ1bmN0aW9uIChjb2wpIHsgcmV0dXJuIG1vdmluZ0NvbHMuaW5kZXhPZihjb2wpIDwgMDsgfTtcbiAgICAgICAgdmFyIG1vdmluZ0Rpc3BsYXllZENvbHMgPSBhbGxEaXNwbGF5ZWRDb2xzLmZpbHRlcihjb2xJc01vdmluZ0Z1bmMpO1xuICAgICAgICB2YXIgb3RoZXJEaXNwbGF5ZWRDb2xzID0gYWxsRGlzcGxheWVkQ29scy5maWx0ZXIoY29sSXNOb3RNb3ZpbmdGdW5jKTtcbiAgICAgICAgdmFyIG90aGVyR3JpZENvbHMgPSBhbGxHcmlkQ29scy5maWx0ZXIoY29sSXNOb3RNb3ZpbmdGdW5jKTtcbiAgICAgICAgLy8gd29yayBvdXQgaG93IG1hbnkgRElTUExBWUVEIGNvbHVtbnMgZml0IGJlZm9yZSB0aGUgJ3gnIHBvc2l0aW9uLiB0aGlzIGdpdmVzIHVzIHRoZSBkaXNwbGF5SW5kZXguXG4gICAgICAgIC8vIGZvciBleGFtcGxlLCBpZiBjb2xzIGFyZSBhLGIsYyxkIGFuZCB3ZSBmaW5kIGEsYiBmaXQgYmVmb3JlICd4JywgdGhlbiB3ZSB3YW50IHRvIHBsYWNlIHRoZSBtb3ZpbmdcbiAgICAgICAgLy8gY29sIGJldHdlZW4gYiBhbmQgYyAoc28gdGhhdCBpdCBpcyB1bmRlciB0aGUgbW91c2UgcG9zaXRpb24pLlxuICAgICAgICB2YXIgZGlzcGxheUluZGV4ID0gMDtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0geDtcbiAgICAgICAgLy8gaWYgd2UgYXJlIGRyYWdnaW5nIHJpZ2h0LCB0aGVuIHRoZSBjb2x1bW5zIHdpbGwgYmUgdG8gdGhlIGxlZnQgb2YgdGhlIG1vdXNlLCBzbyB3ZSBhbHNvIHdhbnQgdG9cbiAgICAgICAgLy8gaW5jbHVkZSB0aGUgd2lkdGggb2YgdGhlIG1vdmluZyBjb2x1bW5zXG4gICAgICAgIGlmIChkcmFnZ2luZ1JpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGhPZk1vdmluZ0Rpc3BsYXllZENvbHNfMSA9IDA7XG4gICAgICAgICAgICBtb3ZpbmdEaXNwbGF5ZWRDb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbCkgeyByZXR1cm4gd2lkdGhPZk1vdmluZ0Rpc3BsYXllZENvbHNfMSArPSBjb2wuZ2V0QWN0dWFsV2lkdGgoKTsgfSk7XG4gICAgICAgICAgICBhdmFpbGFibGVXaWR0aCAtPSB3aWR0aE9mTW92aW5nRGlzcGxheWVkQ29sc18xO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBjb3VudCBob3cgbWFueSBvZiB0aGUgZGlzcGxheWVkIGNvbHVtbnMgd2lsbCBmaXQgdG8gdGhlIGxlZnRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlckRpc3BsYXllZENvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBvdGhlckRpc3BsYXllZENvbHNbaV07XG4gICAgICAgICAgICBhdmFpbGFibGVXaWR0aCAtPSBjb2wuZ2V0QWN0dWFsV2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVXaWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BsYXlJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyaWFsIGFuZCBlcnJvciwgaWYgZ29pbmcgcmlnaHQsIHdlIGFkanVzdCBieSBvbmUsIGkgZGlkbid0IG1hbmFnZSB0byBxdWFudGlmeSB3aHksIGJ1dCBpdCB3b3Jrc1xuICAgICAgICBpZiAoZHJhZ2dpbmdSaWdodCkge1xuICAgICAgICAgICAgZGlzcGxheUluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGRpc3BsYXkgaW5kZXggaXMgd2l0aCByZXNwZWN0IHRvIGFsbCB0aGUgc2hvd2luZyBjb2x1bW5zLCBob3dldmVyIHdoZW4gd2UgbW92ZSwgaXQncyB3aXRoXG4gICAgICAgIC8vIHJlc3BlY3QgdG8gYWxsIGdyaWQgY29sdW1ucywgc28gd2UgbmVlZCB0byB0cmFuc2xhdGUgZnJvbSBkaXNwbGF5IGluZGV4IHRvIGdyaWQgaW5kZXhcbiAgICAgICAgdmFyIGdyaWRDb2xJbmRleDtcbiAgICAgICAgaWYgKGRpc3BsYXlJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBsZWZ0Q29sdW1uID0gb3RoZXJEaXNwbGF5ZWRDb2xzW2Rpc3BsYXlJbmRleCAtIDFdO1xuICAgICAgICAgICAgZ3JpZENvbEluZGV4ID0gb3RoZXJHcmlkQ29scy5pbmRleE9mKGxlZnRDb2x1bW4pICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdyaWRDb2xJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbGlkTW92ZXMgPSBbZ3JpZENvbEluZGV4XTtcbiAgICAgICAgLy8gYWRkIGluIGFsbCBhZGphY2VudCBlbXB0eSBjb2x1bW5zIGFzIG90aGVyIHZhbGlkIG1vdmVzLiB0aGlzIGFsbG93cyB1cyB0byB0cnkgcHV0dGluZyB0aGUgbmV3XG4gICAgICAgIC8vIGNvbHVtbiBpbiBhbnkgcGxhY2Ugb2YgYSBoaWRkZW4gY29sdW1uLCB0byB0cnkgZGlmZmVyZW50IGNvbWJpbmF0aW9ucyBzbyB0aGF0IHdlIGRvbid0IGJyZWFrXG4gICAgICAgIC8vIG1hcnJpZWQgY2hpbGRyZW4uIGluIG90aGVyIHdvcmRzLCBtYXliZSB0aGUgbmV3IGluZGV4IGJyZWFrcyBhIGdyb3VwLCBidXQgb25seSBiZWNhdXNlIHNvbWVcbiAgICAgICAgLy8gY29sdW1ucyBhcmUgaGlkZGVuLCBtYXliZSB3ZSBjYW4gcmVzaHVmZmxlIHRoZSBoaWRkZW4gY29sdW1ucyB0byBmaW5kIGEgcGxhY2UgdGhhdCB3b3Jrcy5cbiAgICAgICAgdmFyIG5leHRDb2wgPSBhbGxHcmlkQ29sc1tncmlkQ29sSW5kZXhdO1xuICAgICAgICB3aGlsZSAodXRpbHNfMS5VdGlscy5leGlzdHMobmV4dENvbCkgJiYgdGhpcy5pc0NvbHVtbkhpZGRlbihhbGxEaXNwbGF5ZWRDb2xzLCBuZXh0Q29sKSkge1xuICAgICAgICAgICAgZ3JpZENvbEluZGV4Kys7XG4gICAgICAgICAgICB2YWxpZE1vdmVzLnB1c2goZ3JpZENvbEluZGV4KTtcbiAgICAgICAgICAgIG5leHRDb2wgPSBhbGxHcmlkQ29sc1tncmlkQ29sSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZE1vdmVzO1xuICAgIH07XG4gICAgLy8gaXNIaWRkZW4gdGFrZXMgaW50byBhY2NvdW50IHZpc2libGU9ZmFsc2UgYW5kIGdyb3VwPWNsb3NlZCwgaWUgaXQgaXMgbm90IGRpc3BsYXllZFxuICAgIE1vdmVDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5pc0NvbHVtbkhpZGRlbiA9IGZ1bmN0aW9uIChkaXNwbGF5ZWRDb2x1bW5zLCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXllZENvbHVtbnMuaW5kZXhPZihjb2wpIDwgMDtcbiAgICB9O1xuICAgIE1vdmVDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZS5lbnN1cmVJbnRlcnZhbFN0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3ZpbmdJbnRlcnZhbElkKSB7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5mYWlsZWRNb3ZlQXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmdJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodGhpcy5tb3ZlSW50ZXJ2YWwuYmluZCh0aGlzKSwgMTAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRUb01vdmVMZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnQW5kRHJvcFNlcnZpY2Uuc2V0R2hvc3RJY29uKGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdBbmREcm9wU2VydmljZS5JQ09OX0xFRlQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnQW5kRHJvcFNlcnZpY2Uuc2V0R2hvc3RJY29uKGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdBbmREcm9wU2VydmljZS5JQ09OX1JJR0hULCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTW92ZUNvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLmVuc3VyZUludGVydmFsQ2xlYXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW92ZUludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubW92aW5nSW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ0ludGVydmFsSWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kcmFnQW5kRHJvcFNlcnZpY2Uuc2V0R2hvc3RJY29uKGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdBbmREcm9wU2VydmljZS5JQ09OX01PVkUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb3ZlQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUubW92ZUludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGl4ZWxzVG9Nb3ZlO1xuICAgICAgICB0aGlzLmludGVydmFsQ291bnQrKztcbiAgICAgICAgcGl4ZWxzVG9Nb3ZlID0gMTAgKyAodGhpcy5pbnRlcnZhbENvdW50ICogNSk7XG4gICAgICAgIGlmIChwaXhlbHNUb01vdmUgPiAxMDApIHtcbiAgICAgICAgICAgIHBpeGVsc1RvTW92ZSA9IDEwMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGl4ZWxzTW92ZWQ7XG4gICAgICAgIGlmICh0aGlzLm5lZWRUb01vdmVMZWZ0KSB7XG4gICAgICAgICAgICBwaXhlbHNNb3ZlZCA9IHRoaXMuZ3JpZFBhbmVsLnNjcm9sbEhvcml6b250YWxseSgtcGl4ZWxzVG9Nb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5lZWRUb01vdmVSaWdodCkge1xuICAgICAgICAgICAgcGl4ZWxzTW92ZWQgPSB0aGlzLmdyaWRQYW5lbC5zY3JvbGxIb3Jpem9udGFsbHkocGl4ZWxzVG9Nb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGl4ZWxzTW92ZWQgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub25EcmFnZ2luZyh0aGlzLmxhc3REcmFnZ2luZ0V2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkTW92ZUF0dGVtcHRzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkTW92ZUF0dGVtcHRzKys7XG4gICAgICAgICAgICB0aGlzLmRyYWdBbmREcm9wU2VydmljZS5zZXRHaG9zdEljb24oZHJhZ0FuZERyb3BTZXJ2aWNlXzEuRHJhZ0FuZERyb3BTZXJ2aWNlLklDT05fUElOTkVEKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZhaWxlZE1vdmVBdHRlbXB0cyA+IDcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMubGFzdERyYWdnaW5nRXZlbnQuZHJhZ0l0ZW0uY29sdW1ucztcbiAgICAgICAgICAgICAgICB2YXIgcGluVHlwZSA9IHRoaXMubmVlZFRvTW92ZUxlZnQgPyBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX0xFRlQgOiBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX1JJR0hUO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5zUGlubmVkKGNvbHVtbnMsIHBpblR5cGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0FuZERyb3BTZXJ2aWNlLm51ZGdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdsb2dnZXJGYWN0b3J5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBsb2dnZXJfMS5Mb2dnZXJGYWN0b3J5KVxuICAgIF0sIE1vdmVDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJsb2dnZXJGYWN0b3J5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIE1vdmVDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRQYW5lbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZFBhbmVsXzEuR3JpZFBhbmVsKVxuICAgIF0sIE1vdmVDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJncmlkUGFuZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZHJhZ0FuZERyb3BTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBkcmFnQW5kRHJvcFNlcnZpY2VfMS5EcmFnQW5kRHJvcFNlcnZpY2UpXG4gICAgXSwgTW92ZUNvbHVtbkNvbnRyb2xsZXIucHJvdG90eXBlLCBcImRyYWdBbmREcm9wU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBNb3ZlQ29sdW1uQ29udHJvbGxlci5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIE1vdmVDb2x1bW5Db250cm9sbGVyLnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIHJldHVybiBNb3ZlQ29sdW1uQ29udHJvbGxlcjtcbn0oKSk7XG5leHBvcnRzLk1vdmVDb2x1bW5Db250cm9sbGVyID0gTW92ZUNvbHVtbkNvbnRyb2xsZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvbW92ZUNvbHVtbkNvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZmlsdGVyTWFuYWdlcl8xID0gcmVxdWlyZShcIi4uL2ZpbHRlci9maWx0ZXJNYW5hZ2VyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgcG9wdXBTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9wb3B1cFNlcnZpY2VcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2V2ZW50U2VydmljZVwiKTtcbnZhciBTdGFuZGFyZE1lbnVGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGFuZGFyZE1lbnVGYWN0b3J5KCkge1xuICAgIH1cbiAgICBTdGFuZGFyZE1lbnVGYWN0b3J5LnByb3RvdHlwZS5zaG93TWVudUFmdGVyTW91c2VFdmVudCA9IGZ1bmN0aW9uIChjb2x1bW4sIG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zaG93UG9wdXAoY29sdW1uLCBmdW5jdGlvbiAoZU1lbnUpIHtcbiAgICAgICAgICAgIF90aGlzLnBvcHVwU2VydmljZS5wb3NpdGlvblBvcHVwVW5kZXJNb3VzZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29sdW1uTWVudScsXG4gICAgICAgICAgICAgICAgbW91c2VFdmVudDogbW91c2VFdmVudCxcbiAgICAgICAgICAgICAgICBlUG9wdXA6IGVNZW51XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdGFuZGFyZE1lbnVGYWN0b3J5LnByb3RvdHlwZS5zaG93TWVudUFmdGVyQnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoY29sdW1uLCBldmVudFNvdXJjZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNob3dQb3B1cChjb2x1bW4sIGZ1bmN0aW9uIChlTWVudSkge1xuICAgICAgICAgICAgX3RoaXMucG9wdXBTZXJ2aWNlLnBvc2l0aW9uUG9wdXBVbmRlckNvbXBvbmVudCh7IHR5cGU6ICdjb2x1bW5NZW51JywgZXZlbnRTb3VyY2U6IGV2ZW50U291cmNlLFxuICAgICAgICAgICAgICAgIGVQb3B1cDogZU1lbnUsIGtlZXBXaXRoaW5Cb3VuZHM6IHRydWUsIGNvbHVtbjogY29sdW1uIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0YW5kYXJkTWVudUZhY3RvcnkucHJvdG90eXBlLnNob3dQb3B1cCA9IGZ1bmN0aW9uIChjb2x1bW4sIHBvc2l0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbHRlcldyYXBwZXIgPSB0aGlzLmZpbHRlck1hbmFnZXIuZ2V0T3JDcmVhdGVGaWx0ZXJXcmFwcGVyKGNvbHVtbik7XG4gICAgICAgIHZhciBlTWVudSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFkZENzc0NsYXNzKGVNZW51LCAnYWctbWVudScpO1xuICAgICAgICBmaWx0ZXJXcmFwcGVyLmd1aVByb21pc2UucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChndWkpIHtcbiAgICAgICAgICAgIGVNZW51LmFwcGVuZENoaWxkKGd1aSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaGlkZVBvcHVwO1xuICAgICAgICB2YXIgYm9keVNjcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBpZiBoIHNjcm9sbCwgcG9wdXAgaXMgbm8gbG9uZ2VyIG92ZXIgdGhlIGNvbHVtblxuICAgICAgICAgICAgaWYgKGV2ZW50LmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgaGlkZVBvcHVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZEV2ZW50TGlzdGVuZXIoJ2JvZHlTY3JvbGwnLCBib2R5U2Nyb2xsTGlzdGVuZXIpO1xuICAgICAgICB2YXIgY2xvc2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5ldmVudFNlcnZpY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignYm9keVNjcm9sbCcsIGJvZHlTY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgICAgICBjb2x1bW4uc2V0TWVudVZpc2libGUoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBuZWVkIHRvIHNob3cgZmlsdGVyIGJlZm9yZSBwb3NpdGlvbmluZywgYXMgb25seSBhZnRlciBmaWx0ZXJcbiAgICAgICAgLy8gaXMgdmlzaWJsZSBjYW4gd2UgZmluZCBvdXQgd2hhdCB0aGUgd2lkdGggb2YgaXQgaXNcbiAgICAgICAgaGlkZVBvcHVwID0gdGhpcy5wb3B1cFNlcnZpY2UuYWRkQXNNb2RhbFBvcHVwKGVNZW51LCB0cnVlLCBjbG9zZWRDYWxsYmFjayk7XG4gICAgICAgIHBvc2l0aW9uQ2FsbGJhY2soZU1lbnUpO1xuICAgICAgICBmaWx0ZXJXcmFwcGVyLmZpbHRlclByb21pc2UudGhlbihmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmFmdGVyR3VpQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBoaWRlUG9wdXA6IGhpZGVQb3B1cFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmlsdGVyLmFmdGVyR3VpQXR0YWNoZWQocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbHVtbi5zZXRNZW51VmlzaWJsZSh0cnVlKTtcbiAgICB9O1xuICAgIFN0YW5kYXJkTWVudUZhY3RvcnkucHJvdG90eXBlLmlzTWVudUVuYWJsZWQgPSBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIC8vIGZvciBzdGFuZGFyZCwgd2Ugc2hvdyBtZW51IGlmIGZpbHRlciBpcyBlbmFibGVkLCBhbmQgaGUgbWVudSBpcyBub3Qgc3VwcHJlc3NlZFxuICAgICAgICByZXR1cm4gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVGaWx0ZXIoKSAmJiBjb2x1bW4uaXNGaWx0ZXJBbGxvd2VkKCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgU3RhbmRhcmRNZW51RmFjdG9yeS5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZpbHRlck1hbmFnZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGZpbHRlck1hbmFnZXJfMS5GaWx0ZXJNYW5hZ2VyKVxuICAgIF0sIFN0YW5kYXJkTWVudUZhY3RvcnkucHJvdG90eXBlLCBcImZpbHRlck1hbmFnZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncG9wdXBTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBwb3B1cFNlcnZpY2VfMS5Qb3B1cFNlcnZpY2UpXG4gICAgXSwgU3RhbmRhcmRNZW51RmFjdG9yeS5wcm90b3R5cGUsIFwicG9wdXBTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIFN0YW5kYXJkTWVudUZhY3RvcnkucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIFN0YW5kYXJkTWVudUZhY3RvcnkgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ21lbnVGYWN0b3J5JylcbiAgICBdLCBTdGFuZGFyZE1lbnVGYWN0b3J5KTtcbiAgICByZXR1cm4gU3RhbmRhcmRNZW51RmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLlN0YW5kYXJkTWVudUZhY3RvcnkgPSBTdGFuZGFyZE1lbnVGYWN0b3J5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL3N0YW5kYXJkTWVudS5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3dpZGdldHMvY29tcG9uZW50XCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIExhcmdlVGV4dENlbGxFZGl0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXJnZVRleHRDZWxsRWRpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExhcmdlVGV4dENlbGxFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBMYXJnZVRleHRDZWxsRWRpdG9yLlRFTVBMQVRFKSB8fCB0aGlzO1xuICAgIH1cbiAgICBMYXJnZVRleHRDZWxsRWRpdG9yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQgPSBwYXJhbXMuY2VsbFN0YXJ0ZWRFZGl0O1xuICAgICAgICB0aGlzLnRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLm1heExlbmd0aCA9IHBhcmFtcy5tYXhMZW5ndGggPyBwYXJhbXMubWF4TGVuZ3RoIDogXCIyMDBcIjtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5jb2xzID0gcGFyYW1zLmNvbHMgPyBwYXJhbXMuY29scyA6IFwiNjBcIjtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5yb3dzID0gcGFyYW1zLnJvd3MgPyBwYXJhbXMucm93cyA6IFwiMTBcIjtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHBhcmFtcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEudmFsdWUgPSBwYXJhbXMudmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldEd1aSgpLnF1ZXJ5U2VsZWN0b3IoJy5hZy1sYXJnZS10ZXh0YXJlYScpLmFwcGVuZENoaWxkKHRoaXMudGV4dGFyZWEpO1xuICAgICAgICB0aGlzLmFkZEd1aUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIExhcmdlVGV4dENlbGxFZGl0b3IucHJvdG90eXBlLm9uS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5ID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcbiAgICAgICAgaWYgKGtleSA9PSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX0xFRlQgfHxcbiAgICAgICAgICAgIGtleSA9PSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX1VQIHx8XG4gICAgICAgICAgICBrZXkgPT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLktFWV9SSUdIVCB8fFxuICAgICAgICAgICAga2V5ID09IGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfRE9XTiB8fFxuICAgICAgICAgICAgKGV2ZW50LnNoaWZ0S2V5ICYmIGtleSA9PSBjb25zdGFudHNfMS5Db25zdGFudHMuS0VZX0VOVEVSKSkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhcmdlVGV4dENlbGxFZGl0b3IucHJvdG90eXBlLmFmdGVyR3VpQXR0YWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXJnZVRleHRDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dGFyZWEudmFsdWU7XG4gICAgfTtcbiAgICBMYXJnZVRleHRDZWxsRWRpdG9yLnByb3RvdHlwZS5pc1BvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIExhcmdlVGV4dENlbGxFZGl0b3IuVEVNUExBVEUgPSBcbiAgICAvLyB0YWIgaW5kZXggaXMgbmVlZGVkIHNvIHdlIGNhbiBmb2N1cywgd2hpY2ggaXMgbmVlZGVkIGZvciBrZXlib2FyZCBldmVudHNcbiAgICAnPGRpdiBjbGFzcz1cImFnLWxhcmdlLXRleHRcIiB0YWJpbmRleD1cIjBcIj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJhZy1sYXJnZS10ZXh0YXJlYVwiPjwvZGl2PicgK1xuICAgICAgICAnPC9kaXY+JztcbiAgICByZXR1cm4gTGFyZ2VUZXh0Q2VsbEVkaXRvcjtcbn0oY29tcG9uZW50XzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkxhcmdlVGV4dENlbGxFZGl0b3IgPSBMYXJnZVRleHRDZWxsRWRpdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxFZGl0b3JzL2xhcmdlVGV4dENlbGxFZGl0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWxlY3RDZWxsRWRpdG9yXzEgPSByZXF1aXJlKFwiLi9zZWxlY3RDZWxsRWRpdG9yXCIpO1xudmFyIFBvcHVwU2VsZWN0Q2VsbEVkaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBvcHVwU2VsZWN0Q2VsbEVkaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3B1cFNlbGVjdENlbGxFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUG9wdXBTZWxlY3RDZWxsRWRpdG9yLnByb3RvdHlwZS5pc1BvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBQb3B1cFNlbGVjdENlbGxFZGl0b3I7XG59KHNlbGVjdENlbGxFZGl0b3JfMS5TZWxlY3RDZWxsRWRpdG9yKSk7XG5leHBvcnRzLlBvcHVwU2VsZWN0Q2VsbEVkaXRvciA9IFBvcHVwU2VsZWN0Q2VsbEVkaXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3JlbmRlcmluZy9jZWxsRWRpdG9ycy9wb3B1cFNlbGVjdENlbGxFZGl0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZXh0Q2VsbEVkaXRvcl8xID0gcmVxdWlyZShcIi4vdGV4dENlbGxFZGl0b3JcIik7XG52YXIgUG9wdXBUZXh0Q2VsbEVkaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBvcHVwVGV4dENlbGxFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9wdXBUZXh0Q2VsbEVkaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBQb3B1cFRleHRDZWxsRWRpdG9yLnByb3RvdHlwZS5pc1BvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBQb3B1cFRleHRDZWxsRWRpdG9yO1xufSh0ZXh0Q2VsbEVkaXRvcl8xLlRleHRDZWxsRWRpdG9yKSk7XG5leHBvcnRzLlBvcHVwVGV4dENlbGxFZGl0b3IgPSBQb3B1cFRleHRDZWxsRWRpdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL2NlbGxFZGl0b3JzL3BvcHVwVGV4dENlbGxFZGl0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcm93Tm9kZUJsb2NrXzEgPSByZXF1aXJlKFwiLi9yb3dOb2RlQmxvY2tcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vbG9nZ2VyXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBSb3dOb2RlQmxvY2tMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvd05vZGVCbG9ja0xvYWRlcihtYXhDb25jdXJyZW50UmVxdWVzdHMpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVCbG9ja0xvYWRzQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVudFJlcXVlc3RzID0gbWF4Q29uY3VycmVudFJlcXVlc3RzO1xuICAgIH1cbiAgICBSb3dOb2RlQmxvY2tMb2FkZXIucHJvdG90eXBlLnNldEJlYW5zID0gZnVuY3Rpb24gKGxvZ2dlckZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXJGYWN0b3J5LmNyZWF0ZSgnUm93Tm9kZUJsb2NrTG9hZGVyJyk7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2tMb2FkZXIucHJvdG90eXBlLmFkZEJsb2NrID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuYmxvY2tzLnB1c2goYmxvY2spO1xuICAgIH07XG4gICAgUm93Tm9kZUJsb2NrTG9hZGVyLnByb3RvdHlwZS5yZW1vdmVCbG9jayA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB1dGlsc18xLl8ucmVtb3ZlRnJvbUFycmF5KHRoaXMuYmxvY2tzLCBibG9jayk7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2tMb2FkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfTtcbiAgICBSb3dOb2RlQmxvY2tMb2FkZXIucHJvdG90eXBlLmxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVCbG9ja0xvYWRzQ291bnQtLTtcbiAgICB9O1xuICAgIFJvd05vZGVCbG9ja0xvYWRlci5wcm90b3R5cGUuY2hlY2tCbG9ja1RvTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbnRDYWNoZVN0YXR1cygpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVCbG9ja0xvYWRzQ291bnQgPj0gdGhpcy5tYXhDb25jdXJyZW50UmVxdWVzdHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcImNoZWNrQmxvY2tUb0xvYWQ6IG1heCBsb2FkcyBleGNlZWRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmxvY2tUb0xvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgaWYgKGJsb2NrLmdldFN0YXRlKCkgPT09IHJvd05vZGVCbG9ja18xLlJvd05vZGVCbG9jay5TVEFURV9ESVJUWSkge1xuICAgICAgICAgICAgICAgIGJsb2NrVG9Mb2FkID0gYmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYmxvY2tUb0xvYWQpIHtcbiAgICAgICAgICAgIGJsb2NrVG9Mb2FkLmxvYWQoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQmxvY2tMb2Fkc0NvdW50Kys7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJjaGVja0Jsb2NrVG9Mb2FkOiBsb2FkaW5nIHBhZ2UgXCIgKyBibG9ja1RvTG9hZC5nZXRCbG9ja051bWJlcigpKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnRDYWNoZVN0YXR1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiY2hlY2tCbG9ja1RvTG9hZDogbm8gcGFnZXMgdG8gbG9hZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93Tm9kZUJsb2NrTG9hZGVyLnByb3RvdHlwZS5nZXRCbG9ja1N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHRoaXMuYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUlkUHJlZml4ID0gYmxvY2suZ2V0Tm9kZUlkUHJlZml4KCk7XG4gICAgICAgICAgICB2YXIgc3RhdGVJdGVtID0ge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBibG9jay5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgICAgIHN0YXJ0Um93OiBibG9jay5nZXRTdGFydFJvdygpLFxuICAgICAgICAgICAgICAgIGVuZFJvdzogYmxvY2suZ2V0RW5kUm93KCksXG4gICAgICAgICAgICAgICAgcGFnZVN0YXR1czogYmxvY2suZ2V0U3RhdGUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLl8uZXhpc3RzKG5vZGVJZFByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbm9kZUlkUHJlZml4ICsgYmxvY2suZ2V0QmxvY2tOdW1iZXIoKV0gPSBzdGF0ZUl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYmxvY2suZ2V0QmxvY2tOdW1iZXIoKV0gPSBzdGF0ZUl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUm93Tm9kZUJsb2NrTG9hZGVyLnByb3RvdHlwZS5wcmludENhY2hlU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sb2dnZXIuaXNMb2dnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInByaW50Q2FjaGVTdGF0dXM6IGFjdGl2ZVBhZ2VMb2Fkc0NvdW50ID0gXCIgKyB0aGlzLmFjdGl2ZUJsb2NrTG9hZHNDb3VudCArIFwiLFwiXG4gICAgICAgICAgICAgICAgKyAoXCIgYmxvY2tzID0gXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmdldEJsb2NrU3RhdGUoKSkpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIF9fcGFyYW0oMCwgY29udGV4dF8xLlF1YWxpZmllcignbG9nZ2VyRmFjdG9yeScpKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtsb2dnZXJfMS5Mb2dnZXJGYWN0b3J5XSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgUm93Tm9kZUJsb2NrTG9hZGVyLnByb3RvdHlwZSwgXCJzZXRCZWFuc1wiLCBudWxsKTtcbiAgICByZXR1cm4gUm93Tm9kZUJsb2NrTG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuUm93Tm9kZUJsb2NrTG9hZGVyID0gUm93Tm9kZUJsb2NrTG9hZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2NhY2hlL3Jvd05vZGVCbG9ja0xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgZmlsdGVyU2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3Jvd05vZGVzL2ZpbHRlclNlcnZpY2VcIik7XG52YXIgRmlsdGVyU3RhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbHRlclN0YWdlKCkge1xuICAgIH1cbiAgICBGaWx0ZXJTdGFnZS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHJvd05vZGUgPSBwYXJhbXMucm93Tm9kZTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlU2VydmVyU2lkZUZpbHRlcigpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlclNlcnZpY2UuZmlsdGVyKHJvd05vZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5maWx0ZXJBY2NvcmRpbmdUb0NvbHVtblN0YXRlKHJvd05vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgRmlsdGVyU3RhZ2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdmaWx0ZXJTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBmaWx0ZXJTZXJ2aWNlXzEuRmlsdGVyU2VydmljZSlcbiAgICBdLCBGaWx0ZXJTdGFnZS5wcm90b3R5cGUsIFwiZmlsdGVyU2VydmljZVwiLCB2b2lkIDApO1xuICAgIEZpbHRlclN0YWdlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdmaWx0ZXJTdGFnZScpXG4gICAgXSwgRmlsdGVyU3RhZ2UpO1xuICAgIHJldHVybiBGaWx0ZXJTdGFnZTtcbn0oKSk7XG5leHBvcnRzLkZpbHRlclN0YWdlID0gRmlsdGVyU3RhZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dNb2RlbHMvaW5NZW1vcnkvZmlsdGVyU3RhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgcm93Tm9kZV8xID0gcmVxdWlyZShcIi4uLy4uL2VudGl0aWVzL3Jvd05vZGVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgc2VsZWN0aW9uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL3NlbGVjdGlvbkNvbnRyb2xsZXJcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgRmxhdHRlblN0YWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGbGF0dGVuU3RhZ2UoKSB7XG4gICAgfVxuICAgIEZsYXR0ZW5TdGFnZS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gcGFyYW1zLnJvd05vZGU7XG4gICAgICAgIC8vIGV2ZW4gaWYgbm90IGRvaW5nIGdyb3VwaW5nLCB3ZSBkbyB0aGUgbWFwcGluZywgYXMgdGhlIGNsaWVudCBtaWdodFxuICAgICAgICAvLyBvZiBwYXNzZWQgaW4gZGF0YSB0aGF0IGFscmVhZHkgaGFzIGEgZ3JvdXBpbmcgaW4gaXQgc29tZXdoZXJlXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgLy8gcHV0dGluZyB2YWx1ZSBpbnRvIGEgd3JhcHBlciBzbyBpdCdzIHBhc3NlZCBieSByZWZlcmVuY2VcbiAgICAgICAgdmFyIG5leHRSb3dUb3AgPSB7IHZhbHVlOiAwIH07XG4gICAgICAgIHZhciBza2lwTGVhZk5vZGVzID0gdGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGl2b3RNb2RlKCk7XG4gICAgICAgIC8vIGlmIHdlIGFyZSByZWR1Y2luZywgYW5kIG5vdCBncm91cGluZywgdGhlbiB3ZSB3YW50IHRvIHNob3cgdGhlIHJvb3Qgbm9kZSwgYXMgdGhhdFxuICAgICAgICAvLyBpcyB3aGVyZSB0aGUgcGl2b3QgdmFsdWVzIGFyZVxuICAgICAgICB2YXIgc2hvd1Jvb3ROb2RlID0gc2tpcExlYWZOb2RlcyAmJiByb290Tm9kZS5sZWFmR3JvdXA7XG4gICAgICAgIHZhciB0b3BMaXN0ID0gc2hvd1Jvb3ROb2RlID8gW3Jvb3ROb2RlXSA6IHJvb3ROb2RlLmNoaWxkcmVuQWZ0ZXJTb3J0O1xuICAgICAgICAvLyBzZXQgYWxsIHJvdyB0b3BzIHRvIG51bGwsIHRoZW4gc2V0IHJvdyB0b3BzIG9uIGFsbCB2aXNpYmxlIHJvd3MuIGlmIHdlIGRvbid0XG4gICAgICAgIC8vIGRvIHRoaXMsIHRoZW4gdGhlIGFsZ29yaXRobSBiZWxvdyBvbmx5IHNldHMgcm93IHRvcHMsIG9sZCByb3cgdG9wcyBmcm9tIG9sZCByb3dzXG4gICAgICAgIC8vIHdpbGwgc3RpbGwgbGllIGFyb3VuZFxuICAgICAgICB0aGlzLnJlc2V0Um93VG9wcyhyb290Tm9kZSk7XG4gICAgICAgIHRoaXMucmVjdXJzaXZlbHlBZGRUb1Jvd3NUb0Rpc3BsYXkodG9wTGlzdCwgcmVzdWx0LCBuZXh0Um93VG9wLCBza2lwTGVhZk5vZGVzLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEZsYXR0ZW5TdGFnZS5wcm90b3R5cGUucmVzZXRSb3dUb3BzID0gZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgcm93Tm9kZS5jbGVhclJvd1RvcCgpO1xuICAgICAgICBpZiAocm93Tm9kZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBpZiAocm93Tm9kZS5jaGlsZHJlbkFmdGVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd05vZGUuY2hpbGRyZW5BZnRlckdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRSb3dUb3BzKHJvd05vZGUuY2hpbGRyZW5BZnRlckdyb3VwW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93Tm9kZS5zaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5zaWJsaW5nLmNsZWFyUm93VG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZsYXR0ZW5TdGFnZS5wcm90b3R5cGUucmVjdXJzaXZlbHlBZGRUb1Jvd3NUb0Rpc3BsYXkgPSBmdW5jdGlvbiAocm93c1RvRmxhdHRlbiwgcmVzdWx0LCBuZXh0Um93VG9wLCBza2lwTGVhZk5vZGVzLCB1aUxldmVsKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmdPckVtcHR5KHJvd3NUb0ZsYXR0ZW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwU3VwcHJlc3NSb3cgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwU3VwcHJlc3NSb3coKTtcbiAgICAgICAgdmFyIGhpZGVPcGVuUGFyZW50cyA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzR3JvdXBIaWRlT3BlblBhcmVudHMoKTtcbiAgICAgICAgdmFyIGdyb3VwUmVtb3ZlU2luZ2xlQ2hpbGRyZW4gPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwUmVtb3ZlU2luZ2xlQ2hpbGRyZW4oKTtcbiAgICAgICAgdmFyIGdyb3VwUmVtb3ZlTG93ZXN0U2luZ2xlQ2hpbGRyZW4gPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwUmVtb3ZlTG93ZXN0U2luZ2xlQ2hpbGRyZW4oKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzVG9GbGF0dGVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93Tm9kZSA9IHJvd3NUb0ZsYXR0ZW5baV07XG4gICAgICAgICAgICAvLyBjaGVjayBhbGwgdGhlc2UgY2FzZXMsIGZvciB3b3JraW5nIG91dCBpZiB0aGlzIHJvdyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIG1hcHBlZCBsaXN0XG4gICAgICAgICAgICB2YXIgaXNQYXJlbnQgPSByb3dOb2RlLmhhc0NoaWxkcmVuKCk7XG4gICAgICAgICAgICB2YXIgaXNHcm91cFN1cHByZXNzZWROb2RlID0gZ3JvdXBTdXBwcmVzc1JvdyAmJiBpc1BhcmVudDtcbiAgICAgICAgICAgIHZhciBpc1NraXBwZWRMZWFmTm9kZSA9IHNraXBMZWFmTm9kZXMgJiYgIWlzUGFyZW50O1xuICAgICAgICAgICAgdmFyIGlzUmVtb3ZlZFNpbmdsZUNoaWxkcmVuR3JvdXAgPSBncm91cFJlbW92ZVNpbmdsZUNoaWxkcmVuICYmIGlzUGFyZW50ICYmIHJvd05vZGUuY2hpbGRyZW5BZnRlckdyb3VwLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIHZhciBpc1JlbW92ZWRMb3dlc3RTaW5nbGVDaGlsZHJlbkdyb3VwID0gZ3JvdXBSZW1vdmVMb3dlc3RTaW5nbGVDaGlsZHJlbiAmJiBpc1BhcmVudCAmJiByb3dOb2RlLmxlYWZHcm91cCAmJiByb3dOb2RlLmNoaWxkcmVuQWZ0ZXJHcm91cC5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICAvLyBoaWRlIG9wZW4gcGFyZW50cyBtZWFucyB3aGVuIGdyb3VwIGlzIG9wZW4sIHdlIGRvbid0IHNob3cgaXQuIHdlIGFsc28gbmVlZCB0byBtYWtlIHN1cmUgdGhlXG4gICAgICAgICAgICAvLyBncm91cCBpcyBleHBhbmRhYmxlIGluIHRoZSBmaXJzdCBwbGFjZSAoYXMgbGVhZiBncm91cHMgYXJlIG5vdCBleHBhbmRhYmxlIGlmIHBpdm90IG1vZGUgaXMgb24pLlxuICAgICAgICAgICAgLy8gdGhlIFVJIHdpbGwgbmV2ZXIgYWxsb3cgZXhwYW5kaW5nIGxlYWYgIGdyb3VwcywgaG93ZXZlciB0aGUgdXNlciBtaWdodCB2aWEgdGhlIEFQSSAob3IgbWVudSBvcHRpb24gJ2V4cGFuZCBhbGwnKVxuICAgICAgICAgICAgdmFyIG5ldmVyQWxsb3dUb0V4cGFuZCA9IHNraXBMZWFmTm9kZXMgJiYgcm93Tm9kZS5sZWFmR3JvdXA7XG4gICAgICAgICAgICB2YXIgaXNIaWRkZW5PcGVuUGFyZW50ID0gaGlkZU9wZW5QYXJlbnRzICYmIHJvd05vZGUuZXhwYW5kZWQgJiYgKCFuZXZlckFsbG93VG9FeHBhbmQpO1xuICAgICAgICAgICAgdmFyIHRoaXNSb3dTaG91bGRCZVJlbmRlcmVkID0gIWlzU2tpcHBlZExlYWZOb2RlICYmICFpc0dyb3VwU3VwcHJlc3NlZE5vZGUgJiYgIWlzSGlkZGVuT3BlblBhcmVudCAmJiAhaXNSZW1vdmVkU2luZ2xlQ2hpbGRyZW5Hcm91cCAmJiAhaXNSZW1vdmVkTG93ZXN0U2luZ2xlQ2hpbGRyZW5Hcm91cDtcbiAgICAgICAgICAgIGlmICh0aGlzUm93U2hvdWxkQmVSZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUm93Tm9kZVRvUm93c1RvRGlzcGxheShyb3dOb2RlLCByZXN1bHQsIG5leHRSb3dUb3AsIHVpTGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHBpdm90aW5nLCB3ZSBuZXZlciBtYXAgYmVsb3cgdGhlIGxlYWYgZ3JvdXBcbiAgICAgICAgICAgIGlmIChza2lwTGVhZk5vZGVzICYmIHJvd05vZGUubGVhZkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSB0cmF2ZXJzZSB0aGUgZ3JvdXAgaWYgaXQgaXMgZXhwZW5kZWQsIGhvd2V2ZXIgd2UgYWx3YXlzIHRyYXZlcnNlIGlmIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHdhcyByZW1vdmVkIChhcyB0aGUgZ3JvdXAgd2lsbCBuZXZlciBiZSBvcGVuZWQgaWYgaXQgaXMgbm90IGRpc3BsYXllZCwgd2Ugc2hvdyB0aGUgY2hpbGRyZW4gaW5zdGVhZClcbiAgICAgICAgICAgICAgICBpZiAocm93Tm9kZS5leHBhbmRlZCB8fCBpc1JlbW92ZWRTaW5nbGVDaGlsZHJlbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgd2FzIGV4Y2x1ZGVkLCB0aGVuIHVpIGxldmVsIGlzIHRoYXQgb2YgdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgdWlMZXZlbEZvckNoaWxkcmVuID0gaXNSZW1vdmVkU2luZ2xlQ2hpbGRyZW5Hcm91cCA/IHVpTGV2ZWwgOiB1aUxldmVsICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWN1cnNpdmVseUFkZFRvUm93c1RvRGlzcGxheShyb3dOb2RlLmNoaWxkcmVuQWZ0ZXJTb3J0LCByZXN1bHQsIG5leHRSb3dUb3AsIHNraXBMZWFmTm9kZXMsIHVpTGV2ZWxGb3JDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1dCBhIGZvb3RlciBpbiBpZiB1c2VyIGlzIGxvb2tpbmcgZm9yIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwSW5jbHVkZUZvb3RlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZUZvb3Rlck5vZGVFeGlzdHMocm93Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFJvd05vZGVUb1Jvd3NUb0Rpc3BsYXkocm93Tm9kZS5zaWJsaW5nLCByZXN1bHQsIG5leHRSb3dUb3AsIHVpTGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvd05vZGUuY2FuRmxvd2VyICYmIHJvd05vZGUuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxvd2VyTm9kZSA9IHRoaXMuY3JlYXRlRmxvd2VyTm9kZShyb3dOb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFJvd05vZGVUb1Jvd3NUb0Rpc3BsYXkoZmxvd2VyTm9kZSwgcmVzdWx0LCBuZXh0Um93VG9wLCB1aUxldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZHVwbGljYXRlZCBtZXRob2QsIGl0J3MgYWxzbyBpbiBmbG9hdGluZ1Jvd01vZGVsXG4gICAgRmxhdHRlblN0YWdlLnByb3RvdHlwZS5hZGRSb3dOb2RlVG9Sb3dzVG9EaXNwbGF5ID0gZnVuY3Rpb24gKHJvd05vZGUsIHJlc3VsdCwgbmV4dFJvd1RvcCwgdWlMZXZlbCkge1xuICAgICAgICByZXN1bHQucHVzaChyb3dOb2RlKTtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyhyb3dOb2RlLnJvd0hlaWdodCkpIHtcbiAgICAgICAgICAgIHZhciByb3dIZWlnaHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRSb3dIZWlnaHRGb3JOb2RlKHJvd05vZGUpO1xuICAgICAgICAgICAgcm93Tm9kZS5zZXRSb3dIZWlnaHQocm93SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByb3dOb2RlLnNldFVpTGV2ZWwodWlMZXZlbCk7XG4gICAgICAgIHJvd05vZGUuc2V0Um93VG9wKG5leHRSb3dUb3AudmFsdWUpO1xuICAgICAgICByb3dOb2RlLnNldFJvd0luZGV4KHJlc3VsdC5sZW5ndGggLSAxKTtcbiAgICAgICAgbmV4dFJvd1RvcC52YWx1ZSArPSByb3dOb2RlLnJvd0hlaWdodDtcbiAgICB9O1xuICAgIEZsYXR0ZW5TdGFnZS5wcm90b3R5cGUuZW5zdXJlRm9vdGVyTm9kZUV4aXN0cyA9IGZ1bmN0aW9uIChncm91cE5vZGUpIHtcbiAgICAgICAgLy8gb25seSBjcmVhdGUgZm9vdGVyIG5vZGUgb25jZSwgb3RoZXJ3aXNlIHdlIGhhdmUgZGFlbW9ucyBhbmRcbiAgICAgICAgLy8gdGhlIGFuaW1hdGUgc2NyZXdzIHVwIHdpdGggdGhlIGRhZW1vbnMgaGFuZ2luZyBhcm91bmRcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKGdyb3VwTm9kZS5zaWJsaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb290ZXJOb2RlID0gbmV3IHJvd05vZGVfMS5Sb3dOb2RlKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC53aXJlQmVhbihmb290ZXJOb2RlKTtcbiAgICAgICAgT2JqZWN0LmtleXMoZ3JvdXBOb2RlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGZvb3Rlck5vZGVba2V5XSA9IGdyb3VwTm9kZVtrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9vdGVyTm9kZS5mb290ZXIgPSB0cnVlO1xuICAgICAgICBmb290ZXJOb2RlLnJvd1RvcCA9IG51bGw7XG4gICAgICAgIGZvb3Rlck5vZGUub2xkUm93VG9wID0gbnVsbDtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKGZvb3Rlck5vZGUuaWQpKSB7XG4gICAgICAgICAgICBmb290ZXJOb2RlLmlkID0gJ3Jvd0dyb3VwRm9vdGVyXycgKyBmb290ZXJOb2RlLmlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBib3RoIGhlYWRlciBhbmQgZm9vdGVyIHRvIHJlZmVyZW5jZSBlYWNoIG90aGVyIGFzIHNpYmxpbmdzLiB0aGlzIGlzIG5ldmVyIHVuZG9uZSxcbiAgICAgICAgLy8gb25seSBvdmVyd3JpdHRlbi4gc28gaWYgYSBncm91cCBpcyBleHBhbmRlZCwgdGhlbiBjb250cmFjdGVkLCBpdCB3aWxsIGhhdmUgYSBnaG9zdFxuICAgICAgICAvLyBzaWJsaW5nIC0gYnV0IHRoYXQncyBmaW5lLCBhcyB3ZSBjYW4gaWdub3JlIHRoaXMgaWYgdGhlIGhlYWRlciBpcyBjb250cmFjdGVkLlxuICAgICAgICBmb290ZXJOb2RlLnNpYmxpbmcgPSBncm91cE5vZGU7XG4gICAgICAgIGdyb3VwTm9kZS5zaWJsaW5nID0gZm9vdGVyTm9kZTtcbiAgICB9O1xuICAgIEZsYXR0ZW5TdGFnZS5wcm90b3R5cGUuY3JlYXRlRmxvd2VyTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhwYXJlbnROb2RlLmNoaWxkRmxvd2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5vZGUuY2hpbGRGbG93ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmxvd2VyTm9kZSA9IG5ldyByb3dOb2RlXzEuUm93Tm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LndpcmVCZWFuKGZsb3dlck5vZGUpO1xuICAgICAgICAgICAgZmxvd2VyTm9kZS5mbG93ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZmxvd2VyTm9kZS5wYXJlbnQgPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKHBhcmVudE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgZmxvd2VyTm9kZS5pZCA9ICdmbG93ZXJOb2RlXycgKyBwYXJlbnROb2RlLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxvd2VyTm9kZS5kYXRhID0gcGFyZW50Tm9kZS5kYXRhO1xuICAgICAgICAgICAgZmxvd2VyTm9kZS5sZXZlbCA9IHBhcmVudE5vZGUubGV2ZWwgKyAxO1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZEZsb3dlciA9IGZsb3dlck5vZGU7XG4gICAgICAgICAgICByZXR1cm4gZmxvd2VyTm9kZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEZsYXR0ZW5TdGFnZS5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3NlbGVjdGlvbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNlbGVjdGlvbkNvbnRyb2xsZXJfMS5TZWxlY3Rpb25Db250cm9sbGVyKVxuICAgIF0sIEZsYXR0ZW5TdGFnZS5wcm90b3R5cGUsIFwic2VsZWN0aW9uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdldmVudFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSlcbiAgICBdLCBGbGF0dGVuU3RhZ2UucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBGbGF0dGVuU3RhZ2UucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgRmxhdHRlblN0YWdlLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgRmxhdHRlblN0YWdlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdmbGF0dGVuU3RhZ2UnKVxuICAgIF0sIEZsYXR0ZW5TdGFnZSk7XG4gICAgcmV0dXJuIEZsYXR0ZW5TdGFnZTtcbn0oKSk7XG5leHBvcnRzLkZsYXR0ZW5TdGFnZSA9IEZsYXR0ZW5TdGFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9pbk1lbW9yeS9mbGF0dGVuU3RhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIEltbXV0YWJsZVNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltbXV0YWJsZVNlcnZpY2UoKSB7XG4gICAgfVxuICAgIEltbXV0YWJsZVNlcnZpY2UucHJvdG90eXBlLnBvc3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvd01vZGVsLmdldFR5cGUoKSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0lOX01FTU9SWSkge1xuICAgICAgICAgICAgdGhpcy5pbk1lbW9yeVJvd01vZGVsID0gdGhpcy5yb3dNb2RlbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gY29udmVydHMgdGhlIHNldFJvd0RhdGEoKSBjb21tYW5kIHRvIGEgdHJhbnNhY3Rpb25cbiAgICBJbW11dGFibGVTZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGVUcmFuc2FjdGlvbkZvclJvd0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAodXRpbHNfMS5fLm1pc3NpbmcodGhpcy5pbk1lbW9yeVJvd01vZGVsKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogSW1tdXRhYmxlU2VydmljZSBvbmx5IHdvcmtzIHdpdGggSW5NZW1vcnlSb3dNb2RlbCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRSb3dOb2RlSWRGdW5jID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Um93Tm9kZUlkRnVuYygpO1xuICAgICAgICBpZiAodXRpbHNfMS5fLm1pc3NpbmcoZ2V0Um93Tm9kZUlkRnVuYykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FnLUdyaWQ6IEltbXV0YWJsZVNlcnZpY2UgcmVxdWlyZXMgZ2V0Um93Tm9kZUlkKCkgY2FsbGJhY2sgdG8gYmUgaW1wbGVtZW50ZWQsIHlvdXIgcm93IGRhdGEgbmVlZCBJRHMhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udmVydCB0aGUgZGF0YSBpbnRvIGEgdHJhbnNhY3Rpb24gb2JqZWN0IGJ5IHdvcmtpbmcgb3V0IGFkZHMsIHJlbW92ZXMgYW5kIHVwZGF0ZXNcbiAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgcmVtb3ZlOiBbXSxcbiAgICAgICAgICAgIHVwZGF0ZTogW10sXG4gICAgICAgICAgICBhZGQ6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBleGlzdGluZ05vZGVzTWFwID0gdGhpcy5pbk1lbW9yeVJvd01vZGVsLmdldENvcHlPZk5vZGVzTWFwKCk7XG4gICAgICAgIHZhciBvcmRlck1hcCA9IHt9O1xuICAgICAgICBpZiAodXRpbHNfMS5fLmV4aXN0cyhkYXRhKSkge1xuICAgICAgICAgICAgLy8gc3BsaXQgYWxsIHRoZSBuZXcgZGF0YSBpbiB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgICAgLy8gaWYgbmV3LCBwdXNoIHRvICdhZGQnXG4gICAgICAgICAgICAvLyBpZiB1cGRhdGUsIHB1c2ggdG8gJ3VwZGF0ZSdcbiAgICAgICAgICAgIC8vIGlmIG5vdCBjaGFuZ2VkLCBkbyBub3QgaW5jbHVkZSBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gZ2V0Um93Tm9kZUlkRnVuYyhkYXRhSXRlbSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nTm9kZSA9IGV4aXN0aW5nTm9kZXNNYXBbaWRdO1xuICAgICAgICAgICAgICAgIG9yZGVyTWFwW2lkXSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFIYXNDaGFuZ2VkID0gZXhpc3RpbmdOb2RlLmRhdGEgIT09IGRhdGFJdGVtO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUhhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZS5wdXNoKGRhdGFJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGlmIGRhdGEgbm90IGNoYW5nZWQsIHdlIGp1c3QgZG9uJ3QgaW5jbHVkZSBpdCBhbnl3aGVyZSwgYXMgaXQncyBub3QgYSBkZWx0YVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBsaXN0LCBzbyB3ZSBrbm93IHRoZSBpdGVtIGlzIG5vdCB0byBiZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nTm9kZXNNYXBbaWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWRkLnB1c2goZGF0YUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIGFsbCByb3dzIHRoYXQgYXJlIGxlZnQsIHNob3VsZCBiZSByZW1vdmVkXG4gICAgICAgIHV0aWxzXzEuXy5pdGVyYXRlT2JqZWN0KGV4aXN0aW5nTm9kZXNNYXAsIGZ1bmN0aW9uIChpZCwgcm93Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHJvd05vZGUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5yZW1vdmUucHVzaChyb3dOb2RlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFt0cmFuc2FjdGlvbiwgb3JkZXJNYXBdO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3Jvd01vZGVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSW1tdXRhYmxlU2VydmljZS5wcm90b3R5cGUsIFwicm93TW9kZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgSW1tdXRhYmxlU2VydmljZS5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEltbXV0YWJsZVNlcnZpY2UucHJvdG90eXBlLCBcInBvc3RDb25zdHJ1Y3RcIiwgbnVsbCk7XG4gICAgSW1tdXRhYmxlU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbignaW1tdXRhYmxlU2VydmljZScpXG4gICAgXSwgSW1tdXRhYmxlU2VydmljZSk7XG4gICAgcmV0dXJuIEltbXV0YWJsZVNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5JbW11dGFibGVTZXJ2aWNlID0gSW1tdXRhYmxlU2VydmljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9pbk1lbW9yeS9pbW11dGFibGVTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBmaWx0ZXJNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vZmlsdGVyL2ZpbHRlck1hbmFnZXJcIik7XG52YXIgcm93Tm9kZV8xID0gcmVxdWlyZShcIi4uLy4uL2VudGl0aWVzL3Jvd05vZGVcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4uLy4uL2V2ZW50c1wiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIHNlbGVjdGlvbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZWxlY3Rpb25Db250cm9sbGVyXCIpO1xudmFyIGluTWVtb3J5Tm9kZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL2luTWVtb3J5Tm9kZU1hbmFnZXJcIik7XG52YXIgY2hhbmdlZFBhdGhfMSA9IHJlcXVpcmUoXCIuL2NoYW5nZWRQYXRoXCIpO1xudmFyIHZhbHVlU2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3ZhbHVlU2VydmljZS92YWx1ZVNlcnZpY2VcIik7XG52YXIgdmFsdWVDYWNoZV8xID0gcmVxdWlyZShcIi4uLy4uL3ZhbHVlU2VydmljZS92YWx1ZUNhY2hlXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkQXBpXCIpO1xudmFyIFJlY3Vyc2lvblR5cGU7XG4oZnVuY3Rpb24gKFJlY3Vyc2lvblR5cGUpIHtcbiAgICBSZWN1cnNpb25UeXBlW1JlY3Vyc2lvblR5cGVbXCJOb3JtYWxcIl0gPSAwXSA9IFwiTm9ybWFsXCI7XG4gICAgUmVjdXJzaW9uVHlwZVtSZWN1cnNpb25UeXBlW1wiQWZ0ZXJGaWx0ZXJcIl0gPSAxXSA9IFwiQWZ0ZXJGaWx0ZXJcIjtcbiAgICBSZWN1cnNpb25UeXBlW1JlY3Vyc2lvblR5cGVbXCJBZnRlckZpbHRlckFuZFNvcnRcIl0gPSAyXSA9IFwiQWZ0ZXJGaWx0ZXJBbmRTb3J0XCI7XG4gICAgUmVjdXJzaW9uVHlwZVtSZWN1cnNpb25UeXBlW1wiUGl2b3ROb2Rlc1wiXSA9IDNdID0gXCJQaXZvdE5vZGVzXCI7XG59KShSZWN1cnNpb25UeXBlIHx8IChSZWN1cnNpb25UeXBlID0ge30pKTtcbjtcbnZhciBJbk1lbW9yeVJvd01vZGVsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbk1lbW9yeVJvd01vZGVsKCkge1xuICAgIH1cbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVmcmVzaEV2ZXJ5dGhpbmdGdW5jID0gdGhpcy5yZWZyZXNoTW9kZWwuYmluZCh0aGlzLCB7IHN0ZXA6IGNvbnN0YW50c18xLkNvbnN0YW50cy5TVEVQX0VWRVJZVEhJTkcgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZE1vZGFsUHJpb3JpdHlFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fRVZFUllUSElOR19DSEFOR0VELCByZWZyZXNoRXZlcnl0aGluZ0Z1bmMpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRNb2RhbFByaW9yaXR5RXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1JPV19HUk9VUF9DSEFOR0VELCByZWZyZXNoRXZlcnl0aGluZ0Z1bmMpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRNb2RhbFByaW9yaXR5RXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1ZBTFVFX0NIQU5HRUQsIHRoaXMub25WYWx1ZUNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFkZE1vZGFsUHJpb3JpdHlFdmVudExpc3RlbmVyKGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DT0xVTU5fUElWT1RfQ0hBTkdFRCwgdGhpcy5yZWZyZXNoTW9kZWwuYmluZCh0aGlzLCB7IHN0ZXA6IGNvbnN0YW50c18xLkNvbnN0YW50cy5TVEVQX1BJVk9UIH0pKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkTW9kYWxQcmlvcml0eUV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1JPV19HUk9VUF9PUEVORUQsIHRoaXMub25Sb3dHcm91cE9wZW5lZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkTW9kYWxQcmlvcml0eUV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX0ZJTFRFUl9DSEFOR0VELCB0aGlzLm9uRmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYWRkTW9kYWxQcmlvcml0eUV2ZW50TGlzdGVuZXIoZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1NPUlRfQ0hBTkdFRCwgdGhpcy5vblNvcnRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5hZGRNb2RhbFByaW9yaXR5RXZlbnRMaXN0ZW5lcihldmVudHNfMS5FdmVudHMuRVZFTlRfQ09MVU1OX1BJVk9UX01PREVfQ0hBTkdFRCwgcmVmcmVzaEV2ZXJ5dGhpbmdGdW5jKTtcbiAgICAgICAgdmFyIHJlZnJlc2hNYXBGdW5jID0gdGhpcy5yZWZyZXNoTW9kZWwuYmluZCh0aGlzLCB7IHN0ZXA6IGNvbnN0YW50c18xLkNvbnN0YW50cy5TVEVQX01BUCwga2VlcFJlbmRlcmVkUm93czogdHJ1ZSwgYW5pbWF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIuUFJPUF9HUk9VUF9SRU1PVkVfU0lOR0xFX0NISUxEUkVOLCByZWZyZXNoTWFwRnVuYyk7XG4gICAgICAgIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyLlBST1BfR1JPVVBfUkVNT1ZFX0xPV0VTVF9TSU5HTEVfQ0hJTERSRU4sIHJlZnJlc2hNYXBGdW5jKTtcbiAgICAgICAgdGhpcy5yb290Tm9kZSA9IG5ldyByb3dOb2RlXzEuUm93Tm9kZSgpO1xuICAgICAgICB0aGlzLm5vZGVNYW5hZ2VyID0gbmV3IGluTWVtb3J5Tm9kZU1hbmFnZXJfMS5Jbk1lbW9yeU5vZGVNYW5hZ2VyKHRoaXMucm9vdE5vZGUsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCB0aGlzLmNvbnRleHQsIHRoaXMuZXZlbnRTZXJ2aWNlLCB0aGlzLmNvbHVtbkNvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLmNvbnRleHQud2lyZUJlYW4odGhpcy5yb290Tm9kZSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5pc0xhc3RSb3dGb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5nZXRSb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucm93c1RvRGlzcGxheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93c1RvRGlzcGxheS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUuZ2V0Um93Qm91bmRzID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5yb3dzVG9EaXNwbGF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvd05vZGUgPSB0aGlzLnJvd3NUb0Rpc3BsYXlbaW5kZXhdO1xuICAgICAgICBpZiAocm93Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dUb3A6IHJvd05vZGUucm93VG9wLFxuICAgICAgICAgICAgICAgIHJvd0hlaWdodDogcm93Tm9kZS5yb3dIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUub25Sb3dHcm91cE9wZW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFuaW1hdGUgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0FuaW1hdGVSb3dzKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaE1vZGVsKHsgc3RlcDogY29uc3RhbnRzXzEuQ29uc3RhbnRzLlNURVBfTUFQLCBrZWVwUmVuZGVyZWRSb3dzOiB0cnVlLCBhbmltYXRlOiBhbmltYXRlIH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUub25GaWx0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5pbWF0ZSA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzQW5pbWF0ZVJvd3MoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoTW9kZWwoeyBzdGVwOiBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9GSUxURVIsIGtlZXBSZW5kZXJlZFJvd3M6IHRydWUsIGFuaW1hdGU6IGFuaW1hdGUgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5vblNvcnRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3ZSBvbmx5IGFjdCBvbiB0aGUgc29ydCBldmVudCBoZXJlIGlmIHRoZSB1c2VyIGlzIGRvaW5nIGluIGdyaWQgc29ydGluZy5cbiAgICAgICAgLy8gd2UgaWdub3JlIGl0IGlmIHRoZSBzb3J0aW5nIGlzIGhhcHBlbmluZyBvbiB0aGUgc2VydmVyIHNpZGUuXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVNlcnZlclNpZGVTb3J0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5pbWF0ZSA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzQW5pbWF0ZVJvd3MoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoTW9kZWwoeyBzdGVwOiBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9TT1JULCBrZWVwUmVuZGVyZWRSb3dzOiB0cnVlLCBhbmltYXRlOiBhbmltYXRlLCBrZWVwRWRpdGluZ1Jvd3M6IHRydWUgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQ29uc3RhbnRzLlJPV19NT0RFTF9UWVBFX0lOX01FTU9SWTtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLm9uVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5Db250cm9sbGVyLmlzUGl2b3RBY3RpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoTW9kZWwoeyBzdGVwOiBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9QSVZPVCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaE1vZGVsKHsgc3RlcDogY29uc3RhbnRzXzEuQ29uc3RhbnRzLlNURVBfQUdHUkVHQVRFIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5jcmVhdGVDaGFuZ2VQYXRoID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciB1cGRhdGVzLCBpZiB0aGUgcm93IGlzIHVwZGF0ZWQgYXQgYWxsLCB0aGVuIHdlIHJlLWNhbGMgYWxsIHRoZSB2YWx1ZXNcbiAgICAgICAgLy8gaW4gdGhhdCByb3cuIHdlIGNvdWxkIGNvbXBhcmUgZWFjaCB2YWx1ZSB0byBlYWNoIG9sZCB2YWx1ZSwgaG93ZXZlciBpZiB3ZVxuICAgICAgICAvLyBkaWQgdGhpcywgd2Ugd291bGQgYmUgY2FsbGluZyB0aGUgdmFsdWVTZXJ2aWNlIHR3aWNlLCBvbmNlIG9uIHRoZSBvbGQgdmFsdWVcbiAgICAgICAgLy8gYW5kIG9uY2Ugb24gdGhlIG5ldyB2YWx1ZS4gc28gaXQncyBsZXNzIHZhbHVlR2V0dGVyIGNhbGxzIGlmIHdlIGp1c3QgYXNzdW1lXG4gICAgICAgIC8vIGVhY2ggY29sdW1uIGlzIGRpZmZlcmVudC4gdGhhdCB3YXkgdGhlIGNoYW5nZWRQYXRoIGlzIHVzZWQgc28gdGhhdCBvbmx5XG4gICAgICAgIC8vIHRoZSBpbXBhY3RlZCBwYXJlbnQgcm93cyBhcmUgcmVjYWxjdWxhdGVkLCBwYXJlbnRzIHdobydzIGNoaWxkcmVuIGhhdmVcbiAgICAgICAgLy8gbm90IGNoYW5nZWQgYXJlIG5vdCBpbXBhY3RlZC5cbiAgICAgICAgdmFyIHZhbHVlQ29sdW1ucyA9IHRoaXMuY29sdW1uQ29udHJvbGxlci5nZXRWYWx1ZUNvbHVtbnMoKTtcbiAgICAgICAgaWYgKCF2YWx1ZUNvbHVtbnMgfHwgdmFsdWVDb2x1bW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5nZWRQYXRoID0gbmV3IGNoYW5nZWRQYXRoXzEuQ2hhbmdlZFBhdGgoZmFsc2UpO1xuICAgICAgICByZXR1cm4gY2hhbmdlZFBhdGg7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5yZWZyZXNoTW9kZWwgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIC8vIHRoaXMgZ29lcyB0aHJvdWdoIHRoZSBwaXBlbGluZSBvZiBzdGFnZXMuIHdoYXQncyBpbiBteSBoZWFkIGlzIHNpbWlsYXJcbiAgICAgICAgLy8gdG8gdGhlIGRpYWdyYW0gb24gdGhpcyBwYWdlOlxuICAgICAgICAvLyBodHRwOi8vY29tbW9ucy5hcGFjaGUub3JnL3NhbmRib3gvY29tbW9ucy1waXBlbGluZS9waXBlbGluZV9iYXNpY3MuaHRtbFxuICAgICAgICAvLyBob3dldmVyIHdlIHdhbnQgdG8ga2VlcCB0aGUgcmVzdWx0cyBvZiBlYWNoIHN0YWdlLCBoZW5jZSB3ZSBtYW51YWxseSBjYWxsXG4gICAgICAgIC8vIGVhY2ggc3RlcCByYXRoZXIgdGhhbiBoYXZlIHRoZW0gY2hhaW4gZWFjaCBvdGhlci5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gZmFsbHRocm91Z2ggaW4gYmVsb3cgc3dpdGNoIGlzIG9uIHB1cnBvc2UsXG4gICAgICAgIC8vIGVnIGlmIFNURVBfRklMVEVSLCB0aGVuIGFsbCBzdGVwcyBiZWxvdyB0aGlzXG4gICAgICAgIC8vIHN0ZXAgZ2V0IGRvbmVcbiAgICAgICAgLy8gbGV0IHN0YXJ0OiBudW1iZXI7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCc9PT09PT09IHN0YXJ0ID09PT09PT0nKTtcbiAgICAgICAgdmFyIGNoYW5nZWRQYXRoID0gdGhpcy5jcmVhdGVDaGFuZ2VQYXRoKHBhcmFtcy5yb3dOb2RlVHJhbnNhY3Rpb24pO1xuICAgICAgICBzd2l0Y2ggKHBhcmFtcy5zdGVwKSB7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5TVEVQX0VWRVJZVEhJTkc6XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvUm93R3JvdXBpbmcocGFyYW1zLmdyb3VwU3RhdGUsIHBhcmFtcy5yb3dOb2RlVHJhbnNhY3Rpb24sIHBhcmFtcy5yb3dOb2RlT3JkZXIsIGNoYW5nZWRQYXRoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyb3dHcm91cGluZyA9ICcgKyAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydCkpO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9GSUxURVI6XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvRmlsdGVyKCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZmlsdGVyID0gJyArIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5TVEVQX1BJVk9UOlxuICAgICAgICAgICAgICAgIHRoaXMuZG9QaXZvdCgpO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9BR0dSRUdBVEU6Ly8gZGVwZW5kcyBvbiBhZ2cgZmllbGRzXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQWdncmVnYXRlKGNoYW5nZWRQYXRoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhZ2dyZWdhdGlvbiA9ICcgKyAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydCkpO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9TT1JUOlxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb1NvcnQoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzb3J0ID0gJyArIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5TVEVQX01BUDpcbiAgICAgICAgICAgICAgICAvLyBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9Sb3dzVG9EaXNwbGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX01PREVMX1VQREFURUQsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGksXG4gICAgICAgICAgICBhbmltYXRlOiBwYXJhbXMuYW5pbWF0ZSxcbiAgICAgICAgICAgIGtlZXBSZW5kZXJlZFJvd3M6IHBhcmFtcy5rZWVwUmVuZGVyZWRSb3dzLFxuICAgICAgICAgICAgbmV3RGF0YTogcGFyYW1zLm5ld0RhdGEsXG4gICAgICAgICAgICBuZXdQYWdlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuJHNjb3BlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy4kc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd3NNaXNzaW5nO1xuICAgICAgICB2YXIgZG9pbmdMZWdhY3lUcmVlRGF0YSA9IHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldE5vZGVDaGlsZERldGFpbHNGdW5jKCkpO1xuICAgICAgICBpZiAoZG9pbmdMZWdhY3lUcmVlRGF0YSkge1xuICAgICAgICAgICAgcm93c01pc3NpbmcgPSB1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5yb290Tm9kZS5jaGlsZHJlbkFmdGVyR3JvdXApIHx8IHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlckdyb3VwLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvd3NNaXNzaW5nID0gdXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMucm9vdE5vZGUuYWxsTGVhZkNoaWxkcmVuKSB8fCB0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVtcHR5ID0gdXRpbHNfMS5VdGlscy5taXNzaW5nKHRoaXMucm9vdE5vZGUpIHx8IHJvd3NNaXNzaW5nIHx8ICF0aGlzLmNvbHVtbkNvbnRyb2xsZXIuaXNSZWFkeSgpO1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5pc1Jvd3NUb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRoaXMucm93c1RvRGlzcGxheSkgJiYgdGhpcy5yb3dzVG9EaXNwbGF5Lmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5nZXROb2Rlc0luUmFuZ2VGb3JTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZmlyc3RJblJhbmdlLCBsYXN0SW5SYW5nZSkge1xuICAgICAgICAvLyBpZiBsYXN0U2VsZWN0ZWROb2RlIGlzIG1pc3NpbmcsIHdlIHN0YXJ0IGF0IHRoZSBmaXJzdCByb3dcbiAgICAgICAgdmFyIGZpcnN0Um93SGl0ID0gIWxhc3RJblJhbmdlO1xuICAgICAgICB2YXIgbGFzdFJvd0hpdCA9IGZhbHNlO1xuICAgICAgICB2YXIgbGFzdFJvdztcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgZ3JvdXBzU2VsZWN0Q2hpbGRyZW4gPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwU2VsZWN0c0NoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuZm9yRWFjaE5vZGVBZnRlckZpbHRlckFuZFNvcnQoZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgICAgIHZhciBsb29raW5nRm9yTGFzdFJvdyA9IGZpcnN0Um93SGl0ICYmICFsYXN0Um93SGl0O1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBmbGlwIHRoZSBzZWxlY3Qgc3dpdGNoXG4gICAgICAgICAgICBpZiAoIWZpcnN0Um93SGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd05vZGUgPT09IGxhc3RJblJhbmdlIHx8IHJvd05vZGUgPT09IGZpcnN0SW5SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJvd0hpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNraXBUaGlzR3JvdXBOb2RlID0gcm93Tm9kZS5ncm91cCAmJiBncm91cHNTZWxlY3RDaGlsZHJlbjtcbiAgICAgICAgICAgIGlmICghc2tpcFRoaXNHcm91cE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5SYW5nZSA9IGZpcnN0Um93SGl0ICYmICFsYXN0Um93SGl0O1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE9mTGFzdFJvdyA9IHJvd05vZGUuaXNQYXJlbnRPZk5vZGUobGFzdFJvdyk7XG4gICAgICAgICAgICAgICAgaWYgKGluUmFuZ2UgfHwgY2hpbGRPZkxhc3RSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvb2tpbmdGb3JMYXN0Um93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd05vZGUgPT09IGxhc3RJblJhbmdlIHx8IHJvd05vZGUgPT09IGZpcnN0SW5SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0Um93SGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd05vZGUgPT09IGxhc3RJblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Um93ID0gbGFzdEluUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Um93ID0gZmlyc3RJblJhbmdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLnNldERhdGFzb3VyY2UgPSBmdW5jdGlvbiAoZGF0YXNvdXJjZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBzaG91bGQgbmV2ZXIgY2FsbCBzZXREYXRhc291cmNlIG9uIGluTWVtb3J5Um93Q29udHJvbGxlcicpO1xuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUuZ2V0VG9wTGV2ZWxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGUgPyB0aGlzLnJvb3ROb2RlLmNoaWxkcmVuQWZ0ZXJHcm91cCA6IG51bGw7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5nZXRSb290Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGU7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93c1RvRGlzcGxheVtpbmRleF07XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5pc1Jvd1ByZXNlbnQgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzVG9EaXNwbGF5LmluZGV4T2Yocm93Tm9kZSkgPj0gMDtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmdldFZpcnR1YWxSb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdhZy1HcmlkOiByb3dNb2RlbC5nZXRWaXJ0dWFsUm93Q291bnQoKSBpcyBub3QgbG9uZ2VyIGEgZnVuY3Rpb24sIHVzZSByb3dNb2RlbC5nZXRSb3dDb3VudCgpIGluc3RlYWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZUxhc3RSb3coKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmdldFBhZ2VGaXJzdFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5nZXRQYWdlTGFzdFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucm93c1RvRGlzcGxheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93c1RvRGlzcGxheS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmdldFJvd0luZGV4QXRQaXhlbCA9IGZ1bmN0aW9uIChwaXhlbFRvTWF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gYmluYXJ5IHNlYXJjaCBvZiB0cmVlXG4gICAgICAgIC8vIGh0dHA6Ly9vbGkubWUudWsvMjAxMy8wNi8wOC9zZWFyY2hpbmctamF2YXNjcmlwdC1hcnJheXMtd2l0aC1hLWJpbmFyeS1zZWFyY2gvXG4gICAgICAgIHZhciBib3R0b21Qb2ludGVyID0gMDtcbiAgICAgICAgdmFyIHRvcFBvaW50ZXIgPSB0aGlzLnJvd3NUb0Rpc3BsYXkubGVuZ3RoIC0gMTtcbiAgICAgICAgLy8gcXVpY2sgY2hlY2ssIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgYm91bmRzLCB0aGVuIHJldHVybiBsYXN0IHJvd1xuICAgICAgICBpZiAocGl4ZWxUb01hdGNoIDw9IDApIHtcbiAgICAgICAgICAgIC8vIGlmIHBpeGVsIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB6ZXJvLCBpdCdzIGFsd2F5cyB0aGUgZmlyc3Qgcm93XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdE5vZGUgPSB0aGlzLnJvd3NUb0Rpc3BsYXlbdGhpcy5yb3dzVG9EaXNwbGF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdE5vZGUucm93VG9wIDw9IHBpeGVsVG9NYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93c1RvRGlzcGxheS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbWlkUG9pbnRlciA9IE1hdGguZmxvb3IoKGJvdHRvbVBvaW50ZXIgKyB0b3BQb2ludGVyKSAvIDIpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3dOb2RlID0gdGhpcy5yb3dzVG9EaXNwbGF5W21pZFBvaW50ZXJdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSb3dJblBpeGVsKGN1cnJlbnRSb3dOb2RlLCBwaXhlbFRvTWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZFBvaW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Um93Tm9kZS5yb3dUb3AgPCBwaXhlbFRvTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBib3R0b21Qb2ludGVyID0gbWlkUG9pbnRlciArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Um93Tm9kZS5yb3dUb3AgPiBwaXhlbFRvTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0b3BQb2ludGVyID0gbWlkUG9pbnRlciAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmlzUm93SW5QaXhlbCA9IGZ1bmN0aW9uIChyb3dOb2RlLCBwaXhlbFRvTWF0Y2gpIHtcbiAgICAgICAgdmFyIHRvcFBpeGVsID0gcm93Tm9kZS5yb3dUb3A7XG4gICAgICAgIHZhciBib3R0b21QaXhlbCA9IHJvd05vZGUucm93VG9wICsgcm93Tm9kZS5yb3dIZWlnaHQ7XG4gICAgICAgIHZhciBwaXhlbEluUm93ID0gdG9wUGl4ZWwgPD0gcGl4ZWxUb01hdGNoICYmIGJvdHRvbVBpeGVsID4gcGl4ZWxUb01hdGNoO1xuICAgICAgICByZXR1cm4gcGl4ZWxJblJvdztcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmdldEN1cnJlbnRQYWdlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yb3dzVG9EaXNwbGF5ICYmIHRoaXMucm93c1RvRGlzcGxheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFJvdyA9IHRoaXMucm93c1RvRGlzcGxheVt0aGlzLnJvd3NUb0Rpc3BsYXkubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgbGFzdFBpeGVsID0gbGFzdFJvdy5yb3dUb3AgKyBsYXN0Um93LnJvd0hlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBsYXN0UGl4ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUuZm9yRWFjaExlYWZOb2RlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZS5hbGxMZWFmQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAocm93Tm9kZSwgaW5kZXgpIHsgcmV0dXJuIGNhbGxiYWNrKHJvd05vZGUsIGluZGV4KTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmZvckVhY2hOb2RlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmVjdXJzaXZlbHlXYWxrTm9kZXNBbmRDYWxsYmFjayh0aGlzLnJvb3ROb2RlLmNoaWxkcmVuQWZ0ZXJHcm91cCwgY2FsbGJhY2ssIFJlY3Vyc2lvblR5cGUuTm9ybWFsLCAwKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmZvckVhY2hOb2RlQWZ0ZXJGaWx0ZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yZWN1cnNpdmVseVdhbGtOb2Rlc0FuZENhbGxiYWNrKHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlckZpbHRlciwgY2FsbGJhY2ssIFJlY3Vyc2lvblR5cGUuQWZ0ZXJGaWx0ZXIsIDApO1xuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUuZm9yRWFjaE5vZGVBZnRlckZpbHRlckFuZFNvcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yZWN1cnNpdmVseVdhbGtOb2Rlc0FuZENhbGxiYWNrKHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlclNvcnQsIGNhbGxiYWNrLCBSZWN1cnNpb25UeXBlLkFmdGVyRmlsdGVyQW5kU29ydCwgMCk7XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5mb3JFYWNoUGl2b3ROb2RlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmVjdXJzaXZlbHlXYWxrTm9kZXNBbmRDYWxsYmFjayhbdGhpcy5yb290Tm9kZV0sIGNhbGxiYWNrLCBSZWN1cnNpb25UeXBlLlBpdm90Tm9kZXMsIDApO1xuICAgIH07XG4gICAgLy8gaXRlcmF0ZXMgdGhyb3VnaCBlYWNoIGl0ZW0gaW4gbWVtb3J5LCBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgLy8gbm9kZXMgLSB0aGUgcm93Tm9kZXMgdG8gdHJhdmVyc2VcbiAgICAvLyBjYWxsYmFjayAtIHRoZSB1c2VyIHByb3ZpZGVkIGNhbGxiYWNrXG4gICAgLy8gcmVjdXJzaW9uIHR5cGUgLSBuZWVkIHRoaXMgdG8ga25vdyB3aGF0IGNoaWxkIG5vZGVzIHRvIHJlY3Vyc2UsIGVnIGlmIGxvb2tpbmcgYXQgYWxsIG5vZGVzLCBvciBmaWx0ZXJlZCBub3RlcyBldGNcbiAgICAvLyBpbmRleCAtIHdvcmtzIHNpbWlsYXIgdG8gdGhlIGluZGV4IGluIGZvckVhY2ggaW4gamF2YXNjcmlwdHMgYXJyYXkgZnVuY3Rpb25cbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5yZWN1cnNpdmVseVdhbGtOb2Rlc0FuZENhbGxiYWNrID0gZnVuY3Rpb24gKG5vZGVzLCBjYWxsYmFjaywgcmVjdXJzaW9uVHlwZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlLCBpbmRleCsrKTtcbiAgICAgICAgICAgICAgICAvLyBnbyB0byB0aGUgbmV4dCBsZXZlbCBpZiBpdCBpcyBhIGdyb3VwXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIHJlY3Vyc2lvbiB0eXBlLCB3ZSBwaWNrIGEgZGlmZmVyZW5jZSBzZXQgb2YgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVDaGlsZHJlbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZWN1cnNpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlY3Vyc2lvblR5cGUuTm9ybWFsOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW5BZnRlckdyb3VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZWN1cnNpb25UeXBlLkFmdGVyRmlsdGVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW5BZnRlckZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVjdXJzaW9uVHlwZS5BZnRlckZpbHRlckFuZFNvcnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbkFmdGVyU29ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVjdXJzaW9uVHlwZS5QaXZvdE5vZGVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBwaXZvdCwgd2UgZG9uJ3QgZ28gYmVsb3cgbGVhZkdyb3VwIGxldmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVDaGlsZHJlbiA9ICFub2RlLmxlYWZHcm91cCA/IG5vZGUuY2hpbGRyZW5BZnRlclNvcnQgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5yZWN1cnNpdmVseVdhbGtOb2Rlc0FuZENhbGxiYWNrKG5vZGVDaGlsZHJlbiwgY2FsbGJhY2ssIHJlY3Vyc2lvblR5cGUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICAvLyBpdCdzIHBvc3NpYmxlIHRvIHJlY29tcHV0ZSB0aGUgYWdncmVnYXRlIHdpdGhvdXQgZG9pbmcgdGhlIG90aGVyIHBhcnRzXG4gICAgLy8gKyBncmlkQXBpLnJlY29tcHV0ZUFnZ3JlZ2F0ZXMoKVxuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmRvQWdncmVnYXRlID0gZnVuY3Rpb24gKGNoYW5nZWRQYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmFnZ3JlZ2F0aW9uU3RhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWdncmVnYXRpb25TdGFnZS5leGVjdXRlKHsgcm93Tm9kZTogdGhpcy5yb290Tm9kZSwgY2hhbmdlZFBhdGg6IGNoYW5nZWRQYXRoIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyArIGdyaWRBcGkuZXhwYW5kQWxsKClcbiAgICAvLyArIGdyaWRBcGkuY29sbGFwc2VBbGwoKVxuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmV4cGFuZE9yQ29sbGFwc2VBbGwgPSBmdW5jdGlvbiAoZXhwYW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3ROb2RlKSB7XG4gICAgICAgICAgICByZWN1cnNpdmVFeHBhbmRPckNvbGxhcHNlKHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlckdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWN1cnNpdmVFeHBhbmRPckNvbGxhcHNlKHJvd05vZGVzKSB7XG4gICAgICAgICAgICBpZiAoIXJvd05vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dOb2RlLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd05vZGUuZXhwYW5kZWQgPSBleHBhbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZUV4cGFuZE9yQ29sbGFwc2Uocm93Tm9kZS5jaGlsZHJlbkFmdGVyR3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaE1vZGVsKHsgc3RlcDogY29uc3RhbnRzXzEuQ29uc3RhbnRzLlNURVBfTUFQIH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUuZG9Tb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNvcnRTdGFnZS5leGVjdXRlKHsgcm93Tm9kZTogdGhpcy5yb290Tm9kZSB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmRvUm93R3JvdXBpbmcgPSBmdW5jdGlvbiAoZ3JvdXBTdGF0ZSwgcm93Tm9kZVRyYW5zYWN0aW9uLCByb3dOb2RlT3JkZXIsIGNoYW5nZWRQYXRoKSB7XG4gICAgICAgIC8vIGdyb3VwaW5nIGlzIGVudGVycHJpc2Ugb25seSwgc28gaWYgc2VydmljZSBtaXNzaW5nLCBza2lwIHRoZSBzdGVwXG4gICAgICAgIHZhciBkb2luZ0xlZ2FjeVRyZWVEYXRhID0gdXRpbHNfMS5VdGlscy5leGlzdHModGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Tm9kZUNoaWxkRGV0YWlsc0Z1bmMoKSk7XG4gICAgICAgIGlmIChkb2luZ0xlZ2FjeVRyZWVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBTdGFnZSkge1xuICAgICAgICAgICAgaWYgKHJvd05vZGVUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBTdGFnZS5leGVjdXRlKHsgcm93Tm9kZTogdGhpcy5yb290Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcm93Tm9kZVRyYW5zYWN0aW9uOiByb3dOb2RlVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHJvd05vZGVPcmRlcjogcm93Tm9kZU9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkUGF0aDogY2hhbmdlZFBhdGggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBncm91cHMgYXJlIGFib3V0IHRvIGdldCBkaXNwb3NlZCwgc28gbmVlZCB0byBkZXNlbGVjdCBhbnkgdGhhdCBhcmUgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIucmVtb3ZlR3JvdXBzRnJvbVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBTdGFnZS5leGVjdXRlKHsgcm93Tm9kZTogdGhpcy5yb290Tm9kZSB9KTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgb3Blbi9jbG9zZWQgc3RhdGUgb24gZ3JvdXBzXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlR3JvdXBTdGF0ZShncm91cFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0dyb3VwU2VsZWN0c0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIudXBkYXRlR3JvdXBzRnJvbUNoaWxkcmVuU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZS5jaGlsZHJlbkFmdGVyR3JvdXAgPSB0aGlzLnJvb3ROb2RlLmFsbExlYWZDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUucmVzdG9yZUdyb3VwU3RhdGUgPSBmdW5jdGlvbiAoZ3JvdXBTdGF0ZSkge1xuICAgICAgICBpZiAoIWdyb3VwU3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1dGlsc18xLlV0aWxzLnRyYXZlcnNlTm9kZXNXaXRoS2V5KHRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlckdyb3VwLCBmdW5jdGlvbiAobm9kZSwga2V5KSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZ3JvdXAgd2FzIG9wZW4gbGFzdCB0aW1lLCB0aGVuIG9wZW4gaXQgdGhpcyB0aW1lLiBob3dldmVyXG4gICAgICAgICAgICAvLyBpZiB3YXMgbm90IG9wZW4gbGFzdCB0aW1lLCB0aGVuIGRvbid0IHRvdWNoIHRoZSBncm91cCwgc28gdGhlICdncm91cERlZmF1bHRFeHBhbmRlZCdcbiAgICAgICAgICAgIC8vIHNldHRpbmcgd2lsbCB0YWtlIGVmZmVjdC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ3JvdXBTdGF0ZVtrZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBub2RlLmV4cGFuZGVkID0gZ3JvdXBTdGF0ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmRvRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZpbHRlclN0YWdlLmV4ZWN1dGUoeyByb3dOb2RlOiB0aGlzLnJvb3ROb2RlIH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUuZG9QaXZvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGl2b3RTdGFnZSkge1xuICAgICAgICAgICAgdGhpcy5waXZvdFN0YWdlLmV4ZWN1dGUoeyByb3dOb2RlOiB0aGlzLnJvb3ROb2RlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZS5nZXRHcm91cFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucm9vdE5vZGUuY2hpbGRyZW5BZnRlckdyb3VwIHx8ICF0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1JlbWVtYmVyR3JvdXBTdGF0ZVdoZW5OZXdEYXRhKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy50cmF2ZXJzZU5vZGVzV2l0aEtleSh0aGlzLnJvb3ROb2RlLmNoaWxkcmVuQWZ0ZXJHcm91cCwgZnVuY3Rpb24gKG5vZGUsIGtleSkgeyByZXR1cm4gcmVzdWx0W2tleV0gPSBub2RlLmV4cGFuZGVkOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLmdldENvcHlPZk5vZGVzTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWFuYWdlci5nZXRDb3B5T2ZOb2Rlc01hcCgpO1xuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUuZ2V0Um93Tm9kZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWFuYWdlci5nZXRSb3dOb2RlKGlkKTtcbiAgICB9O1xuICAgIC8vIHJvd3M6IHRoZSByb3dzIHRvIHB1dCBpbnRvIHRoZSBtb2RlbFxuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLnNldFJvd0RhdGEgPSBmdW5jdGlvbiAocm93RGF0YSkge1xuICAgICAgICAvLyBubyBuZWVkIHRvIGludmFsaWRhdGUgY2FjaGUsIGFzIHRoZSBjYWNoZSBpcyBzdG9yZWQgb24gdGhlIHJvd05vZGUsXG4gICAgICAgIC8vIHNvIG5ldyByb3dOb2RlcyBtZWFucyB0aGUgY2FjaGUgaXMgd2lwZWQgYW55d2F5LlxuICAgICAgICAvLyByZW1lbWJlciBncm91cCBzdGF0ZSwgc28gd2UgY2FuIGV4cGFuZCBncm91cHMgdGhhdCBzaG91bGQgYmUgZXhwYW5kZWRcbiAgICAgICAgdmFyIGdyb3VwU3RhdGUgPSB0aGlzLmdldEdyb3VwU3RhdGUoKTtcbiAgICAgICAgdGhpcy5ub2RlTWFuYWdlci5zZXRSb3dEYXRhKHJvd0RhdGEpO1xuICAgICAgICAvLyB0aGlzIGV2ZW50IGtpY2tzIG9mZjpcbiAgICAgICAgLy8gLSBjbGVhcnMgc2VsZWN0aW9uXG4gICAgICAgIC8vIC0gdXBkYXRlcyBmaWx0ZXJzXG4gICAgICAgIC8vIC0gc2hvd3MgJ25vIHJvd3MnIG92ZXJsYXkgaWYgbmVlZGVkXG4gICAgICAgIHZhciByb3dEYXRhQ2hhbmdlZEV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1JPV19EQVRBX0NIQU5HRUQsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChyb3dEYXRhQ2hhbmdlZEV2ZW50KTtcbiAgICAgICAgdGhpcy5yZWZyZXNoTW9kZWwoe1xuICAgICAgICAgICAgc3RlcDogY29uc3RhbnRzXzEuQ29uc3RhbnRzLlNURVBfRVZFUllUSElORyxcbiAgICAgICAgICAgIGdyb3VwU3RhdGU6IGdyb3VwU3RhdGUsXG4gICAgICAgICAgICBuZXdEYXRhOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUudXBkYXRlUm93RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhVHJhbiwgcm93Tm9kZU9yZGVyKSB7XG4gICAgICAgIHRoaXMudmFsdWVDYWNoZS5vbkRhdGFDaGFuZ2VkKCk7XG4gICAgICAgIHZhciByb3dOb2RlVHJhbiA9IHRoaXMubm9kZU1hbmFnZXIudXBkYXRlUm93RGF0YShyb3dEYXRhVHJhbiwgcm93Tm9kZU9yZGVyKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoTW9kZWwoe1xuICAgICAgICAgICAgc3RlcDogY29uc3RhbnRzXzEuQ29uc3RhbnRzLlNURVBfRVZFUllUSElORyxcbiAgICAgICAgICAgIHJvd05vZGVUcmFuc2FjdGlvbjogcm93Tm9kZVRyYW4sXG4gICAgICAgICAgICByb3dOb2RlT3JkZXI6IHJvd05vZGVPcmRlcixcbiAgICAgICAgICAgIGtlZXBSZW5kZXJlZFJvd3M6IHRydWUsXG4gICAgICAgICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAga2VlcEVkaXRpbmdSb3dzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudHNfMS5FdmVudHMuRVZFTlRfUk9XX0RBVEFfVVBEQVRFRCxcbiAgICAgICAgICAgIGFwaTogdGhpcy5ncmlkQXBpLFxuICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHJvd05vZGVUcmFuO1xuICAgIH07XG4gICAgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUuZG9Sb3dzVG9EaXNwbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJvd3NUb0Rpc3BsYXkgPSB0aGlzLmZsYXR0ZW5TdGFnZS5leGVjdXRlKHsgcm93Tm9kZTogdGhpcy5yb290Tm9kZSB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLm9uUm93SGVpZ2h0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoTW9kZWwoeyBzdGVwOiBjb25zdGFudHNfMS5Db25zdGFudHMuU1RFUF9NQVAsIGtlZXBSZW5kZXJlZFJvd3M6IHRydWUsIGtlZXBFZGl0aW5nUm93czogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLnJlc2V0Um93SGVpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoTm9kZShmdW5jdGlvbiAocm93Tm9kZSkgeyByZXR1cm4gcm93Tm9kZS5zZXRSb3dIZWlnaHQobnVsbCk7IH0pO1xuICAgICAgICB0aGlzLm9uUm93SGVpZ2h0Q2hhbmdlZCgpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5Db250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQ29udHJvbGxlcilcbiAgICBdLCBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZpbHRlck1hbmFnZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGZpbHRlck1hbmFnZXJfMS5GaWx0ZXJNYW5hZ2VyKVxuICAgIF0sIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLCBcImZpbHRlck1hbmFnZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnJHNjb3BlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUsIFwiJHNjb3BlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3NlbGVjdGlvbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNlbGVjdGlvbkNvbnRyb2xsZXJfMS5TZWxlY3Rpb25Db250cm9sbGVyKVxuICAgIF0sIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLCBcInNlbGVjdGlvbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgndmFsdWVTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB2YWx1ZVNlcnZpY2VfMS5WYWx1ZVNlcnZpY2UpXG4gICAgXSwgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUsIFwidmFsdWVTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3ZhbHVlQ2FjaGUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHZhbHVlQ2FjaGVfMS5WYWx1ZUNhY2hlKVxuICAgIF0sIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLCBcInZhbHVlQ2FjaGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZpbHRlclN0YWdlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUsIFwiZmlsdGVyU3RhZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnc29ydFN0YWdlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUsIFwic29ydFN0YWdlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZsYXR0ZW5TdGFnZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLCBcImZsYXR0ZW5TdGFnZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuT3B0aW9uYWwoJ2dyb3VwU3RhZ2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZSwgXCJncm91cFN0YWdlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5PcHRpb25hbCgnYWdncmVnYXRpb25TdGFnZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEluTWVtb3J5Um93TW9kZWwucHJvdG90eXBlLCBcImFnZ3JlZ2F0aW9uU3RhZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLk9wdGlvbmFsKCdwaXZvdFN0YWdlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSW5NZW1vcnlSb3dNb2RlbC5wcm90b3R5cGUsIFwicGl2b3RTdGFnZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBJbk1lbW9yeVJvd01vZGVsLnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIEluTWVtb3J5Um93TW9kZWwgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ3Jvd01vZGVsJylcbiAgICBdLCBJbk1lbW9yeVJvd01vZGVsKTtcbiAgICByZXR1cm4gSW5NZW1vcnlSb3dNb2RlbDtcbn0oKSk7XG5leHBvcnRzLkluTWVtb3J5Um93TW9kZWwgPSBJbk1lbW9yeVJvd01vZGVsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2luTWVtb3J5L2luTWVtb3J5Um93TW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIHNvcnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vcm93Tm9kZXMvc29ydFNlcnZpY2VcIik7XG52YXIgU29ydFN0YWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTb3J0U3RhZ2UoKSB7XG4gICAgfVxuICAgIFNvcnRTdGFnZS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgLy8gaWYgdGhlIHNvcnRpbmcgaXMgYWxyZWFkeSBkb25lIGJ5IHRoZSBzZXJ2ZXIsIHRoZW4gd2Ugc2hvdWxkIG5vdCBkbyBpdCBoZXJlXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVNlcnZlclNpZGVTb3J0aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFNlcnZpY2Uuc29ydChwYXJhbXMucm93Tm9kZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRTZXJ2aWNlLnNvcnRBY2NvcmRpbmdUb0NvbHVtbnNTdGF0ZShwYXJhbXMucm93Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBTb3J0U3RhZ2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdzb3J0U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgc29ydFNlcnZpY2VfMS5Tb3J0U2VydmljZSlcbiAgICBdLCBTb3J0U3RhZ2UucHJvdG90eXBlLCBcInNvcnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgU29ydFN0YWdlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdzb3J0U3RhZ2UnKVxuICAgIF0sIFNvcnRTdGFnZSk7XG4gICAgcmV0dXJuIFNvcnRTdGFnZTtcbn0oKSk7XG5leHBvcnRzLlNvcnRTdGFnZSA9IFNvcnRTdGFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9pbk1lbW9yeS9zb3J0U3RhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9ldmVudFNlcnZpY2VcIik7XG52YXIgc2VsZWN0aW9uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL3NlbGVjdGlvbkNvbnRyb2xsZXJcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vLi4vZXZlbnRzXCIpO1xudmFyIHNvcnRDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vc29ydENvbnRyb2xsZXJcIik7XG52YXIgZmlsdGVyTWFuYWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL2ZpbHRlci9maWx0ZXJNYW5hZ2VyXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTtcbnZhciBpbmZpbml0ZUNhY2hlXzEgPSByZXF1aXJlKFwiLi9pbmZpbml0ZUNhY2hlXCIpO1xudmFyIGJlYW5TdHViXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9iZWFuU3R1YlwiKTtcbnZhciByb3dOb2RlQ2FjaGVfMSA9IHJlcXVpcmUoXCIuLi9jYWNoZS9yb3dOb2RlQ2FjaGVcIik7XG52YXIgcm93Tm9kZUJsb2NrTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vY2FjaGUvcm93Tm9kZUJsb2NrTG9hZGVyXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkQXBpXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgSW5maW5pdGVSb3dNb2RlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluZmluaXRlUm93TW9kZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5maW5pdGVSb3dNb2RlbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5nZXRSb3dCb3VuZHMgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvd0hlaWdodDogdGhpcy5yb3dIZWlnaHQsXG4gICAgICAgICAgICByb3dUb3A6IHRoaXMucm93SGVpZ2h0ICogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNSb3dNb2RlbEluZmluaXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0hlaWdodCA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldFJvd0hlaWdodEFzTnVtYmVyKCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5zZXREYXRhc291cmNlKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldERhdGFzb3VyY2UoKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveUZ1bmMoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGVzdHJveUNhY2hlKCk7IH0pO1xuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuaXNMYXN0Um93Rm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZmluaXRlQ2FjaGUgPyB0aGlzLmluZmluaXRlQ2FjaGUuaXNNYXhSb3dGb3VuZCgpIDogZmFsc2U7XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9GSUxURVJfQ0hBTkdFRCwgdGhpcy5vbkZpbHRlckNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfU09SVF9DSEFOR0VELCB0aGlzLm9uU29ydENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5vbkZpbHRlckNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0VuYWJsZVNlcnZlclNpZGVGaWx0ZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5vblNvcnRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNFbmFibGVTZXJ2ZXJTaWRlU29ydGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLkNvbnN0YW50cy5ST1dfTU9ERUxfVFlQRV9JTkZJTklURTtcbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLnNldERhdGFzb3VyY2UgPSBmdW5jdGlvbiAoZGF0YXNvdXJjZSkge1xuICAgICAgICB0aGlzLmRhdGFzb3VyY2UgPSBkYXRhc291cmNlO1xuICAgICAgICAvLyBvbmx5IHJlc2V0IGlmIHdlIGhhdmUgYSB2YWxpZCBkYXRhc291cmNlIHRvIHdvcmtpbmcgd2l0aFxuICAgICAgICBpZiAoZGF0YXNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0ZvckRlcHJlY2F0ZWQoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuY2hlY2tGb3JEZXByZWNhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZHMgPSB0aGlzLmRhdGFzb3VyY2U7XG4gICAgICAgIC8vIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBsb2FkcyB3ZSBhcmUgYWxsb3dlZCB0byB0aGUgc2VydmVyXG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhkcy5tYXhDb25jdXJyZW50UmVxdWVzdHMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBzaW5jZSB2ZXJzaW9uIDUuMS54LCBtYXhDb25jdXJyZW50UmVxdWVzdHMgaXMgcmVwbGFjZWQgd2l0aCBncmlkIHByb3BlcnR5IG1heENvbmN1cnJlbnREYXRhc291cmNlUmVxdWVzdHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbHNfMS5VdGlscy5leGlzdHMoZHMubWF4UGFnZXNJbkNhY2hlKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogc2luY2UgdmVyc2lvbiA1LjEueCwgbWF4UGFnZXNJbkNhY2hlIGlzIHJlcGxhY2VkIHdpdGggZ3JpZCBwcm9wZXJ0eSBtYXhQYWdlc0luUGFnaW5hdGlvbkNhY2hlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKGRzLm92ZXJmbG93U2l6ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FnLUdyaWQ6IHNpbmNlIHZlcnNpb24gNS4xLngsIG92ZXJmbG93U2l6ZSBpcyByZXBsYWNlZCB3aXRoIGdyaWQgcHJvcGVydHkgcGFnaW5hdGlvbk92ZXJmbG93U2l6ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyhkcy5ibG9ja1NpemUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBzaW5jZSB2ZXJzaW9uIDUuMS54LCBwYWdlU2l6ZS9ibG9ja1NpemUgaXMgcmVwbGFjZWQgd2l0aCBncmlkIHByb3BlcnR5IGluZmluaXRlUGFnZVNpemUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMubWlzc2luZyh0aGlzLmluZmluaXRlQ2FjaGUpO1xuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuaXNSb3dzVG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsc18xLlV0aWxzLmV4aXN0cyh0aGlzLmluZmluaXRlQ2FjaGUpO1xuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuZ2V0Tm9kZXNJblJhbmdlRm9yU2VsZWN0aW9uID0gZnVuY3Rpb24gKGZpcnN0SW5SYW5nZSwgbGFzdEluUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5maW5pdGVDYWNoZS5nZXRSb3dOb2Rlc0luUmFuZ2UoZmlyc3RJblJhbmdlLCBsYXN0SW5SYW5nZSk7XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIHJldHVybiBoZXJlLCBhcyB0aGUgdXNlciBjb3VsZCBiZSBzZXR0aW5nIGZpbHRlciBvciBzb3J0IGJlZm9yZVxuICAgICAgICAvLyBkYXRhLXNvdXJjZSBpcyBzZXRcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyh0aGlzLmRhdGFzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdXNlciBpcyBwcm92aWRpbmcgaWQncywgdGhlbiB0aGlzIG1lYW5zIHdlIGNhbiBrZWVwIHRoZSBzZWxlY3Rpb24gYmV0d2VlbiBkYXRzb3VyY2UgaGl0cyxcbiAgICAgICAgLy8gYXMgdGhlIHJvd3Mgd2lsbCBrZWVwIHRoZWlyIHVuaXF1ZSBpZCdzIGV2ZW4gaWYsIGZvciBleGFtcGxlLCBzZXJ2ZXIgc2lkZSBzb3J0aW5nIG9yIGZpbHRlcmluZ1xuICAgICAgICAvLyBpcyBkb25lLlxuICAgICAgICB2YXIgdXNlckdlbmVyYXRpbmdJZHMgPSB1dGlsc18xLlV0aWxzLmV4aXN0cyh0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRSb3dOb2RlSWRGdW5jKCkpO1xuICAgICAgICBpZiAoIXVzZXJHZW5lcmF0aW5nSWRzKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5jcmVhdGVNb2RlbFVwZGF0ZWRFdmVudCgpO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLmNyZWF0ZU1vZGVsVXBkYXRlZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX01PREVMX1VQREFURUQsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGksXG4gICAgICAgICAgICAvLyBub3Qgc3VyZSBpZiB0aGVzZSBzaG91bGQgYWxsIGJlIGZhbHNlIC0gbm90aWNlZCBpZiBhZnRlciBpbXBsZW1lbnRpbmcsXG4gICAgICAgICAgICAvLyBtYXliZSB0aGV5IHNob3VsZCBiZSB0cnVlP1xuICAgICAgICAgICAgbmV3UGFnZTogZmFsc2UsXG4gICAgICAgICAgICBuZXdEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBSZW5kZXJlZFJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgYW5pbWF0ZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLnJlc2V0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIG5vdCBmaXJzdCB0aW1lIGNyZWF0aW5nIGEgY2FjaGUsIG5lZWQgdG8gZGVzdHJveSB0aGUgb2xkIG9uZVxuICAgICAgICB0aGlzLmRlc3Ryb3lDYWNoZSgpO1xuICAgICAgICB2YXIgbWF4Q29uY3VycmVudFJlcXVlc3RzID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TWF4Q29uY3VycmVudERhdGFzb3VyY2VSZXF1ZXN0cygpO1xuICAgICAgICAvLyB0aGVyZSBpcyBhIGJpLWRpcmVjdGlvbmFsIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgbG9hZGVyIGFuZCB0aGUgY2FjaGUsXG4gICAgICAgIC8vIHNvIHdlIGNyZWF0ZSBsb2FkZXIgaGVyZSwgYW5kIHRoZW4gcGFzcyBkZXBlbmRlbmNpZXMgaW4gc2V0RGVwZW5kZW5jaWVzKCkgbWV0aG9kIGxhdGVyXG4gICAgICAgIHRoaXMucm93Tm9kZUJsb2NrTG9hZGVyID0gbmV3IHJvd05vZGVCbG9ja0xvYWRlcl8xLlJvd05vZGVCbG9ja0xvYWRlcihtYXhDb25jdXJyZW50UmVxdWVzdHMpO1xuICAgICAgICB0aGlzLmNvbnRleHQud2lyZUJlYW4odGhpcy5yb3dOb2RlQmxvY2tMb2FkZXIpO1xuICAgICAgICB2YXIgY2FjaGVTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIC8vIHRoZSB1c2VyIHByb3ZpZGVkIGRhdGFzb3VyY2VcbiAgICAgICAgICAgIGRhdGFzb3VyY2U6IHRoaXMuZGF0YXNvdXJjZSxcbiAgICAgICAgICAgIC8vIHNvcnQgYW5kIGZpbHRlciBtb2RlbFxuICAgICAgICAgICAgZmlsdGVyTW9kZWw6IHRoaXMuZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJNb2RlbCgpLFxuICAgICAgICAgICAgc29ydE1vZGVsOiB0aGlzLnNvcnRDb250cm9sbGVyLmdldFNvcnRNb2RlbCgpLFxuICAgICAgICAgICAgcm93Tm9kZUJsb2NrTG9hZGVyOiB0aGlzLnJvd05vZGVCbG9ja0xvYWRlcixcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgLSB0aGlzIHdheSB3ZSB0YWtlIGEgc25hcHNob3Qgb2YgdGhlbSwgc28gaWYgdXNlciBjaGFuZ2VzIGFueSwgdGhleSB3aWxsIGJlXG4gICAgICAgICAgICAvLyB1c2VkIG5leHQgdGltZSB3ZSBjcmVhdGUgYSBuZXcgY2FjaGUsIHdoaWNoIGlzIGdlbmVyYWxseSBhZnRlciBhIGZpbHRlciBvciBzb3J0IGNoYW5nZSxcbiAgICAgICAgICAgIC8vIG9yIGEgbmV3IGRhdGFzb3VyY2UgaXMgc2V0XG4gICAgICAgICAgICBtYXhDb25jdXJyZW50UmVxdWVzdHM6IG1heENvbmN1cnJlbnRSZXF1ZXN0cyxcbiAgICAgICAgICAgIG92ZXJmbG93U2l6ZTogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q2FjaGVPdmVyZmxvd1NpemUoKSxcbiAgICAgICAgICAgIGluaXRpYWxSb3dDb3VudDogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0SW5maW5pdGVJbml0aWFsUm93Q291bnQoKSxcbiAgICAgICAgICAgIG1heEJsb2Nrc0luQ2FjaGU6IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldE1heEJsb2Nrc0luQ2FjaGUoKSxcbiAgICAgICAgICAgIGJsb2NrU2l6ZTogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q2FjaGVCbG9ja1NpemUoKSxcbiAgICAgICAgICAgIHJvd0hlaWdodDogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Um93SGVpZ2h0QXNOdW1iZXIoKSxcbiAgICAgICAgICAgIC8vIHRoZSBjYWNoZSBjb3VsZCBjcmVhdGUgdGhpcywgaG93ZXZlciBpdCBpcyBhbHNvIHVzZWQgYnkgdGhlIHBhZ2VzLCBzbyBoYW5keSB0byBjcmVhdGUgaXRcbiAgICAgICAgICAgIC8vIGhlcmUgYXMgdGhlIHNldHRpbmdzIGFyZSBhbHNvIHBhc3NlZCB0byB0aGUgcGFnZXNcbiAgICAgICAgICAgIGxhc3RBY2Nlc3NlZFNlcXVlbmNlOiBuZXcgdXRpbHNfMS5OdW1iZXJTZXF1ZW5jZSgpXG4gICAgICAgIH07XG4gICAgICAgIC8vIHNldCBkZWZhdWx0c1xuICAgICAgICBpZiAoIShjYWNoZVNldHRpbmdzLm1heENvbmN1cnJlbnRSZXF1ZXN0cyA+PSAxKSkge1xuICAgICAgICAgICAgY2FjaGVTZXR0aW5ncy5tYXhDb25jdXJyZW50UmVxdWVzdHMgPSAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZ2Ugc2l6ZSBuZWVkcyB0byBiZSAxIG9yIGdyZWF0ZXIuIGhhdmluZyBpdCBhdCAxIHdvdWxkIGJlIHNpbGx5LCBhcyB5b3Ugd291bGQgYmUgaGl0dGluZyB0aGVcbiAgICAgICAgLy8gc2VydmVyIGZvciBvbmUgcGFnZSBhdCBhIHRpbWUuIHNvIHRoZSBkZWZhdWx0IGlmIG5vdCBzcGVjaWZpZWQgaXMgMTAwLlxuICAgICAgICBpZiAoIShjYWNoZVNldHRpbmdzLmJsb2NrU2l6ZSA+PSAxKSkge1xuICAgICAgICAgICAgY2FjaGVTZXR0aW5ncy5ibG9ja1NpemUgPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdXNlciBkb2Vzbid0IGdpdmUgaW5pdGlhbCByb3dzIHRvIGRpc3BsYXksIHdlIGFzc3VtZSB6ZXJvXG4gICAgICAgIGlmICghKGNhY2hlU2V0dGluZ3MuaW5pdGlhbFJvd0NvdW50ID49IDEpKSB7XG4gICAgICAgICAgICBjYWNoZVNldHRpbmdzLmluaXRpYWxSb3dDb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdXNlciBkb2Vzbid0IHByb3ZpZGUgb3ZlcmZsb3csIHdlIHVzZSBkZWZhdWx0IG92ZXJmbG93IG9mIDEsIHNvIHVzZXIgY2FuIHNjcm9sbCBwYXN0XG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHBhZ2UgYW5kIHJlcXVlc3QgZmlyc3Qgcm93IG9mIG5leHQgcGFnZVxuICAgICAgICBpZiAoIShjYWNoZVNldHRpbmdzLm92ZXJmbG93U2l6ZSA+PSAxKSkge1xuICAgICAgICAgICAgY2FjaGVTZXR0aW5ncy5vdmVyZmxvd1NpemUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5maW5pdGVDYWNoZSA9IG5ldyBpbmZpbml0ZUNhY2hlXzEuSW5maW5pdGVDYWNoZShjYWNoZVNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LndpcmVCZWFuKHRoaXMuaW5maW5pdGVDYWNoZSk7XG4gICAgICAgIHRoaXMuaW5maW5pdGVDYWNoZS5hZGRFdmVudExpc3RlbmVyKHJvd05vZGVDYWNoZV8xLlJvd05vZGVDYWNoZS5FVkVOVF9DQUNIRV9VUERBVEVELCB0aGlzLm9uQ2FjaGVVcGRhdGVkLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuZGVzdHJveUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbmZpbml0ZUNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmluZmluaXRlQ2FjaGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbmZpbml0ZUNhY2hlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb3dOb2RlQmxvY2tMb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucm93Tm9kZUJsb2NrTG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucm93Tm9kZUJsb2NrTG9hZGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUub25DYWNoZVVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuY3JlYXRlTW9kZWxVcGRhdGVkRXZlbnQoKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiAocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5maW5pdGVDYWNoZSA/IHRoaXMuaW5maW5pdGVDYWNoZS5nZXRSb3cocm93SW5kZXgpIDogbnVsbDtcbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLmZvckVhY2hOb2RlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmluZmluaXRlQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5maW5pdGVDYWNoZS5mb3JFYWNoTm9kZURlZXAoY2FsbGJhY2ssIG5ldyB1dGlsc18xLk51bWJlclNlcXVlbmNlKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5nZXRDdXJyZW50UGFnZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um93Q291bnQoKSAqIHRoaXMucm93SGVpZ2h0O1xuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuZ2V0Um93SW5kZXhBdFBpeGVsID0gZnVuY3Rpb24gKHBpeGVsKSB7XG4gICAgICAgIGlmICh0aGlzLnJvd0hlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIHJvd0luZGV4Rm9yUGl4ZWwgPSBNYXRoLmZsb29yKHBpeGVsIC8gdGhpcy5yb3dIZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHJvd0luZGV4Rm9yUGl4ZWwgPiB0aGlzLmdldFBhZ2VMYXN0Um93KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlTGFzdFJvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd0luZGV4Rm9yUGl4ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuZ2V0UGFnZUZpcnN0Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLmdldFBhZ2VMYXN0Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZpbml0ZUNhY2hlID8gdGhpcy5pbmZpbml0ZUNhY2hlLmdldFZpcnR1YWxSb3dDb3VudCgpIC0gMSA6IDA7XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5nZXRSb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5maW5pdGVDYWNoZSA/IHRoaXMuaW5maW5pdGVDYWNoZS5nZXRWaXJ0dWFsUm93Q291bnQoKSA6IDA7XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS51cGRhdGVSb3dEYXRhID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLmV4aXN0cyh0cmFuc2FjdGlvbi5yZW1vdmUpIHx8IHV0aWxzXzEuVXRpbHMuZXhpc3RzKHRyYW5zYWN0aW9uLnVwZGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogdXBkYXRlUm93RGF0YSBmb3IgSW5maW5pdGVSb3dNb2RlbCBkb2VzIG5vdCBzdXBwb3J0IHJlbW92ZSBvciB1cGRhdGUsIG9ubHkgYWRkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMubWlzc2luZyh0cmFuc2FjdGlvbi5hZGRJbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogdXBkYXRlUm93RGF0YSBmb3IgSW5maW5pdGVSb3dNb2RlbCByZXF1aXJlcyBhZGQgYW5kIGFkZEluZGV4IHRvIGJlIHNldCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZmluaXRlQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5maW5pdGVDYWNoZS5pbnNlcnRJdGVtc0F0SW5kZXgodHJhbnNhY3Rpb24uYWRkSW5kZXgsIHRyYW5zYWN0aW9uLmFkZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLmlzUm93UHJlc2VudCA9IGZ1bmN0aW9uIChyb3dOb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLnJlZnJlc2hDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5maW5pdGVDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5pbmZpbml0ZUNhY2hlLnJlZnJlc2hDYWNoZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5wdXJnZUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbmZpbml0ZUNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmluZmluaXRlQ2FjaGUucHVyZ2VDYWNoZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5nZXRWaXJ0dWFsUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZmluaXRlQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZmluaXRlQ2FjaGUuZ2V0VmlydHVhbFJvd0NvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUuaXNNYXhSb3dGb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5maW5pdGVDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5maW5pdGVDYWNoZS5pc01heFJvd0ZvdW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLnNldFZpcnR1YWxSb3dDb3VudCA9IGZ1bmN0aW9uIChyb3dDb3VudCwgbWF4Um93Rm91bmQpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5maW5pdGVDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5pbmZpbml0ZUNhY2hlLnNldFZpcnR1YWxSb3dDb3VudChyb3dDb3VudCwgbWF4Um93Rm91bmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZS5nZXRCbG9ja1N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yb3dOb2RlQmxvY2tMb2FkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd05vZGVCbG9ja0xvYWRlci5nZXRCbG9ja1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdmaWx0ZXJNYW5hZ2VyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBmaWx0ZXJNYW5hZ2VyXzEuRmlsdGVyTWFuYWdlcilcbiAgICBdLCBJbmZpbml0ZVJvd01vZGVsLnByb3RvdHlwZSwgXCJmaWx0ZXJNYW5hZ2VyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3NvcnRDb250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBzb3J0Q29udHJvbGxlcl8xLlNvcnRDb250cm9sbGVyKVxuICAgIF0sIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLCBcInNvcnRDb250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3NlbGVjdGlvbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNlbGVjdGlvbkNvbnRyb2xsZXJfMS5TZWxlY3Rpb25Db250cm9sbGVyKVxuICAgIF0sIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLCBcInNlbGVjdGlvbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZEFwaScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZEFwaV8xLkdyaWRBcGkpXG4gICAgXSwgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUsIFwiZ3JpZEFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb2x1bW5BcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5BcGkpXG4gICAgXSwgSW5maW5pdGVSb3dNb2RlbC5wcm90b3R5cGUsIFwiY29sdW1uQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5QcmVEZXN0cm95LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEluZmluaXRlUm93TW9kZWwucHJvdG90eXBlLCBcImRlc3Ryb3lcIiwgbnVsbCk7XG4gICAgSW5maW5pdGVSb3dNb2RlbCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbigncm93TW9kZWwnKVxuICAgIF0sIEluZmluaXRlUm93TW9kZWwpO1xuICAgIHJldHVybiBJbmZpbml0ZVJvd01vZGVsO1xufShiZWFuU3R1Yl8xLkJlYW5TdHViKSk7XG5leHBvcnRzLkluZmluaXRlUm93TW9kZWwgPSBJbmZpbml0ZVJvd01vZGVsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2luZmluaXRlL2luZmluaXRlUm93TW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZmlsdGVyTWFuYWdlcl8xID0gcmVxdWlyZShcIi4uL2ZpbHRlci9maWx0ZXJNYW5hZ2VyXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBGaWx0ZXJTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXJTZXJ2aWNlKCkge1xuICAgIH1cbiAgICBGaWx0ZXJTZXJ2aWNlLnByb3RvdHlwZS5wb3N0Q29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRvaW5nVHJlZURhdGEgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc1RyZWVEYXRhKCk7XG4gICAgfTtcbiAgICBGaWx0ZXJTZXJ2aWNlLnByb3RvdHlwZS5maWx0ZXJBY2NvcmRpbmdUb0NvbHVtblN0YXRlID0gZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgdmFyIGZpbHRlckFjdGl2ZSA9IHRoaXMuZmlsdGVyTWFuYWdlci5pc0FueUZpbHRlclByZXNlbnQoKTtcbiAgICAgICAgdGhpcy5maWx0ZXIocm93Tm9kZSwgZmlsdGVyQWN0aXZlKTtcbiAgICB9O1xuICAgIEZpbHRlclNlcnZpY2UucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChyb3dOb2RlLCBmaWx0ZXJBY3RpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZ2V0IGFsbCBjaGlsZHJlbiB0aGF0IGFyZSBncm91cHMgdG8gYWxzbyBmaWx0ZXJcbiAgICAgICAgaWYgKHJvd05vZGUuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgcm93Tm9kZS5jaGlsZHJlbkFmdGVyR3JvdXAuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMuZmlsdGVyKG5vZGUsIGZpbHRlckFjdGl2ZSk7IH0pO1xuICAgICAgICAgICAgLy8gcmVzdWx0IG9mIGZpbHRlciBmb3IgdGhpcyBub2RlXG4gICAgICAgICAgICBpZiAoZmlsdGVyQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5jaGlsZHJlbkFmdGVyRmlsdGVyID0gcm93Tm9kZS5jaGlsZHJlbkFmdGVyR3JvdXAuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBncm91cCBpcyBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IGlmIGl0IGhhcyBhbnkgY2hpbGRyZW4gb2YgaXQncyBvd24uXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5IHRoaXMgc3RhZ2UsIHRoZSBjaGlsZCBncm91cHMgYXJlIGFscmVhZHkgZmlsdGVyZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhc3NCZWNhdXNlQ2hpbGRyZW4gPSBjaGlsZE5vZGUuY2hpbGRyZW5BZnRlckZpbHRlciAmJiBjaGlsZE5vZGUuY2hpbGRyZW5BZnRlckZpbHRlci5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIGxlYWYgbGV2ZWwgbm9kZXMgYW5kIHRyZWUgZGF0YSBub2RlcyBoYXZlIGRhdGEuIHRoZXNlIGdldCBhZGRlZCBpZlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZGF0YSBwYXNzZXMgdGhlIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFzc0JlY2F1c2VEYXRhUGFzc2VzID0gY2hpbGROb2RlLmRhdGEgJiYgX3RoaXMuZmlsdGVyTWFuYWdlci5kb2VzUm93UGFzc0ZpbHRlcihjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RlIC0gdHJlZSBkYXRhIG5vZGVzIHBhc3MgZWl0aGVyIGlmIGEpIHRoZXkgcGFzcyB0aGVtc2VsdmVzIG9yIGIpIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgcGFzc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFzc0JlY2F1c2VDaGlsZHJlbiB8fCBwYXNzQmVjYXVzZURhdGFQYXNzZXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgZmlsdGVyaW5nLCB0aGUgcmVzdWx0IGlzIHRoZSBvcmlnaW5hbCBsaXN0XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5jaGlsZHJlbkFmdGVyRmlsdGVyID0gcm93Tm9kZS5jaGlsZHJlbkFmdGVyR3JvdXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEFsbENoaWxkcmVuQ291bnQocm93Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dOb2RlLmNoaWxkcmVuQWZ0ZXJGaWx0ZXIgPSByb3dOb2RlLmNoaWxkcmVuQWZ0ZXJHcm91cDtcbiAgICAgICAgICAgIHJvd05vZGUuc2V0QWxsQ2hpbGRyZW5Db3VudChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsdGVyU2VydmljZS5wcm90b3R5cGUuc2V0QWxsQ2hpbGRyZW5Db3VudFRyZWVEYXRhID0gZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgLy8gZm9yIHRyZWUgZGF0YSwgd2UgaW5jbHVkZSBhbGwgY2hpbGRyZW4sIGdyb3VwcyBhbmQgbGVhZnNcbiAgICAgICAgdmFyIGFsbENoaWxkcmVuQ291bnQgPSAwO1xuICAgICAgICByb3dOb2RlLmNoaWxkcmVuQWZ0ZXJGaWx0ZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgY2hpbGQgaXRzZWxmXG4gICAgICAgICAgICBhbGxDaGlsZHJlbkNvdW50Kys7XG4gICAgICAgICAgICAvLyBpbmNsdWRlIGNoaWxkcmVuIG9mIGNoaWxkcmVuXG4gICAgICAgICAgICBhbGxDaGlsZHJlbkNvdW50ICs9IGNoaWxkLmFsbENoaWxkcmVuQ291bnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByb3dOb2RlLnNldEFsbENoaWxkcmVuQ291bnQoYWxsQ2hpbGRyZW5Db3VudCk7XG4gICAgfTtcbiAgICBGaWx0ZXJTZXJ2aWNlLnByb3RvdHlwZS5zZXRBbGxDaGlsZHJlbkNvdW50R3JpZEdyb3VwaW5nID0gZnVuY3Rpb24gKHJvd05vZGUpIHtcbiAgICAgICAgLy8gZm9yIGdyaWQgZGF0YSwgd2Ugb25seSBjb3VudCB0aGUgbGVhZnNcbiAgICAgICAgdmFyIGFsbENoaWxkcmVuQ291bnQgPSAwO1xuICAgICAgICByb3dOb2RlLmNoaWxkcmVuQWZ0ZXJGaWx0ZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5ncm91cCkge1xuICAgICAgICAgICAgICAgIGFsbENoaWxkcmVuQ291bnQgKz0gY2hpbGQuYWxsQ2hpbGRyZW5Db3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsbENoaWxkcmVuQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJvd05vZGUuc2V0QWxsQ2hpbGRyZW5Db3VudChhbGxDaGlsZHJlbkNvdW50KTtcbiAgICB9O1xuICAgIEZpbHRlclNlcnZpY2UucHJvdG90eXBlLnNldEFsbENoaWxkcmVuQ291bnQgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5kb2luZ1RyZWVEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFsbENoaWxkcmVuQ291bnRUcmVlRGF0YShyb3dOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWxsQ2hpbGRyZW5Db3VudEdyaWRHcm91cGluZyhyb3dOb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2ZpbHRlck1hbmFnZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGZpbHRlck1hbmFnZXJfMS5GaWx0ZXJNYW5hZ2VyKVxuICAgIF0sIEZpbHRlclNlcnZpY2UucHJvdG90eXBlLCBcImZpbHRlck1hbmFnZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgRmlsdGVyU2VydmljZS5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEZpbHRlclNlcnZpY2UucHJvdG90eXBlLCBcInBvc3RDb25zdHJ1Y3RcIiwgbnVsbCk7XG4gICAgRmlsdGVyU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbihcImZpbHRlclNlcnZpY2VcIilcbiAgICBdLCBGaWx0ZXJTZXJ2aWNlKTtcbiAgICByZXR1cm4gRmlsdGVyU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkZpbHRlclNlcnZpY2UgPSBGaWx0ZXJTZXJ2aWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93Tm9kZXMvZmlsdGVyU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBzb3J0Q29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL3NvcnRDb250cm9sbGVyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgdmFsdWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVTZXJ2aWNlL3ZhbHVlU2VydmljZVwiKTtcbnZhciBncmlkT3B0aW9uc1dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmlkT3B0aW9uc1dyYXBwZXJcIik7XG52YXIgY29sdW1uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL2NvbHVtbkNvbnRyb2xsZXIvY29sdW1uQ29udHJvbGxlclwiKTtcbnZhciBTb3J0U2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU29ydFNlcnZpY2UoKSB7XG4gICAgfVxuICAgIFNvcnRTZXJ2aWNlLnByb3RvdHlwZS5zb3J0QWNjb3JkaW5nVG9Db2x1bW5zU3RhdGUgPSBmdW5jdGlvbiAocm93Tm9kZSkge1xuICAgICAgICB2YXIgc29ydE9wdGlvbnMgPSB0aGlzLnNvcnRDb250cm9sbGVyLmdldFNvcnRGb3JSb3dDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMuc29ydChyb3dOb2RlLCBzb3J0T3B0aW9ucyk7XG4gICAgfTtcbiAgICBTb3J0U2VydmljZS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChyb3dOb2RlLCBzb3J0T3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByb3dOb2RlLmNoaWxkcmVuQWZ0ZXJTb3J0ID0gcm93Tm9kZS5jaGlsZHJlbkFmdGVyRmlsdGVyLnNsaWNlKDApO1xuICAgICAgICAvLyB3ZSBjbGVhciBvdXQgdGhlICdwdWxsIGRvd24gb3BlbiBwYXJlbnRzJyBmaXJzdCwgYXMgdGhlIHZhbHVlcyBtaXggdXAgdGhlIHNvcnRpbmdcbiAgICAgICAgdGhpcy5wdWxsRG93bkRhdGFGb3JIaWRlT3BlblBhcmVudHMocm93Tm9kZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBzb3J0QWN0aXZlID0gdXRpbHNfMS5fLmV4aXN0cyhzb3J0T3B0aW9ucykgJiYgc29ydE9wdGlvbnMubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKHNvcnRBY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFJFIGh0dHBzOi8vYWctZ3JpZC5hdGxhc3NpYW4ubmV0L2Jyb3dzZS9BRy00NDRcbiAgICAgICAgICAgIC8vSmF2YXNjcmlwdCBzb3J0IGlzIG5vbiBkZXRlcm1pbmlzdGljIHdoZW4gYWxsIHRoZSBhcnJheSBpdGVtcyBhcmUgZXF1YWxzXG4gICAgICAgICAgICAvL2llIENvbXBhcmF0b3IgYWx3YXlzIHJldHVybnMgMCwgc28gaWYgeW91IHdhbnQgdG8gZW5zdXJlIHRoZSBhcnJheSBrZWVwcyBpdHNcbiAgICAgICAgICAgIC8vb3JkZXIsIHRoZW4geW91IG5lZWQgdG8gYWRkIGFuIGFkZGl0aW9uYWwgc29ydGluZyBjb25kaXRpb24gbWFudWFsbHksIGluIHRoaXNcbiAgICAgICAgICAgIC8vY2FzZSB3ZSBhcmUgZ29pbmcgdG8gaW5zcGVjdCB0aGUgb3JpZ2luYWwgYXJyYXkgcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBzb3J0ZWRSb3dOb2RlcyA9IHJvd05vZGUuY2hpbGRyZW5BZnRlclNvcnQubWFwKGZ1bmN0aW9uIChpdCwgcG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY3VycmVudFBvczogcG9zLCByb3dOb2RlOiBpdCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb3J0ZWRSb3dOb2Rlcy5zb3J0KHRoaXMuY29tcGFyZVJvd05vZGVzLmJpbmQodGhpcywgc29ydE9wdGlvbnMpKTtcbiAgICAgICAgICAgIHJvd05vZGUuY2hpbGRyZW5BZnRlclNvcnQgPSBzb3J0ZWRSb3dOb2Rlcy5tYXAoZnVuY3Rpb24gKHNvcnRlZCkgeyByZXR1cm4gc29ydGVkLnJvd05vZGU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRJbmRleGVzKHJvd05vZGUpO1xuICAgICAgICB0aGlzLnB1bGxEb3duRGF0YUZvckhpZGVPcGVuUGFyZW50cyhyb3dOb2RlLCBmYWxzZSk7XG4gICAgICAgIC8vIHNvcnQgYW55IGdyb3VwcyByZWN1cnNpdmVseVxuICAgICAgICByb3dOb2RlLmNoaWxkcmVuQWZ0ZXJGaWx0ZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc29ydChjaGlsZCwgc29ydE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvcnRTZXJ2aWNlLnByb3RvdHlwZS5jb21wYXJlUm93Tm9kZXMgPSBmdW5jdGlvbiAoc29ydE9wdGlvbnMsIHNvcnRlZE5vZGVBLCBzb3J0ZWROb2RlQikge1xuICAgICAgICB2YXIgbm9kZUEgPSBzb3J0ZWROb2RlQS5yb3dOb2RlO1xuICAgICAgICB2YXIgbm9kZUIgPSBzb3J0ZWROb2RlQi5yb3dOb2RlO1xuICAgICAgICAvLyBJdGVyYXRlIGNvbHVtbnMsIHJldHVybiB0aGUgZmlyc3QgdGhhdCBkb2Vzbid0IG1hdGNoXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3J0T3B0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHNvcnRPcHRpb24gPSBzb3J0T3B0aW9uc1tpXTtcbiAgICAgICAgICAgIC8vIGxldCBjb21wYXJlZCA9IGNvbXBhcmUobm9kZUEsIG5vZGVCLCBzb3J0T3B0aW9uLmNvbHVtbiwgc29ydE9wdGlvbi5pbnZlcnRlciA9PT0gLTEpO1xuICAgICAgICAgICAgdmFyIGlzSW52ZXJ0ZWQgPSBzb3J0T3B0aW9uLmludmVydGVyID09PSAtMTtcbiAgICAgICAgICAgIHZhciB2YWx1ZUEgPSB0aGlzLmdldFZhbHVlKG5vZGVBLCBzb3J0T3B0aW9uLmNvbHVtbik7XG4gICAgICAgICAgICB2YXIgdmFsdWVCID0gdGhpcy5nZXRWYWx1ZShub2RlQiwgc29ydE9wdGlvbi5jb2x1bW4pO1xuICAgICAgICAgICAgdmFyIGNvbXBhcmF0b3JSZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoc29ydE9wdGlvbi5jb2x1bW4uZ2V0Q29sRGVmKCkuY29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIC8vaWYgY29tcGFyYXRvciBwcm92aWRlZCwgdXNlIGl0XG4gICAgICAgICAgICAgICAgY29tcGFyYXRvclJlc3VsdCA9IHNvcnRPcHRpb24uY29sdW1uLmdldENvbERlZigpLmNvbXBhcmF0b3IodmFsdWVBLCB2YWx1ZUIsIG5vZGVBLCBub2RlQiwgaXNJbnZlcnRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL290aGVyd2lzZSBkbyBvdXIgb3duIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yUmVzdWx0ID0gdXRpbHNfMS5fLmRlZmF1bHRDb21wYXJhdG9yKHZhbHVlQSwgdmFsdWVCLCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0FjY2VudGVkU29ydCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yUmVzdWx0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JSZXN1bHQgKiBzb3J0T3B0aW9uLmludmVydGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFsbCBtYXRjaGVkLCB3ZSBtYWtlIGlzIHNvIHRoYXQgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgaXMga2VwdDpcbiAgICAgICAgcmV0dXJuIHNvcnRlZE5vZGVBLmN1cnJlbnRQb3MgLSBzb3J0ZWROb2RlQi5jdXJyZW50UG9zO1xuICAgIH07XG4gICAgU29ydFNlcnZpY2UucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKG5vZGVBLCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVTZXJ2aWNlLmdldFZhbHVlKGNvbHVtbiwgbm9kZUEpO1xuICAgIH07XG4gICAgU29ydFNlcnZpY2UucHJvdG90eXBlLnVwZGF0ZUNoaWxkSW5kZXhlcyA9IGZ1bmN0aW9uIChyb3dOb2RlKSB7XG4gICAgICAgIGlmICh1dGlsc18xLl8ubWlzc2luZyhyb3dOb2RlLmNoaWxkcmVuQWZ0ZXJTb3J0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJvd05vZGUuY2hpbGRyZW5BZnRlclNvcnQuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGluZGV4ID09PSAwO1xuICAgICAgICAgICAgdmFyIGxhc3RDaGlsZCA9IGluZGV4ID09PSByb3dOb2RlLmNoaWxkcmVuQWZ0ZXJTb3J0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjaGlsZC5zZXRGaXJzdENoaWxkKGZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgY2hpbGQuc2V0TGFzdENoaWxkKGxhc3RDaGlsZCk7XG4gICAgICAgICAgICBjaGlsZC5zZXRDaGlsZEluZGV4KGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb3J0U2VydmljZS5wcm90b3R5cGUucHVsbERvd25EYXRhRm9ySGlkZU9wZW5QYXJlbnRzID0gZnVuY3Rpb24gKHJvd05vZGUsIGNsZWFyT3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh1dGlsc18xLl8ubWlzc2luZyhyb3dOb2RlLmNoaWxkcmVuQWZ0ZXJTb3J0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNHcm91cEhpZGVPcGVuUGFyZW50cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcm93Tm9kZS5jaGlsZHJlbkFmdGVyU29ydC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFJvd05vZGUpIHtcbiAgICAgICAgICAgIHZhciBncm91cERpc3BsYXlDb2xzID0gX3RoaXMuY29sdW1uQ29udHJvbGxlci5nZXRHcm91cERpc3BsYXlDb2x1bW5zKCk7XG4gICAgICAgICAgICBncm91cERpc3BsYXlDb2xzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwRGlzcGxheUNvbCkge1xuICAgICAgICAgICAgICAgIHZhciBzaG93Um93R3JvdXAgPSBncm91cERpc3BsYXlDb2wuZ2V0Q29sRGVmKCkuc2hvd1Jvd0dyb3VwO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2hvd1Jvd0dyb3VwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhZy1HcmlkOiBncm91cEhpZGVPcGVuUGFyZW50cyBvbmx5IHdvcmtzIHdoZW4gc3BlY2lmeWluZyBzcGVjaWZpYyBjb2x1bW5zIGZvciBjb2xEZWYuc2hvd1Jvd0dyb3VwJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlpbmdHcm91cEtleSA9IHNob3dSb3dHcm91cDtcbiAgICAgICAgICAgICAgICB2YXIgcm93R3JvdXBDb2x1bW4gPSBfdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldFByaW1hcnlDb2x1bW4oZGlzcGxheWluZ0dyb3VwS2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1Jvd05vZGVNYXRjaGVzID0gcm93R3JvdXBDb2x1bW4gPT09IGNoaWxkUm93Tm9kZS5yb3dHcm91cENvbHVtbjtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1Jvd05vZGVNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGRvaW5nIGEgY2xlYXIgb3BlcmF0aW9uLCB3ZSBjbGVhciBkb3duIHRoZSB2YWx1ZSBmb3IgZXZlcnkgcG9zc2libGUgZ3JvdXAgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUm93Tm9kZS5zZXRHcm91cFZhbHVlKGdyb3VwRGlzcGxheUNvbC5nZXRJZCgpLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGRvaW5nIGEgc2V0IG9wZXJhdGlvbiwgd2Ugc2V0IG9ubHkgd2hlcmUgdGhlIHB1bGwgZG93biBpcyB0byBvY2N1clxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50VG9TdGVhbEZyb20gPSBjaGlsZFJvd05vZGUuZ2V0Rmlyc3RDaGlsZE9mRmlyc3RDaGlsZChyb3dHcm91cENvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUb1N0ZWFsRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRSb3dOb2RlLnNldEdyb3VwVmFsdWUoZ3JvdXBEaXNwbGF5Q29sLmdldElkKCksIHBhcmVudFRvU3RlYWxGcm9tLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnc29ydENvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNvcnRDb250cm9sbGVyXzEuU29ydENvbnRyb2xsZXIpXG4gICAgXSwgU29ydFNlcnZpY2UucHJvdG90eXBlLCBcInNvcnRDb250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbHVtbkNvbnRyb2xsZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbHVtbkNvbnRyb2xsZXJfMS5Db2x1bW5Db250cm9sbGVyKVxuICAgIF0sIFNvcnRTZXJ2aWNlLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3ZhbHVlU2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdmFsdWVTZXJ2aWNlXzEuVmFsdWVTZXJ2aWNlKVxuICAgIF0sIFNvcnRTZXJ2aWNlLnByb3RvdHlwZSwgXCJ2YWx1ZVNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgU29ydFNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIFNvcnRTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5CZWFuKCdzb3J0U2VydmljZScpXG4gICAgXSwgU29ydFNlcnZpY2UpO1xuICAgIHJldHVybiBTb3J0U2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlNvcnRTZXJ2aWNlID0gU29ydFNlcnZpY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dOb2Rlcy9zb3J0U2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgTElORV9TRVBBUkFUT1IgPSAnXFxyXFxuJztcbnZhciBYbWxGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxGYWN0b3J5KCkge1xuICAgIH1cbiAgICBYbWxGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVYbWwgPSBmdW5jdGlvbiAoeG1sRWxlbWVudCwgYm9vbGVhblRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9wcyA9IFwiXCI7XG4gICAgICAgIGlmICh4bWxFbGVtZW50LnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmICh4bWxFbGVtZW50LnByb3BlcnRpZXMucHJlZml4ZWRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgeG1sRWxlbWVudC5wcm9wZXJ0aWVzLnByZWZpeGVkQXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXhlZFNldCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwcmVmaXhlZFNldC5tYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMgKz0gX3RoaXMucmV0dXJuQXR0cmlidXRlSWZQb3B1bGF0ZWQocHJlZml4ZWRTZXQucHJlZml4ICsga2V5LCBwcmVmaXhlZFNldC5tYXBba2V5XSwgYm9vbGVhblRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeG1sRWxlbWVudC5wcm9wZXJ0aWVzLnJhd01hcCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHhtbEVsZW1lbnQucHJvcGVydGllcy5yYXdNYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcyArPSBfdGhpcy5yZXR1cm5BdHRyaWJ1dGVJZlBvcHVsYXRlZChrZXksIHhtbEVsZW1lbnQucHJvcGVydGllcy5yYXdNYXBba2V5XSwgYm9vbGVhblRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gXCI8XCIgKyB4bWxFbGVtZW50Lm5hbWUgKyBwcm9wcztcbiAgICAgICAgaWYgKCF4bWxFbGVtZW50LmNoaWxkcmVuICYmIHhtbEVsZW1lbnQudGV4dE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiLz5cIiArIExJTkVfU0VQQVJBVE9SO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4bWxFbGVtZW50LnRleHROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyBcIj5cIiArIHhtbEVsZW1lbnQudGV4dE5vZGUgKyBcIjwvXCIgKyB4bWxFbGVtZW50Lm5hbWUgKyBcIj5cIiArIExJTkVfU0VQQVJBVE9SO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIj5cIiArIExJTkVfU0VQQVJBVE9SO1xuICAgICAgICB4bWxFbGVtZW50LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gX3RoaXMuY3JlYXRlWG1sKGl0LCBib29sZWFuVHJhbnNmb3JtZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiPC9cIiArIHhtbEVsZW1lbnQubmFtZSArIFwiPlwiICsgTElORV9TRVBBUkFUT1I7XG4gICAgfTtcbiAgICBYbWxGYWN0b3J5LnByb3RvdHlwZS5yZXR1cm5BdHRyaWJ1dGVJZlBvcHVsYXRlZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBib29sZWFuVHJhbnNmb3JtZXIpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHhtbFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICgodHlwZW9mICh2YWx1ZSkgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgIGlmIChib29sZWFuVHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgICAgICB4bWxWYWx1ZSA9IGJvb2xlYW5UcmFuc2Zvcm1lcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeG1sVmFsdWUgPSAnXCInICsgeG1sVmFsdWUgKyAnXCInO1xuICAgICAgICByZXR1cm4gXCIgXCIgKyBrZXkgKyBcIj1cIiArIHhtbFZhbHVlO1xuICAgIH07XG4gICAgWG1sRmFjdG9yeSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbigneG1sRmFjdG9yeScpXG4gICAgXSwgWG1sRmFjdG9yeSk7XG4gICAgcmV0dXJuIFhtbEZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5YbWxGYWN0b3J5ID0gWG1sRmFjdG9yeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3htbEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbnRhaW5lcnMvY2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXIvQ2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXIuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHJlYWN0X3JlZHV4XzEgPSByZXF1aXJlKFwicmVhY3QtcmVkdXhcIik7XHJcbnZhciBDbGllbnRDb21taXNzaW9uTGlzdENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXJcIik7XHJcbnZhciBDbGllbnRMaXN0Q29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcG9uZW50cy9DbGllbnRMaXN0Q29tcG9uZW50L0NsaWVudExpc3RDb21wb25lbnRcIik7XHJcbnZhciBtYXBTdGF0ZVRvUHJvcHMgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICh7fSk7IH07XHJcbmV4cG9ydHMuQ2xpZW50TGlzdENvbnRhaW5lciA9IHJlYWN0X3JlZHV4XzEuY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIENsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyXzEubWFwRGlzcGF0Y2hUb1Byb3BzKShDbGllbnRMaXN0Q29tcG9uZW50XzEuZGVmYXVsdCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbnRhaW5lcnMvY2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXIvQ2xpZW50TGlzdENvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIiBpbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xyXG5pbXBvcnQgeyBMaW5rLCBSb3V0ZUNvbXBvbmVudFByb3BzIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XHJcbmltcG9ydCAnLi9DbGllbnRDb21taXNzaW9uTGlzdENvbnRhaW5lci5jc3MnO1xyXG5pbXBvcnQgeyBBcHBsaWNhdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vc3RvcmUnO1xyXG5pbXBvcnQgKiBhcyBMb2FkZXJTdG9yZSBmcm9tICcuLi8uLi9zdG9yZS9sb2FkZXInO1xyXG5pbXBvcnQge0NsaWVudExpc3RDb250YWluZXJ9IGZyb20gJy4vQ2xpZW50TGlzdENvbnRhaW5lcic7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIENsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50PGFueSwgYW55PiB7XHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICB0aGlzLnByb3BzLmNvbXBvbmVudERpZE1vdW50KCk7XHJcbiAgICB9ICBcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG5cdFx0PGRpdj5cclxuICAgICAgICAgICAgPENsaWVudExpc3RDb250YWluZXIgLz48L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IChzdGF0ZTogQXBwbGljYXRpb25TdGF0ZSkgPT4gKHsgICBcclxuICAgIGlzTG9hZGluZzogc3RhdGUuaXNMb2FkaW5nXHJcbn0pXHJcbmV4cG9ydCBjb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSAoZGlzcGF0Y2gpID0+ICh7XHJcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHJcbiAgICB9XHJcbn0pXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzKShDbGllbnRDb21taXNzaW9uTGlzdENvbnRhaW5lcikgYXMgdHlwZW9mIENsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29udGFpbmVycy9jbGllbnRDb21taXNzaW9uTGlzdENvbnRhaW5lci9jbGllbnRDb21taXNzaW9uTGlzdENvbnRhaW5lci50c3giLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcmVkdXhfMSA9IHJlcXVpcmUoXCJyZWR1eFwiKTtcclxudmFyIHJlZHV4X3RodW5rXzEgPSByZXF1aXJlKFwicmVkdXgtdGh1bmtcIik7XHJcbnZhciByZWFjdF9yb3V0ZXJfcmVkdXhfMSA9IHJlcXVpcmUoXCJyZWFjdC1yb3V0ZXItcmVkdXhcIik7XHJcbnZhciBzdG9yZV8xID0gcmVxdWlyZShcIi4vc3RvcmVcIik7XHJcbi8vaW1wb3J0IHsgUHJvc3BlY3RNaWRkbGVXYXJlLCBlcnJvckhhbmRsZXIgfSBmcm9tICcuL2FwaS9Qcm9zcGVjdC9Qcm9zcGVjdEFwaSc7XHJcbmZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKGhpc3RvcnksIGluaXRpYWxTdGF0ZSkge1xyXG4gICAgLy8gQnVpbGQgbWlkZGxld2FyZS4gVGhlc2UgYXJlIGZ1bmN0aW9ucyB0aGF0IGNhbiBwcm9jZXNzIHRoZSBhY3Rpb25zIGJlZm9yZSB0aGV5IHJlYWNoIHRoZSBzdG9yZS5cclxuICAgIHZhciB3aW5kb3dJZkRlZmluZWQgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XHJcbiAgICAvLyBJZiBkZXZUb29scyBpcyBpbnN0YWxsZWQsIGNvbm5lY3QgdG8gaXRcclxuICAgIHZhciBkZXZUb29sc0V4dGVuc2lvbiA9IHdpbmRvd0lmRGVmaW5lZCAmJiB3aW5kb3dJZkRlZmluZWQuZGV2VG9vbHNFeHRlbnNpb247XHJcbiAgICB2YXIgY3JlYXRlU3RvcmVXaXRoTWlkZGxld2FyZSA9IHJlZHV4XzEuY29tcG9zZShyZWR1eF8xLmFwcGx5TWlkZGxld2FyZShyZWR1eF90aHVua18xLmRlZmF1bHQsIHJlYWN0X3JvdXRlcl9yZWR1eF8xLnJvdXRlck1pZGRsZXdhcmUoaGlzdG9yeSkpLCBkZXZUb29sc0V4dGVuc2lvbiA/IGRldlRvb2xzRXh0ZW5zaW9uKCkgOiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gbmV4dDsgfSkocmVkdXhfMS5jcmVhdGVTdG9yZSk7XHJcbiAgICAvLyBDb21iaW5lIGFsbCByZWR1Y2VycyBhbmQgaW5zdGFudGlhdGUgdGhlIGFwcC13aWRlIHN0b3JlIGluc3RhbmNlXHJcbiAgICB2YXIgYWxsUmVkdWNlcnMgPSBidWlsZFJvb3RSZWR1Y2VyKHN0b3JlXzEucmVkdWNlcnMpO1xyXG4gICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmVXaXRoTWlkZGxld2FyZShhbGxSZWR1Y2VycywgaW5pdGlhbFN0YXRlKTtcclxuICAgIC8vIEVuYWJsZSBXZWJwYWNrIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQgZm9yIHJlZHVjZXJzXHJcbiAgICBpZiAobW9kdWxlLmhvdCkge1xyXG4gICAgICAgIG1vZHVsZS5ob3QuYWNjZXB0KCcuL3N0b3JlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbmV4dFJvb3RSZWR1Y2VyID0gcmVxdWlyZSgnLi9zdG9yZScpO1xyXG4gICAgICAgICAgICBzdG9yZS5yZXBsYWNlUmVkdWNlcihidWlsZFJvb3RSZWR1Y2VyKG5leHRSb290UmVkdWNlci5yZWR1Y2VycykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0b3JlO1xyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGNvbmZpZ3VyZVN0b3JlO1xyXG5mdW5jdGlvbiBidWlsZFJvb3RSZWR1Y2VyKGFsbFJlZHVjZXJzKSB7XHJcbiAgICByZXR1cm4gcmVkdXhfMS5jb21iaW5lUmVkdWNlcnMoT2JqZWN0LmFzc2lnbih7fSwgYWxsUmVkdWNlcnMsIHsgcm91dGluZzogcmVhY3Rfcm91dGVyX3JlZHV4XzEucm91dGVyUmVkdWNlciB9KSk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29uZmlndXJlU3RvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSkoMTQwKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYXNwbmV0LXByZXJlbmRlcmluZy9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSkoMTQ3KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSkoMTQ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhZy1ncmlkLXJlYWN0IHYxNC4wLjBcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKTtcbnZhciBBZ0dyaWQgPSByZXF1aXJlKFwiYWctZ3JpZFwiKTtcbnZhciBhZ19ncmlkXzEgPSByZXF1aXJlKFwiYWctZ3JpZFwiKTtcbnZhciBBZ1JlYWN0Q29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZ1JlYWN0Q29tcG9uZW50KHJlYWN0Q29tcG9uZW50LCBwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5yZWFjdENvbXBvbmVudCA9IHJlYWN0Q29tcG9uZW50O1xuICAgICAgICB0aGlzLnBhcmVudENvbXBvbmVudCA9IHBhcmVudENvbXBvbmVudDtcbiAgICB9XG4gICAgQWdSZWFjdENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RnJhbWV3b3JrQ29tcG9uZW50SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFJlZjtcbiAgICB9O1xuICAgIEFnUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgYWdfZ3JpZF8xLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF90aGlzLmVQYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBBZ0dyaWQuVXRpbHMuYWRkQ3NzQ2xhc3MoX3RoaXMuZVBhcmVudEVsZW1lbnQsICdhZy1yZWFjdC1jb250YWluZXInKTtcbiAgICAgICAgICAgIC8vIHNvIHVzZXIgY2FuIGhhdmUgYWNjZXNzIHRvIHRoZSByZWFjdCBjb250YWluZXIsXG4gICAgICAgICAgICAvLyB0byBhZGQgY3NzIGNsYXNzIG9yIHN0eWxlXG4gICAgICAgICAgICBwYXJhbXMucmVhY3RDb250YWluZXIgPSBfdGhpcy5lUGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIHZhciBzZWxmID0gX3RoaXM7XG4gICAgICAgICAgICB2YXIgUmVhY3RDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KF90aGlzLnJlYWN0Q29tcG9uZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wYXJlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBNVVNUIGJlIGEgZnVuY3Rpb24sIG5vdCBhbiBhcnJvdyBmdW5jdGlvblxuICAgICAgICAgICAgICAgIFJlYWN0RE9NLnJlbmRlcihSZWFjdENvbXBvbmVudCwgX3RoaXMuZVBhcmVudEVsZW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRSZWYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTVVTVCBiZSBhIGZ1bmN0aW9uLCBub3QgYW4gYXJyb3cgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBSZWFjdERPTS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihfdGhpcy5wYXJlbnRDb21wb25lbnQsIFJlYWN0Q29tcG9uZW50LCBfdGhpcy5lUGFyZW50RWxlbWVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudFJlZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWdSZWFjdENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3VpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lUGFyZW50RWxlbWVudDtcbiAgICB9O1xuICAgIEFnUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUodGhpcy5lUGFyZW50RWxlbWVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWdSZWFjdENvbXBvbmVudDtcbn0oKSk7XG5leHBvcnRzLkFnUmVhY3RDb21wb25lbnQgPSBBZ1JlYWN0Q29tcG9uZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQtcmVhY3QvbGliL2FnUmVhY3RDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhZy1ncmlkLXJlYWN0IHYxNC4wLjBcblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFnX2dyaWRfMSA9IHJlcXVpcmUoXCJhZy1ncmlkXCIpO1xudmFyIGFnUmVhY3RDb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuL2FnUmVhY3RDb21wb25lbnRcIik7XG52YXIgYWdHcmlkUmVhY3RfMSA9IHJlcXVpcmUoXCIuL2FnR3JpZFJlYWN0XCIpO1xudmFyIFJlYWN0RnJhbWV3b3JrQ29tcG9uZW50V3JhcHBlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWN0RnJhbWV3b3JrQ29tcG9uZW50V3JhcHBlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWFjdEZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUmVhY3RGcmFtZXdvcmtDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVXcmFwcGVyID0gZnVuY3Rpb24gKFJlYWN0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBEeW5hbWljQWdSZWFjdENvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoRHluYW1pY0FnUmVhY3RDb21wb25lbnQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBEeW5hbWljQWdSZWFjdENvbXBvbmVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgUmVhY3RDb21wb25lbnQsIF9zZWxmLmFnR3JpZFJlYWN0KSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRHluYW1pY0FnUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRHluYW1pY0FnUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmhhc01ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1ld29ya0NvbXBvbmVudEluc3RhbmNlID0gd3JhcHBlci5nZXRGcmFtZXdvcmtDb21wb25lbnRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZXdvcmtDb21wb25lbnRJbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJhZyBncmlkOiBcIiArIG5hbWUgKyBcIiBJdCBzZWVtcyBsaWtlIHlvdSBhcmUgdXNpbmcgcmVhY3QgZmliZXIgKD52MTYuMC4wKS4gQWctZ3JpZCBoYXMgZXhwZXJpbWVudGFsIHN1cHBvcnQgZm9yIGl0LCBwbGVhc2UgaWYgdGhlcmUgaXMgYW55IGlzc3VlIHRoYXQgeW91IGZpbmQgbGV0IHVzIGtub3dcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWV3b3JrQ29tcG9uZW50SW5zdGFuY2VbbmFtZV0gIT0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBEeW5hbWljQWdSZWFjdENvbXBvbmVudC5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWV3b3JrQ29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmdldEZyYW1ld29ya0NvbXBvbmVudEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1ld29ya0NvbXBvbmVudEluc3RhbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jYWxsTWV0aG9kKG5hbWUsIGFyZ3MpOyB9LCAxMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHdyYXBwZXIuZ2V0RnJhbWV3b3JrQ29tcG9uZW50SW5zdGFuY2UoKVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoZnJhbWV3b3JrQ29tcG9uZW50SW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBEeW5hbWljQWdSZWFjdENvbXBvbmVudC5wcm90b3R5cGUuYWRkTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlcltuYW1lXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBEeW5hbWljQWdSZWFjdENvbXBvbmVudDtcbiAgICAgICAgfShhZ1JlYWN0Q29tcG9uZW50XzEuQWdSZWFjdENvbXBvbmVudCkpO1xuICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBEeW5hbWljQWdSZWFjdENvbXBvbmVudCgpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdEZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXI7XG59KGFnX2dyaWRfMS5CYXNlQ29tcG9uZW50V3JhcHBlcikpO1xuX19kZWNvcmF0ZShbXG4gICAgYWdfZ3JpZF8xLkF1dG93aXJlZCgnYWdHcmlkUmVhY3QnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgYWdHcmlkUmVhY3RfMS5BZ0dyaWRSZWFjdClcbl0sIFJlYWN0RnJhbWV3b3JrQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUsIFwiYWdHcmlkUmVhY3RcIiwgdm9pZCAwKTtcblJlYWN0RnJhbWV3b3JrQ29tcG9uZW50V3JhcHBlciA9IF9fZGVjb3JhdGUoW1xuICAgIGFnX2dyaWRfMS5CZWFuKCdmcmFtZXdvcmtDb21wb25lbnRXcmFwcGVyJylcbl0sIFJlYWN0RnJhbWV3b3JrQ29tcG9uZW50V3JhcHBlcik7XG5leHBvcnRzLlJlYWN0RnJhbWV3b3JrQ29tcG9uZW50V3JhcHBlciA9IFJlYWN0RnJhbWV3b3JrQ29tcG9uZW50V3JhcHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkLXJlYWN0L2xpYi9yZWFjdEZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLkFnR3JpZFJlYWN0ID0gcmVxdWlyZSgnLi9saWIvYWdHcmlkUmVhY3QnKS5BZ0dyaWRSZWFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkLXJlYWN0L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JpZF8xID0gcmVxdWlyZShcIi4uL2dyaWRcIik7XG5mdW5jdGlvbiBpbml0aWFsaXNlQWdHcmlkV2l0aEFuZ3VsYXIxKGFuZ3VsYXIpIHtcbiAgICB2YXIgYW5ndWxhck1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKFwiYWdHcmlkXCIsIFtdKTtcbiAgICBhbmd1bGFyTW9kdWxlLmRpcmVjdGl2ZShcImFnR3JpZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogXCJBXCIsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRlbGVtZW50JywgJyRzY29wZScsICckY29tcGlsZScsICckYXR0cnMnLCBBbmd1bGFyRGlyZWN0aXZlQ29udHJvbGxlcl0sXG4gICAgICAgICAgICBzY29wZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy5pbml0aWFsaXNlQWdHcmlkV2l0aEFuZ3VsYXIxID0gaW5pdGlhbGlzZUFnR3JpZFdpdGhBbmd1bGFyMTtcbmZ1bmN0aW9uIEFuZ3VsYXJEaXJlY3RpdmVDb250cm9sbGVyKCRlbGVtZW50LCAkc2NvcGUsICRjb21waWxlLCAkYXR0cnMpIHtcbiAgICB2YXIgZ3JpZE9wdGlvbnM7XG4gICAgdmFyIHF1aWNrRmlsdGVyT25TY29wZTtcbiAgICB2YXIga2V5T2ZHcmlkSW5TY29wZSA9ICRhdHRycy5hZ0dyaWQ7XG4gICAgcXVpY2tGaWx0ZXJPblNjb3BlID0ga2V5T2ZHcmlkSW5TY29wZSArICcucXVpY2tGaWx0ZXJUZXh0JztcbiAgICBncmlkT3B0aW9ucyA9ICRzY29wZS4kZXZhbChrZXlPZkdyaWRJblNjb3BlKTtcbiAgICBpZiAoIWdyaWRPcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIldBUk5JTkcgLSBncmlkIG9wdGlvbnMgZm9yIGFnLUdyaWQgbm90IGZvdW5kLiBQbGVhc2UgZW5zdXJlIHRoZSBhdHRyaWJ1dGUgYWctZ3JpZCBwb2ludHMgdG8gYSB2YWxpZCBvYmplY3Qgb24gdGhlIHNjb3BlXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlR3JpZERpdiA9ICRlbGVtZW50WzBdO1xuICAgIHZhciBncmlkUGFyYW1zID0ge1xuICAgICAgICAkc2NvcGU6ICRzY29wZSxcbiAgICAgICAgJGNvbXBpbGU6ICRjb21waWxlLFxuICAgICAgICBxdWlja0ZpbHRlck9uU2NvcGU6IHF1aWNrRmlsdGVyT25TY29wZVxuICAgIH07XG4gICAgdmFyIGdyaWQgPSBuZXcgZ3JpZF8xLkdyaWQoZUdyaWREaXYsIGdyaWRPcHRpb25zLCBncmlkUGFyYW1zKTtcbiAgICAkc2NvcGUuJG9uKFwiJGRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBncmlkLmRlc3Ryb3koKTtcbiAgICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbXBvbmVudHMvYWdHcmlkTmcxLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbXBvbmVudFV0aWxfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudFV0aWxcIik7XG52YXIgZ3JpZF8xID0gcmVxdWlyZShcIi4uL2dyaWRcIik7XG52YXIgcmVnaXN0ZXJlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdGlhbGlzZUFnR3JpZFdpdGhXZWJDb21wb25lbnRzKCkge1xuICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogaW5pdGlhbGlzZUFnR3JpZFdpdGhXZWJDb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIGFnLWdyaWQtd2ViY29tcG9uZW50IGRlcGVuZGVuY3kgaW5zdGVhZC4gJyk7XG4gICAgLy8gb25seSByZWdpc3RlciB0byBXZWJDb21wb25lbnRzIG9uY2VcbiAgICBpZiAocmVnaXN0ZXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICFkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignYWctR3JpZDogdW5hYmxlIHRvIGZpbmQgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCkgZnVuY3Rpb24sIHVuYWJsZSB0byBpbml0aWFsaXNlIGFnLUdyaWQgYXMgYSBXZWIgQ29tcG9uZW50Jyk7XG4gICAgfVxuICAgIC8vIGkgZG9uJ3QgdGhpbmsgdGhpcyB0eXBlIG9mIGV4dGVuc2lvbiBpcyBwb3NzaWJsZSBpbiBUeXBlU2NyaXB0LCBzbyBiYWNrIHRvXG4gICAgLy8gcGxhaW4gSmF2YXNjcmlwdCB0byBjcmVhdGUgdGhpcyBvYmplY3RcbiAgICB2YXIgQWdpbGVHcmlkUHJvdG8gPSBPYmplY3QuY3JlYXRlKEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgLy8gd3JhcCBlYWNoIHByb3BlcnR5IHdpdGggYSBnZXQgYW5kIHNldCBtZXRob2QsIHNvIHdlIGNhbiB0cmFjayB3aGVuIGNoYW5nZXMgYXJlIGRvbmVcbiAgICBjb21wb25lbnRVdGlsXzEuQ29tcG9uZW50VXRpbC5BTExfUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFnaWxlR3JpZFByb3RvLCBrZXksIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fYWdHcmlkU2V0UHJvcGVydHkoa2V5LCB2KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2FnR3JpZEdldFByb3BlcnR5KGtleSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgYWdHcmlkUHJvdG9Ob1R5cGUgPSBBZ2lsZUdyaWRQcm90bztcbiAgICBhZ0dyaWRQcm90b05vVHlwZS5fX2FnR3JpZFNldFByb3BlcnR5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdGhpcy5fX2F0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIC8vIGtlZXBpbmcgdGhpcyBjb25zaXN0ZW50IHdpdGggdGhlIG5nMiBvbkNoYW5nZSwgc28gSSBjYW4gcmV1c2UgdGhlIGhhbmRsaW5nIGNvZGVcbiAgICAgICAgdmFyIGNoYW5nZU9iamVjdCA9IHt9O1xuICAgICAgICBjaGFuZ2VPYmplY3Rba2V5XSA9IHsgY3VycmVudFZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKGNoYW5nZU9iamVjdCk7XG4gICAgfTtcbiAgICBhZ0dyaWRQcm90b05vVHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXNlZCkge1xuICAgICAgICAgICAgY29tcG9uZW50VXRpbF8xLkNvbXBvbmVudFV0aWwucHJvY2Vzc09uQ2hhbmdlKGNoYW5nZXMsIHRoaXMuX2dyaWRPcHRpb25zLCB0aGlzLmFwaSwgdGhpcy5jb2x1bW5BcGkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhZ0dyaWRQcm90b05vVHlwZS5fX2FnR3JpZEdldFByb3BlcnR5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuX19hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9fYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fYXR0cmlidXRlc1trZXldO1xuICAgIH07XG4gICAgYWdHcmlkUHJvdG9Ob1R5cGUuc2V0R3JpZE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZ2xvYmFsRXZlbnRMaXN0ZW5lciA9IHRoaXMuZ2xvYmFsRXZlbnRMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9ncmlkT3B0aW9ucyA9IGNvbXBvbmVudFV0aWxfMS5Db21wb25lbnRVdGlsLmNvcHlBdHRyaWJ1dGVzVG9HcmlkT3B0aW9ucyhvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgdmFyIGdyaWRQYXJhbXMgPSB7XG4gICAgICAgICAgICBnbG9iYWxFdmVudExpc3RlbmVyOiBnbG9iYWxFdmVudExpc3RlbmVyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FnR3JpZCA9IG5ldyBncmlkXzEuR3JpZCh0aGlzLCB0aGlzLl9ncmlkT3B0aW9ucywgZ3JpZFBhcmFtcyk7XG4gICAgICAgIHRoaXMuYXBpID0gb3B0aW9ucy5hcGk7XG4gICAgICAgIHRoaXMuY29sdW1uQXBpID0gb3B0aW9ucy5jb2x1bW5BcGk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIGNvcGllcyBhbGwgdGhlIGF0dHJpYnV0ZXMgaW50byB0aGlzIG9iamVjdFxuICAgIGFnR3JpZFByb3RvTm9UeXBlLmNyZWF0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5RnJvbUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhZ0dyaWRQcm90b05vVHlwZS5zZXRQcm9wZXJ0eUZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdG9DYW1lbENhc2UoYXR0cmlidXRlLm5vZGVOYW1lKTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLm5vZGVWYWx1ZTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFV0aWxfMS5Db21wb25lbnRVdGlsLkFMTF9QUk9QRVJUSUVTLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhZ0dyaWRQcm90b05vVHlwZS5hdHRhY2hlZENhbGxiYWNrID0gZnVuY3Rpb24gKHBhcmFtcykgeyB9O1xuICAgIGFnR3JpZFByb3RvTm9UeXBlLmRldGFjaGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAocGFyYW1zKSB7IH07XG4gICAgYWdHcmlkUHJvdG9Ob1R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eUZyb21BdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICB9O1xuICAgIGFnR3JpZFByb3RvTm9UeXBlLmdsb2JhbEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBldmVudCkge1xuICAgICAgICB2YXIgZXZlbnRMb3dlckNhc2UgPSBldmVudFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGJyb3dzZXJFdmVudCA9IG5ldyBFdmVudChldmVudExvd2VyQ2FzZSk7XG4gICAgICAgIHZhciBicm93c2VyRXZlbnROb1R5cGUgPSBicm93c2VyRXZlbnQ7XG4gICAgICAgIGJyb3dzZXJFdmVudE5vVHlwZS5hZ0dyaWREZXRhaWxzID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChicm93c2VyRXZlbnQpO1xuICAgICAgICB2YXIgY2FsbGJhY2tNZXRob2QgPSAnb24nICsgZXZlbnRMb3dlckNhc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tjYWxsYmFja01ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXNbY2FsbGJhY2tNZXRob2RdKGJyb3dzZXJFdmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGZpbmFsbHksIHJlZ2lzdGVyXG4gICAgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdhZy1ncmlkJywgeyBwcm90b3R5cGU6IEFnaWxlR3JpZFByb3RvIH0pO1xufVxuZXhwb3J0cy5pbml0aWFsaXNlQWdHcmlkV2l0aFdlYkNvbXBvbmVudHMgPSBpbml0aWFsaXNlQWdHcmlkV2l0aFdlYkNvbXBvbmVudHM7XG5mdW5jdGlvbiB0b0NhbWVsQ2FzZShteVN0cmluZykge1xuICAgIGlmICh0eXBlb2YgbXlTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBteVN0cmluZy5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbiAoZykge1xuICAgICAgICAgICAgcmV0dXJuIGdbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbXlTdHJpbmc7XG4gICAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvY29tcG9uZW50cy9hZ0dyaWRXZWJDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29sRGVmVXRpbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sRGVmVXRpbCgpIHtcbiAgICB9XG4gICAgQ29sRGVmVXRpbC5TVFJJTkdfUFJPUEVSVElFUyA9IFtcbiAgICAgICAgJ2hlYWRlck5hbWUnLFxuICAgICAgICAnY29sdW1uR3JvdXBTaG93JyxcbiAgICAgICAgJ2hlYWRlckNsYXNzJyxcbiAgICAgICAgJ3Rvb2xQYW5lbENsYXNzJyxcbiAgICAgICAgJ2hlYWRlclZhbHVlR2V0dGVyJyxcbiAgICAgICAgJ3Bpdm90S2V5cycsXG4gICAgICAgICdncm91cElkJyxcbiAgICAgICAgJ2NvbElkJyxcbiAgICAgICAgJ3NvcnQnLFxuICAgICAgICAnZmllbGQnLFxuICAgICAgICAndHlwZScsXG4gICAgICAgICd0b29sdGlwRmllbGQnLFxuICAgICAgICAnaGVhZGVyVG9vbHRpcCcsXG4gICAgICAgICdjZWxsQ2xhc3MnLFxuICAgICAgICAnc2hvd1Jvd0dyb3VwJyxcbiAgICAgICAgJ3RlbXBsYXRlJyxcbiAgICAgICAgJ3RlbXBsYXRlVXJsJyxcbiAgICAgICAgJ2ZpbHRlcicsXG4gICAgICAgICdhZ2dGdW5jJyxcbiAgICAgICAgJ2NlbGxFZGl0b3InXG4gICAgXTtcbiAgICBDb2xEZWZVdGlsLk9CSkVDVF9QUk9QRVJUSUVTID0gW1xuICAgICAgICAnaGVhZGVyR3JvdXBDb21wb25lbnQnLFxuICAgICAgICAnaGVhZGVyR3JvdXBDb21wb25lbnRGcmFtZXdvcmsnLFxuICAgICAgICAnaGVhZGVyR3JvdXBDb21wb25lbnRQYXJhbXMnLFxuICAgICAgICAnY2VsbFN0eWxlJyxcbiAgICAgICAgJ2NlbGxSZW5kZXJlclBhcmFtcycsXG4gICAgICAgICdjZWxsRWRpdG9yRnJhbWV3b3JrJyxcbiAgICAgICAgJ2NlbGxFZGl0b3JQYXJhbXMnLFxuICAgICAgICAncGlubmVkUm93Q2VsbFJlbmRlcmVyRnJhbWV3b3JrJyxcbiAgICAgICAgJ3Bpbm5lZFJvd0NlbGxSZW5kZXJlclBhcmFtcycsXG4gICAgICAgICdmaWx0ZXJGcmFtZXdvcmsnLFxuICAgICAgICAnZmlsdGVyUGFyYW1zJyxcbiAgICAgICAgJ3Bpdm90VmFsdWVDb2x1bW4nLFxuICAgICAgICAnaGVhZGVyQ29tcG9uZW50JyxcbiAgICAgICAgJ2hlYWRlckNvbXBvbmVudEZyYW1ld29yaycsXG4gICAgICAgICdoZWFkZXJDb21wb25lbnRQYXJhbXMnLFxuICAgICAgICAnZmxvYXRpbmdGaWx0ZXJDb21wb25lbnQnLFxuICAgICAgICAnZmxvYXRpbmdGaWx0ZXJDb21wb25lbnRQYXJhbXMnLFxuICAgICAgICAnZmxvYXRpbmdGaWx0ZXJDb21wb25lbnRGcmFtZXdvcmsnLFxuICAgICAgICAncmVmRGF0YSdcbiAgICBdO1xuICAgIENvbERlZlV0aWwuQVJSQVlfUFJPUEVSVElFUyA9IFtcbiAgICAgICAgJ2NoaWxkcmVuJyxcbiAgICAgICAgJ3NvcnRpbmdPcmRlcicsXG4gICAgICAgICdhbGxvd2VkQWdnRnVuY3MnLFxuICAgICAgICAnbWVudVRhYnMnLFxuICAgICAgICAncGl2b3RUb3RhbENvbHVtbklkcycsXG4gICAgICAgICdjZWxsQ2xhc3NSdWxlcycsXG4gICAgICAgICdpY29ucydcbiAgICBdO1xuICAgIENvbERlZlV0aWwuTlVNQkVSX1BST1BFUlRJRVMgPSBbXG4gICAgICAgICdzb3J0ZWRBdCcsXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgICdtaW5XaWR0aCcsXG4gICAgICAgICdtYXhXaWR0aCcsXG4gICAgICAgICdyb3dHcm91cEluZGV4JyxcbiAgICAgICAgJ3Bpdm90SW5kZXgnXG4gICAgXTtcbiAgICBDb2xEZWZVdGlsLkJPT0xFQU5fUFJPUEVSVElFUyA9IFtcbiAgICAgICAgJ3N1cHByZXNzVG9vbFBhbmVsJyxcbiAgICAgICAgJ29wZW5CeURlZmF1bHQnLFxuICAgICAgICAnbWFycnlDaGlsZHJlbicsXG4gICAgICAgICdoaWRlJyxcbiAgICAgICAgJ3Bpbm5lZCcsXG4gICAgICAgICdyb3dHcm91cCcsXG4gICAgICAgICdwaXZvdCcsXG4gICAgICAgICdjaGVja2JveFNlbGVjdGlvbicsXG4gICAgICAgICdoZWFkZXJDaGVja2JveFNlbGVjdGlvbicsXG4gICAgICAgICdoZWFkZXJDaGVja2JveFNlbGVjdGlvbkZpbHRlcmVkT25seScsXG4gICAgICAgICdzdXBwcmVzc01lbnUnLFxuICAgICAgICAnc3VwcHJlc3NTb3J0aW5nJyxcbiAgICAgICAgJ3N1cHByZXNzTW92YWJsZScsXG4gICAgICAgICdzdXBwcmVzc0ZpbHRlcicsXG4gICAgICAgICd1blNvcnRJY29uJyxcbiAgICAgICAgJ3N1cHByZXNzU2l6ZVRvRml0JyxcbiAgICAgICAgJ3N1cHByZXNzUmVzaXplJyxcbiAgICAgICAgJ3N1cHByZXNzQXV0b1NpemUnLFxuICAgICAgICAnZW5hYmxlUm93R3JvdXAnLFxuICAgICAgICAnZW5hYmxlUGl2b3QnLFxuICAgICAgICAnZW5hYmxlVmFsdWUnLFxuICAgICAgICAnZWRpdGFibGUnLFxuICAgICAgICAnc3VwcHJlc3NQYXN0ZScsXG4gICAgICAgICdzdXBwcmVzc05hdmlnYWJsZScsXG4gICAgICAgICd2b2xhdGlsZScsXG4gICAgICAgICdlbmFibGVDZWxsQ2hhbmdlRmxhc2gnXG4gICAgXTtcbiAgICBDb2xEZWZVdGlsLkZVTkNUSU9OX1BST1BFUlRJRVMgPSBbXG4gICAgICAgICd2YWx1ZUdldHRlcicsXG4gICAgICAgICd2YWx1ZVNldHRlcicsXG4gICAgICAgICdrZXlDcmVhdG9yJyxcbiAgICAgICAgJ2hlYWRlckNlbGxSZW5kZXJlcicsXG4gICAgICAgICdoZWFkZXJDZWxsVGVtcGxhdGUnLFxuICAgICAgICAnY2VsbFJlbmRlcmVyRnJhbWV3b3JrJyxcbiAgICAgICAgJ3Bpbm5lZFJvd0NlbGxSZW5kZXJlcicsXG4gICAgICAgICd2YWx1ZUZvcm1hdHRlcicsXG4gICAgICAgICdwaW5uZWRSb3dWYWx1ZUZvcm1hdHRlcicsXG4gICAgICAgICd2YWx1ZVBhcnNlcicsXG4gICAgICAgICdjb21wYXJhdG9yJyxcbiAgICAgICAgJ2VxdWFscycsXG4gICAgICAgICdwaXZvdENvbXBhcmF0b3InLFxuICAgICAgICAnc3VwcHJlc3NLZXlib2FyZEV2ZW50JyxcbiAgICAgICAgJ2NvbFNwYW4nLFxuICAgICAgICAnZ2V0UXVpY2tGaWx0ZXJUZXh0JyxcbiAgICAgICAgJ25ld1ZhbHVlSGFuZGxlcicsXG4gICAgICAgICdvbkNlbGxWYWx1ZUNoYW5nZWQnLFxuICAgICAgICAnb25DZWxsQ2xpY2tlZCcsXG4gICAgICAgICdvbkNlbGxEb3VibGVDbGlja2VkJyxcbiAgICAgICAgJ29uQ2VsbENvbnRleHRNZW51J1xuICAgIF07XG4gICAgQ29sRGVmVXRpbC5BTExfUFJPUEVSVElFUyA9IENvbERlZlV0aWwuQVJSQVlfUFJPUEVSVElFU1xuICAgICAgICAuY29uY2F0KENvbERlZlV0aWwuT0JKRUNUX1BST1BFUlRJRVMpXG4gICAgICAgIC5jb25jYXQoQ29sRGVmVXRpbC5TVFJJTkdfUFJPUEVSVElFUylcbiAgICAgICAgLmNvbmNhdChDb2xEZWZVdGlsLk5VTUJFUl9QUk9QRVJUSUVTKVxuICAgICAgICAuY29uY2F0KENvbERlZlV0aWwuRlVOQ1RJT05fUFJPUEVSVElFUylcbiAgICAgICAgLmNvbmNhdChDb2xEZWZVdGlsLkJPT0xFQU5fUFJPUEVSVElFUyk7XG4gICAgcmV0dXJuIENvbERlZlV0aWw7XG59KCkpO1xuZXhwb3J0cy5Db2xEZWZVdGlsID0gQ29sRGVmVXRpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbXBvbmVudHMvY29sRGVmVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXNlQ29tcG9uZW50V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZUNvbXBvbmVudFdyYXBwZXIoKSB7XG4gICAgfVxuICAgIEJhc2VDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKE9yaWdpbmFsQ29uc3RydWN0b3IsIG1hbmRhdG9yeU1ldGhvZExpc3QsIG9wdGlvbmFsTWV0aG9kTGlzdCwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgd3JhcHBlciA9IHRoaXMuY3JlYXRlV3JhcHBlcihPcmlnaW5hbENvbnN0cnVjdG9yLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgbWFuZGF0b3J5TWV0aG9kTGlzdC5mb3JFYWNoKChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgX3RoaXMuY3JlYXRlTWV0aG9kKHdyYXBwZXIsIG1ldGhvZE5hbWUsIHRydWUpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChvcHRpb25hbE1ldGhvZExpc3QpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsTWV0aG9kTGlzdC5mb3JFYWNoKChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZU1ldGhvZCh3cmFwcGVyLCBtZXRob2ROYW1lLCBmYWxzZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfTtcbiAgICBCYXNlQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUuY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKHdyYXBwZXIsIG1ldGhvZE5hbWUsIG1hbmRhdG9yeSkge1xuICAgICAgICB3cmFwcGVyLmFkZE1ldGhvZChtZXRob2ROYW1lLCB0aGlzLmNyZWF0ZU1ldGhvZFByb3h5KHdyYXBwZXIsIG1ldGhvZE5hbWUsIG1hbmRhdG9yeSkpO1xuICAgIH07XG4gICAgQmFzZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZU1ldGhvZFByb3h5ID0gZnVuY3Rpb24gKHdyYXBwZXIsIG1ldGhvZE5hbWUsIG1hbmRhdG9yeSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIuaGFzTWV0aG9kKG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2FsbE1ldGhvZChtZXRob2ROYW1lLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hbmRhdG9yeSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctR3JpZDogRnJhbWV3b3JrIGNvbXBvbmVudCBpcyBtaXNzaW5nIHRoZSBtZXRob2QgJyArIG1ldGhvZE5hbWUgKyAnKCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VDb21wb25lbnRXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuQmFzZUNvbXBvbmVudFdyYXBwZXIgPSBCYXNlQ29tcG9uZW50V3JhcHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2NvbXBvbmVudHMvZnJhbWV3b3JrL2ZyYW1ld29ya0NvbXBvbmVudFdyYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmF1bHRDb2x1bW5UeXBlcyA9IHtcbiAgICBcIm51bWVyaWNDb2x1bW5cIjoge1xuICAgICAgICBcImhlYWRlckNsYXNzXCI6IFwiYWctbnVtZXJpYy1oZWFkZXJcIixcbiAgICAgICAgXCJjZWxsQ2xhc3NcIjogXCJhZy1udW1lcmljLWNlbGxcIlxuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9lbnRpdGllcy9kZWZhdWx0Q29sdW1uVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudHMoKSB7XG4gICAgfVxuICAgIC8qKiBFdmVyeXRoaW5nIGhhcyBjaGFuZ2VkIHdpdGggdGhlIGNvbHVtbnMuIEVpdGhlciBjb21wbGV0ZSBuZXcgc2V0IG9mIGNvbHVtbnMgc2V0LCBvciB1c2VyIGNhbGxlZCBzZXRTdGF0ZSgpKi9cbiAgICBFdmVudHMuRVZFTlRfQ09MVU1OX0VWRVJZVEhJTkdfQ0hBTkdFRCA9ICdjb2x1bW5FdmVyeXRoaW5nQ2hhbmdlZCc7XG4gICAgLyoqIFVzZXIgaGFzIHNldCBpbiBuZXcgY29sdW1ucy4gKi9cbiAgICBFdmVudHMuRVZFTlRfTkVXX0NPTFVNTlNfTE9BREVEID0gJ25ld0NvbHVtbnNMb2FkZWQnO1xuICAgIC8qKiBUaGUgcGl2b3QgbW9kZSBmbGFnIHdhcyBjaGFuZ2VkICovXG4gICAgRXZlbnRzLkVWRU5UX0NPTFVNTl9QSVZPVF9NT0RFX0NIQU5HRUQgPSAnY29sdW1uUGl2b3RNb2RlQ2hhbmdlZCc7XG4gICAgLyoqIEEgcm93IGdyb3VwIGNvbHVtbiB3YXMgYWRkZWQsIHJlbW92ZWQgb3Igb3JkZXIgY2hhbmdlZC4gKi9cbiAgICBFdmVudHMuRVZFTlRfQ09MVU1OX1JPV19HUk9VUF9DSEFOR0VEID0gJ2NvbHVtblJvd0dyb3VwQ2hhbmdlZCc7XG4gICAgLyoqIEEgcGl2b3QgY29sdW1uIHdhcyBhZGRlZCwgcmVtb3ZlZCBvciBvcmRlciBjaGFuZ2VkLiAqL1xuICAgIEV2ZW50cy5FVkVOVF9DT0xVTU5fUElWT1RfQ0hBTkdFRCA9ICdjb2x1bW5QaXZvdENoYW5nZWQnO1xuICAgIC8qKiBUaGUgbGlzdCBvZiBncmlkIGNvbHVtbnMgaGFzIGNoYW5nZWQuICovXG4gICAgRXZlbnRzLkVWRU5UX0dSSURfQ09MVU1OU19DSEFOR0VEID0gJ2dyaWRDb2x1bW5zQ2hhbmdlZCc7XG4gICAgLyoqIEEgdmFsdWUgY29sdW1uIHdhcyBhZGRlZCwgcmVtb3ZlZCBvciBhZ2cgZnVuY3Rpb24gd2FzIGNoYW5nZWQuICovXG4gICAgRXZlbnRzLkVWRU5UX0NPTFVNTl9WQUxVRV9DSEFOR0VEID0gJ2NvbHVtblZhbHVlQ2hhbmdlZCc7XG4gICAgLyoqIEEgY29sdW1uIHdhcyBtb3ZlZCAqL1xuICAgIEV2ZW50cy5FVkVOVF9DT0xVTU5fTU9WRUQgPSAnY29sdW1uTW92ZWQnO1xuICAgIC8qKiBPbmUgb3IgbW9yZSBjb2x1bW5zIHdhcyBzaG93biAvIGhpZGRlbiAqL1xuICAgIEV2ZW50cy5FVkVOVF9DT0xVTU5fVklTSUJMRSA9ICdjb2x1bW5WaXNpYmxlJztcbiAgICAvKiogT25lIG9yIG1vcmUgY29sdW1ucyB3YXMgcGlubmVkIC8gdW5waW5uZWQqL1xuICAgIEV2ZW50cy5FVkVOVF9DT0xVTU5fUElOTkVEID0gJ2NvbHVtblBpbm5lZCc7XG4gICAgLyoqIEEgY29sdW1uIGdyb3VwIHdhcyBvcGVuZWQgLyBjbG9zZWQgKi9cbiAgICBFdmVudHMuRVZFTlRfQ09MVU1OX0dST1VQX09QRU5FRCA9ICdjb2x1bW5Hcm91cE9wZW5lZCc7XG4gICAgLyoqIE9uZSBvciBtb3JlIGNvbHVtbnMgd2FzIHJlc2l6ZWQuIElmIGp1c3Qgb25lLCB0aGUgY29sdW1uIGluIHRoZSBldmVudCBpcyBzZXQuICovXG4gICAgRXZlbnRzLkVWRU5UX0NPTFVNTl9SRVNJWkVEID0gJ2NvbHVtblJlc2l6ZWQnO1xuICAgIC8qKiBUaGUgbGlzdCBvZiBkaXNwbGF5ZWQgY29sdW1ucyBoYXMgY2hhbmdlZCwgY2FuIHJlc3VsdCBmcm9tIGNvbHVtbnMgb3BlbiAvIGNsb3NlLCBjb2x1bW4gbW92ZSwgcGl2b3QsIGdyb3VwLCBldGMgKi9cbiAgICBFdmVudHMuRVZFTlRfRElTUExBWUVEX0NPTFVNTlNfQ0hBTkdFRCA9ICdkaXNwbGF5ZWRDb2x1bW5zQ2hhbmdlZCc7XG4gICAgLyoqIFRoZSBsaXN0IG9mIHZpcnR1YWwgY29sdW1ucyBoYXMgY2hhbmdlZCwgcmVzdWx0cyBmcm9tIHZpZXdwb3J0IGNoYW5naW5nICovXG4gICAgRXZlbnRzLkVWRU5UX1ZJUlRVQUxfQ09MVU1OU19DSEFOR0VEID0gJ3ZpcnR1YWxDb2x1bW5zQ2hhbmdlZCc7XG4gICAgLyoqIEEgcm93IGdyb3VwIHdhcyBvcGVuZWQgLyBjbG9zZWQgKi9cbiAgICBFdmVudHMuRVZFTlRfUk9XX0dST1VQX09QRU5FRCA9ICdyb3dHcm91cE9wZW5lZCc7XG4gICAgLyoqIFRoZSBjbGllbnQgaGFzIHNldCBuZXcgZGF0YSBpbnRvIHRoZSBncmlkICovXG4gICAgRXZlbnRzLkVWRU5UX1JPV19EQVRBX0NIQU5HRUQgPSAncm93RGF0YUNoYW5nZWQnO1xuICAgIC8qKiBUaGUgY2xpZW50IGhhcyB1cGRhdGVkIGRhdGEgZm9yIHRoZSBncmlkICovXG4gICAgRXZlbnRzLkVWRU5UX1JPV19EQVRBX1VQREFURUQgPSAncm93RGF0YVVwZGF0ZWQnO1xuICAgIC8qKiBUaGUgY2xpZW50IGhhcyBzZXQgbmV3IGZsb2F0aW5nIGRhdGEgaW50byB0aGUgZ3JpZCAqL1xuICAgIEV2ZW50cy5FVkVOVF9QSU5ORURfUk9XX0RBVEFfQ0hBTkdFRCA9ICdwaW5uZWRSb3dEYXRhQ2hhbmdlZCc7XG4gICAgLyoqIFJhbmdlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZCAqL1xuICAgIEV2ZW50cy5FVkVOVF9SQU5HRV9TRUxFQ1RJT05fQ0hBTkdFRCA9ICdyYW5nZVNlbGVjdGlvbkNoYW5nZWQnO1xuICAgIC8qKiBNb2RlbCB3YXMgdXBkYXRlZCAtIGdyaWQgdXBkYXRlcyB0aGUgZHJhd24gcm93cyB3aGVuIHRoaXMgaGFwcGVucyAqL1xuICAgIEV2ZW50cy5FVkVOVF9NT0RFTF9VUERBVEVEID0gJ21vZGVsVXBkYXRlZCc7XG4gICAgRXZlbnRzLkVWRU5UX0NFTExfQ0xJQ0tFRCA9ICdjZWxsQ2xpY2tlZCc7XG4gICAgRXZlbnRzLkVWRU5UX0NFTExfRE9VQkxFX0NMSUNLRUQgPSAnY2VsbERvdWJsZUNsaWNrZWQnO1xuICAgIEV2ZW50cy5FVkVOVF9DRUxMX0NPTlRFWFRfTUVOVSA9ICdjZWxsQ29udGV4dE1lbnUnO1xuICAgIEV2ZW50cy5FVkVOVF9DRUxMX1ZBTFVFX0NIQU5HRUQgPSAnY2VsbFZhbHVlQ2hhbmdlZCc7XG4gICAgRXZlbnRzLkVWRU5UX1JPV19WQUxVRV9DSEFOR0VEID0gJ3Jvd1ZhbHVlQ2hhbmdlZCc7XG4gICAgRXZlbnRzLkVWRU5UX0NFTExfRk9DVVNFRCA9ICdjZWxsRm9jdXNlZCc7XG4gICAgRXZlbnRzLkVWRU5UX1JPV19TRUxFQ1RFRCA9ICdyb3dTZWxlY3RlZCc7XG4gICAgRXZlbnRzLkVWRU5UX1NFTEVDVElPTl9DSEFOR0VEID0gJ3NlbGVjdGlvbkNoYW5nZWQnO1xuICAgIEV2ZW50cy5FVkVOVF9DRUxMX01PVVNFX09WRVIgPSAnY2VsbE1vdXNlT3Zlcic7XG4gICAgRXZlbnRzLkVWRU5UX0NFTExfTU9VU0VfT1VUID0gJ2NlbGxNb3VzZU91dCc7XG4gICAgLyoqIDIgZXZlbnRzIGZvciBmaWx0ZXJpbmcuIFRoZSBncmlkIExJU1RFTlMgZm9yIGZpbHRlckNoYW5nZWQgYW5kIGFmdGVyRmlsdGVyQ2hhbmdlZCAqL1xuICAgIEV2ZW50cy5FVkVOVF9GSUxURVJfQ0hBTkdFRCA9ICdmaWx0ZXJDaGFuZ2VkJztcbiAgICAvKiogRmlsdGVyIHdhcyBjaGFuZ2UgYnV0IG5vdCBhcHBsaWVkLiBPbmx5IHVzZWZ1bCBpZiBhcHBseSBidXR0b25zIGFyZSB1c2VkIGluIGZpbHRlcnMuICovXG4gICAgRXZlbnRzLkVWRU5UX0ZJTFRFUl9NT0RJRklFRCA9ICdmaWx0ZXJNb2RpZmllZCc7XG4gICAgRXZlbnRzLkVWRU5UX1NPUlRfQ0hBTkdFRCA9ICdzb3J0Q2hhbmdlZCc7XG4gICAgLyoqIEEgcm93IHdhcyByZW1vdmVkIGZyb20gdGhlIGRvbSwgZm9yIGFueSByZWFzb24uIFVzZSB0byBjbGVhbiB1cCByZXNvdXJjZXMgKGlmIGFueSkgdXNlZCBieSB0aGUgcm93LiAqL1xuICAgIEV2ZW50cy5FVkVOVF9WSVJUVUFMX1JPV19SRU1PVkVEID0gJ3ZpcnR1YWxSb3dSZW1vdmVkJztcbiAgICBFdmVudHMuRVZFTlRfUk9XX0NMSUNLRUQgPSAncm93Q2xpY2tlZCc7XG4gICAgRXZlbnRzLkVWRU5UX1JPV19ET1VCTEVfQ0xJQ0tFRCA9ICdyb3dEb3VibGVDbGlja2VkJztcbiAgICAvKiogR2V0cyBjYWxsZWQgb25jZSBhZnRlciB0aGUgZ3JpZCBoYXMgZmluaXNoZWQgaW5pdGlhbGlzaW5nLiAqL1xuICAgIEV2ZW50cy5FVkVOVF9HUklEX1JFQURZID0gJ2dyaWRSZWFkeSc7XG4gICAgLyoqIFdpZHRoIG9mIGhlaWdodCBvZiB0aGUgbWFpbiBncmlkIGRpdiBoYXMgY2hhbmdlZC4gR3JpZCBsaXN0ZW5zIGZvciB0aGlzIGFuZCBkb2VzIGxheW91dCBvZiBncmlkIGlmIGl0J3NcbiAgICAgKiBjaGFuZ2VkLCBzbyBhbHdheXMgZmlsbGluZyB0aGUgc3BhY2UgaXQgd2FzIGdpdmVuLiAqL1xuICAgIEV2ZW50cy5FVkVOVF9HUklEX1NJWkVfQ0hBTkdFRCA9ICdncmlkU2l6ZUNoYW5nZWQnO1xuICAgIC8qKiBUaGUgaW5kZXhlcyBvZiB0aGUgcm93cyByZW5kZXJlZCBoYXMgY2hhbmdlZCwgZWcgdXNlciBoYXMgc2Nyb2xsZWQgdG8gYSBuZXcgdmVydGljYWwgcG9zaXRpb24uICovXG4gICAgRXZlbnRzLkVWRU5UX1ZJRVdQT1JUX0NIQU5HRUQgPSAndmlld3BvcnRDaGFuZ2VkJztcbiAgICAvKiogQSBjb2x1bW4gZHJhZyBoYXMgc3RhcnRlZCwgZWl0aGVyIHJlc2l6aW5nIGEgY29sdW1uIG9yIG1vdmluZyBhIGNvbHVtbi4gKi9cbiAgICBFdmVudHMuRVZFTlRfRFJBR19TVEFSVEVEID0gJ2RyYWdTdGFydGVkJztcbiAgICAvKiogQSBjb2x1bW4gZHJhZyBoYXMgc3RvcHBlZCAqL1xuICAgIEV2ZW50cy5FVkVOVF9EUkFHX1NUT1BQRUQgPSAnZHJhZ1N0b3BwZWQnO1xuICAgIEV2ZW50cy5FVkVOVF9ST1dfRURJVElOR19TVEFSVEVEID0gJ3Jvd0VkaXRpbmdTdGFydGVkJztcbiAgICBFdmVudHMuRVZFTlRfUk9XX0VESVRJTkdfU1RPUFBFRCA9ICdyb3dFZGl0aW5nU3RvcHBlZCc7XG4gICAgRXZlbnRzLkVWRU5UX0NFTExfRURJVElOR19TVEFSVEVEID0gJ2NlbGxFZGl0aW5nU3RhcnRlZCc7XG4gICAgRXZlbnRzLkVWRU5UX0NFTExfRURJVElOR19TVE9QUEVEID0gJ2NlbGxFZGl0aW5nU3RvcHBlZCc7XG4gICAgLyoqIE1haW4gYm9keSBvZiBncmlkIGhhcyBzY3JvbGxlZCwgZWl0aGVyIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5ICovXG4gICAgRXZlbnRzLkVWRU5UX0JPRFlfU0NST0xMID0gJ2JvZHlTY3JvbGwnO1xuICAgIC8qKiBUaGUgZGlzcGxheWVkIHBhZ2UgZm9yIHBhZ2luYXRpb24gaGFzIGNoYW5nZWQuIEZvciBleGFtcGxlIHRoZSBkYXRhIHdhcyBmaWx0ZXJlZCBvciBzb3J0ZWQsXG4gICAgICogb3IgdGhlIHVzZXIgaGFzIG1vdmVkIHRvIGEgZGlmZmVyZW50IHBhZ2UuICovXG4gICAgRXZlbnRzLkVWRU5UX1BBR0lOQVRJT05fQ0hBTkdFRCA9ICdwYWdpbmF0aW9uQ2hhbmdlZCc7XG4gICAgLyoqIE9ubHkgdXNlZCBieSBSZWFjdCwgQW5ndWxhciAyKywgV2ViIENvbXBvbmVudHMsIEF1cmVsaWEgYW5kIFZ1ZUpTIGFnLUdyaWQgY29tcG9uZW50c1xuICAgICAqIChub3QgdXNlZCBpZiBkb2luZyBwbGFpbiBKYXZhU2NyaXB0IG9yIEFuZ3VsYXIgMS54KS4gSWYgdGhlIGdyaWQgcmVjZWl2ZXMgY2hhbmdlcyBkdWVcbiAgICAgKiB0byBib3VuZCBwcm9wZXJ0aWVzLCB0aGlzIGV2ZW50IGZpcmVzIGFmdGVyIHRoZSBncmlkIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSBjaGFuZ2UuICovXG4gICAgRXZlbnRzLkVWRU5UX0NPTVBPTkVOVF9TVEFURV9DSEFOR0VEID0gJ2NvbXBvbmVudFN0YXRlQ2hhbmdlZCc7XG4gICAgLyoqIEFsbCBpdGVtcyBmcm9tIGhlcmUgZG93biBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBncmlkLCBub3QgaW50ZW5kZWQgZm9yIGV4dGVybmFsIHVzZS4gKi9cbiAgICAvLyBub3QgZG9jdW1lbnRlZCwgZWl0aGVyIGV4cGVyaW1lbnRhbCwgb3Igd2UganVzdCBkb24ndCB3YW50IHVzZXJzIHVzaW5nIGFuIGRkZXBlbmRpbmcgb24gdGhlbVxuICAgIEV2ZW50cy5FVkVOVF9CT0RZX0hFSUdIVF9DSEFOR0VEID0gJ2JvZHlIZWlnaHRDaGFuZ2VkJztcbiAgICBFdmVudHMuRVZFTlRfRElTUExBWUVEX0NPTFVNTlNfV0lEVEhfQ0hBTkdFRCA9ICdkaXNwbGF5ZWRDb2x1bW5zV2lkdGhDaGFuZ2VkJztcbiAgICBFdmVudHMuRVZFTlRfU0NST0xMX1ZJU0lCSUxJVFlfQ0hBTkdFRCA9ICdzY3JvbGxWaXNpYmlsaXR5Q2hhbmdlZCc7XG4gICAgRXZlbnRzLkVWRU5UX0NPTFVNTl9IT1ZFUl9DSEFOR0VEID0gJ2NvbHVtbkhvdmVyQ2hhbmdlZCc7XG4gICAgRXZlbnRzLkVWRU5UX0ZMQVNIX0NFTExTID0gJ2ZsYXNoQ2VsbHMnO1xuICAgIC8vIHRoZXNlIGFyZSB1c2VkIGZvciBzZXJ2ZXIgc2lkZSBncm91cCBhbmQgYWdnIC0gb25seSB1c2VkIGJ5IENTIHdpdGggVmlld3BvcnQgUm93IE1vZGVsIC0gaW50ZW50aW9uIGlzXG4gICAgLy8gdG8gZGVzaWduIHRoZXNlIGJldHRlciBhcm91bmQgc2VydmVyIHNpZGUgZnVuY3Rpb25zIGFuZCB0aGVuIHJlbGVhc2UgdG8gZ2VuZXJhbCBwdWJsaWMgd2hlbiBmdWxseSB3b3JraW5nIHdpdGhcbiAgICAvLyBhbGwgdGhlIHJvdyBtb2RlbHMuXG4gICAgRXZlbnRzLkVWRU5UX0NPTFVNTl9ST1dfR1JPVVBfQ0hBTkdFX1JFUVVFU1QgPSAnY29sdW1uUm93R3JvdXBDaGFuZ2VSZXF1ZXN0JztcbiAgICBFdmVudHMuRVZFTlRfQ09MVU1OX1BJVk9UX0NIQU5HRV9SRVFVRVNUID0gJ2NvbHVtblBpdm90Q2hhbmdlUmVxdWVzdCc7XG4gICAgRXZlbnRzLkVWRU5UX0NPTFVNTl9WQUxVRV9DSEFOR0VfUkVRVUVTVCA9ICdjb2x1bW5WYWx1ZUNoYW5nZVJlcXVlc3QnO1xuICAgIEV2ZW50cy5FVkVOVF9DT0xVTU5fQUdHX0ZVTkNfQ0hBTkdFX1JFUVVFU1QgPSAnY29sdW1uQWdnRnVuY0NoYW5nZVJlcXVlc3QnO1xuICAgIHJldHVybiBFdmVudHM7XG59KCkpO1xuZXhwb3J0cy5FdmVudHMgPSBFdmVudHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9ldmVudEtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBkYXRlRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9kYXRlRmlsdGVyXCIpO1xudmFyIGNvbXBvbmVudEFubm90YXRpb25zXzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9jb21wb25lbnRBbm5vdGF0aW9uc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIGNvbXBvbmVudFJlY2lwZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2ZyYW1ld29yay9jb21wb25lbnRSZWNpcGVzXCIpO1xudmFyIGNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4uL3dpZGdldHMvY29tcG9uZW50XCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBJbnB1dFRleHRGbG9hdGluZ0ZpbHRlckNvbXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnB1dFRleHRGbG9hdGluZ0ZpbHRlckNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5wdXRUZXh0RmxvYXRpbmdGaWx0ZXJDb21wKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIjxkaXY+PGlucHV0ICByZWY9XFxcImVDb2x1bW5GbG9hdGluZ0ZpbHRlclxcXCIgY2xhc3M9XFxcImFnLWZsb2F0aW5nLWZpbHRlci1pbnB1dFxcXCI+PC9kaXY+XCIpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxhc3RLbm93bk1vZGVsID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnB1dFRleHRGbG9hdGluZ0ZpbHRlckNvbXAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMub25GbG9hdGluZ0ZpbHRlckNoYW5nZWQgPSBwYXJhbXMub25GbG9hdGluZ0ZpbHRlckNoYW5nZWQ7XG4gICAgICAgIHRoaXMuY3VycmVudFBhcmVudE1vZGVsID0gcGFyYW1zLmN1cnJlbnRQYXJlbnRNb2RlbDtcbiAgICAgICAgdmFyIGRlYm91bmNlTXMgPSBwYXJhbXMuZGVib3VuY2VNcyAhPSBudWxsID8gcGFyYW1zLmRlYm91bmNlTXMgOiA1MDA7XG4gICAgICAgIHZhciB0b0RlYm91bmNlID0gdXRpbHNfMS5fLmRlYm91bmNlKHRoaXMuc3luY1VwV2l0aFBhcmVudEZpbHRlci5iaW5kKHRoaXMpLCBkZWJvdW5jZU1zKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5lQ29sdW1uRmxvYXRpbmdGaWx0ZXIsICdpbnB1dCcsIHRvRGVib3VuY2UpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVDb2x1bW5GbG9hdGluZ0ZpbHRlciwgJ2tleXByZXNzJywgdG9EZWJvdW5jZSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZUNvbHVtbkZsb2F0aW5nRmlsdGVyLCAna2V5ZG93bicsIHRvRGVib3VuY2UpO1xuICAgICAgICB2YXIgY29sdW1uRGVmID0gcGFyYW1zLmNvbHVtbi5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIGlmIChjb2x1bW5EZWYuZmlsdGVyUGFyYW1zICYmIGNvbHVtbkRlZi5maWx0ZXJQYXJhbXMuZmlsdGVyT3B0aW9ucyAmJiBjb2x1bW5EZWYuZmlsdGVyUGFyYW1zLmZpbHRlck9wdGlvbnMubGVuZ3RoID09PSAxICYmIGNvbHVtbkRlZi5maWx0ZXJQYXJhbXMuZmlsdGVyT3B0aW9uc1swXSA9PT0gJ2luUmFuZ2UnKSB7XG4gICAgICAgICAgICB0aGlzLmVDb2x1bW5GbG9hdGluZ0ZpbHRlci5yZWFkT25seSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0VGV4dEZsb2F0aW5nRmlsdGVyQ29tcC5wcm90b3R5cGUub25QYXJlbnRNb2RlbENoYW5nZWQgPSBmdW5jdGlvbiAocGFyZW50TW9kZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuZXF1YWxNb2RlbHModGhpcy5sYXN0S25vd25Nb2RlbCwgcGFyZW50TW9kZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxhc3RLbm93bk1vZGVsID0gcGFyZW50TW9kZWw7XG4gICAgICAgIHZhciBpbmNvbWluZ1RleHRWYWx1ZSA9IHRoaXMuYXNGbG9hdGluZ0ZpbHRlclRleHQocGFyZW50TW9kZWwpO1xuICAgICAgICBpZiAoaW5jb21pbmdUZXh0VmFsdWUgPT09IHRoaXMuZUNvbHVtbkZsb2F0aW5nRmlsdGVyLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVDb2x1bW5GbG9hdGluZ0ZpbHRlci52YWx1ZSA9IGluY29taW5nVGV4dFZhbHVlO1xuICAgIH07XG4gICAgSW5wdXRUZXh0RmxvYXRpbmdGaWx0ZXJDb21wLnByb3RvdHlwZS5zeW5jVXBXaXRoUGFyZW50RmlsdGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5hc1BhcmVudE1vZGVsKCk7XG4gICAgICAgIGlmICh0aGlzLmVxdWFsTW9kZWxzKHRoaXMubGFzdEtub3duTW9kZWwsIG1vZGVsKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG1vZGVsVXBkYXRlZCA9IG51bGw7XG4gICAgICAgIGlmICh1dGlsc18xLl8uaXNLZXlQcmVzc2VkKGUsIGNvbnN0YW50c18xLkNvbnN0YW50cy5LRVlfRU5URVIpKSB7XG4gICAgICAgICAgICBtb2RlbFVwZGF0ZWQgPSB0aGlzLm9uRmxvYXRpbmdGaWx0ZXJDaGFuZ2VkKHtcbiAgICAgICAgICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICAgICAgICAgYXBwbHk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9kZWxVcGRhdGVkID0gdGhpcy5vbkZsb2F0aW5nRmlsdGVyQ2hhbmdlZCh7XG4gICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGVsVXBkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0S25vd25Nb2RlbCA9IG1vZGVsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dFRleHRGbG9hdGluZ0ZpbHRlckNvbXAucHJvdG90eXBlLmVxdWFsTW9kZWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmICh1dGlsc18xLl8ucmVmZXJlbmNlQ29tcGFyZShsZWZ0LCByaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCFsZWZ0IHx8ICFyaWdodClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGVmdCkgfHwgQXJyYXkuaXNBcnJheShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAodXRpbHNfMS5fLnJlZmVyZW5jZUNvbXBhcmUobGVmdC50eXBlLCByaWdodC50eXBlKSAmJlxuICAgICAgICAgICAgdXRpbHNfMS5fLnJlZmVyZW5jZUNvbXBhcmUobGVmdC5maWx0ZXIsIHJpZ2h0LmZpbHRlcikgJiZcbiAgICAgICAgICAgIHV0aWxzXzEuXy5yZWZlcmVuY2VDb21wYXJlKGxlZnQuZmlsdGVyVG8sIHJpZ2h0LmZpbHRlclRvKSAmJlxuICAgICAgICAgICAgdXRpbHNfMS5fLnJlZmVyZW5jZUNvbXBhcmUobGVmdC5maWx0ZXJUeXBlLCByaWdodC5maWx0ZXJUeXBlKSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5SZWZTZWxlY3RvcignZUNvbHVtbkZsb2F0aW5nRmlsdGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MSW5wdXRFbGVtZW50KVxuICAgIF0sIElucHV0VGV4dEZsb2F0aW5nRmlsdGVyQ29tcC5wcm90b3R5cGUsIFwiZUNvbHVtbkZsb2F0aW5nRmlsdGVyXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIElucHV0VGV4dEZsb2F0aW5nRmlsdGVyQ29tcDtcbn0oY29tcG9uZW50XzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLklucHV0VGV4dEZsb2F0aW5nRmlsdGVyQ29tcCA9IElucHV0VGV4dEZsb2F0aW5nRmlsdGVyQ29tcDtcbnZhciBUZXh0RmxvYXRpbmdGaWx0ZXJDb21wID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dEZsb2F0aW5nRmlsdGVyQ29tcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0RmxvYXRpbmdGaWx0ZXJDb21wKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRleHRGbG9hdGluZ0ZpbHRlckNvbXAucHJvdG90eXBlLmFzRmxvYXRpbmdGaWx0ZXJUZXh0ID0gZnVuY3Rpb24gKHBhcmVudE1vZGVsKSB7XG4gICAgICAgIGlmICghcGFyZW50TW9kZWwpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIHJldHVybiBwYXJlbnRNb2RlbC5maWx0ZXI7XG4gICAgfTtcbiAgICBUZXh0RmxvYXRpbmdGaWx0ZXJDb21wLnByb3RvdHlwZS5hc1BhcmVudE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudFBhcmVudE1vZGVsID0gdGhpcy5jdXJyZW50UGFyZW50TW9kZWwoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGN1cnJlbnRQYXJlbnRNb2RlbC50eXBlLFxuICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmVDb2x1bW5GbG9hdGluZ0ZpbHRlci52YWx1ZSxcbiAgICAgICAgICAgIGZpbHRlclR5cGU6ICd0ZXh0J1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRleHRGbG9hdGluZ0ZpbHRlckNvbXA7XG59KElucHV0VGV4dEZsb2F0aW5nRmlsdGVyQ29tcCkpO1xuZXhwb3J0cy5UZXh0RmxvYXRpbmdGaWx0ZXJDb21wID0gVGV4dEZsb2F0aW5nRmlsdGVyQ29tcDtcbnZhciBEYXRlRmxvYXRpbmdGaWx0ZXJDb21wID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZUZsb2F0aW5nRmlsdGVyQ29tcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlRmxvYXRpbmdGaWx0ZXJDb21wKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGFzdEtub3duTW9kZWwgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERhdGVGbG9hdGluZ0ZpbHRlckNvbXAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMub25GbG9hdGluZ0ZpbHRlckNoYW5nZWQgPSBwYXJhbXMub25GbG9hdGluZ0ZpbHRlckNoYW5nZWQ7XG4gICAgICAgIHRoaXMuY3VycmVudFBhcmVudE1vZGVsID0gcGFyYW1zLmN1cnJlbnRQYXJlbnRNb2RlbDtcbiAgICAgICAgdmFyIGRlYm91bmNlTXMgPSBwYXJhbXMuZGVib3VuY2VNcyAhPSBudWxsID8gcGFyYW1zLmRlYm91bmNlTXMgOiA1MDA7XG4gICAgICAgIHZhciB0b0RlYm91bmNlID0gdXRpbHNfMS5fLmRlYm91bmNlKHRoaXMub25EYXRlQ2hhbmdlZC5iaW5kKHRoaXMpLCBkZWJvdW5jZU1zKTtcbiAgICAgICAgdmFyIGRhdGVDb21wb25lbnRQYXJhbXMgPSB7XG4gICAgICAgICAgICBvbkRhdGVDaGFuZ2VkOiB0b0RlYm91bmNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0ZUNvbXBvbmVudFByb21pc2UgPSB0aGlzLmNvbXBvbmVudFJlY2lwZXMubmV3RGF0ZUNvbXBvbmVudChkYXRlQ29tcG9uZW50UGFyYW1zKTtcbiAgICAgICAgdmFyIGJvZHkgPSB1dGlsc18xLl8ubG9hZFRlbXBsYXRlKFwiPGRpdj48L2Rpdj5cIik7XG4gICAgICAgIHRoaXMuZGF0ZUNvbXBvbmVudFByb21pc2UudGhlbihmdW5jdGlvbiAoZGF0ZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChkYXRlQ29tcG9uZW50LmdldEd1aSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0VGVtcGxhdGVGcm9tRWxlbWVudChib2R5KTtcbiAgICB9O1xuICAgIERhdGVGbG9hdGluZ0ZpbHRlckNvbXAucHJvdG90eXBlLm9uRGF0ZUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnRNb2RlbCA9IHRoaXMuY3VycmVudFBhcmVudE1vZGVsKCk7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXNQYXJlbnRNb2RlbCgpO1xuICAgICAgICBpZiAodGhpcy5lcXVhbE1vZGVscyhwYXJlbnRNb2RlbCwgbW9kZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9uRmxvYXRpbmdGaWx0ZXJDaGFuZ2VkKHtcbiAgICAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgICAgIGFwcGx5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhc3RLbm93bk1vZGVsID0gbW9kZWw7XG4gICAgfTtcbiAgICBEYXRlRmxvYXRpbmdGaWx0ZXJDb21wLnByb3RvdHlwZS5lcXVhbE1vZGVscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAodXRpbHNfMS5fLnJlZmVyZW5jZUNvbXBhcmUobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghbGVmdCB8fCAhcmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxlZnQpIHx8IEFycmF5LmlzQXJyYXkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gKHV0aWxzXzEuXy5yZWZlcmVuY2VDb21wYXJlKGxlZnQudHlwZSwgcmlnaHQudHlwZSkgJiZcbiAgICAgICAgICAgIHV0aWxzXzEuXy5yZWZlcmVuY2VDb21wYXJlKGxlZnQuZGF0ZUZyb20sIHJpZ2h0LmRhdGVGcm9tKSAmJlxuICAgICAgICAgICAgdXRpbHNfMS5fLnJlZmVyZW5jZUNvbXBhcmUobGVmdC5kYXRlVG8sIHJpZ2h0LmRhdGVUbykgJiZcbiAgICAgICAgICAgIHV0aWxzXzEuXy5yZWZlcmVuY2VDb21wYXJlKGxlZnQuZmlsdGVyVHlwZSwgcmlnaHQuZmlsdGVyVHlwZSkpO1xuICAgIH07XG4gICAgRGF0ZUZsb2F0aW5nRmlsdGVyQ29tcC5wcm90b3R5cGUuYXNQYXJlbnRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRQYXJlbnRNb2RlbCA9IHRoaXMuY3VycmVudFBhcmVudE1vZGVsKCk7XG4gICAgICAgIHZhciBmaWx0ZXJWYWx1ZURhdGUgPSB0aGlzLmRhdGVDb21wb25lbnRQcm9taXNlLnJlc29sdmVOb3cobnVsbCwgZnVuY3Rpb24gKGRhdGVDb21wb25lbnQpIHsgcmV0dXJuIGRhdGVDb21wb25lbnQuZ2V0RGF0ZSgpOyB9KTtcbiAgICAgICAgdmFyIGZpbHRlclZhbHVlVGV4dCA9IHV0aWxzXzEuXy5zZXJpYWxpemVEYXRlVG9ZeXl5TW1EZChkYXRlRmlsdGVyXzEuRGF0ZUZpbHRlci5yZW1vdmVUaW1lem9uZShmaWx0ZXJWYWx1ZURhdGUpLCBcIi1cIik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBjdXJyZW50UGFyZW50TW9kZWwudHlwZSxcbiAgICAgICAgICAgIGRhdGVGcm9tOiBmaWx0ZXJWYWx1ZVRleHQsXG4gICAgICAgICAgICBkYXRlVG86IGN1cnJlbnRQYXJlbnRNb2RlbCA/IGN1cnJlbnRQYXJlbnRNb2RlbC5kYXRlVG8gOiBudWxsLFxuICAgICAgICAgICAgZmlsdGVyVHlwZTogJ2RhdGUnXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEYXRlRmxvYXRpbmdGaWx0ZXJDb21wLnByb3RvdHlwZS5vblBhcmVudE1vZGVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChwYXJlbnRNb2RlbCkge1xuICAgICAgICB0aGlzLmxhc3RLbm93bk1vZGVsID0gcGFyZW50TW9kZWw7XG4gICAgICAgIHRoaXMuZGF0ZUNvbXBvbmVudFByb21pc2UudGhlbihmdW5jdGlvbiAoZGF0ZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRNb2RlbCB8fCAhcGFyZW50TW9kZWwuZGF0ZUZyb20pIHtcbiAgICAgICAgICAgICAgICBkYXRlQ29tcG9uZW50LnNldERhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZUNvbXBvbmVudC5zZXREYXRlKHV0aWxzXzEuXy5wYXJzZVl5eXlNbURkVG9EYXRlKHBhcmVudE1vZGVsLmRhdGVGcm9tLCAnLScpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29tcG9uZW50UmVjaXBlcycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29tcG9uZW50UmVjaXBlc18xLkNvbXBvbmVudFJlY2lwZXMpXG4gICAgXSwgRGF0ZUZsb2F0aW5nRmlsdGVyQ29tcC5wcm90b3R5cGUsIFwiY29tcG9uZW50UmVjaXBlc1wiLCB2b2lkIDApO1xuICAgIHJldHVybiBEYXRlRmxvYXRpbmdGaWx0ZXJDb21wO1xufShjb21wb25lbnRfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuRGF0ZUZsb2F0aW5nRmlsdGVyQ29tcCA9IERhdGVGbG9hdGluZ0ZpbHRlckNvbXA7XG52YXIgTnVtYmVyRmxvYXRpbmdGaWx0ZXJDb21wID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVtYmVyRmxvYXRpbmdGaWx0ZXJDb21wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bWJlckZsb2F0aW5nRmlsdGVyQ29tcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOdW1iZXJGbG9hdGluZ0ZpbHRlckNvbXAucHJvdG90eXBlLmFzRmxvYXRpbmdGaWx0ZXJUZXh0ID0gZnVuY3Rpb24gKHBhcmVudE1vZGVsKSB7XG4gICAgICAgIHZhciByYXdQYXJlbnRNb2RlbCA9IHRoaXMuY3VycmVudFBhcmVudE1vZGVsKCk7XG4gICAgICAgIGlmIChwYXJlbnRNb2RlbCA9PSBudWxsICYmIHJhd1BhcmVudE1vZGVsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGlmIChwYXJlbnRNb2RlbCA9PSBudWxsICYmIHJhd1BhcmVudE1vZGVsICE9IG51bGwgJiYgcmF3UGFyZW50TW9kZWwudHlwZSAhPT0gJ2luUmFuZ2UnKSB7XG4gICAgICAgICAgICB0aGlzLmVDb2x1bW5GbG9hdGluZ0ZpbHRlci5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYXdQYXJlbnRNb2RlbCAhPSBudWxsICYmIHJhd1BhcmVudE1vZGVsLnR5cGUgPT09ICdpblJhbmdlJykge1xuICAgICAgICAgICAgdGhpcy5lQ29sdW1uRmxvYXRpbmdGaWx0ZXIucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG51bWJlcl8xID0gdGhpcy5hc051bWJlcihyYXdQYXJlbnRNb2RlbC5maWx0ZXIpO1xuICAgICAgICAgICAgdmFyIG51bWJlclRvID0gdGhpcy5hc051bWJlcihyYXdQYXJlbnRNb2RlbC5maWx0ZXJUbyk7XG4gICAgICAgICAgICByZXR1cm4gKG51bWJlcl8xID8gbnVtYmVyXzEgKyAnJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJy0nICtcbiAgICAgICAgICAgICAgICAobnVtYmVyVG8gPyBudW1iZXJUbyArICcnIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1iZXIgPSB0aGlzLmFzTnVtYmVyKHBhcmVudE1vZGVsLmZpbHRlcik7XG4gICAgICAgIHRoaXMuZUNvbHVtbkZsb2F0aW5nRmlsdGVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBudW1iZXIgIT0gbnVsbCA/IG51bWJlciArICcnIDogJyc7XG4gICAgfTtcbiAgICBOdW1iZXJGbG9hdGluZ0ZpbHRlckNvbXAucHJvdG90eXBlLmFzUGFyZW50TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50UGFyZW50TW9kZWwgPSB0aGlzLmN1cnJlbnRQYXJlbnRNb2RlbCgpO1xuICAgICAgICB2YXIgZmlsdGVyVmFsdWVOdW1iZXIgPSB0aGlzLmFzTnVtYmVyKHRoaXMuZUNvbHVtbkZsb2F0aW5nRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgdmFyIGZpbHRlclZhbHVlVGV4dCA9IHRoaXMuZUNvbHVtbkZsb2F0aW5nRmlsdGVyLnZhbHVlO1xuICAgICAgICB2YXIgbW9kZWxGaWx0ZXJWYWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChmaWx0ZXJWYWx1ZU51bWJlciA9PSBudWxsICYmIGZpbHRlclZhbHVlVGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgIG1vZGVsRmlsdGVyVmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlclZhbHVlTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vZGVsRmlsdGVyVmFsdWUgPSBjdXJyZW50UGFyZW50TW9kZWwuZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9kZWxGaWx0ZXJWYWx1ZSA9IGZpbHRlclZhbHVlTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBjdXJyZW50UGFyZW50TW9kZWwudHlwZSxcbiAgICAgICAgICAgIGZpbHRlcjogbW9kZWxGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgIGZpbHRlclRvOiAhY3VycmVudFBhcmVudE1vZGVsID8gbnVsbCA6IGN1cnJlbnRQYXJlbnRNb2RlbC5maWx0ZXJUbyxcbiAgICAgICAgICAgIGZpbHRlclR5cGU6ICdudW1iZXInXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBOdW1iZXJGbG9hdGluZ0ZpbHRlckNvbXAucHJvdG90eXBlLmFzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGFzTnVtYmVyID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgdmFyIGludmFsaWROdW1iZXIgPSAhdXRpbHNfMS5fLmlzTnVtZXJpYyhhc051bWJlcik7XG4gICAgICAgIHJldHVybiBpbnZhbGlkTnVtYmVyID8gbnVsbCA6IGFzTnVtYmVyO1xuICAgIH07XG4gICAgcmV0dXJuIE51bWJlckZsb2F0aW5nRmlsdGVyQ29tcDtcbn0oSW5wdXRUZXh0RmxvYXRpbmdGaWx0ZXJDb21wKSk7XG5leHBvcnRzLk51bWJlckZsb2F0aW5nRmlsdGVyQ29tcCA9IE51bWJlckZsb2F0aW5nRmlsdGVyQ29tcDtcbnZhciBTZXRGbG9hdGluZ0ZpbHRlckNvbXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXRGbG9hdGluZ0ZpbHRlckNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2V0RmxvYXRpbmdGaWx0ZXJDb21wKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNldEZsb2F0aW5nRmlsdGVyQ29tcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5lQ29sdW1uRmxvYXRpbmdGaWx0ZXIucmVhZE9ubHkgPSB0cnVlO1xuICAgIH07XG4gICAgU2V0RmxvYXRpbmdGaWx0ZXJDb21wLnByb3RvdHlwZS5hc0Zsb2F0aW5nRmlsdGVyVGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRNb2RlbCkge1xuICAgICAgICBpZiAoIXBhcmVudE1vZGVsIHx8IHBhcmVudE1vZGVsLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgdmFyIGFycmF5VG9EaXNwbGF5ID0gcGFyZW50TW9kZWwubGVuZ3RoID4gMTAgPyBwYXJlbnRNb2RlbC5zbGljZSgwLCAxMCkuY29uY2F0KFsnLi4uJ10pIDogcGFyZW50TW9kZWw7XG4gICAgICAgIHJldHVybiBcIihcIiArIHBhcmVudE1vZGVsLmxlbmd0aCArIFwiKSBcIiArIGFycmF5VG9EaXNwbGF5LmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgU2V0RmxvYXRpbmdGaWx0ZXJDb21wLnByb3RvdHlwZS5hc1BhcmVudE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lQ29sdW1uRmxvYXRpbmdGaWx0ZXIudmFsdWUgPT0gbnVsbCB8fCB0aGlzLmVDb2x1bW5GbG9hdGluZ0ZpbHRlci52YWx1ZSA9PT0gJycpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZUNvbHVtbkZsb2F0aW5nRmlsdGVyLnZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXRGbG9hdGluZ0ZpbHRlckNvbXA7XG59KElucHV0VGV4dEZsb2F0aW5nRmlsdGVyQ29tcCkpO1xuZXhwb3J0cy5TZXRGbG9hdGluZ0ZpbHRlckNvbXAgPSBTZXRGbG9hdGluZ0ZpbHRlckNvbXA7XG52YXIgUmVhZE1vZGVsQXNTdHJpbmdGbG9hdGluZ0ZpbHRlckNvbXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkTW9kZWxBc1N0cmluZ0Zsb2F0aW5nRmlsdGVyQ29tcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWFkTW9kZWxBc1N0cmluZ0Zsb2F0aW5nRmlsdGVyQ29tcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZWFkTW9kZWxBc1N0cmluZ0Zsb2F0aW5nRmlsdGVyQ29tcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5lQ29sdW1uRmxvYXRpbmdGaWx0ZXIucmVhZE9ubHkgPSB0cnVlO1xuICAgIH07XG4gICAgUmVhZE1vZGVsQXNTdHJpbmdGbG9hdGluZ0ZpbHRlckNvbXAucHJvdG90eXBlLm9uUGFyZW50TW9kZWxDaGFuZ2VkID0gZnVuY3Rpb24gKHBhcmVudE1vZGVsKSB7XG4gICAgICAgIHRoaXMuZUNvbHVtbkZsb2F0aW5nRmlsdGVyLnZhbHVlID0gdGhpcy5hc0Zsb2F0aW5nRmlsdGVyVGV4dCh0aGlzLmN1cnJlbnRQYXJlbnRNb2RlbCgpKTtcbiAgICB9O1xuICAgIFJlYWRNb2RlbEFzU3RyaW5nRmxvYXRpbmdGaWx0ZXJDb21wLnByb3RvdHlwZS5hc0Zsb2F0aW5nRmlsdGVyVGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRNb2RlbCkge1xuICAgICAgICByZXR1cm4gcGFyZW50TW9kZWw7XG4gICAgfTtcbiAgICBSZWFkTW9kZWxBc1N0cmluZ0Zsb2F0aW5nRmlsdGVyQ29tcC5wcm90b3R5cGUuYXNQYXJlbnRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gUmVhZE1vZGVsQXNTdHJpbmdGbG9hdGluZ0ZpbHRlckNvbXA7XG59KElucHV0VGV4dEZsb2F0aW5nRmlsdGVyQ29tcCkpO1xuZXhwb3J0cy5SZWFkTW9kZWxBc1N0cmluZ0Zsb2F0aW5nRmlsdGVyQ29tcCA9IFJlYWRNb2RlbEFzU3RyaW5nRmxvYXRpbmdGaWx0ZXJDb21wO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvZmlsdGVyL2Zsb2F0aW5nRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgY29sdW1uXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvY29sdW1uXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgc2V0TGVmdEZlYXR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJpbmcvZmVhdHVyZXMvc2V0TGVmdEZlYXR1cmVcIik7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgY29tcG9uZW50QW5ub3RhdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi93aWRnZXRzL2NvbXBvbmVudEFubm90YXRpb25zXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBiZWFuc18xID0gcmVxdWlyZShcIi4uL3JlbmRlcmluZy9iZWFuc1wiKTtcbnZhciBCYXNlRmlsdGVyV3JhcHBlckNvbXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNlRmlsdGVyV3JhcHBlckNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFzZUZpbHRlcldyYXBwZXJDb21wKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEJhc2VGaWx0ZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBwYXJhbXMuY29sdW1uO1xuICAgICAgICB2YXIgYmFzZSA9IHV0aWxzXzEuXy5sb2FkVGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJhZy1oZWFkZXItY2VsbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjxkaXYgY2xhc3M9XFxcImFnLWZsb2F0aW5nLWZpbHRlci1ib2R5XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9kaXY+PC9kaXY+XCIpO1xuICAgICAgICB0aGlzLmVucmljaEJvZHkoYmFzZSk7XG4gICAgICAgIHRoaXMuc2V0VGVtcGxhdGVGcm9tRWxlbWVudChiYXNlKTtcbiAgICAgICAgdGhpcy5zZXR1cFdpZHRoKCk7XG4gICAgICAgIHZhciBzZXRMZWZ0RmVhdHVyZSA9IG5ldyBzZXRMZWZ0RmVhdHVyZV8xLlNldExlZnRGZWF0dXJlKHRoaXMuY29sdW1uLCB0aGlzLmdldEd1aSgpLCB0aGlzLmJlYW5zKTtcbiAgICAgICAgc2V0TGVmdEZlYXR1cmUuaW5pdCgpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lGdW5jKHNldExlZnRGZWF0dXJlLmRlc3Ryb3kuYmluZChzZXRMZWZ0RmVhdHVyZSkpO1xuICAgIH07XG4gICAgQmFzZUZpbHRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5zZXR1cFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmNvbHVtbiwgY29sdW1uXzEuQ29sdW1uLkVWRU5UX1dJRFRIX0NIQU5HRUQsIHRoaXMub25Db2x1bW5XaWR0aENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub25Db2x1bW5XaWR0aENoYW5nZWQoKTtcbiAgICB9O1xuICAgIEJhc2VGaWx0ZXJXcmFwcGVyQ29tcC5wcm90b3R5cGUub25Db2x1bW5XaWR0aENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ2V0R3VpKCkuc3R5bGUud2lkdGggPSB0aGlzLmNvbHVtbi5nZXRBY3R1YWxXaWR0aCgpICsgJ3B4JztcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb250ZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb250ZXh0XzEuQ29udGV4dClcbiAgICBdLCBCYXNlRmlsdGVyV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnYmVhbnMnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGJlYW5zXzEuQmVhbnMpXG4gICAgXSwgQmFzZUZpbHRlcldyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJiZWFuc1wiLCB2b2lkIDApO1xuICAgIHJldHVybiBCYXNlRmlsdGVyV3JhcHBlckNvbXA7XG59KGNvbXBvbmVudF8xLkNvbXBvbmVudCkpO1xuZXhwb3J0cy5CYXNlRmlsdGVyV3JhcHBlckNvbXAgPSBCYXNlRmlsdGVyV3JhcHBlckNvbXA7XG52YXIgRmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLmZsb2F0aW5nRmlsdGVyQ29tcFByb21pc2UgPSBwYXJhbXMuZmxvYXRpbmdGaWx0ZXJDb21wO1xuICAgICAgICB0aGlzLnN1cHByZXNzRmlsdGVyQnV0dG9uID0gcGFyYW1zLnN1cHByZXNzRmlsdGVyQnV0dG9uO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1cHByZXNzRmlsdGVyQnV0dG9uICYmIHRoaXMuZUJ1dHRvblNob3dNYWluRmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVCdXR0b25TaG93TWFpbkZpbHRlciwgJ2NsaWNrJywgdGhpcy5zaG93UGFyZW50RmlsdGVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5lbnJpY2hCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5mbG9hdGluZ0ZpbHRlckNvbXBQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGZsb2F0aW5nRmlsdGVyQ29tcCkge1xuICAgICAgICAgICAgdmFyIGZsb2F0aW5nRmlsdGVyQm9keSA9IGJvZHkucXVlcnlTZWxlY3RvcignLmFnLWZsb2F0aW5nLWZpbHRlci1ib2R5Jyk7XG4gICAgICAgICAgICB2YXIgZmxvYXRpbmdGaWx0ZXJDb21wVWkgPSBmbG9hdGluZ0ZpbHRlckNvbXAuZ2V0R3VpKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3VwcHJlc3NGaWx0ZXJCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBmbG9hdGluZ0ZpbHRlckJvZHkuYXBwZW5kQ2hpbGQoZmxvYXRpbmdGaWx0ZXJDb21wVWkpO1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuXy5yZW1vdmVDc3NDbGFzcyhmbG9hdGluZ0ZpbHRlckJvZHksICdhZy1mbG9hdGluZy1maWx0ZXItYm9keScpO1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuXy5hZGRDc3NDbGFzcyhmbG9hdGluZ0ZpbHRlckJvZHksICdhZy1mbG9hdGluZy1maWx0ZXItZnVsbC1ib2R5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbG9hdGluZ0ZpbHRlckJvZHkuYXBwZW5kQ2hpbGQoZmxvYXRpbmdGaWx0ZXJDb21wVWkpO1xuICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQodXRpbHNfMS5fLmxvYWRUZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImFnLWZsb2F0aW5nLWZpbHRlci1idXR0b25cXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHJlZj1cXFwiZUJ1dHRvblNob3dNYWluRmlsdGVyXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XCIpKTtcbiAgICAgICAgICAgICAgICB2YXIgZUljb24gPSB1dGlsc18xLl8uY3JlYXRlSWNvbk5vU3BhbignZmlsdGVyJywgX3RoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBfdGhpcy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIGJvZHkucXVlcnlTZWxlY3RvcignYnV0dG9uJykuYXBwZW5kQ2hpbGQoZUljb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsb2F0aW5nRmlsdGVyQ29tcC5hZnRlckd1aUF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgZmxvYXRpbmdGaWx0ZXJDb21wLmFmdGVyR3VpQXR0YWNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLndpcmVRdWVyeVNlbGVjdG9ycygpO1xuICAgICAgICAgICAgX3RoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5vblBhcmVudE1vZGVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChwYXJlbnRNb2RlbCkge1xuICAgICAgICB0aGlzLmZsb2F0aW5nRmlsdGVyQ29tcFByb21pc2UudGhlbihmdW5jdGlvbiAoZmxvYXRpbmdGaWx0ZXJDb21wKSB7XG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlckNvbXAub25QYXJlbnRNb2RlbENoYW5nZWQocGFyZW50TW9kZWwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXAucHJvdG90eXBlLnNob3dQYXJlbnRGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWVudUZhY3Rvcnkuc2hvd01lbnVBZnRlckJ1dHRvbkNsaWNrKHRoaXMuY29sdW1uLCB0aGlzLmVCdXR0b25TaG93TWFpbkZpbHRlciwgJ2ZpbHRlck1lbnVUYWInLCBbJ2ZpbHRlck1lbnVUYWInXSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5SZWZTZWxlY3RvcignZUJ1dHRvblNob3dNYWluRmlsdGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MSW5wdXRFbGVtZW50KVxuICAgIF0sIEZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImVCdXR0b25TaG93TWFpbkZpbHRlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdtZW51RmFjdG9yeScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXAucHJvdG90eXBlLCBcIm1lbnVGYWN0b3J5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIHJldHVybiBGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wO1xufShCYXNlRmlsdGVyV3JhcHBlckNvbXApKTtcbmV4cG9ydHMuRmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcCA9IEZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXA7XG52YXIgRW1wdHlGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1wdHlGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcHR5RmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFbXB0eUZsb2F0aW5nRmlsdGVyV3JhcHBlckNvbXAucHJvdG90eXBlLmVucmljaEJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgIH07XG4gICAgRW1wdHlGbG9hdGluZ0ZpbHRlcldyYXBwZXJDb21wLnByb3RvdHlwZS5vblBhcmVudE1vZGVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChwYXJlbnRNb2RlbCkge1xuICAgIH07XG4gICAgcmV0dXJuIEVtcHR5RmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcDtcbn0oQmFzZUZpbHRlcldyYXBwZXJDb21wKSk7XG5leHBvcnRzLkVtcHR5RmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcCA9IEVtcHR5RmxvYXRpbmdGaWx0ZXJXcmFwcGVyQ29tcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2ZpbHRlci9mbG9hdGluZ0ZpbHRlcldyYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gZGVmYXVsdEdyb3VwQ29tcGFyYXRvcih2YWx1ZUEsIHZhbHVlQiwgbm9kZUEsIG5vZGVCLCBhY2NlbnRlZENvbXBhcmUpIHtcbiAgICBpZiAoYWNjZW50ZWRDb21wYXJlID09PSB2b2lkIDApIHsgYWNjZW50ZWRDb21wYXJlID0gZmFsc2U7IH1cbiAgICBjb25zb2xlLndhcm4oJ2FnLUdyaWQ6IFNpbmNlIGFnLWdyaWQgMTEuMC4wIGRlZmF1bHRHcm91cENvbXBhcmF0b3IgaXMgbm90IG5lY2Vzc2FyeS4gWW91IGNhbiByZW1vdmUgdGhpcyBmcm9tIHlvdXIgY29sRGVmJyk7XG4gICAgdmFyIG5vZGVBSXNHcm91cCA9IHV0aWxzXzEuVXRpbHMuZXhpc3RzKG5vZGVBKSAmJiBub2RlQS5ncm91cDtcbiAgICB2YXIgbm9kZUJJc0dyb3VwID0gdXRpbHNfMS5VdGlscy5leGlzdHMobm9kZUIpICYmIG5vZGVCLmdyb3VwO1xuICAgIHZhciBib3RoQXJlR3JvdXBzID0gbm9kZUFJc0dyb3VwICYmIG5vZGVCSXNHcm91cDtcbiAgICB2YXIgYm90aEFyZU5vcm1hbCA9ICFub2RlQUlzR3JvdXAgJiYgIW5vZGVCSXNHcm91cDtcbiAgICBpZiAoYm90aEFyZUdyb3Vwcykge1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5VdGlscy5kZWZhdWx0Q29tcGFyYXRvcihub2RlQS5rZXksIG5vZGVCLmtleSwgYWNjZW50ZWRDb21wYXJlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYm90aEFyZU5vcm1hbCkge1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5VdGlscy5kZWZhdWx0Q29tcGFyYXRvcih2YWx1ZUEsIHZhbHVlQiwgYWNjZW50ZWRDb21wYXJlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZUFJc0dyb3VwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdEdyb3VwQ29tcGFyYXRvciA9IGRlZmF1bHRHcm91cENvbXBhcmF0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9mdW5jdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIHRvdWNoTGlzdGVuZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi93aWRnZXRzL3RvdWNoTGlzdGVuZXJcIik7XG52YXIgY29tcG9uZW50QW5ub3RhdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi8uLi93aWRnZXRzL2NvbXBvbmVudEFubm90YXRpb25zXCIpO1xudmFyIG9yaWdpbmFsQ29sdW1uR3JvdXBfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnRpdGllcy9vcmlnaW5hbENvbHVtbkdyb3VwXCIpO1xudmFyIEhlYWRlckdyb3VwQ29tcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRlckdyb3VwQ29tcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkZXJHcm91cENvbXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBIZWFkZXJHcm91cENvbXAuVEVNUExBVEUpIHx8IHRoaXM7XG4gICAgfVxuICAgIEhlYWRlckdyb3VwQ29tcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuc2V0dXBMYWJlbCgpO1xuICAgICAgICB0aGlzLmFkZEdyb3VwRXhwYW5kSWNvbigpO1xuICAgICAgICB0aGlzLnNldHVwRXhwYW5kSWNvbnMoKTtcbiAgICB9O1xuICAgIEhlYWRlckdyb3VwQ29tcC5wcm90b3R5cGUuc2V0dXBFeHBhbmRJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hZGRJbkljb24oJ2NvbHVtbkdyb3VwT3BlbmVkJywgJ2FnT3BlbmVkJyk7XG4gICAgICAgIHRoaXMuYWRkSW5JY29uKCdjb2x1bW5Hcm91cENsb3NlZCcsICdhZ0Nsb3NlZCcpO1xuICAgICAgICB0aGlzLmFkZFRvdWNoQW5kQ2xpY2tMaXN0ZW5lcnModGhpcy5lQ2xvc2VJY29uKTtcbiAgICAgICAgdGhpcy5hZGRUb3VjaEFuZENsaWNrTGlzdGVuZXJzKHRoaXMuZU9wZW5JY29uKTtcbiAgICAgICAgdGhpcy51cGRhdGVJY29uVmlzaWJpbGl0eSgpO1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW5Hcm91cCA9IHRoaXMucGFyYW1zLmNvbHVtbkdyb3VwLmdldE9yaWdpbmFsQ29sdW1uR3JvdXAoKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIob3JpZ2luYWxDb2x1bW5Hcm91cCwgb3JpZ2luYWxDb2x1bW5Hcm91cF8xLk9yaWdpbmFsQ29sdW1uR3JvdXAuRVZFTlRfRVhQQU5ERURfQ0hBTkdFRCwgdGhpcy51cGRhdGVJY29uVmlzaWJpbGl0eS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIob3JpZ2luYWxDb2x1bW5Hcm91cCwgb3JpZ2luYWxDb2x1bW5Hcm91cF8xLk9yaWdpbmFsQ29sdW1uR3JvdXAuRVZFTlRfRVhQQU5EQUJMRV9DSEFOR0VELCB0aGlzLnVwZGF0ZUljb25WaXNpYmlsaXR5LmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgSGVhZGVyR3JvdXBDb21wLnByb3RvdHlwZS5hZGRUb3VjaEFuZENsaWNrTGlzdGVuZXJzID0gZnVuY3Rpb24gKGVFbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHBhbmRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3RXhwYW5kZWRWYWx1ZSA9ICFfdGhpcy5wYXJhbXMuY29sdW1uR3JvdXAuaXNFeHBhbmRlZCgpO1xuICAgICAgICAgICAgX3RoaXMuY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5Hcm91cE9wZW5lZChfdGhpcy5wYXJhbXMuY29sdW1uR3JvdXAuZ2V0T3JpZ2luYWxDb2x1bW5Hcm91cCgpLCBuZXdFeHBhbmRlZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRvdWNoTGlzdGVuZXIgPSBuZXcgdG91Y2hMaXN0ZW5lcl8xLlRvdWNoTGlzdGVuZXIodGhpcy5lQ2xvc2VJY29uKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodG91Y2hMaXN0ZW5lciwgdG91Y2hMaXN0ZW5lcl8xLlRvdWNoTGlzdGVuZXIuRVZFTlRfVEFQLCBleHBhbmRBY3Rpb24pO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lGdW5jKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvdWNoTGlzdGVuZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoZUVsZW1lbnQsICdjbGljaycsIGV4cGFuZEFjdGlvbik7XG4gICAgfTtcbiAgICBIZWFkZXJHcm91cENvbXAucHJvdG90eXBlLnVwZGF0ZUljb25WaXNpYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sdW1uR3JvdXAgPSB0aGlzLnBhcmFtcy5jb2x1bW5Hcm91cDtcbiAgICAgICAgaWYgKGNvbHVtbkdyb3VwLmlzRXhwYW5kYWJsZSgpKSB7XG4gICAgICAgICAgICB2YXIgZXhwYW5kZWQgPSB0aGlzLnBhcmFtcy5jb2x1bW5Hcm91cC5pc0V4cGFuZGVkKCk7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnNldFZpc2libGUodGhpcy5lT3Blbkljb24sICFleHBhbmRlZCk7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnNldFZpc2libGUodGhpcy5lQ2xvc2VJY29uLCBleHBhbmRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnNldFZpc2libGUodGhpcy5lT3Blbkljb24sIGZhbHNlKTtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuc2V0VmlzaWJsZSh0aGlzLmVDbG9zZUljb24sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGVhZGVyR3JvdXBDb21wLnByb3RvdHlwZS5hZGRJbkljb24gPSBmdW5jdGlvbiAoaWNvbk5hbWUsIHJlZk5hbWUpIHtcbiAgICAgICAgdmFyIGVJY29uID0gdXRpbHNfMS5VdGlscy5jcmVhdGVJY29uTm9TcGFuKGljb25OYW1lLCB0aGlzLmdyaWRPcHRpb25zV3JhcHBlciwgbnVsbCk7XG4gICAgICAgIHRoaXMuZ2V0UmVmRWxlbWVudChyZWZOYW1lKS5hcHBlbmRDaGlsZChlSWNvbik7XG4gICAgfTtcbiAgICBIZWFkZXJHcm91cENvbXAucHJvdG90eXBlLmFkZEdyb3VwRXhwYW5kSWNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmFtcy5jb2x1bW5Hcm91cC5pc0V4cGFuZGFibGUoKSkge1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5zZXRWaXNpYmxlKHRoaXMuZU9wZW5JY29uLCBmYWxzZSk7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLnNldFZpc2libGUodGhpcy5lQ2xvc2VJY29uLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhlYWRlckdyb3VwQ29tcC5wcm90b3R5cGUuc2V0dXBMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm8gcmVuZGVyZXIsIGRlZmF1bHQgdGV4dCByZW5kZXJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmRpc3BsYXlOYW1lICYmIHRoaXMucGFyYW1zLmRpc3BsYXlOYW1lICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuaXNCcm93c2VyU2FmYXJpKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEd1aSgpLnN0eWxlLmRpc3BsYXkgPSAndGFibGUtY2VsbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZUlubmVyVGV4dCA9IHRoaXMuZ2V0UmVmRWxlbWVudCgnYWdMYWJlbCcpO1xuICAgICAgICAgICAgZUlubmVyVGV4dC5pbm5lckhUTUwgPSB0aGlzLnBhcmFtcy5kaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGVhZGVyR3JvdXBDb21wLlRFTVBMQVRFID0gXCI8ZGl2IGNsYXNzPVxcXCJhZy1oZWFkZXItZ3JvdXAtY2VsbC1sYWJlbFxcXCI+XCIgK1xuICAgICAgICBcIjxzcGFuIHJlZj1cXFwiYWdMYWJlbFxcXCIgY2xhc3M9XFxcImFnLWhlYWRlci1ncm91cC10ZXh0XFxcIj48L3NwYW4+XCIgK1xuICAgICAgICBcIjxzcGFuIHJlZj1cXFwiYWdPcGVuZWRcXFwiIGNsYXNzPVxcXCJhZy1oZWFkZXItaWNvbiBhZy1oZWFkZXItZXhwYW5kLWljb24gYWctaGVhZGVyLWV4cGFuZC1pY29uLWV4cGFuZGVkXFxcIj48L3NwYW4+XCIgK1xuICAgICAgICBcIjxzcGFuIHJlZj1cXFwiYWdDbG9zZWRcXFwiIGNsYXNzPVxcXCJhZy1oZWFkZXItaWNvbiBhZy1oZWFkZXItZXhwYW5kLWljb24gYWctaGVhZGVyLWV4cGFuZC1pY29uLWNvbGxhcHNlZFxcXCI+PC9zcGFuPlwiICtcbiAgICAgICAgXCI8L2Rpdj5cIjtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgSGVhZGVyR3JvdXBDb21wLnByb3RvdHlwZSwgXCJjb2x1bW5Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIEhlYWRlckdyb3VwQ29tcC5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2FnT3BlbmVkJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MRWxlbWVudClcbiAgICBdLCBIZWFkZXJHcm91cENvbXAucHJvdG90eXBlLCBcImVPcGVuSWNvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdhZ0Nsb3NlZCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgSGVhZGVyR3JvdXBDb21wLnByb3RvdHlwZSwgXCJlQ2xvc2VJY29uXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEhlYWRlckdyb3VwQ29tcDtcbn0oY29tcG9uZW50XzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLkhlYWRlckdyb3VwQ29tcCA9IEhlYWRlckdyb3VwQ29tcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2hlYWRlclJlbmRlcmluZy9oZWFkZXJHcm91cC9oZWFkZXJHcm91cENvbXAuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRcIik7XG52YXIgY29sdW1uXzEgPSByZXF1aXJlKFwiLi4vLi4vZW50aXRpZXMvY29sdW1uXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG52YXIgY29sdW1uR3JvdXBfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnRpdGllcy9jb2x1bW5Hcm91cFwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBob3Jpem9udGFsRHJhZ1NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ob3Jpem9udGFsRHJhZ1NlcnZpY2VcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjc3NDbGFzc0FwcGxpZXJfMSA9IHJlcXVpcmUoXCIuLi9jc3NDbGFzc0FwcGxpZXJcIik7XG52YXIgZHJhZ0FuZERyb3BTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vZHJhZ0FuZERyb3AvZHJhZ0FuZERyb3BTZXJ2aWNlXCIpO1xudmFyIHNldExlZnRGZWF0dXJlXzEgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyaW5nL2ZlYXR1cmVzL3NldExlZnRGZWF0dXJlXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkQXBpXCIpO1xudmFyIGNvbXBvbmVudFJlY2lwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21wb25lbnRzL2ZyYW1ld29yay9jb21wb25lbnRSZWNpcGVzXCIpO1xudmFyIGJlYW5zXzEgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyaW5nL2JlYW5zXCIpO1xudmFyIEhlYWRlckdyb3VwV3JhcHBlckNvbXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkZXJHcm91cFdyYXBwZXJDb21wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRlckdyb3VwV3JhcHBlckNvbXAoY29sdW1uR3JvdXAsIGVSb290LCBkcmFnU291cmNlRHJvcFRhcmdldCwgcGlubmVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIEhlYWRlckdyb3VwV3JhcHBlckNvbXAuVEVNUExBVEUpIHx8IHRoaXM7XG4gICAgICAgIC8vIHRoZSBjaGlsZHJlbiBjYW4gY2hhbmdlLCB3ZSBrZWVwIGRlc3Ryb3kgZnVuY3Rpb25zIHJlbGF0ZWQgdG8gbGlzdGVuaW5nIHRvIHRoZSBjaGlsZHJlbiBoZXJlXG4gICAgICAgIF90aGlzLmNoaWxkQ29sdW1uc0Rlc3Ryb3lGdW5jcyA9IFtdO1xuICAgICAgICBfdGhpcy5jb2x1bW5Hcm91cCA9IGNvbHVtbkdyb3VwO1xuICAgICAgICBfdGhpcy5lUm9vdCA9IGVSb290O1xuICAgICAgICBfdGhpcy5kcmFnU291cmNlRHJvcFRhcmdldCA9IGRyYWdTb3VyY2VEcm9wVGFyZ2V0O1xuICAgICAgICBfdGhpcy5waW5uZWQgPSBwaW5uZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSGVhZGVyR3JvdXBXcmFwcGVyQ29tcC5wcm90b3R5cGUucG9zdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3NzQ2xhc3NBcHBsaWVyXzEuQ3NzQ2xhc3NBcHBsaWVyLmFkZEhlYWRlckNsYXNzZXNGcm9tQ29sRGVmKHRoaXMuY29sdW1uR3JvdXAuZ2V0Q29sR3JvdXBEZWYoKSwgdGhpcy5nZXRHdWkoKSwgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIG51bGwsIHRoaXMuY29sdW1uR3JvdXApO1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0aGlzLmNvbHVtbkNvbnRyb2xsZXIuZ2V0RGlzcGxheU5hbWVGb3JDb2x1bW5Hcm91cCh0aGlzLmNvbHVtbkdyb3VwLCAnaGVhZGVyJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kSGVhZGVyR3JvdXBDb21wKGRpc3BsYXlOYW1lKTtcbiAgICAgICAgdGhpcy5zZXR1cFJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmFkZENsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5zZXR1cFdpZHRoKCk7XG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlcygpO1xuICAgICAgICB2YXIgc2V0TGVmdEZlYXR1cmUgPSBuZXcgc2V0TGVmdEZlYXR1cmVfMS5TZXRMZWZ0RmVhdHVyZSh0aGlzLmNvbHVtbkdyb3VwLCB0aGlzLmdldEd1aSgpLCB0aGlzLmJlYW5zKTtcbiAgICAgICAgc2V0TGVmdEZlYXR1cmUuaW5pdCgpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lGdW5jKHNldExlZnRGZWF0dXJlLmRlc3Ryb3kuYmluZChzZXRMZWZ0RmVhdHVyZSkpO1xuICAgIH07XG4gICAgSGVhZGVyR3JvdXBXcmFwcGVyQ29tcC5wcm90b3R5cGUuYWRkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRHdWkoKS5zZXRBdHRyaWJ1dGUoXCJjb2wtaWRcIiwgdGhpcy5jb2x1bW5Hcm91cC5nZXRVbmlxdWVJZCgpKTtcbiAgICB9O1xuICAgIEhlYWRlckdyb3VwV3JhcHBlckNvbXAucHJvdG90eXBlLmFwcGVuZEhlYWRlckdyb3VwQ29tcCA9IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgY29sdW1uR3JvdXA6IHRoaXMuY29sdW1uR3JvdXAsXG4gICAgICAgICAgICBzZXRFeHBhbmRlZDogZnVuY3Rpb24gKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uQ29udHJvbGxlci5zZXRDb2x1bW5Hcm91cE9wZW5lZChfdGhpcy5jb2x1bW5Hcm91cC5nZXRPcmlnaW5hbENvbHVtbkdyb3VwKCksIGV4cGFuZGVkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGksXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRDb250ZXh0KClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5hZnRlckhlYWRlckNvbXBDcmVhdGVkLmJpbmQodGhpcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlY2lwZXMubmV3SGVhZGVyR3JvdXBDb21wb25lbnQocGFyYW1zKS50aGVuKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIEhlYWRlckdyb3VwV3JhcHBlckNvbXAucHJvdG90eXBlLmFmdGVySGVhZGVyQ29tcENyZWF0ZWQgPSBmdW5jdGlvbiAoZGlzcGxheU5hbWUsIGhlYWRlckdyb3VwQ29tcCkge1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGhlYWRlckdyb3VwQ29tcCk7XG4gICAgICAgIHRoaXMuc2V0dXBNb3ZlKGhlYWRlckdyb3VwQ29tcC5nZXRHdWkoKSwgZGlzcGxheU5hbWUpO1xuICAgICAgICBpZiAoaGVhZGVyR3JvdXBDb21wLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveUZ1bmMoaGVhZGVyR3JvdXBDb21wLmRlc3Ryb3kuYmluZChoZWFkZXJHcm91cENvbXApKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGVhZGVyR3JvdXBXcmFwcGVyQ29tcC5wcm90b3R5cGUuYWRkQ2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaGF2aW5nIGRpZmZlcmVudCBjbGFzc2VzIGJlbG93IGFsbG93cyB0aGUgc3R5bGUgdG8gbm90IGhhdmUgYSBib3R0b20gYm9yZGVyXG4gICAgICAgIC8vIG9uIHRoZSBncm91cCBoZWFkZXIsIGlmIG5vIGdyb3VwIGlzIHNwZWNpZmllZFxuICAgICAgICAvLyBjb2x1bW5Hcm91cC5nZXRDb2xHcm91cERlZlxuICAgICAgICBpZiAodGhpcy5jb2x1bW5Hcm91cC5pc1BhZGRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRDc3NDbGFzcygnYWctaGVhZGVyLWdyb3VwLWNlbGwtbm8tZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ3NzQ2xhc3MoJ2FnLWhlYWRlci1ncm91cC1jZWxsLXdpdGgtZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGVhZGVyR3JvdXBXcmFwcGVyQ29tcC5wcm90b3R5cGUuc2V0dXBNb3ZlID0gZnVuY3Rpb24gKGVIZWFkZXJHcm91cCwgZGlzcGxheU5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFlSGVhZGVyR3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1N1cHByZXNzTW92aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZUhlYWRlckdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ1NvdXJjZV8xID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdTb3VyY2VUeXBlLkhlYWRlckNlbGwsXG4gICAgICAgICAgICAgICAgZUVsZW1lbnQ6IGVIZWFkZXJHcm91cCxcbiAgICAgICAgICAgICAgICBkcmFnSXRlbU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgIC8vIHdlIGFkZCBpbiB0aGUgb3JpZ2luYWwgZ3JvdXAgbGVhZiBjb2x1bW5zLCBzbyB3ZSBtb3ZlIGJvdGggdmlzaWJsZSBhbmQgbm9uLXZpc2libGUgaXRlbXNcbiAgICAgICAgICAgICAgICBkcmFnSXRlbUNhbGxiYWNrOiB0aGlzLmdldERyYWdJdGVtRm9yR3JvdXAuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBkcmFnU291cmNlRHJvcFRhcmdldDogdGhpcy5kcmFnU291cmNlRHJvcFRhcmdldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0FuZERyb3BTZXJ2aWNlLmFkZERyYWdTb3VyY2UoZHJhZ1NvdXJjZV8xLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveUZ1bmMoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZHJhZ0FuZERyb3BTZXJ2aWNlLnJlbW92ZURyYWdTb3VyY2UoZHJhZ1NvdXJjZV8xKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHdoZW4gbW92aW5nIHRoZSBjb2x1bW5zLCB3ZSB3YW50IHRvIG1vdmUgYWxsIHRoZSBjb2x1bW5zIChjb250YWluZWQgd2l0aGluIHRoZSBEcmFnSXRlbSkgaW4gdGhpcyBncm91cCBpbiBvbmUgZ28sXG4gICAgLy8gYW5kIGluIHRoZSBvcmRlciB0aGV5IGFyZSBjdXJyZW50bHkgaW4gdGhlIHNjcmVlbi5cbiAgICBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZS5nZXREcmFnSXRlbUZvckdyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWxsQ29sdW1uc09yaWdpbmFsT3JkZXIgPSB0aGlzLmNvbHVtbkdyb3VwLmdldE9yaWdpbmFsQ29sdW1uR3JvdXAoKS5nZXRMZWFmQ29sdW1ucygpO1xuICAgICAgICAvLyBjYXB0dXJlIHZpc2libGUgc3RhdGUsIHVzZWQgd2hlbiByZWVudGVyaW5nIGdyaWQgdG8gZGljdGF0ZSB3aGljaCBjb2x1bW5zIHNob3VsZCBiZSB2aXNpYmxlXG4gICAgICAgIHZhciB2aXNpYmxlU3RhdGUgPSB7fTtcbiAgICAgICAgYWxsQ29sdW1uc09yaWdpbmFsT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiB2aXNpYmxlU3RhdGVbY29sdW1uLmdldElkKCldID0gY29sdW1uLmlzVmlzaWJsZSgpOyB9KTtcbiAgICAgICAgdmFyIGFsbENvbHVtbnNDdXJyZW50T3JkZXIgPSBbXTtcbiAgICAgICAgdGhpcy5jb2x1bW5Db250cm9sbGVyLmdldEFsbERpc3BsYXllZENvbHVtbnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChhbGxDb2x1bW5zT3JpZ2luYWxPcmRlci5pbmRleE9mKGNvbHVtbikgPj0gMCkge1xuICAgICAgICAgICAgICAgIGFsbENvbHVtbnNDdXJyZW50T3JkZXIucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbUFycmF5KGFsbENvbHVtbnNPcmlnaW5hbE9yZGVyLCBjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gd2UgYXJlIGxlZnQgd2l0aCBub24tdmlzaWJsZSBjb2x1bW5zLCBzdGljayB0aGVzZSBpbiBhdCB0aGUgZW5kXG4gICAgICAgIGFsbENvbHVtbnNPcmlnaW5hbE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gYWxsQ29sdW1uc0N1cnJlbnRPcmRlci5wdXNoKGNvbHVtbik7IH0pO1xuICAgICAgICAvLyBjcmVhdGUgYW5kIHJldHVybiBkcmFnSXRlbVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uczogYWxsQ29sdW1uc0N1cnJlbnRPcmRlcixcbiAgICAgICAgICAgIHZpc2libGVTdGF0ZTogdmlzaWJsZVN0YXRlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZS5pc1N1cHByZXNzTW92aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpZiBhbnkgY2hpbGQgaXMgZml4ZWQsIHRoZW4gZG9uJ3QgYWxsb3cgbW92aW5nXG4gICAgICAgIHZhciBjaGlsZFN1cHByZXNzZXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2x1bW5Hcm91cC5nZXRMZWFmQ29sdW1ucygpLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgaWYgKGNvbHVtbi5nZXRDb2xEZWYoKS5zdXBwcmVzc01vdmFibGUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFN1cHByZXNzZXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNoaWxkU3VwcHJlc3Nlc01vdmluZ1xuICAgICAgICAgICAgfHwgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc01vdmFibGVDb2x1bW5zKClcbiAgICAgICAgICAgIHx8IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEhlYWRlckdyb3VwV3JhcHBlckNvbXAucHJvdG90eXBlLnNldHVwV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gY2hpbGQgY29sdW1ucywgYXMgdGhleSBpbXBhY3Qgb3VyIHdpZHRoXG4gICAgICAgIHRoaXMuYWRkTGlzdGVuZXJzVG9DaGlsZHJlbkNvbHVtbnMoKTtcbiAgICAgICAgLy8gdGhlIGNoaWxkcmVuIGJlbG9uZ2luZyB0byB0aGlzIGdyb3VwIGNhbiBjaGFuZ2UsIHNvIHdlIG5lZWQgdG8gYWRkIGFuZCByZW1vdmUgbGlzdGVuZXJzIGFzIHRoZXkgY2hhbmdlXG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuY29sdW1uR3JvdXAsIGNvbHVtbkdyb3VwXzEuQ29sdW1uR3JvdXAuRVZFTlRfRElTUExBWUVEX0NISUxEUkVOX0NIQU5HRUQsIHRoaXMub25EaXNwbGF5ZWRDaGlsZHJlbkNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub25XaWR0aENoYW5nZWQoKTtcbiAgICAgICAgLy8gdGhlIGNoaWxkIGxpc3RlbmVycyBhcmUgbm90IHRpZWQgdG8gdGhpcyBjb21wb25lbnRzIGxpZmVjeWNsZSwgYXMgY2hpbGRyZW4gY2FuIGdldCBhZGRlZCBhbmQgcmVtb3ZlZFxuICAgICAgICAvLyB0byB0aGUgZ3JvdXAgLSBoZW5jZSB0aGV5IGFyZSBvbiBhIGRpZmZlcmVudCBsaWZlY3ljbGUuIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZSBleGlzdGluZyBjaGlsZHJlblxuICAgICAgICAvLyBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgd2hlbiB3ZSBmaW5hbGx5IGdldCBkZXN0cm95ZWRcbiAgICAgICAgdGhpcy5hZGREZXN0cm95RnVuYyh0aGlzLmRlc3Ryb3lMaXN0ZW5lcnNPbkNoaWxkcmVuQ29sdW1ucy5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIEhlYWRlckdyb3VwV3JhcHBlckNvbXAucHJvdG90eXBlLm9uRGlzcGxheWVkQ2hpbGRyZW5DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkZExpc3RlbmVyc1RvQ2hpbGRyZW5Db2x1bW5zKCk7XG4gICAgICAgIHRoaXMub25XaWR0aENoYW5nZWQoKTtcbiAgICB9O1xuICAgIEhlYWRlckdyb3VwV3JhcHBlckNvbXAucHJvdG90eXBlLmFkZExpc3RlbmVyc1RvQ2hpbGRyZW5Db2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBmaXJzdCBkZXN0cm95IGFueSBvbGQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuZGVzdHJveUxpc3RlbmVyc09uQ2hpbGRyZW5Db2x1bW5zKCk7XG4gICAgICAgIC8vIG5vdyBhZGQgbmV3IGxpc3RlbmVycyB0byB0aGUgbmV3IHNldCBvZiBjaGlsZHJlblxuICAgICAgICB2YXIgd2lkdGhDaGFuZ2VkTGlzdGVuZXIgPSB0aGlzLm9uV2lkdGhDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29sdW1uR3JvdXAuZ2V0TGVhZkNvbHVtbnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbHVtbi5hZGRFdmVudExpc3RlbmVyKGNvbHVtbl8xLkNvbHVtbi5FVkVOVF9XSURUSF9DSEFOR0VELCB3aWR0aENoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICBjb2x1bW4uYWRkRXZlbnRMaXN0ZW5lcihjb2x1bW5fMS5Db2x1bW4uRVZFTlRfVklTSUJMRV9DSEFOR0VELCB3aWR0aENoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICBfdGhpcy5jaGlsZENvbHVtbnNEZXN0cm95RnVuY3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLnJlbW92ZUV2ZW50TGlzdGVuZXIoY29sdW1uXzEuQ29sdW1uLkVWRU5UX1dJRFRIX0NIQU5HRUQsIHdpZHRoQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihjb2x1bW5fMS5Db2x1bW4uRVZFTlRfVklTSUJMRV9DSEFOR0VELCB3aWR0aENoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZS5kZXN0cm95TGlzdGVuZXJzT25DaGlsZHJlbkNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRDb2x1bW5zRGVzdHJveUZ1bmNzLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIGZ1bmMoKTsgfSk7XG4gICAgICAgIHRoaXMuY2hpbGRDb2x1bW5zRGVzdHJveUZ1bmNzID0gW107XG4gICAgfTtcbiAgICBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZS5vbldpZHRoQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRHdWkoKS5zdHlsZS53aWR0aCA9IHRoaXMuY29sdW1uR3JvdXAuZ2V0QWN0dWFsV2lkdGgoKSArICdweCc7XG4gICAgfTtcbiAgICBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZS5zZXR1cFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lSGVhZGVyQ2VsbFJlc2l6ZSA9IHRoaXMuZ2V0UmVmRWxlbWVudCgnYWdSZXNpemUnKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbkdyb3VwLmlzUmVzaXphYmxlKCkpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMucmVtb3ZlRnJvbVBhcmVudCh0aGlzLmVIZWFkZXJDZWxsUmVzaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdTZXJ2aWNlLmFkZERyYWdIYW5kbGluZyh7XG4gICAgICAgICAgICBlRHJhZ2dhYmxlRWxlbWVudDogdGhpcy5lSGVhZGVyQ2VsbFJlc2l6ZSxcbiAgICAgICAgICAgIGVCb2R5OiB0aGlzLmVSb290LFxuICAgICAgICAgICAgY3Vyc29yOiAnY29sLXJlc2l6ZScsXG4gICAgICAgICAgICBzdGFydEFmdGVyUGl4ZWxzOiAwLFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uRHJhZ2dpbmc6IHRoaXMub25EcmFnZ2luZy5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NBdXRvU2l6ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVIZWFkZXJDZWxsUmVzaXplLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxpc3Qgb2YgYWxsIHRoZSBjb2x1bW4ga2V5cyB3ZSBhcmUgcmVzcG9uc2libGUgZm9yXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2x1bW5Hcm91cC5nZXREaXNwbGF5ZWRMZWFmQ29sdW1ucygpLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgYWxsIGNvbHMgaW4gdGhlIGdyb3VwIG1heSBiZSBwYXJ0aWNpcGF0aW5nIHdpdGggYXV0by1yZXNpemVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2x1bW4uZ2V0Q29sRGVmKCkuc3VwcHJlc3NBdXRvU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGNvbHVtbi5nZXRDb2xJZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uQ29udHJvbGxlci5hdXRvU2l6ZUNvbHVtbnMoa2V5cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhlYWRlckdyb3VwV3JhcHBlckNvbXAucHJvdG90eXBlLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmdyb3VwV2lkdGhTdGFydCA9IHRoaXMuY29sdW1uR3JvdXAuZ2V0QWN0dWFsV2lkdGgoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbldpZHRoU3RhcnRzID0gW107XG4gICAgICAgIHRoaXMuY29sdW1uR3JvdXAuZ2V0RGlzcGxheWVkTGVhZkNvbHVtbnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIF90aGlzLmNoaWxkcmVuV2lkdGhTdGFydHMucHVzaChjb2x1bW4uZ2V0QWN0dWFsV2lkdGgoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVhZGVyR3JvdXBXcmFwcGVyQ29tcC5wcm90b3R5cGUub25EcmFnZ2luZyA9IGZ1bmN0aW9uIChkcmFnQ2hhbmdlLCBmaW5pc2hlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyB0aGlzIHdpbGwgYmUgdGhlIHdpZHRoIHdlIGhhdmUgdG8gZGlzdHJpYnV0ZSB0byB0aGUgcmVzaXphYmxlIGNvbHVtbnNcbiAgICAgICAgdmFyIHdpZHRoRm9yUmVzaXphYmxlQ29scztcbiAgICAgICAgLy8gdGhpcyBpcyBhbGwgdGhlIGRpc3BsYXllZCBjb2xzIGluIHRoZSBncm91cCBsZXNzIHRob3NlIHRoYXQgd2UgY2Fubm90IHJlc2l6ZVxuICAgICAgICB2YXIgcmVzaXphYmxlQ29scztcbiAgICAgICAgLy8gYSBsb3Qgb2YgdmFyaWFibGVzIGRlZmluZWQgZm9yIHRoZSBmaXJzdCBzZXQgb2YgbWF0aHMsIGJ1dCBwdXR0aW5nXG4gICAgICAgIC8vIGJyYWNlcyBpbiwgd2UgbG9jYWxpc2UgdGhlIHZhcmlhYmxlcyB0byB0aGlzIGJpdCBvZiB0aGUgbWV0aG9kXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkcmFnQ2hhbmdlTm9ybWFsaXNlZCA9IHRoaXMubm9ybWFsaXNlRHJhZ0NoYW5nZShkcmFnQ2hhbmdlKTtcbiAgICAgICAgICAgIHZhciB0b3RhbEdyb3VwV2lkdGggPSB0aGlzLmdyb3VwV2lkdGhTdGFydCArIGRyYWdDaGFuZ2VOb3JtYWxpc2VkO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXllZENvbHVtbnMgPSB0aGlzLmNvbHVtbkdyb3VwLmdldERpc3BsYXllZExlYWZDb2x1bW5zKCk7XG4gICAgICAgICAgICByZXNpemFibGVDb2xzID0gdXRpbHNfMS5VdGlscy5maWx0ZXIoZGlzcGxheWVkQ29sdW1ucywgZnVuY3Rpb24gKGNvbCkgeyByZXR1cm4gY29sLmlzUmVzaXphYmxlKCk7IH0pO1xuICAgICAgICAgICAgdmFyIG5vblJlc2l6YWJsZUNvbHMgPSB1dGlsc18xLlV0aWxzLmZpbHRlcihkaXNwbGF5ZWRDb2x1bW5zLCBmdW5jdGlvbiAoY29sKSB7IHJldHVybiAhY29sLmlzUmVzaXphYmxlKCk7IH0pO1xuICAgICAgICAgICAgdmFyIG5vblJlc2l6YWJsZUNvbHNXaWR0aF8xID0gMDtcbiAgICAgICAgICAgIG5vblJlc2l6YWJsZUNvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7IHJldHVybiBub25SZXNpemFibGVDb2xzV2lkdGhfMSArPSBjb2wuZ2V0QWN0dWFsV2lkdGgoKTsgfSk7XG4gICAgICAgICAgICB3aWR0aEZvclJlc2l6YWJsZUNvbHMgPSB0b3RhbEdyb3VwV2lkdGggLSBub25SZXNpemFibGVDb2xzV2lkdGhfMTtcbiAgICAgICAgICAgIHZhciBtaW5XaWR0aF8xID0gMDtcbiAgICAgICAgICAgIHJlc2l6YWJsZUNvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7IHJldHVybiBtaW5XaWR0aF8xICs9IGNvbC5nZXRNaW5XaWR0aCgpOyB9KTtcbiAgICAgICAgICAgIGlmICh3aWR0aEZvclJlc2l6YWJsZUNvbHMgPCBtaW5XaWR0aF8xKSB7XG4gICAgICAgICAgICAgICAgd2lkdGhGb3JSZXNpemFibGVDb2xzID0gbWluV2lkdGhfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkaXN0cmlidXRlIHRoZSBuZXcgd2lkdGggdG8gdGhlIGNoaWxkIGhlYWRlcnNcbiAgICAgICAgdmFyIGNoYW5nZVJhdGlvID0gd2lkdGhGb3JSZXNpemFibGVDb2xzIC8gdGhpcy5ncm91cFdpZHRoU3RhcnQ7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgcGl4ZWxzIHVzZWQsIGFuZCBsYXN0IGNvbHVtbiBnZXRzIHRoZSByZW1haW5pbmcsXG4gICAgICAgIC8vIHRvIGNhdGVyIGZvciByb3VuZGluZyBlcnJvcnMsIGFuZCBtaW4gd2lkdGggYWRqdXN0bWVudHNcbiAgICAgICAgdmFyIHBpeGVsc1RvRGlzdHJpYnV0ZSA9IHdpZHRoRm9yUmVzaXphYmxlQ29scztcbiAgICAgICAgcmVzaXphYmxlQ29scy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbm90TGFzdENvbCA9IGluZGV4ICE9PSAocmVzaXphYmxlQ29scy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZFNpemU7XG4gICAgICAgICAgICBpZiAobm90TGFzdENvbCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCB0aGUgbGFzdCBjb2wsIGNhbGN1bGF0ZSB0aGUgY29sdW1uIHdpZHRoIGFzIG5vcm1hbFxuICAgICAgICAgICAgICAgIHZhciBzdGFydENoaWxkU2l6ZSA9IF90aGlzLmNoaWxkcmVuV2lkdGhTdGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkU2l6ZSA9IHN0YXJ0Q2hpbGRTaXplICogY2hhbmdlUmF0aW87XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkU2l6ZSA8IGNvbHVtbi5nZXRNaW5XaWR0aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkU2l6ZSA9IGNvbHVtbi5nZXRNaW5XaWR0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwaXhlbHNUb0Rpc3RyaWJ1dGUgLT0gbmV3Q2hpbGRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbGFzdCBjb2wsIGdpdmUgaXQgdGhlIHJlbWFpbmluZyBwaXhlbHNcbiAgICAgICAgICAgICAgICBuZXdDaGlsZFNpemUgPSBwaXhlbHNUb0Rpc3RyaWJ1dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jb2x1bW5Db250cm9sbGVyLnNldENvbHVtbldpZHRoKGNvbHVtbiwgbmV3Q2hpbGRTaXplLCBmaW5pc2hlZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gb3B0aW9uYWxseSBpbnZlcnRzIHRoZSBkcmFnLCBkZXBlbmRpbmcgb24gcGlubmVkIGFuZCBSVExcbiAgICAvLyBub3RlIC0gdGhpcyBtZXRob2QgaXMgZHVwbGljYXRlZCBpbiBSZW5kZXJlZEhlYWRlckNlbGwgLSBzaG91bGQgcmVmYWN0b3Igb3V0P1xuICAgIEhlYWRlckdyb3VwV3JhcHBlckNvbXAucHJvdG90eXBlLm5vcm1hbGlzZURyYWdDaGFuZ2UgPSBmdW5jdGlvbiAoZHJhZ0NoYW5nZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZHJhZ0NoYW5nZTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRW5hYmxlUnRsKCkpIHtcbiAgICAgICAgICAgIC8vIGZvciBSVEwsIGRyYWdnaW5nIGxlZnQgbWFrZXMgdGhlIGNvbCBiaWdnZXIsIGV4Y2VwdCB3aGVuIHBpbm5pbmcgbGVmdFxuICAgICAgICAgICAgaWYgKHRoaXMucGlubmVkICE9PSBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX0xFRlQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3IgTFRSIChpZSBub3JtYWwpLCBkcmFnZ2luZyBsZWZ0IG1ha2VzIHRoZSBjb2wgc21hbGxlciwgZXhjZXB0IHdoZW4gcGlubmluZyByaWdodFxuICAgICAgICAgICAgaWYgKHRoaXMucGlubmVkID09PSBjb2x1bW5fMS5Db2x1bW4uUElOTkVEX1JJR0hUKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIZWFkZXJHcm91cFdyYXBwZXJDb21wLlRFTVBMQVRFID0gJzxkaXYgY2xhc3M9XCJhZy1oZWFkZXItZ3JvdXAtY2VsbFwiPicgK1xuICAgICAgICAnPGRpdiByZWY9XCJhZ1Jlc2l6ZVwiIGNsYXNzPVwiYWctaGVhZGVyLWNlbGwtcmVzaXplXCI+PC9kaXY+JyArXG4gICAgICAgICc8L2Rpdj4nO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgSGVhZGVyR3JvdXBXcmFwcGVyQ29tcC5wcm90b3R5cGUsIFwiY29sdW1uQ29udHJvbGxlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdob3Jpem9udGFsRHJhZ1NlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGhvcml6b250YWxEcmFnU2VydmljZV8xLkhvcml6b250YWxEcmFnU2VydmljZSlcbiAgICBdLCBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJkcmFnU2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdkcmFnQW5kRHJvcFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGRyYWdBbmREcm9wU2VydmljZV8xLkRyYWdBbmREcm9wU2VydmljZSlcbiAgICBdLCBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJkcmFnQW5kRHJvcFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29udGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29udGV4dF8xLkNvbnRleHQpXG4gICAgXSwgSGVhZGVyR3JvdXBXcmFwcGVyQ29tcC5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdjb21wb25lbnRSZWNpcGVzJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb21wb25lbnRSZWNpcGVzXzEuQ29tcG9uZW50UmVjaXBlcylcbiAgICBdLCBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJjb21wb25lbnRSZWNpcGVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRBcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRBcGlfMS5HcmlkQXBpKVxuICAgIF0sIEhlYWRlckdyb3VwV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImdyaWRBcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIEhlYWRlckdyb3VwV3JhcHBlckNvbXAucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdiZWFucycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgYmVhbnNfMS5CZWFucylcbiAgICBdLCBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJiZWFuc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBIZWFkZXJHcm91cFdyYXBwZXJDb21wLnByb3RvdHlwZSwgXCJwb3N0Q29uc3RydWN0XCIsIG51bGwpO1xuICAgIHJldHVybiBIZWFkZXJHcm91cFdyYXBwZXJDb21wO1xufShjb21wb25lbnRfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuSGVhZGVyR3JvdXBXcmFwcGVyQ29tcCA9IEhlYWRlckdyb3VwV3JhcHBlckNvbXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyR3JvdXAvaGVhZGVyR3JvdXBXcmFwcGVyQ29tcC5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi93aWRnZXRzL2NvbXBvbmVudFwiKTtcbnZhciBjb2x1bW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnRpdGllcy9jb2x1bW5cIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBzb3J0Q29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL3NvcnRDb250cm9sbGVyXCIpO1xudmFyIHRvdWNoTGlzdGVuZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi93aWRnZXRzL3RvdWNoTGlzdGVuZXJcIik7XG52YXIgZXZlbnRTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vZXZlbnRTZXJ2aWNlXCIpO1xudmFyIGNvbXBvbmVudEFubm90YXRpb25zXzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRBbm5vdGF0aW9uc1wiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9ldmVudHNcIik7XG52YXIgSGVhZGVyQ29tcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRlckNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGVyQ29tcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBIZWFkZXJDb21wLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSB1dGlsc18xLlV0aWxzLmZpcnN0RXhpc3RpbmdWYWx1ZShwYXJhbXMudGVtcGxhdGUsIEhlYWRlckNvbXAuVEVNUExBVEUpO1xuICAgICAgICB0aGlzLnNldFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuc2V0dXBUYXAoKTtcbiAgICAgICAgdGhpcy5zZXR1cEljb25zKHBhcmFtcy5jb2x1bW4pO1xuICAgICAgICB0aGlzLnNldHVwTWVudSgpO1xuICAgICAgICB0aGlzLnNldHVwU29ydCgpO1xuICAgICAgICB0aGlzLnNldHVwRmlsdGVySWNvbigpO1xuICAgICAgICB0aGlzLnNldHVwVGV4dChwYXJhbXMuZGlzcGxheU5hbWUpO1xuICAgIH07XG4gICAgSGVhZGVyQ29tcC5wcm90b3R5cGUuc2V0dXBUZXh0ID0gZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmVUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmVUZXh0LmlubmVySFRNTCA9IGRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIZWFkZXJDb21wLnByb3RvdHlwZS5zZXR1cEljb25zID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB0aGlzLmFkZEluSWNvbignc29ydEFzY2VuZGluZycsIHRoaXMuZVNvcnRBc2MsIGNvbHVtbik7XG4gICAgICAgIHRoaXMuYWRkSW5JY29uKCdzb3J0RGVzY2VuZGluZycsIHRoaXMuZVNvcnREZXNjLCBjb2x1bW4pO1xuICAgICAgICB0aGlzLmFkZEluSWNvbignc29ydFVuU29ydCcsIHRoaXMuZVNvcnROb25lLCBjb2x1bW4pO1xuICAgICAgICB0aGlzLmFkZEluSWNvbignbWVudScsIHRoaXMuZU1lbnUsIGNvbHVtbik7XG4gICAgICAgIHRoaXMuYWRkSW5JY29uKCdmaWx0ZXInLCB0aGlzLmVGaWx0ZXIsIGNvbHVtbik7XG4gICAgfTtcbiAgICBIZWFkZXJDb21wLnByb3RvdHlwZS5hZGRJbkljb24gPSBmdW5jdGlvbiAoaWNvbk5hbWUsIGVQYXJlbnQsIGNvbHVtbikge1xuICAgICAgICBpZiAoZVBhcmVudCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZUljb24gPSB1dGlsc18xLlV0aWxzLmNyZWF0ZUljb25Ob1NwYW4oaWNvbk5hbWUsIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLCBjb2x1bW4pO1xuICAgICAgICBlUGFyZW50LmFwcGVuZENoaWxkKGVJY29uKTtcbiAgICB9O1xuICAgIEhlYWRlckNvbXAucHJvdG90eXBlLnNldHVwVGFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc1RvdWNoKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG91Y2hMaXN0ZW5lciA9IG5ldyB0b3VjaExpc3RlbmVyXzEuVG91Y2hMaXN0ZW5lcih0aGlzLmdldEd1aSgpKTtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmVuYWJsZU1lbnUpIHtcbiAgICAgICAgICAgIHZhciBsb25nVGFwTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCkuc2hvd0NvbHVtbk1lbnVBZnRlck1vdXNlQ2xpY2soX3RoaXMucGFyYW1zLmNvbHVtbiwgZXZlbnQudG91Y2hTdGFydCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodG91Y2hMaXN0ZW5lciwgdG91Y2hMaXN0ZW5lcl8xLlRvdWNoTGlzdGVuZXIuRVZFTlRfTE9OR19UQVAsIGxvbmdUYXBMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmVuYWJsZVNvcnRpbmcpIHtcbiAgICAgICAgICAgIHZhciB0YXBMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zb3J0Q29udHJvbGxlci5wcm9ncmVzc1NvcnQoX3RoaXMucGFyYW1zLmNvbHVtbiwgZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRvdWNoTGlzdGVuZXIsIHRvdWNoTGlzdGVuZXJfMS5Ub3VjaExpc3RlbmVyLkVWRU5UX1RBUCwgdGFwTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveUZ1bmMoZnVuY3Rpb24gKCkgeyByZXR1cm4gdG91Y2hMaXN0ZW5lci5kZXN0cm95KCk7IH0pO1xuICAgIH07XG4gICAgSGVhZGVyQ29tcC5wcm90b3R5cGUuc2V0dXBNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBpZiBubyBtZW51IHByb3ZpZGVkIGluIHRlbXBsYXRlLCBkbyBub3RoaW5nXG4gICAgICAgIGlmICghdGhpcy5lTWVudSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wYXJhbXMuZW5hYmxlTWVudSkge1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVGcm9tUGFyZW50KHRoaXMuZU1lbnUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZU1lbnUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zaG93TWVudShfdGhpcy5lTWVudSk7IH0pO1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzU3VwcHJlc3NNZW51SGlkZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVNZW51LnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgICAgICB0aGlzLmFkZEd1aUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lTWVudS5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZEd1aUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVNZW51LnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmVNZW51LnN0eWxlO1xuICAgICAgICBzdHlsZVsndHJhbnNpdGlvbiddID0gJ29wYWNpdHkgMC4ycywgYm9yZGVyIDAuMnMnO1xuICAgICAgICBzdHlsZVsnLXdlYmtpdC10cmFuc2l0aW9uJ10gPSAnb3BhY2l0eSAwLjJzLCBib3JkZXIgMC4ycyc7XG4gICAgfTtcbiAgICBIZWFkZXJDb21wLnByb3RvdHlwZS5zaG93TWVudSA9IGZ1bmN0aW9uIChldmVudFNvdXJjZSkge1xuICAgICAgICB0aGlzLm1lbnVGYWN0b3J5LnNob3dNZW51QWZ0ZXJCdXR0b25DbGljayh0aGlzLnBhcmFtcy5jb2x1bW4sIGV2ZW50U291cmNlKTtcbiAgICB9O1xuICAgIEhlYWRlckNvbXAucHJvdG90eXBlLnJlbW92ZVNvcnRJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVGcm9tUGFyZW50KHRoaXMuZVNvcnRBc2MpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUZyb21QYXJlbnQodGhpcy5lU29ydERlc2MpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUZyb21QYXJlbnQodGhpcy5lU29ydE5vbmUpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLnJlbW92ZUZyb21QYXJlbnQodGhpcy5lU29ydE9yZGVyKTtcbiAgICB9O1xuICAgIEhlYWRlckNvbXAucHJvdG90eXBlLnNldHVwU29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVuYWJsZVNvcnRpbmcgPSB0aGlzLnBhcmFtcy5lbmFibGVTb3J0aW5nO1xuICAgICAgICBpZiAoIWVuYWJsZVNvcnRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU29ydEljb25zKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZSBldmVudCBvbiB0aGUgaGVhZGVyLCBzbyB3aGVuIGNsaWNrZWQsIHdlIGRvIHNvcnRpbmdcbiAgICAgICAgaWYgKHRoaXMuZUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVMYWJlbCwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGFyYW1zLnByb2dyZXNzU29ydChldmVudC5zaGlmdEtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLnBhcmFtcy5jb2x1bW4sIGNvbHVtbl8xLkNvbHVtbi5FVkVOVF9TT1JUX0NIQU5HRUQsIHRoaXMub25Tb3J0Q2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vblNvcnRDaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfU09SVF9DSEFOR0VELCB0aGlzLnNldE11bHRpU29ydE9yZGVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNldE11bHRpU29ydE9yZGVyKCk7XG4gICAgfTtcbiAgICBIZWFkZXJDb21wLnByb3RvdHlwZS5vblNvcnRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5nZXRHdWkoKSwgJ2FnLWhlYWRlci1jZWxsLXNvcnRlZC1hc2MnLCB0aGlzLnBhcmFtcy5jb2x1bW4uaXNTb3J0QXNjZW5kaW5nKCkpO1xuICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5nZXRHdWkoKSwgJ2FnLWhlYWRlci1jZWxsLXNvcnRlZC1kZXNjJywgdGhpcy5wYXJhbXMuY29sdW1uLmlzU29ydERlc2NlbmRpbmcoKSk7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkT3JSZW1vdmVDc3NDbGFzcyh0aGlzLmdldEd1aSgpLCAnYWctaGVhZGVyLWNlbGwtc29ydGVkLW5vbmUnLCB0aGlzLnBhcmFtcy5jb2x1bW4uaXNTb3J0Tm9uZSgpKTtcbiAgICAgICAgaWYgKHRoaXMuZVNvcnRBc2MpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkT3JSZW1vdmVDc3NDbGFzcyh0aGlzLmVTb3J0QXNjLCAnYWctaGlkZGVuJywgIXRoaXMucGFyYW1zLmNvbHVtbi5pc1NvcnRBc2NlbmRpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZVNvcnREZXNjKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5lU29ydERlc2MsICdhZy1oaWRkZW4nLCAhdGhpcy5wYXJhbXMuY29sdW1uLmlzU29ydERlc2NlbmRpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZVNvcnROb25lKSB7XG4gICAgICAgICAgICB2YXIgYWx3YXlzSGlkZU5vU29ydCA9ICF0aGlzLnBhcmFtcy5jb2x1bW4uZ2V0Q29sRGVmKCkudW5Tb3J0SWNvbiAmJiAhdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNVblNvcnRJY29uKCk7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmFkZE9yUmVtb3ZlQ3NzQ2xhc3ModGhpcy5lU29ydE5vbmUsICdhZy1oaWRkZW4nLCBhbHdheXNIaWRlTm9Tb3J0IHx8ICF0aGlzLnBhcmFtcy5jb2x1bW4uaXNTb3J0Tm9uZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gd2UgbGlzdGVuIGhlcmUgZm9yIGdsb2JhbCBzb3J0IGV2ZW50cywgTk9UIGNvbHVtbiBzb3J0IGV2ZW50cywgYXMgd2Ugd2FudCB0byBkbyB0aGlzXG4gICAgLy8gd2hlbiBzb3J0aW5nIGhhcyBiZWVuIHNldCBvbiBhbGwgY29sdW1uIChpZiB3ZSBsaXN0ZW5lZCBqdXN0IGZvciBvdXIgY29sICh3aGVyZSB3ZVxuICAgIC8vIHNldCB0aGUgYXNjIC8gZGVzYyBpY29ucykgdGhlbiBpdCdzIHBvc3NpYmxlIG90aGVyIGNvbHMgYXJlIHlldCB0byBnZXQgdGhlaXIgc29ydGluZyBzdGF0ZS5cbiAgICBIZWFkZXJDb21wLnByb3RvdHlwZS5zZXRNdWx0aVNvcnRPcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVTb3J0T3JkZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sID0gdGhpcy5wYXJhbXMuY29sdW1uO1xuICAgICAgICB2YXIgYWxsQ29sdW1uc1dpdGhTb3J0aW5nID0gdGhpcy5zb3J0Q29udHJvbGxlci5nZXRDb2x1bW5zV2l0aFNvcnRpbmdPcmRlcmVkKCk7XG4gICAgICAgIHZhciBpbmRleFRoaXNDb2wgPSBhbGxDb2x1bW5zV2l0aFNvcnRpbmcuaW5kZXhPZihjb2wpO1xuICAgICAgICB2YXIgbW9yZVRoYW5PbmVDb2xTb3J0aW5nID0gYWxsQ29sdW1uc1dpdGhTb3J0aW5nLmxlbmd0aCA+IDE7XG4gICAgICAgIHZhciBzaG93SW5kZXggPSBjb2wuaXNTb3J0aW5nKCkgJiYgbW9yZVRoYW5PbmVDb2xTb3J0aW5nO1xuICAgICAgICB1dGlsc18xLlV0aWxzLnNldFZpc2libGUodGhpcy5lU29ydE9yZGVyLCBzaG93SW5kZXgpO1xuICAgICAgICBpZiAoaW5kZXhUaGlzQ29sID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuZVNvcnRPcmRlci5pbm5lckhUTUwgPSAoaW5kZXhUaGlzQ29sICsgMSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZVNvcnRPcmRlci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGVhZGVyQ29tcC5wcm90b3R5cGUuc2V0dXBGaWx0ZXJJY29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZUZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMucGFyYW1zLmNvbHVtbiwgY29sdW1uXzEuQ29sdW1uLkVWRU5UX0ZJTFRFUl9DSEFOR0VELCB0aGlzLm9uRmlsdGVyQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbkZpbHRlckNoYW5nZWQoKTtcbiAgICB9O1xuICAgIEhlYWRlckNvbXAucHJvdG90eXBlLm9uRmlsdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpbHRlclByZXNlbnQgPSB0aGlzLnBhcmFtcy5jb2x1bW4uaXNGaWx0ZXJBY3RpdmUoKTtcbiAgICAgICAgdXRpbHNfMS5VdGlscy5hZGRPclJlbW92ZUNzc0NsYXNzKHRoaXMuZUZpbHRlciwgJ2FnLWhpZGRlbicsICFmaWx0ZXJQcmVzZW50KTtcbiAgICB9O1xuICAgIEhlYWRlckNvbXAuVEVNUExBVEUgPSAnPGRpdiBjbGFzcz1cImFnLWNlbGwtbGFiZWwtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPicgK1xuICAgICAgICAnICA8c3BhbiByZWY9XCJlTWVudVwiIGNsYXNzPVwiYWctaGVhZGVyLWljb24gYWctaGVhZGVyLWNlbGwtbWVudS1idXR0b25cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+JyArXG4gICAgICAgICcgIDxkaXYgcmVmPVwiZUxhYmVsXCIgY2xhc3M9XCJhZy1oZWFkZXItY2VsbC1sYWJlbFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj4nICtcbiAgICAgICAgJyAgICA8c3BhbiByZWY9XCJlVGV4dFwiIGNsYXNzPVwiYWctaGVhZGVyLWNlbGwtdGV4dFwiIHJvbGU9XCJjb2x1bW5oZWFkZXJcIj48L3NwYW4+JyArXG4gICAgICAgICcgICAgPHNwYW4gcmVmPVwiZUZpbHRlclwiIGNsYXNzPVwiYWctaGVhZGVyLWljb24gYWctZmlsdGVyLWljb25cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+JyArXG4gICAgICAgICcgICAgPHNwYW4gcmVmPVwiZVNvcnRPcmRlclwiIGNsYXNzPVwiYWctaGVhZGVyLWljb24gYWctc29ydC1vcmRlclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj4nICtcbiAgICAgICAgJyAgICA8c3BhbiByZWY9XCJlU29ydEFzY1wiIGNsYXNzPVwiYWctaGVhZGVyLWljb24gYWctc29ydC1hc2NlbmRpbmctaWNvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj4nICtcbiAgICAgICAgJyAgICA8c3BhbiByZWY9XCJlU29ydERlc2NcIiBjbGFzcz1cImFnLWhlYWRlci1pY29uIGFnLXNvcnQtZGVzY2VuZGluZy1pY29uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPicgK1xuICAgICAgICAnICAgIDxzcGFuIHJlZj1cImVTb3J0Tm9uZVwiIGNsYXNzPVwiYWctaGVhZGVyLWljb24gYWctc29ydC1ub25lLWljb25cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+JyArXG4gICAgICAgICcgIDwvZGl2PicgK1xuICAgICAgICAnPC9kaXY+JztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgSGVhZGVyQ29tcC5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3NvcnRDb250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBzb3J0Q29udHJvbGxlcl8xLlNvcnRDb250cm9sbGVyKVxuICAgIF0sIEhlYWRlckNvbXAucHJvdG90eXBlLCBcInNvcnRDb250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ21lbnVGYWN0b3J5JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSGVhZGVyQ29tcC5wcm90b3R5cGUsIFwibWVudUZhY3RvcnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgSGVhZGVyQ29tcC5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2VGaWx0ZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEhlYWRlckNvbXAucHJvdG90eXBlLCBcImVGaWx0ZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5SZWZTZWxlY3RvcignZVNvcnRBc2MnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEhlYWRlckNvbXAucHJvdG90eXBlLCBcImVTb3J0QXNjXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2VTb3J0RGVzYycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgSGVhZGVyQ29tcC5wcm90b3R5cGUsIFwiZVNvcnREZXNjXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2VTb3J0Tm9uZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgSGVhZGVyQ29tcC5wcm90b3R5cGUsIFwiZVNvcnROb25lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2VTb3J0T3JkZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEhlYWRlckNvbXAucHJvdG90eXBlLCBcImVTb3J0T3JkZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5SZWZTZWxlY3RvcignZU1lbnUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxuICAgIF0sIEhlYWRlckNvbXAucHJvdG90eXBlLCBcImVNZW51XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2VMYWJlbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXG4gICAgXSwgSGVhZGVyQ29tcC5wcm90b3R5cGUsIFwiZUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2VUZXh0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MRWxlbWVudClcbiAgICBdLCBIZWFkZXJDb21wLnByb3RvdHlwZSwgXCJlVGV4dFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWFkZXJDb21wO1xufShjb21wb25lbnRfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuSGVhZGVyQ29tcCA9IEhlYWRlckNvbXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9oZWFkZXJSZW5kZXJpbmcvaGVhZGVyL2hlYWRlckNvbXAuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYWdDaGVja2JveF8xID0gcmVxdWlyZShcIi4uLy4uL3dpZGdldHMvYWdDaGVja2JveFwiKTtcbnZhciBiZWFuU3R1Yl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvYmVhblN0dWJcIik7XG52YXIgY29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRleHQvY29udGV4dFwiKTtcbnZhciBjb2x1bW5Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY29sdW1uQ29udHJvbGxlci9jb2x1bW5Db250cm9sbGVyXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkQXBpXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4uLy4uL2V2ZW50c1wiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9ldmVudFNlcnZpY2VcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpO1xudmFyIHNlbGVjdGlvbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZWxlY3Rpb25Db250cm9sbGVyXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBTZWxlY3RBbGxGZWF0dXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VsZWN0QWxsRmVhdHVyZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWxlY3RBbGxGZWF0dXJlKGNiU2VsZWN0QWxsLCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2JTZWxlY3RBbGxWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnByb2Nlc3NpbmdFdmVudEZyb21DaGVja2JveCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5jYlNlbGVjdEFsbCA9IGNiU2VsZWN0QWxsO1xuICAgICAgICBfdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHZhciBjb2xEZWYgPSBjb2x1bW4uZ2V0Q29sRGVmKCk7XG4gICAgICAgIF90aGlzLmZpbHRlcmVkT25seSA9IGNvbERlZiA/ICEhY29sRGVmLmhlYWRlckNoZWNrYm94U2VsZWN0aW9uRmlsdGVyZWRPbmx5IDogZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2VsZWN0QWxsRmVhdHVyZS5wcm90b3R5cGUucG9zdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zaG93T3JIaWRlU2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRTZXJ2aWNlLCBldmVudHNfMS5FdmVudHMuRVZFTlRfRElTUExBWUVEX0NPTFVNTlNfQ0hBTkdFRCwgdGhpcy5zaG93T3JIaWRlU2VsZWN0QWxsLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1NFTEVDVElPTl9DSEFOR0VELCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9NT0RFTF9VUERBVEVELCB0aGlzLm9uTW9kZWxDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmNiU2VsZWN0QWxsLCBhZ0NoZWNrYm94XzEuQWdDaGVja2JveC5FVkVOVF9DSEFOR0VELCB0aGlzLm9uQ2JTZWxlY3RBbGwuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICBTZWxlY3RBbGxGZWF0dXJlLnByb3RvdHlwZS5zaG93T3JIaWRlU2VsZWN0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNiU2VsZWN0QWxsVmlzaWJsZSA9IHRoaXMuaXNDaGVja2JveFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmNiU2VsZWN0QWxsLnNldFZpc2libGUodGhpcy5jYlNlbGVjdEFsbFZpc2libGUpO1xuICAgICAgICBpZiAodGhpcy5jYlNlbGVjdEFsbFZpc2libGUpIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2UgdXNlciBpcyB0cnlpbmcgdGhpcyBmZWF0dXJlIHdpdGggdGhlIHdyb25nIG1vZGVsIHR5cGVcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSaWdodFJvd01vZGVsVHlwZSgpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoZWNrYm94IGlzIHNob3dpbmcgdGhlIHJpZ2h0IHN0YXRlXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlT2ZDaGVja2JveCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3RBbGxGZWF0dXJlLnByb3RvdHlwZS5vbk1vZGVsQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNiU2VsZWN0QWxsVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVPZkNoZWNrYm94KCk7XG4gICAgfTtcbiAgICBTZWxlY3RBbGxGZWF0dXJlLnByb3RvdHlwZS5vblNlbGVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYlNlbGVjdEFsbFZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlT2ZDaGVja2JveCgpO1xuICAgIH07XG4gICAgU2VsZWN0QWxsRmVhdHVyZS5wcm90b3R5cGUuZ2V0TmV4dENoZWNrYm94U3RhdGUgPSBmdW5jdGlvbiAoc2VsZWN0aW9uQ291bnQpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbkNvdW50LnNlbGVjdGVkID09PSAwICYmIHNlbGVjdGlvbkNvdW50Lm5vdFNlbGVjdGVkID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiBubyByb3dzLCBhbHdheXMgaGF2ZSBpdCB1bnNlbGVjdGVkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uQ291bnQuc2VsZWN0ZWQgPiAwICYmIHNlbGVjdGlvbkNvdW50Lm5vdFNlbGVjdGVkID4gMCkge1xuICAgICAgICAgICAgLy8gaWYgbWl4IG9mIHNlbGVjdGVkIGFuZCB1bnNlbGVjdGVkLCB0aGlzIGlzIHRoZSB0cmktc3RhdGVcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvbkNvdW50LnNlbGVjdGVkID4gMCkge1xuICAgICAgICAgICAgLy8gb25seSBzZWxlY3RlZFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHNlbGVjdGVkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdEFsbEZlYXR1cmUucHJvdG90eXBlLnVwZGF0ZVN0YXRlT2ZDaGVja2JveCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ0V2ZW50RnJvbUNoZWNrYm94KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nRXZlbnRGcm9tQ2hlY2tib3ggPSB0cnVlO1xuICAgICAgICB2YXIgc2VsZWN0aW9uQ291bnQgPSB0aGlzLmdldFNlbGVjdGlvbkNvdW50KCk7XG4gICAgICAgIHZhciBhbGxTZWxlY3RlZCA9IHRoaXMuZ2V0TmV4dENoZWNrYm94U3RhdGUoc2VsZWN0aW9uQ291bnQpO1xuICAgICAgICB0aGlzLmNiU2VsZWN0QWxsLnNldFNlbGVjdGVkKGFsbFNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nRXZlbnRGcm9tQ2hlY2tib3ggPSBmYWxzZTtcbiAgICB9O1xuICAgIFNlbGVjdEFsbEZlYXR1cmUucHJvdG90eXBlLmdldFNlbGVjdGlvbkNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRDb3VudCA9IDA7XG4gICAgICAgIHZhciBub3RTZWxlY3RlZENvdW50ID0gMDtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vdFNlbGVjdGVkQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRBcGkuZm9yRWFjaE5vZGVBZnRlckZpbHRlcihjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRBcGkuZm9yRWFjaE5vZGUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub3RTZWxlY3RlZDogbm90U2VsZWN0ZWRDb3VudCxcbiAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZENvdW50XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTZWxlY3RBbGxGZWF0dXJlLnByb3RvdHlwZS5jaGVja1JpZ2h0Um93TW9kZWxUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93TW9kZWxUeXBlID0gdGhpcy5yb3dNb2RlbC5nZXRUeXBlKCk7XG4gICAgICAgIHZhciByb3dNb2RlbE1hdGNoZXMgPSByb3dNb2RlbFR5cGUgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5ST1dfTU9ERUxfVFlQRV9JTl9NRU1PUlk7XG4gICAgICAgIGlmICghcm93TW9kZWxNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImFnLUdyaWQ6IHNlbGVjdEFsbENoZWNrYm94IGlzIG9ubHkgYXZhaWxhYmxlIGlmIHVzaW5nIG5vcm1hbCByb3cgbW9kZWwsIHlvdSBhcmUgdXNpbmcgXCIgKyByb3dNb2RlbFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3RBbGxGZWF0dXJlLnByb3RvdHlwZS5vbkNiU2VsZWN0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nRXZlbnRGcm9tQ2hlY2tib3gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2JTZWxlY3RBbGxWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5jYlNlbGVjdEFsbC5pc1NlbGVjdGVkKCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLnNlbGVjdEFsbFJvd05vZGVzKHRoaXMuZmlsdGVyZWRPbmx5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5kZXNlbGVjdEFsbFJvd05vZGVzKHRoaXMuZmlsdGVyZWRPbmx5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0QWxsRmVhdHVyZS5wcm90b3R5cGUuaXNDaGVja2JveFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY29sdW1uLmdldENvbERlZigpLmhlYWRlckNoZWNrYm94U2VsZWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jKHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgIGNvbERlZjogdGhpcy5jb2x1bW4uZ2V0Q29sRGVmKCksXG4gICAgICAgICAgICAgICAgY29sdW1uQXBpOiB0aGlzLmNvbHVtbkFwaSxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzUm93TW9kZWxFbnRlcnByaXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2hlYWRlckNoZWNrYm94U2VsZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIEVudGVycHJpc2UgUm93IE1vZGVsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzUm93TW9kZWxJbmZpbml0ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdoZWFkZXJDaGVja2JveFNlbGVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBJbmZpbml0ZSBSb3cgTW9kZWwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNSb3dNb2RlbFZpZXdwb3J0KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2hlYWRlckNoZWNrYm94U2VsZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIFZpZXdwb3J0IFJvdyBNb2RlbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGUgcm93IG1vZGVsIGlzIGNvbXBhdGlibGUsIHNvIHJldHVybiB0cnVlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRBcGknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRBcGlfMS5HcmlkQXBpKVxuICAgIF0sIFNlbGVjdEFsbEZlYXR1cmUucHJvdG90eXBlLCBcImdyaWRBcGlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIFNlbGVjdEFsbEZlYXR1cmUucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdldmVudFNlcnZpY2UnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGV2ZW50U2VydmljZV8xLkV2ZW50U2VydmljZSlcbiAgICBdLCBTZWxlY3RBbGxGZWF0dXJlLnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncm93TW9kZWwnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZWxlY3RBbGxGZWF0dXJlLnByb3RvdHlwZSwgXCJyb3dNb2RlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdzZWxlY3Rpb25Db250cm9sbGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBzZWxlY3Rpb25Db250cm9sbGVyXzEuU2VsZWN0aW9uQ29udHJvbGxlcilcbiAgICBdLCBTZWxlY3RBbGxGZWF0dXJlLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25Db250cm9sbGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIFNlbGVjdEFsbEZlYXR1cmUucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBTZWxlY3RBbGxGZWF0dXJlLnByb3RvdHlwZSwgXCJwb3N0Q29uc3RydWN0XCIsIG51bGwpO1xuICAgIHJldHVybiBTZWxlY3RBbGxGZWF0dXJlO1xufShiZWFuU3R1Yl8xLkJlYW5TdHViKSk7XG5leHBvcnRzLlNlbGVjdEFsbEZlYXR1cmUgPSBTZWxlY3RBbGxGZWF0dXJlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvaGVhZGVyUmVuZGVyaW5nL2hlYWRlci9zZWxlY3RBbGxGZWF0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgVGFiYmVkTGF5b3V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJiZWRMYXlvdXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuZUd1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmVHdWkuaW5uZXJIVE1MID0gVGFiYmVkTGF5b3V0LlRFTVBMQVRFO1xuICAgICAgICB0aGlzLmVIZWFkZXIgPSB0aGlzLmVHdWkucXVlcnlTZWxlY3RvcignI3RhYkhlYWRlcicpO1xuICAgICAgICB0aGlzLmVCb2R5ID0gdGhpcy5lR3VpLnF1ZXJ5U2VsZWN0b3IoJyN0YWJCb2R5Jyk7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkQ3NzQ2xhc3ModGhpcy5lR3VpLCBwYXJhbXMuY3NzQ2xhc3MpO1xuICAgICAgICBpZiAocGFyYW1zLml0ZW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gX3RoaXMuYWRkSXRlbShpdGVtKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGFiYmVkTGF5b3V0LnByb3RvdHlwZS5zZXRBZnRlckF0dGFjaGVkUGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLmFmdGVyQXR0YWNoZWRQYXJhbXMgPSBwYXJhbXM7XG4gICAgfTtcbiAgICBUYWJiZWRMYXlvdXQucHJvdG90eXBlLmdldE1pbldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZUR1bW15Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAvLyBwb3NpdGlvbiBmaXhlZCwgc28gaXQgaXNuJ3QgcmVzdHJpY3RlZCB0byB0aGUgYm91bmRhcmllcyBvZiB0aGUgcGFyZW50XG4gICAgICAgIGVEdW1teUNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIC8vIHdlIHB1dCB0aGUgZHVtbXkgaW50byB0aGUgYm9keSBjb250YWluZXIsIHNvIGl0IHdpbGwgaW5oZXJpdCBhbGwgdGhlXG4gICAgICAgIC8vIGNzcyBzdHlsZXMgdGhhdCB0aGUgcmVhbCBjZWxscyBhcmUgaW5oZXJpdGluZ1xuICAgICAgICB0aGlzLmVHdWkuYXBwZW5kQ2hpbGQoZUR1bW15Q29udGFpbmVyKTtcbiAgICAgICAgdmFyIG1pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtV3JhcHBlcikge1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVBbGxDaGlsZHJlbihlRHVtbXlDb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGVDbG9uZSA9IGl0ZW1XcmFwcGVyLnRhYmJlZEl0ZW0uYm9keVByb21pc2UucmVzb2x2ZU5vdyhudWxsLCBmdW5jdGlvbiAoYm9keSkgeyByZXR1cm4gYm9keS5jbG9uZU5vZGUodHJ1ZSk7IH0pO1xuICAgICAgICAgICAgaWYgKGVDbG9uZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGVEdW1teUNvbnRhaW5lci5hcHBlbmRDaGlsZChlQ2xvbmUpO1xuICAgICAgICAgICAgaWYgKG1pbldpZHRoIDwgZUR1bW15Q29udGFpbmVyLm9mZnNldFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGggPSBlRHVtbXlDb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVHdWkucmVtb3ZlQ2hpbGQoZUR1bW15Q29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIG1pbldpZHRoO1xuICAgIH07XG4gICAgVGFiYmVkTGF5b3V0LnByb3RvdHlwZS5zaG93Rmlyc3RJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dJdGVtV3JhcHBlcih0aGlzLml0ZW1zWzBdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFiYmVkTGF5b3V0LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGVIZWFkZXJCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGVIZWFkZXJCdXR0b24uYXBwZW5kQ2hpbGQoaXRlbS50aXRsZSk7XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkQ3NzQ2xhc3MoZUhlYWRlckJ1dHRvbiwgJ2FnLXRhYicpO1xuICAgICAgICB0aGlzLmVIZWFkZXIuYXBwZW5kQ2hpbGQoZUhlYWRlckJ1dHRvbik7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge1xuICAgICAgICAgICAgdGFiYmVkSXRlbTogaXRlbSxcbiAgICAgICAgICAgIGVIZWFkZXJCdXR0b246IGVIZWFkZXJCdXR0b25cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHdyYXBwZXIpO1xuICAgICAgICBlSGVhZGVyQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zaG93SXRlbVdyYXBwZXIuYmluZCh0aGlzLCB3cmFwcGVyKSk7XG4gICAgfTtcbiAgICBUYWJiZWRMYXlvdXQucHJvdG90eXBlLnNob3dJdGVtID0gZnVuY3Rpb24gKHRhYmJlZEl0ZW0pIHtcbiAgICAgICAgdmFyIGl0ZW1XcmFwcGVyID0gdXRpbHNfMS5VdGlscy5maW5kKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtV3JhcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1XcmFwcGVyLnRhYmJlZEl0ZW0gPT09IHRhYmJlZEl0ZW07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXRlbVdyYXBwZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0l0ZW1XcmFwcGVyKGl0ZW1XcmFwcGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFiYmVkTGF5b3V0LnByb3RvdHlwZS5zaG93SXRlbVdyYXBwZXIgPSBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMub25JdGVtQ2xpY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMub25JdGVtQ2xpY2tlZCh7IGl0ZW06IHdyYXBwZXIudGFiYmVkSXRlbSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY3RpdmVJdGVtID09PSB3cmFwcGVyKSB7XG4gICAgICAgICAgICB1dGlsc18xLlV0aWxzLmNhbGxJZlByZXNlbnQodGhpcy5wYXJhbXMub25BY3RpdmVJdGVtQ2xpY2tlZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVBbGxDaGlsZHJlbih0aGlzLmVCb2R5KTtcbiAgICAgICAgd3JhcHBlci50YWJiZWRJdGVtLmJvZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIF90aGlzLmVCb2R5LmFwcGVuZENoaWxkKGJvZHkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgdXRpbHNfMS5VdGlscy5yZW1vdmVDc3NDbGFzcyh0aGlzLmFjdGl2ZUl0ZW0uZUhlYWRlckJ1dHRvbiwgJ2FnLXRhYi1zZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxzXzEuVXRpbHMuYWRkQ3NzQ2xhc3Mod3JhcHBlci5lSGVhZGVyQnV0dG9uLCAnYWctdGFiLXNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IHdyYXBwZXI7XG4gICAgICAgIGlmICh3cmFwcGVyLnRhYmJlZEl0ZW0uYWZ0ZXJBdHRhY2hlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICB3cmFwcGVyLnRhYmJlZEl0ZW0uYWZ0ZXJBdHRhY2hlZENhbGxiYWNrKHRoaXMuYWZ0ZXJBdHRhY2hlZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmJlZExheW91dC5wcm90b3R5cGUuZ2V0R3VpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lR3VpO1xuICAgIH07XG4gICAgVGFiYmVkTGF5b3V0LlRFTVBMQVRFID0gJzxkaXY+JyArXG4gICAgICAgICc8ZGl2IGlkPVwidGFiSGVhZGVyXCIgY2xhc3M9XCJhZy10YWItaGVhZGVyXCI+PC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGlkPVwidGFiQm9keVwiIGNsYXNzPVwiYWctdGFiLWJvZHlcIj48L2Rpdj4nICtcbiAgICAgICAgJzwvZGl2Pic7XG4gICAgcmV0dXJuIFRhYmJlZExheW91dDtcbn0oKSk7XG5leHBvcnRzLlRhYmJlZExheW91dCA9IFRhYmJlZExheW91dDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2xheW91dC90YWJiZWRMYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVmVydGljYWxTdGFjayA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmVydGljYWxTdGFjaygpIHtcbiAgICAgICAgdGhpcy5pc0xheW91dFBhbmVsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZFBhbmVscyA9IFtdO1xuICAgICAgICB0aGlzLmVHdWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5lR3VpLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB9XG4gICAgVmVydGljYWxTdGFjay5wcm90b3R5cGUuYWRkUGFuZWwgPSBmdW5jdGlvbiAocGFuZWwsIGhlaWdodCkge1xuICAgICAgICB2YXIgY29tcG9uZW50O1xuICAgICAgICBpZiAocGFuZWwuaXNMYXlvdXRQYW5lbCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFBhbmVscy5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHBhbmVsLmdldEd1aSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gcGFuZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVHdWkuYXBwZW5kQ2hpbGQoY29tcG9uZW50KTtcbiAgICB9O1xuICAgIFZlcnRpY2FsU3RhY2sucHJvdG90eXBlLmdldEd1aSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZUd1aTtcbiAgICB9O1xuICAgIFZlcnRpY2FsU3RhY2sucHJvdG90eXBlLmRvTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRQYW5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRQYW5lbHNbaV0uZG9MYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFZlcnRpY2FsU3RhY2s7XG59KCkpO1xuZXhwb3J0cy5WZXJ0aWNhbFN0YWNrID0gVmVydGljYWxTdGFjaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL2xheW91dC92ZXJ0aWNhbFN0YWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExpbmtlZExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG4gICAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgIH1cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5sYXN0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3QubmV4dCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maXJzdCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdCA9IGVudHJ5O1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maXJzdDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdCA9IHJlc3VsdC5uZXh0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lml0ZW07XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZmlyc3Q7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKSk7XG5leHBvcnRzLkxpbmtlZExpc3QgPSBMaW5rZWRMaXN0O1xudmFyIExpbmtlZExpc3RJdGVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5rZWRMaXN0SXRlbSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIExpbmtlZExpc3RJdGVtO1xufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL21pc2MvbGlua2VkTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuZnVuY3Rpb24gc2ltcGxlSHR0cFJlcXVlc3QocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsc18xLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIGh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGh0dHBSZXF1ZXN0Lm9wZW4oJ0dFVCcsIHBhcmFtcy51cmwpO1xuICAgICAgICBodHRwUmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIGh0dHBSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChodHRwUmVxdWVzdC5yZWFkeVN0YXRlID09IDQgJiYgaHR0cFJlcXVlc3Quc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgIHZhciBodHRwUmVzcG9uc2UgPSBKU09OLnBhcnNlKGh0dHBSZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShodHRwUmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy5zaW1wbGVIdHRwUmVxdWVzdCA9IHNpbXBsZUh0dHBSZXF1ZXN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvbWlzYy9zaW1wbGVIdHRwUmVxdWVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQcm9wZXJ0eUtleXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5S2V5cygpIHtcbiAgICB9XG4gICAgUHJvcGVydHlLZXlzLlNUUklOR19QUk9QRVJUSUVTID0gW1xuICAgICAgICAnc29ydGluZ09yZGVyJywgJ3Jvd0NsYXNzJywgJ3Jvd1NlbGVjdGlvbicsICdvdmVybGF5TG9hZGluZ1RlbXBsYXRlJyxcbiAgICAgICAgJ292ZXJsYXlOb1Jvd3NUZW1wbGF0ZScsICdoZWFkZXJDZWxsVGVtcGxhdGUnLCAncXVpY2tGaWx0ZXJUZXh0JywgJ3Jvd01vZGVsVHlwZScsXG4gICAgICAgICdlZGl0VHlwZScsICdkb21MYXlvdXQnLCAnY2xpcGJvYXJkRGVsaW1pbmF0b3InLCAncm93R3JvdXBQYW5lbFNob3cnXG4gICAgXTtcbiAgICBQcm9wZXJ0eUtleXMuT0JKRUNUX1BST1BFUlRJRVMgPSBbXG4gICAgICAgICdjb21wb25lbnRzJywgJ2ZyYW1ld29ya0NvbXBvbmVudHMnLCAncm93U3R5bGUnLCAnY29udGV4dCcsICdhdXRvR3JvdXBDb2x1bW5EZWYnLCAnZ3JvdXBDb2x1bW5EZWYnLCAnbG9jYWxlVGV4dCcsXG4gICAgICAgICdpY29ucycsICdkYXRhc291cmNlJywgJ2VudGVycHJpc2VEYXRhc291cmNlJywgJ3ZpZXdwb3J0RGF0YXNvdXJjZScsICdncm91cFJvd1JlbmRlcmVyUGFyYW1zJywgJ2FnZ0Z1bmNzJyxcbiAgICAgICAgJ2Z1bGxXaWR0aENlbGxSZW5kZXJlclBhcmFtcycsICdkZWZhdWx0Q29sR3JvdXBEZWYnLCAnZGVmYXVsdENvbERlZicsICdkZWZhdWx0RXhwb3J0UGFyYW1zJywgJ2NvbHVtblR5cGVzJyxcbiAgICAgICAgJ3Jvd0NsYXNzUnVsZXMnXG4gICAgICAgIC8vLCdjZWxsUmVuZGVyZXJzJywnY2VsbEVkaXRvcnMnXG4gICAgXTtcbiAgICBQcm9wZXJ0eUtleXMuQVJSQVlfUFJPUEVSVElFUyA9IFtcbiAgICAgICAgJ3NsYXZlR3JpZHMnLCAnYWxpZ25lZEdyaWRzJywgJ3Jvd0RhdGEnLFxuICAgICAgICAnY29sdW1uRGVmcycsICdleGNlbFN0eWxlcycsICdwaW5uZWRUb3BSb3dEYXRhJywgJ3Bpbm5lZEJvdHRvbVJvd0RhdGEnXG4gICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBdO1xuICAgIFByb3BlcnR5S2V5cy5OVU1CRVJfUFJPUEVSVElFUyA9IFtcbiAgICAgICAgJ3Jvd0hlaWdodCcsICdyb3dCdWZmZXInLCAnY29sV2lkdGgnLCAnaGVhZGVySGVpZ2h0JywgJ2dyb3VwSGVhZGVySGVpZ2h0JywgJ2Zsb2F0aW5nRmlsdGVyc0hlaWdodCcsXG4gICAgICAgICdwaXZvdEhlYWRlckhlaWdodCcsICdwaXZvdEdyb3VwSGVhZGVySGVpZ2h0JywgJ2dyb3VwRGVmYXVsdEV4cGFuZGVkJyxcbiAgICAgICAgJ21pbkNvbFdpZHRoJywgJ21heENvbFdpZHRoJywgJ3ZpZXdwb3J0Um93TW9kZWxQYWdlU2l6ZScsICd2aWV3cG9ydFJvd01vZGVsQnVmZmVyU2l6ZScsXG4gICAgICAgICdsYXlvdXRJbnRlcnZhbCcsICdhdXRvU2l6ZVBhZGRpbmcnLCAnbWF4QmxvY2tzSW5DYWNoZScsICdtYXhDb25jdXJyZW50RGF0YXNvdXJjZVJlcXVlc3RzJyxcbiAgICAgICAgJ2NhY2hlT3ZlcmZsb3dTaXplJywgJ3BhZ2luYXRpb25QYWdlU2l6ZScsICdjYWNoZUJsb2NrU2l6ZScsICdpbmZpbml0ZUluaXRpYWxSb3dDb3VudCcsXG4gICAgICAgICdzY3JvbGxiYXJXaWR0aCcsICdwYWdpbmF0aW9uU3RhcnRQYWdlJywgJ2luZmluaXRlQmxvY2tTaXplJ1xuICAgIF07XG4gICAgUHJvcGVydHlLZXlzLkJPT0xFQU5fUFJPUEVSVElFUyA9IFtcbiAgICAgICAgJ3Rvb2xQYW5lbFN1cHByZXNzUm93R3JvdXBzJywgJ3Rvb2xQYW5lbFN1cHByZXNzVmFsdWVzJywgJ3Rvb2xQYW5lbFN1cHByZXNzUGl2b3RzJywgJ3Rvb2xQYW5lbFN1cHByZXNzUGl2b3RNb2RlJyxcbiAgICAgICAgJ3N1cHByZXNzUm93Q2xpY2tTZWxlY3Rpb24nLCAnc3VwcHJlc3NDZWxsU2VsZWN0aW9uJywgJ3N1cHByZXNzSG9yaXpvbnRhbFNjcm9sbCcsICdkZWJ1ZycsXG4gICAgICAgICdlbmFibGVDb2xSZXNpemUnLCAnZW5hYmxlQ2VsbEV4cHJlc3Npb25zJywgJ2VuYWJsZVNvcnRpbmcnLCAnZW5hYmxlU2VydmVyU2lkZVNvcnRpbmcnLFxuICAgICAgICAnZW5hYmxlRmlsdGVyJywgJ2VuYWJsZVNlcnZlclNpZGVGaWx0ZXInLCAnYW5ndWxhckNvbXBpbGVSb3dzJywgJ2FuZ3VsYXJDb21waWxlRmlsdGVycycsXG4gICAgICAgICdhbmd1bGFyQ29tcGlsZUhlYWRlcnMnLCAnZ3JvdXBTdXBwcmVzc0F1dG9Db2x1bW4nLCAnZ3JvdXBTZWxlY3RzQ2hpbGRyZW4nLFxuICAgICAgICAnZ3JvdXBJbmNsdWRlRm9vdGVyJywgJ2dyb3VwVXNlRW50aXJlUm93JywgJ2dyb3VwU3VwcHJlc3NSb3cnLCAnZ3JvdXBTdXBwcmVzc0JsYW5rSGVhZGVyJywgJ2ZvclByaW50JyxcbiAgICAgICAgJ3N1cHByZXNzTWVudUhpZGUnLCAncm93RGVzZWxlY3Rpb24nLCAndW5Tb3J0SWNvbicsICdzdXBwcmVzc011bHRpU29ydCcsXG4gICAgICAgICdzaW5nbGVDbGlja0VkaXQnLCAnc3VwcHJlc3NMb2FkaW5nT3ZlcmxheScsICdzdXBwcmVzc05vUm93c092ZXJsYXknLCAnc3VwcHJlc3NBdXRvU2l6ZScsXG4gICAgICAgICdzdXBwcmVzc1BhcmVudHNJblJvd05vZGVzJywgJ3Nob3dUb29sUGFuZWwnLCAnc3VwcHJlc3NDb2x1bW5Nb3ZlQW5pbWF0aW9uJywgJ3N1cHByZXNzTW92YWJsZUNvbHVtbnMnLFxuICAgICAgICAnc3VwcHJlc3NGaWVsZERvdE5vdGF0aW9uJywgJ2VuYWJsZVJhbmdlU2VsZWN0aW9uJyxcbiAgICAgICAgJ3Bpdm90UGFuZWxTaG93JywgJ3N1cHByZXNzVG91Y2gnLCAnc3VwcHJlc3NBc3luY0V2ZW50cycsICdhbGxvd0NvbnRleHRNZW51V2l0aENvbnRyb2xLZXknLFxuICAgICAgICAnc3VwcHJlc3NDb250ZXh0TWVudScsICdzdXBwcmVzc01lbnVGaWx0ZXJQYW5lbCcsICdzdXBwcmVzc01lbnVNYWluUGFuZWwnLCAnc3VwcHJlc3NNZW51Q29sdW1uUGFuZWwnLFxuICAgICAgICAnZW5hYmxlU3RhdHVzQmFyJywgJ2Fsd2F5c1Nob3dTdGF0dXNCYXInLCAncmVtZW1iZXJHcm91cFN0YXRlV2hlbk5ld0RhdGEnLCAnZW5hYmxlQ2VsbENoYW5nZUZsYXNoJywgJ3N1cHByZXNzRHJhZ0xlYXZlSGlkZXNDb2x1bW5zJyxcbiAgICAgICAgJ3N1cHByZXNzTWlkZGxlQ2xpY2tTY3JvbGxzJywgJ3N1cHByZXNzUHJldmVudERlZmF1bHRPbk1vdXNlV2hlZWwnLCAnc3VwcHJlc3NVc2VDb2xJZEZvckdyb3VwcycsXG4gICAgICAgICdzdXBwcmVzc0NvcHlSb3dzVG9DbGlwYm9hcmQnLCAncGl2b3RNb2RlJywgJ3N1cHByZXNzQWdnRnVuY0luSGVhZGVyJywgJ3N1cHByZXNzQ29sdW1uVmlydHVhbGlzYXRpb24nLCAnc3VwcHJlc3NBZ2dBdFJvb3RMZXZlbCcsXG4gICAgICAgICdzdXBwcmVzc0ZvY3VzQWZ0ZXJSZWZyZXNoJywgJ2Z1bmN0aW9uc1Bhc3NpdmUnLCAnZnVuY3Rpb25zUmVhZE9ubHknLFxuICAgICAgICAnYW5pbWF0ZVJvd3MnLCAnZ3JvdXBTZWxlY3RzRmlsdGVyZWQnLCAnZ3JvdXBSZW1vdmVTaW5nbGVDaGlsZHJlbicsICdncm91cFJlbW92ZUxvd2VzdFNpbmdsZUNoaWxkcmVuJyxcbiAgICAgICAgJ2VuYWJsZVJ0bCcsICdzdXBwcmVzc0NsaWNrRWRpdCcsXG4gICAgICAgICdlbmFibGVHcm91cEVkaXQnLCAnZW1iZWRGdWxsV2lkdGhSb3dzJywgJ3N1cHByZXNzVGFiYmluZycsICdzdXBwcmVzc1BhZ2luYXRpb25QYW5lbCcsICdmbG9hdGluZ0ZpbHRlcicsXG4gICAgICAgICdncm91cEhpZGVPcGVuUGFyZW50cycsICdncm91cE11bHRpQXV0b0NvbHVtbicsICdwYWdpbmF0aW9uJywgJ3N0b3BFZGl0aW5nV2hlbkdyaWRMb3Nlc0ZvY3VzJyxcbiAgICAgICAgJ3BhZ2luYXRpb25BdXRvUGFnZVNpemUnLCAnc3VwcHJlc3NTY3JvbGxPbk5ld0RhdGEnLCAncHVyZ2VDbG9zZWRSb3dOb2RlcycsICdjYWNoZVF1aWNrRmlsdGVyJyxcbiAgICAgICAgJ2RlbHRhUm93RGF0YU1vZGUnLCAnZW5zdXJlRG9tT3JkZXInLCAnYWNjZW50ZWRTb3J0JywgJ3Bpdm90VG90YWxzJywgJ3N1cHByZXNzQ2hhbmdlRGV0ZWN0aW9uJyxcbiAgICAgICAgJ3ZhbHVlQ2FjaGUnLCAndmFsdWVDYWNoZU5ldmVyRXhwaXJlcycsICdhZ2dyZWdhdGVPbmx5Q2hhbmdlZENvbHVtbnMnLCAnc3VwcHJlc3NBbmltYXRpb25GcmFtZScsXG4gICAgICAgICdzdXBwcmVzc0V4Y2VsRXhwb3J0JywgJ3N1cHByZXNzQ3N2RXhwb3J0JywgJ3RyZWVEYXRhJ1xuICAgIF07XG4gICAgUHJvcGVydHlLZXlzLkZVTkNUSU9OX1BST1BFUlRJRVMgPSBbJ2hlYWRlckNlbGxSZW5kZXJlcicsICdsb2NhbGVUZXh0RnVuYycsICdncm91cFJvd0lubmVyUmVuZGVyZXInLCAnZ3JvdXBSb3dJbm5lclJlbmRlcmVyRnJhbWV3b3JrJyxcbiAgICAgICAgJ2RhdGVDb21wb25lbnQnLCAnZGF0ZUNvbXBvbmVudEZyYW1ld29yaycsICdncm91cFJvd1JlbmRlcmVyJywgJ2dyb3VwUm93UmVuZGVyZXJGcmFtZXdvcmsnLCAnaXNFeHRlcm5hbEZpbHRlclByZXNlbnQnLFxuICAgICAgICAnZ2V0Um93SGVpZ2h0JywgJ2RvZXNFeHRlcm5hbEZpbHRlclBhc3MnLCAnZ2V0Um93Q2xhc3MnLCAnZ2V0Um93U3R5bGUnLCAnZ2V0Um93Q2xhc3NSdWxlcycsICdnZXRIZWFkZXJDZWxsVGVtcGxhdGUnLFxuICAgICAgICAndHJhdmVyc2VOb2RlJywgJ2dldENvbnRleHRNZW51SXRlbXMnLCAnZ2V0TWFpbk1lbnVJdGVtcycsICdwcm9jZXNzUm93UG9zdENyZWF0ZScsICdwcm9jZXNzQ2VsbEZvckNsaXBib2FyZCcsXG4gICAgICAgICdnZXROb2RlQ2hpbGREZXRhaWxzJywgJ2dyb3VwUm93QWdnTm9kZXMnLCAnZ2V0Um93Tm9kZUlkJywgJ2lzRnVsbFdpZHRoQ2VsbCcsICdmdWxsV2lkdGhDZWxsUmVuZGVyZXInLFxuICAgICAgICAnZnVsbFdpZHRoQ2VsbFJlbmRlcmVyRnJhbWV3b3JrJywgJ2RvZXNEYXRhRmxvd2VyJywgJ3Byb2Nlc3NTZWNvbmRhcnlDb2xEZWYnLCAncHJvY2Vzc1NlY29uZGFyeUNvbEdyb3VwRGVmJyxcbiAgICAgICAgJ2dldEJ1c2luZXNzS2V5Rm9yTm9kZScsICdzZW5kVG9DbGlwYm9hcmQnLCAnbmF2aWdhdGVUb05leHRDZWxsJywgJ3RhYlRvTmV4dENlbGwnLFxuICAgICAgICAncHJvY2Vzc0NlbGxGcm9tQ2xpcGJvYXJkJywgJ2dldERvY3VtZW50JywgJ3Bvc3RQcm9jZXNzUG9wdXAnLCAnZ2V0Q2hpbGRDb3VudCcsICdnZXREYXRhUGF0aCddO1xuICAgIFByb3BlcnR5S2V5cy5BTExfUFJPUEVSVElFUyA9IFByb3BlcnR5S2V5cy5BUlJBWV9QUk9QRVJUSUVTXG4gICAgICAgIC5jb25jYXQoUHJvcGVydHlLZXlzLk9CSkVDVF9QUk9QRVJUSUVTKVxuICAgICAgICAuY29uY2F0KFByb3BlcnR5S2V5cy5TVFJJTkdfUFJPUEVSVElFUylcbiAgICAgICAgLmNvbmNhdChQcm9wZXJ0eUtleXMuTlVNQkVSX1BST1BFUlRJRVMpXG4gICAgICAgIC5jb25jYXQoUHJvcGVydHlLZXlzLkZVTkNUSU9OX1BST1BFUlRJRVMpXG4gICAgICAgIC5jb25jYXQoUHJvcGVydHlLZXlzLkJPT0xFQU5fUFJPUEVSVElFUyk7XG4gICAgcmV0dXJuIFByb3BlcnR5S2V5cztcbn0oKSk7XG5leHBvcnRzLlByb3BlcnR5S2V5cyA9IFByb3BlcnR5S2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3Byb3BlcnR5S2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbi8qKlxuICogVGhlcmUgYXJlIG1hbnkgaW5zdGFuY2VzIG9mIHRoaXMgY29tcG9uZW50IGNvdmVyaW5nIGVhY2ggb2YgdGhlIGFyZWFzIGEgcm93IGNhbiBiZSBlbnRlcmVkXG4gKiBlZyBib2R5LCBwaW5uZWQgbGVmdCwgZnVsbFdpZHRoLiBUaGUgY29tcG9uZW50IGRpZmZlcnMgZnJvbSBvdGhlcnMgaW4gdGhhdCBpdCdzIGdpdmVuIHRoZVxuICogZWxlbWVudHMsIHRoZXJlIGlzIG5vIHRlbXBsYXRlLiBBbGwgb2YgdGhlIGVsZW1lbnRzIGFyZSBwYXJ0IG9mIHRoZSBHcmlkUGFuZWwuXG4gKi9cbnZhciBSb3dDb250YWluZXJDb21wb25lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvd0NvbnRhaW5lckNvbXBvbmVudChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jaGlsZENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yb3dUZW1wbGF0ZXNUb0FkZCA9IFtdO1xuICAgICAgICB0aGlzLmFmdGVyR3VpQXR0YWNoZWRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyID0gcGFyYW1zLmVDb250YWluZXI7XG4gICAgICAgIHRoaXMuZVZpZXdwb3J0ID0gcGFyYW1zLmVWaWV3cG9ydDtcbiAgICAgICAgdGhpcy5oaWRlV2hlbk5vQ2hpbGRyZW4gPSBwYXJhbXMuaGlkZVdoZW5Ob0NoaWxkcmVuO1xuICAgIH1cbiAgICBSb3dDb250YWluZXJDb21wb25lbnQucHJvdG90eXBlLnBvc3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZG9tT3JkZXIgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5pc0Vuc3VyZURvbU9yZGVyKCkgJiYgIXRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmlzRm9yUHJpbnQoKTtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2liaWxpdHkoKTtcbiAgICB9O1xuICAgIFJvd0NvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0Um93RWxlbWVudCA9IGZ1bmN0aW9uIChjb21wSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2NvbXAtaWQ9XFxcIlwiICsgY29tcElkICsgXCJcXFwiXVwiKTtcbiAgICB9O1xuICAgIFJvd0NvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICB0aGlzLmVDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgIH07XG4gICAgUm93Q29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZS5mbHVzaFJvd1RlbXBsYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaWYgZG9pbmcgZG9tIG9yZGVyLCB0aGVuIHJvd1RlbXBsYXRlcyB3aWxsIGJlIGVtcHR5LFxuICAgICAgICAvLyBvciBpZiBub3cgcm93cyBhZGRlZCBzaW5jZSBsYXN0IHRpbWUgYWxzbyBlbXB0eS5cbiAgICAgICAgaWYgKHRoaXMucm93VGVtcGxhdGVzVG9BZGQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgaHRtbFRvQWRkID0gdGhpcy5yb3dUZW1wbGF0ZXNUb0FkZC5qb2luKCcnKTtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuYXBwZW5kSHRtbCh0aGlzLmVDb250YWluZXIsIGh0bWxUb0FkZCk7XG4gICAgICAgICAgICB0aGlzLnJvd1RlbXBsYXRlc1RvQWRkLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBvbmx5IGVtcHR5IGlmIG5vIHJvd3Mgc2luY2UgbGFzdCB0aW1lLCBhcyB3aGVuXG4gICAgICAgIC8vIGRvaW5nIGRvbSBvcmRlciwgd2Ugc3RpbGwgaGF2ZSBjYWxsYmFja3MgdG8gcHJvY2Vzc1xuICAgICAgICB0aGlzLmFmdGVyR3VpQXR0YWNoZWRDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gZnVuYygpOyB9KTtcbiAgICAgICAgdGhpcy5hZnRlckd1aUF0dGFjaGVkQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubGFzdFBsYWNlZEVsZW1lbnQgPSBudWxsO1xuICAgIH07XG4gICAgUm93Q29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZS5hcHBlbmRSb3dUZW1wbGF0ZSA9IGZ1bmN0aW9uIChyb3dUZW1wbGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tT3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFBsYWNlZEVsZW1lbnQgPSB1dGlsc18xLlV0aWxzLmluc2VydFRlbXBsYXRlV2l0aERvbU9yZGVyKHRoaXMuZUNvbnRhaW5lciwgcm93VGVtcGxhdGUsIHRoaXMubGFzdFBsYWNlZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3dUZW1wbGF0ZXNUb0FkZC5wdXNoKHJvd1RlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFmdGVyR3VpQXR0YWNoZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIC8vIGl0IGlzIGltcG9ydGFudCB3ZSBwdXQgaXRlbXMgaW4gaW4gb3JkZXIsIHNvIHRoYXQgd2hlbiB3ZSBvcGVuIGEgcm93IGdyb3VwLFxuICAgICAgICAvLyB0aGUgbmV3IHJvd3MgYXJlIGluc2VydGVkIGFmdGVyIHRoZSBvcGVuZWQgZ3JvdXAsIGJ1dCBiZWZvcmUgdGhlIHJvd3MgYmVsb3cuXG4gICAgICAgIC8vIHRoYXQgd2F5LCB0aGUgcm93cyBiZWxvdyBhcmUgb3ZlciB0aGUgbmV3IHJvd3MgKGFzIGRvbSByZW5kZXJzIGxhc3QgaW4gZG9tIG92ZXJcbiAgICAgICAgLy8gaXRlbXMgcHJldmlvdXMgaW4gZG9tKSwgb3RoZXJ3aXNlIHRoZSBjaGlsZCByb3dzIHdvdWxkIGNvdmVyIHRoZSByb3cgYmVsb3cgYW5kXG4gICAgICAgIC8vIHRoYXQgbWVhbnQgdGhlIHVzZXIgZG9lc24ndCBzZWUgdGhlIHJvd3MgYmVsb3cgc2xpZGUgYXdheS5cbiAgICAgICAgdGhpcy5jaGlsZENvdW50Kys7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpYmlsaXR5KCk7XG4gICAgfTtcbiAgICBSb3dDb250YWluZXJDb21wb25lbnQucHJvdG90eXBlLmVuc3VyZURvbU9yZGVyID0gZnVuY3Rpb24gKGVSb3cpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tT3JkZXIpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuZW5zdXJlRG9tT3JkZXIodGhpcy5lQ29udGFpbmVyLCBlUm93LCB0aGlzLmxhc3RQbGFjZWRFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMubGFzdFBsYWNlZEVsZW1lbnQgPSBlUm93O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3dDb250YWluZXJDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZVJvd0VsZW1lbnQgPSBmdW5jdGlvbiAoZVJvdykge1xuICAgICAgICB0aGlzLmVDb250YWluZXIucmVtb3ZlQ2hpbGQoZVJvdyk7XG4gICAgICAgIHRoaXMuY2hpbGRDb3VudC0tO1xuICAgICAgICB0aGlzLmNoZWNrVmlzaWJpbGl0eSgpO1xuICAgIH07XG4gICAgUm93Q29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZS5jaGVja1Zpc2liaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5oaWRlV2hlbk5vQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZUd1aSA9IHRoaXMuZVZpZXdwb3J0ID8gdGhpcy5lVmlld3BvcnQgOiB0aGlzLmVDb250YWluZXI7XG4gICAgICAgIHZhciB2aXNpYmxlID0gdGhpcy5jaGlsZENvdW50ID4gMDtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSAhPT0gdmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgICAgIHV0aWxzXzEuVXRpbHMuc2V0VmlzaWJsZShlR3VpLCB2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIFJvd0NvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIFJvd0NvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zdENvbnN0cnVjdFwiLCBudWxsKTtcbiAgICByZXR1cm4gUm93Q29udGFpbmVyQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydHMuUm93Q29udGFpbmVyQ29tcG9uZW50ID0gUm93Q29udGFpbmVyQ29tcG9uZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcmVuZGVyaW5nL3Jvd0NvbnRhaW5lckNvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIHJvd05vZGVCbG9ja18xID0gcmVxdWlyZShcIi4uL2NhY2hlL3Jvd05vZGVCbG9ja1wiKTtcbnZhciByb3dSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmluZy9yb3dSZW5kZXJlclwiKTtcbnZhciBJbmZpbml0ZUJsb2NrID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5maW5pdGVCbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmZpbml0ZUJsb2NrKHBhZ2VOdW1iZXIsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYWdlTnVtYmVyLCBwYXJhbXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhY2hlUGFyYW1zID0gcGFyYW1zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluZmluaXRlQmxvY2sucHJvdG90eXBlLmNyZWF0ZUJsYW5rUm93Tm9kZSA9IGZ1bmN0aW9uIChyb3dJbmRleCkge1xuICAgICAgICB2YXIgcm93Tm9kZSA9IF9zdXBlci5wcm90b3R5cGUuY3JlYXRlQmxhbmtSb3dOb2RlLmNhbGwodGhpcywgcm93SW5kZXgpO1xuICAgICAgICByb3dOb2RlLnVpTGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLnNldEluZGV4QW5kVG9wT25Sb3dOb2RlKHJvd05vZGUsIHJvd0luZGV4KTtcbiAgICAgICAgcmV0dXJuIHJvd05vZGU7XG4gICAgfTtcbiAgICBJbmZpbml0ZUJsb2NrLnByb3RvdHlwZS5zZXREYXRhQW5kSWQgPSBmdW5jdGlvbiAocm93Tm9kZSwgZGF0YSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMuZXhpc3RzKGRhdGEpKSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIGlmIHRoZSB1c2VyIGlzIG5vdCBwcm92aWRpbmcgaWQncyB3ZSBqdXN0IHVzZSB0aGVcbiAgICAgICAgICAgIC8vIGluZGV4IGZvciB0aGUgcm93LiB0aGlzIHdpbGwgYWxsb3cgc2VsZWN0aW9uIHRvIHdvcmsgKHRoYXQgaXMgYmFzZWRcbiAgICAgICAgICAgIC8vIG9uIGluZGV4KSBhcyBsb25nIHVzZXIgaXMgbm90IGluc2VydGluZyBvciBkZWxldGluZyByb3dzLFxuICAgICAgICAgICAgLy8gb3Igd2FudGluZyB0byBrZWVwIHNlbGVjdGlvbiBiZXR3ZWVuIHNlcnZlciBzaWRlIHNvcnRpbmcgb3IgZmlsdGVyaW5nXG4gICAgICAgICAgICByb3dOb2RlLnNldERhdGFBbmRJZChkYXRhLCBpbmRleC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvd05vZGUuc2V0RGF0YUFuZElkKHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5maW5pdGVCbG9jay5wcm90b3R5cGUuc2V0Um93Tm9kZSA9IGZ1bmN0aW9uIChyb3dJbmRleCwgcm93Tm9kZSkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldFJvd05vZGUuY2FsbCh0aGlzLCByb3dJbmRleCwgcm93Tm9kZSk7XG4gICAgICAgIHRoaXMuc2V0SW5kZXhBbmRUb3BPblJvd05vZGUocm93Tm9kZSwgcm93SW5kZXgpO1xuICAgIH07XG4gICAgSW5maW5pdGVCbG9jay5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywge1xuICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgcm93UmVuZGVyZXI6IHRoaXMucm93UmVuZGVyZXJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbmZpbml0ZUJsb2NrLnByb3RvdHlwZS5nZXROb2RlSWRQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgSW5maW5pdGVCbG9jay5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gKGRpc3BsYXlJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3dVc2luZ0xvY2FsSW5kZXgoZGlzcGxheUluZGV4KTtcbiAgICB9O1xuICAgIEluZmluaXRlQmxvY2sucHJvdG90eXBlLnNldEluZGV4QW5kVG9wT25Sb3dOb2RlID0gZnVuY3Rpb24gKHJvd05vZGUsIHJvd0luZGV4KSB7XG4gICAgICAgIHJvd05vZGUuc2V0Um93SW5kZXgocm93SW5kZXgpO1xuICAgICAgICByb3dOb2RlLnJvd1RvcCA9IHRoaXMuY2FjaGVQYXJhbXMucm93SGVpZ2h0ICogcm93SW5kZXg7XG4gICAgfTtcbiAgICBJbmZpbml0ZUJsb2NrLnByb3RvdHlwZS5sb2FkRnJvbURhdGFzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFBST0JMRU0gLiAuIC4gLiB3aGVuIHRoZSB1c2VyIHNldHMgc29ydCB2aWEgY29sRGVmLnNvcnQsIHRoZW4gdGhpcyBjb2RlXG4gICAgICAgIC8vIGlzIGV4ZWN1dGluZyBiZWZvcmUgdGhlIHNvcnQgaXMgc2V0IHVwLCBzbyBzZXJ2ZXIgaXMgbm90IGdldHRpbmcgdGhlIHNvcnRcbiAgICAgICAgLy8gbW9kZWwuIG5lZWQgdG8gY2hhbmdlIHdpdGggcmVnYXJkcyBvcmRlciAtIHNvIHRoZSBzZXJ2ZXIgc2lkZSByZXF1ZXN0IGlzXG4gICAgICAgIC8vIEFGVEVSIHRodXMgaXQgZ2V0cyB0aGUgcmlnaHQgc29ydCBtb2RlbC5cbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHN0YXJ0Um93OiB0aGlzLmdldFN0YXJ0Um93KCksXG4gICAgICAgICAgICBlbmRSb3c6IHRoaXMuZ2V0RW5kUm93KCksXG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IHRoaXMucGFnZUxvYWRlZC5iaW5kKHRoaXMsIHRoaXMuZ2V0VmVyc2lvbigpKSxcbiAgICAgICAgICAgIGZhaWxDYWxsYmFjazogdGhpcy5wYWdlTG9hZEZhaWxlZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc29ydE1vZGVsOiB0aGlzLmNhY2hlUGFyYW1zLnNvcnRNb2RlbCxcbiAgICAgICAgICAgIGZpbHRlck1vZGVsOiB0aGlzLmNhY2hlUGFyYW1zLmZpbHRlck1vZGVsLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0Q29udGV4dCgpXG4gICAgICAgIH07XG4gICAgICAgIGlmICh1dGlsc18xLlV0aWxzLm1pc3NpbmcodGhpcy5jYWNoZVBhcmFtcy5kYXRhc291cmNlLmdldFJvd3MpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhZy1HcmlkOiBkYXRhc291cmNlIGlzIG1pc3NpbmcgZ2V0Um93cyBtZXRob2RcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgb2xkIHZlcnNpb24gb2YgZGF0YXNvdXJjZSB1c2VkXG4gICAgICAgIHZhciBnZXRSb3dzUGFyYW1zID0gdXRpbHNfMS5VdGlscy5nZXRGdW5jdGlvblBhcmFtZXRlcnModGhpcy5jYWNoZVBhcmFtcy5kYXRhc291cmNlLmdldFJvd3MpO1xuICAgICAgICBpZiAoZ2V0Um93c1BhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FnLWdyaWQ6IEl0IGxvb2tzIGxpa2UgeW91ciBwYWdpbmcgZGF0YXNvdXJjZSBpcyBvZiB0aGUgb2xkIHR5cGUsIHRha2luZyBtb3JlIHRoYW4gb25lIHBhcmFtZXRlci4nKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWctZ3JpZDogRnJvbSBhZy1ncmlkIDEuOS4wLCBub3cgdGhlIGdldFJvd3MgdGFrZXMgb25lIHBhcmFtZXRlci4gU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1dCBpbiB0aW1lb3V0LCB0byBmb3JjZSByZXN1bHQgdG8gYmUgYXN5bmNcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jYWNoZVBhcmFtcy5kYXRhc291cmNlLmdldFJvd3MocGFyYW1zKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkT3B0aW9uc1dyYXBwZXJfMS5HcmlkT3B0aW9uc1dyYXBwZXIpXG4gICAgXSwgSW5maW5pdGVCbG9jay5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIEluZmluaXRlQmxvY2sucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgncm93UmVuZGVyZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHJvd1JlbmRlcmVyXzEuUm93UmVuZGVyZXIpXG4gICAgXSwgSW5maW5pdGVCbG9jay5wcm90b3R5cGUsIFwicm93UmVuZGVyZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgSW5maW5pdGVCbG9jay5wcm90b3R5cGUsIFwiaW5pdFwiLCBudWxsKTtcbiAgICByZXR1cm4gSW5maW5pdGVCbG9jaztcbn0ocm93Tm9kZUJsb2NrXzEuUm93Tm9kZUJsb2NrKSk7XG5leHBvcnRzLkluZmluaXRlQmxvY2sgPSBJbmZpbml0ZUJsb2NrO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvcm93TW9kZWxzL2luZmluaXRlL2luZmluaXRlQmxvY2suanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGFnLWdyaWQgLSBBZHZhbmNlZCBEYXRhIEdyaWQgLyBEYXRhIFRhYmxlIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCAvIFJlYWN0IC8gQW5ndWxhckpTIC8gV2ViIENvbXBvbmVudHNcbiAqIEB2ZXJzaW9uIHYxNC4wLjFcbiAqIEBsaW5rIGh0dHA6Ly93d3cuYWctZ3JpZC5jb20vXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2V2ZW50U2VydmljZVwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9ldmVudHNcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vbG9nZ2VyXCIpO1xudmFyIGluZmluaXRlQmxvY2tfMSA9IHJlcXVpcmUoXCIuL2luZmluaXRlQmxvY2tcIik7XG52YXIgcm93Tm9kZUNhY2hlXzEgPSByZXF1aXJlKFwiLi4vY2FjaGUvcm93Tm9kZUNhY2hlXCIpO1xudmFyIGdyaWRBcGlfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmlkQXBpXCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgSW5maW5pdGVDYWNoZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluZmluaXRlQ2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5maW5pdGVDYWNoZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcmFtcykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5maW5pdGVDYWNoZS5wcm90b3R5cGUuc2V0QmVhbnMgPSBmdW5jdGlvbiAobG9nZ2VyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlckZhY3RvcnkuY3JlYXRlKCdJbmZpbml0ZUNhY2hlJyk7XG4gICAgfTtcbiAgICBJbmZpbml0ZUNhY2hlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gc3RhcnQgbG9hZCBvZiBkYXRhLCBhcyB0aGUgdmlydHVhbFJvd0NvdW50IHdpbGwgcmVtYWluIGF0IDAgb3RoZXJ3aXNlLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRoaXMgdG8ga2ljayB0aGluZ3Mgb2ZmLCBvdGhlcndpc2UgZ3JpZCB3b3VsZCBuZXZlciBjYWxsIGdldFJvdygpXG4gICAgICAgIHRoaXMuZ2V0Um93KDApO1xuICAgIH07XG4gICAgSW5maW5pdGVDYWNoZS5wcm90b3R5cGUubW92ZUl0ZW1zRG93biA9IGZ1bmN0aW9uIChwYWdlLCBtb3ZlRnJvbUluZGV4LCBtb3ZlQ291bnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gcGFnZS5nZXRTdGFydFJvdygpO1xuICAgICAgICB2YXIgZW5kUm93ID0gcGFnZS5nZXRFbmRSb3coKTtcbiAgICAgICAgdmFyIGluZGV4T2ZMYXN0Um93VG9Nb3ZlID0gbW92ZUZyb21JbmRleCArIG1vdmVDb3VudDtcbiAgICAgICAgLy8gYWxsIHJvd3MgbmVlZCB0byBiZSBtb3ZlZCBkb3duIGJlbG93IHRoZSBpbnNlcnRpb24gaW5kZXhcbiAgICAgICAgZm9yICh2YXIgY3VycmVudFJvd0luZGV4ID0gZW5kUm93IC0gMTsgY3VycmVudFJvd0luZGV4ID49IHN0YXJ0Um93OyBjdXJyZW50Um93SW5kZXgtLSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgbW92ZSByb3dzIGF0IG9yIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIGluZGV4XG4gICAgICAgICAgICBpZiAoY3VycmVudFJvd0luZGV4IDwgaW5kZXhPZkxhc3RSb3dUb01vdmUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleE9mTm9kZVdlV2FudCA9IGN1cnJlbnRSb3dJbmRleCAtIG1vdmVDb3VudDtcbiAgICAgICAgICAgIHZhciBub2RlRm9yVGhpc0luZGV4ID0gdGhpcy5nZXRSb3coaW5kZXhPZk5vZGVXZVdhbnQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVGb3JUaGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBwYWdlLnNldFJvd05vZGUoY3VycmVudFJvd0luZGV4LCBub2RlRm9yVGhpc0luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhZ2Uuc2V0QmxhbmtSb3dOb2RlKGN1cnJlbnRSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgcGFnZS5zZXREaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZpbml0ZUNhY2hlLnByb3RvdHlwZS5pbnNlcnRJdGVtcyA9IGZ1bmN0aW9uIChibG9jaywgaW5kZXhUb0luc2VydCwgaXRlbXMpIHtcbiAgICAgICAgdmFyIHBhZ2VTdGFydFJvdyA9IGJsb2NrLmdldFN0YXJ0Um93KCk7XG4gICAgICAgIHZhciBwYWdlRW5kUm93ID0gYmxvY2suZ2V0RW5kUm93KCk7XG4gICAgICAgIHZhciBuZXdSb3dOb2RlcyA9IFtdO1xuICAgICAgICAvLyBuZXh0IHN0YWdlIGlzIGluc2VydCB0aGUgcm93cyBpbnRvIHRoaXMgcGFnZSwgaWYgYXBwbGljYWJsZVxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaXRlbXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgcm93SW5kZXggPSBpbmRleFRvSW5zZXJ0ICsgaW5kZXg7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJvd0luVGhpc1BhZ2UgPSByb3dJbmRleCA+PSBwYWdlU3RhcnRSb3cgJiYgcm93SW5kZXggPCBwYWdlRW5kUm93O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3dJblRoaXNQYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBuZXdSb3dOb2RlID0gYmxvY2suc2V0TmV3RGF0YShyb3dJbmRleCwgZGF0YUl0ZW0pO1xuICAgICAgICAgICAgICAgIG5ld1Jvd05vZGVzLnB1c2gobmV3Um93Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1Jvd05vZGVzO1xuICAgIH07XG4gICAgSW5maW5pdGVDYWNoZS5wcm90b3R5cGUuaW5zZXJ0SXRlbXNBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4VG9JbnNlcnQsIGl0ZW1zKSB7XG4gICAgICAgIC8vIGdldCBhbGwgcGFnZSBpZCdzIGFzIE5VTUJFUlMgKG5vdCBzdHJpbmdzLCBhcyB3ZSBuZWVkIHRvIHNvcnQgYXMgbnVtYmVycykgYW5kIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5ld05vZGVzID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaEJsb2NrSW5SZXZlcnNlT3JkZXIoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICB2YXIgcGFnZUVuZFJvdyA9IGJsb2NrLmdldEVuZFJvdygpO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGluc2VydGlvbiBpcyBhZnRlciB0aGlzIHBhZ2UsIHRoZW4gdGhpcyBwYWdlIGlzIG5vdCBpbXBhY3RlZFxuICAgICAgICAgICAgaWYgKHBhZ2VFbmRSb3cgPD0gaW5kZXhUb0luc2VydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm1vdmVJdGVtc0Rvd24oYmxvY2ssIGluZGV4VG9JbnNlcnQsIGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZXNUaGlzUGFnZSA9IF90aGlzLmluc2VydEl0ZW1zKGJsb2NrLCBpbmRleFRvSW5zZXJ0LCBpdGVtcyk7XG4gICAgICAgICAgICBuZXdOb2Rlc1RoaXNQYWdlLmZvckVhY2goZnVuY3Rpb24gKHJvd05vZGUpIHsgcmV0dXJuIG5ld05vZGVzLnB1c2gocm93Tm9kZSk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXhSb3dGb3VuZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmhhY2tfc2V0VmlydHVhbFJvd0NvdW50KHRoaXMuZ2V0VmlydHVhbFJvd0NvdW50KCkgKyBpdGVtcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DYWNoZVVwZGF0ZWQoKTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1JPV19EQVRBX1VQREFURUQsXG4gICAgICAgICAgICBhcGk6IHRoaXMuZ3JpZEFwaSxcbiAgICAgICAgICAgIGNvbHVtbkFwaTogdGhpcy5jb2x1bW5BcGlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcbiAgICAvLyB0aGUgcm93UmVuZGVyZXIgd2lsbCBub3QgcGFzcyBkb250Q3JlYXRlUGFnZSwgbWVhbmluZyB3aGVuIHJlbmRlcmluZyB0aGUgZ3JpZCxcbiAgICAvLyBpdCB3aWxsIHdhbnQgbmV3IHBhZ2VzIGluIHRoZSBjYWNoZSBhcyBpdCBhc2tzIGZvciByb3dzLiBvbmx5IHdoZW4gd2UgYXJlIGluc2VydGluZyAvXG4gICAgLy8gcmVtb3Zpbmcgcm93cyB2aWEgdGhlIGFwaSBpcyBkb250Q3JlYXRlUGFnZSBzZXQsIHdoZXJlIHdlIG1vdmUgcm93cyBiZXR3ZWVuIHRoZSBwYWdlcy5cbiAgICBJbmZpbml0ZUNhY2hlLnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiAocm93SW5kZXgsIGRvbnRDcmVhdGVQYWdlKSB7XG4gICAgICAgIGlmIChkb250Q3JlYXRlUGFnZSA9PT0gdm9pZCAwKSB7IGRvbnRDcmVhdGVQYWdlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGJsb2NrSWQgPSBNYXRoLmZsb29yKHJvd0luZGV4IC8gdGhpcy5jYWNoZVBhcmFtcy5ibG9ja1NpemUpO1xuICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLmdldEJsb2NrKGJsb2NrSWQpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoZG9udENyZWF0ZVBhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2NrID0gdGhpcy5jcmVhdGVCbG9jayhibG9ja0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2suZ2V0Um93KHJvd0luZGV4KTtcbiAgICB9O1xuICAgIEluZmluaXRlQ2FjaGUucHJvdG90eXBlLmNyZWF0ZUJsb2NrID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHZhciBuZXdCbG9jayA9IG5ldyBpbmZpbml0ZUJsb2NrXzEuSW5maW5pdGVCbG9jayhibG9ja051bWJlciwgdGhpcy5jYWNoZVBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29udGV4dC53aXJlQmVhbihuZXdCbG9jayk7XG4gICAgICAgIHRoaXMucG9zdENyZWF0ZUJsb2NrKG5ld0Jsb2NrKTtcbiAgICAgICAgcmV0dXJuIG5ld0Jsb2NrO1xuICAgIH07XG4gICAgLy8gd2UgaGF2ZSB0aGlzIG9uIGluZmluaXRlIHJvdyBtb2RlbCBvbmx5LCBub3QgZW50ZXJwcmlzZSByb3cgbW9kZWwsXG4gICAgLy8gYmVjYXVzZSBmb3IgZW50ZXJwcmlzZSwgaXQgd291bGQgbGVhdmUgdGhlIGNoaWxkcmVuIGluIGluY29uc2lzdGVudFxuICAgIC8vIHN0YXRlIC0gZWcgaWYgYSBub2RlIGhhZCBjaGlsZHJlbiwgYnV0IGFmdGVyIHRoZSByZWZyZXNoIGl0IGhhZCBkYXRhXG4gICAgLy8gZm9yIGEgZGlmZmVyZW50IHJvdywgdGhlbiB0aGUgY2hpbGRyZW4gd291bGQgYmUgd2l0aCB0aGUgd3Jvbmcgcm93IG5vZGUuXG4gICAgSW5maW5pdGVDYWNoZS5wcm90b3R5cGUucmVmcmVzaENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hCbG9ja0luT3JkZXIoZnVuY3Rpb24gKGJsb2NrKSB7IHJldHVybiBibG9jay5zZXREaXJ0eSgpOyB9KTtcbiAgICAgICAgdGhpcy5jaGVja0Jsb2NrVG9Mb2FkKCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgSW5maW5pdGVDYWNoZS5wcm90b3R5cGUsIFwiZXZlbnRTZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2NvbnRleHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvbnRleHRfMS5Db250ZXh0KVxuICAgIF0sIEluZmluaXRlQ2FjaGUucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb2x1bW5Db250cm9sbGVyXzEuQ29sdW1uQXBpKVxuICAgIF0sIEluZmluaXRlQ2FjaGUucHJvdG90eXBlLCBcImNvbHVtbkFwaVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkQXBpJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBncmlkQXBpXzEuR3JpZEFwaSlcbiAgICBdLCBJbmZpbml0ZUNhY2hlLnByb3RvdHlwZSwgXCJncmlkQXBpXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIF9fcGFyYW0oMCwgY29udGV4dF8xLlF1YWxpZmllcignbG9nZ2VyRmFjdG9yeScpKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtsb2dnZXJfMS5Mb2dnZXJGYWN0b3J5XSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgSW5maW5pdGVDYWNoZS5wcm90b3R5cGUsIFwic2V0QmVhbnNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5Qb3N0Q29uc3RydWN0LFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEluZmluaXRlQ2FjaGUucHJvdG90eXBlLCBcImluaXRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIEluZmluaXRlQ2FjaGU7XG59KHJvd05vZGVDYWNoZV8xLlJvd05vZGVDYWNoZSkpO1xuZXhwb3J0cy5JbmZpbml0ZUNhY2hlID0gSW5maW5pdGVDYWNoZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9pbmZpbml0ZS9pbmZpbml0ZUNhY2hlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3dpZGdldHMvY29tcG9uZW50XCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L2NvbnRleHRcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGNvbXBvbmVudEFubm90YXRpb25zXzEgPSByZXF1aXJlKFwiLi4vLi4vd2lkZ2V0cy9jb21wb25lbnRBbm5vdGF0aW9uc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2V2ZW50U2VydmljZVwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9ldmVudHNcIik7XG52YXIgcm93UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJpbmcvcm93UmVuZGVyZXJcIik7XG52YXIgcGFnaW5hdGlvblByb3h5XzEgPSByZXF1aXJlKFwiLi4vcGFnaW5hdGlvblByb3h5XCIpO1xudmFyIFBhZ2luYXRpb25Db21wID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFnaW5hdGlvbkNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFnaW5hdGlvbkNvbXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUucG9zdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRUZW1wbGF0ZSh0aGlzLmdldFRlbXBsYXRlKCkpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50U2VydmljZSwgZXZlbnRzXzEuRXZlbnRzLkVWRU5UX1BBR0lOQVRJT05fQ0hBTkdFRCwgdGhpcy5vblBhZ2luYXRpb25DaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmJ0Rmlyc3QsICdjbGljaycsIHRoaXMub25CdEZpcnN0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmJ0TGFzdCwgJ2NsaWNrJywgdGhpcy5vbkJ0TGFzdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5idE5leHQsICdjbGljaycsIHRoaXMub25CdE5leHQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKHRoaXMuYnRQcmV2aW91cywgJ2NsaWNrJywgdGhpcy5vbkJ0UHJldmlvdXMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub25QYWdpbmF0aW9uQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLm9uUGFnaW5hdGlvbkNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlT3JEaXNhYmxlQnV0dG9ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJvd0xhYmVscygpO1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRQYWdlTGFiZWwoKTtcbiAgICAgICAgdGhpcy5zZXRUb3RhbExhYmVscygpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLnNldEN1cnJlbnRQYWdlTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldEN1cnJlbnRQYWdlKCk7XG4gICAgICAgIHRoaXMubGJDdXJyZW50LmlubmVySFRNTCA9IHRoaXMuZm9ybWF0TnVtYmVyKGN1cnJlbnRQYWdlICsgMSk7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUuZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB1c2VyRnVuYyA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldFBhZ2luYXRpb25OdW1iZXJGb3JtYXR0ZXJGdW5jKCk7XG4gICAgICAgIGlmICh1c2VyRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJGdW5jKHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuXy5mb3JtYXROdW1iZXJDb21tYXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUuZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NhbGVUZXh0RnVuYyA9IHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldExvY2FsZVRleHRGdW5jKCk7XG4gICAgICAgIHZhciBzdHJQYWdlID0gbG9jYWxlVGV4dEZ1bmMoJ3BhZ2UnLCAnUGFnZScpO1xuICAgICAgICB2YXIgc3RyVG8gPSBsb2NhbGVUZXh0RnVuYygndG8nLCAndG8nKTtcbiAgICAgICAgdmFyIHN0ck9mID0gbG9jYWxlVGV4dEZ1bmMoJ29mJywgJ29mJyk7XG4gICAgICAgIHZhciBzdHJGaXJzdCA9IGxvY2FsZVRleHRGdW5jKCdmaXJzdCcsICdGaXJzdCcpO1xuICAgICAgICB2YXIgc3RyUHJldmlvdXMgPSBsb2NhbGVUZXh0RnVuYygncHJldmlvdXMnLCAnUHJldmlvdXMnKTtcbiAgICAgICAgdmFyIHN0ck5leHQgPSBsb2NhbGVUZXh0RnVuYygnbmV4dCcsICdOZXh0Jyk7XG4gICAgICAgIHZhciBzdHJMYXN0ID0gbG9jYWxlVGV4dEZ1bmMoJ2xhc3QnLCAnTGFzdCcpO1xuICAgICAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJhZy1wYWdpbmctcGFuZWwgYWctZm9udC1zdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIHJlZj1cXFwiZVN1bW1hcnlQYW5lbFxcXCIgY2xhc3M9XFxcImFnLXBhZ2luZy1yb3ctc3VtbWFyeS1wYW5lbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiByZWY9XFxcImxiRmlyc3RSb3dPblBhZ2VcXFwiPjwvc3Bhbj4gXCIgKyBzdHJUbyArIFwiIDxzcGFuIHJlZj1cXFwibGJMYXN0Um93T25QYWdlXFxcIj48L3NwYW4+IFwiICsgc3RyT2YgKyBcIiA8c3BhbiByZWY9XFxcImxiUmVjb3JkQ291bnRcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiYWctcGFnaW5nLXBhZ2Utc3VtbWFyeS1wYW5lbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJhZy1wYWdpbmctYnV0dG9uXFxcIiByZWY9XFxcImJ0Rmlyc3RcXFwiPlwiICsgc3RyRmlyc3QgKyBcIjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYWctcGFnaW5nLWJ1dHRvblxcXCIgcmVmPVxcXCJidFByZXZpb3VzXFxcIj5cIiArIHN0clByZXZpb3VzICsgXCI8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIFwiICsgc3RyUGFnZSArIFwiIDxzcGFuIHJlZj1cXFwibGJDdXJyZW50XFxcIj48L3NwYW4+IFwiICsgc3RyT2YgKyBcIiA8c3BhbiByZWY9XFxcImxiVG90YWxcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImFnLXBhZ2luZy1idXR0b25cXFwiIHJlZj1cXFwiYnROZXh0XFxcIj5cIiArIHN0ck5leHQgKyBcIjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYWctcGFnaW5nLWJ1dHRvblxcXCIgcmVmPVxcXCJidExhc3RcXFwiPlwiICsgc3RyTGFzdCArIFwiPC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cIjtcbiAgICB9O1xuICAgIFBhZ2luYXRpb25Db21wLnByb3RvdHlwZS5vbkJ0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uUHJveHkuZ29Ub05leHRQYWdlKCk7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUub25CdFByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhZ2luYXRpb25Qcm94eS5nb1RvUHJldmlvdXNQYWdlKCk7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUub25CdEZpcnN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhZ2luYXRpb25Qcm94eS5nb1RvRmlyc3RQYWdlKCk7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUub25CdExhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFnaW5hdGlvblByb3h5LmdvVG9MYXN0UGFnZSgpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLmVuYWJsZU9yRGlzYWJsZUJ1dHRvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldEN1cnJlbnRQYWdlKCk7XG4gICAgICAgIHZhciBtYXhSb3dGb3VuZCA9IHRoaXMucGFnaW5hdGlvblByb3h5LmlzTGFzdFBhZ2VGb3VuZCgpO1xuICAgICAgICB2YXIgdG90YWxQYWdlcyA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFRvdGFsUGFnZXMoKTtcbiAgICAgICAgdmFyIGRpc2FibGVQcmV2aW91c0FuZEZpcnN0ID0gY3VycmVudFBhZ2UgPT09IDA7XG4gICAgICAgIHRoaXMuYnRQcmV2aW91cy5kaXNhYmxlZCA9IGRpc2FibGVQcmV2aW91c0FuZEZpcnN0O1xuICAgICAgICB0aGlzLmJ0Rmlyc3QuZGlzYWJsZWQgPSBkaXNhYmxlUHJldmlvdXNBbmRGaXJzdDtcbiAgICAgICAgdmFyIHplcm9QYWdlc1RvRGlzcGxheSA9IHRoaXMuaXNaZXJvUGFnZXNUb0Rpc3BsYXkoKTtcbiAgICAgICAgdmFyIG9uTGFzdFBhZ2UgPSBtYXhSb3dGb3VuZCAmJiBjdXJyZW50UGFnZSA9PT0gKHRvdGFsUGFnZXMgLSAxKTtcbiAgICAgICAgdmFyIGRpc2FibGVOZXh0ID0gb25MYXN0UGFnZSB8fCB6ZXJvUGFnZXNUb0Rpc3BsYXk7XG4gICAgICAgIHRoaXMuYnROZXh0LmRpc2FibGVkID0gZGlzYWJsZU5leHQ7XG4gICAgICAgIHZhciBkaXNhYmxlTGFzdCA9ICFtYXhSb3dGb3VuZCB8fCB6ZXJvUGFnZXNUb0Rpc3BsYXkgfHwgY3VycmVudFBhZ2UgPT09ICh0b3RhbFBhZ2VzIC0gMSk7XG4gICAgICAgIHRoaXMuYnRMYXN0LmRpc2FibGVkID0gZGlzYWJsZUxhc3Q7XG4gICAgfTtcbiAgICBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUudXBkYXRlUm93TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudFBhZ2UgPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRDdXJyZW50UGFnZSgpO1xuICAgICAgICB2YXIgcGFnZVNpemUgPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRQYWdlU2l6ZSgpO1xuICAgICAgICB2YXIgbWF4Um93Rm91bmQgPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5pc0xhc3RQYWdlRm91bmQoKTtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuaXNMYXN0UGFnZUZvdW5kKCkgP1xuICAgICAgICAgICAgdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0VG90YWxSb3dDb3VudCgpIDogbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0Um93O1xuICAgICAgICB2YXIgZW5kUm93O1xuICAgICAgICBpZiAodGhpcy5pc1plcm9QYWdlc1RvRGlzcGxheSgpKSB7XG4gICAgICAgICAgICBzdGFydFJvdyA9IDA7XG4gICAgICAgICAgICBlbmRSb3cgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRSb3cgPSAocGFnZVNpemUgKiBjdXJyZW50UGFnZSkgKyAxO1xuICAgICAgICAgICAgZW5kUm93ID0gc3RhcnRSb3cgKyBwYWdlU2l6ZSAtIDE7XG4gICAgICAgICAgICBpZiAobWF4Um93Rm91bmQgJiYgZW5kUm93ID4gcm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICBlbmRSb3cgPSByb3dDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxiRmlyc3RSb3dPblBhZ2UuaW5uZXJIVE1MID0gdGhpcy5mb3JtYXROdW1iZXIoc3RhcnRSb3cpO1xuICAgICAgICB0aGlzLmxiTGFzdFJvd09uUGFnZS5pbm5lckhUTUwgPSB0aGlzLmZvcm1hdE51bWJlcihlbmRSb3cpO1xuICAgIH07XG4gICAgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLmlzWmVyb1BhZ2VzVG9EaXNwbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4Um93Rm91bmQgPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5pc0xhc3RQYWdlRm91bmQoKTtcbiAgICAgICAgdmFyIHRvdGFsUGFnZXMgPSB0aGlzLnBhZ2luYXRpb25Qcm94eS5nZXRUb3RhbFBhZ2VzKCk7XG4gICAgICAgIHJldHVybiBtYXhSb3dGb3VuZCAmJiB0b3RhbFBhZ2VzID09PSAwO1xuICAgIH07XG4gICAgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLnNldFRvdGFsTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFzdFBhZ2VGb3VuZCA9IHRoaXMucGFnaW5hdGlvblByb3h5LmlzTGFzdFBhZ2VGb3VuZCgpO1xuICAgICAgICB2YXIgdG90YWxQYWdlcyA9IHRoaXMucGFnaW5hdGlvblByb3h5LmdldFRvdGFsUGFnZXMoKTtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5wYWdpbmF0aW9uUHJveHkuaXNMYXN0UGFnZUZvdW5kKCkgP1xuICAgICAgICAgICAgdGhpcy5wYWdpbmF0aW9uUHJveHkuZ2V0VG90YWxSb3dDb3VudCgpIDogbnVsbDtcbiAgICAgICAgaWYgKGxhc3RQYWdlRm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMubGJUb3RhbC5pbm5lckhUTUwgPSB0aGlzLmZvcm1hdE51bWJlcih0b3RhbFBhZ2VzKTtcbiAgICAgICAgICAgIHRoaXMubGJSZWNvcmRDb3VudC5pbm5lckhUTUwgPSB0aGlzLmZvcm1hdE51bWJlcihyb3dDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbW9yZVRleHQgPSB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRMb2NhbGVUZXh0RnVuYygpKCdtb3JlJywgJ21vcmUnKTtcbiAgICAgICAgICAgIHRoaXMubGJUb3RhbC5pbm5lckhUTUwgPSBtb3JlVGV4dDtcbiAgICAgICAgICAgIHRoaXMubGJSZWNvcmRDb3VudC5pbm5lckhUTUwgPSBtb3JlVGV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIFBhZ2luYXRpb25Db21wLnByb3RvdHlwZSwgXCJncmlkT3B0aW9uc1dyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnZXZlbnRTZXJ2aWNlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBldmVudFNlcnZpY2VfMS5FdmVudFNlcnZpY2UpXG4gICAgXSwgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdwYWdpbmF0aW9uUHJveHknKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHBhZ2luYXRpb25Qcm94eV8xLlBhZ2luYXRpb25Qcm94eSlcbiAgICBdLCBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUsIFwicGFnaW5hdGlvblByb3h5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3Jvd1JlbmRlcmVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCByb3dSZW5kZXJlcl8xLlJvd1JlbmRlcmVyKVxuICAgIF0sIFBhZ2luYXRpb25Db21wLnByb3RvdHlwZSwgXCJyb3dSZW5kZXJlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdidEZpcnN0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MQnV0dG9uRWxlbWVudClcbiAgICBdLCBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUsIFwiYnRGaXJzdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdidFByZXZpb3VzJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MQnV0dG9uRWxlbWVudClcbiAgICBdLCBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUsIFwiYnRQcmV2aW91c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdidE5leHQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxCdXR0b25FbGVtZW50KVxuICAgIF0sIFBhZ2luYXRpb25Db21wLnByb3RvdHlwZSwgXCJidE5leHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5SZWZTZWxlY3RvcignYnRMYXN0JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MQnV0dG9uRWxlbWVudClcbiAgICBdLCBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUsIFwiYnRMYXN0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbXBvbmVudEFubm90YXRpb25zXzEuUmVmU2VsZWN0b3IoJ2xiUmVjb3JkQ291bnQnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQYWdpbmF0aW9uQ29tcC5wcm90b3R5cGUsIFwibGJSZWNvcmRDb3VudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdsYkZpcnN0Um93T25QYWdlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLCBcImxiRmlyc3RSb3dPblBhZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5SZWZTZWxlY3RvcignbGJMYXN0Um93T25QYWdlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLCBcImxiTGFzdFJvd09uUGFnZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdlU3VtbWFyeVBhbmVsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLCBcImVTdW1tYXJ5UGFuZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29tcG9uZW50QW5ub3RhdGlvbnNfMS5SZWZTZWxlY3RvcignbGJDdXJyZW50JyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLCBcImxiQ3VycmVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb21wb25lbnRBbm5vdGF0aW9uc18xLlJlZlNlbGVjdG9yKCdsYlRvdGFsJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLCBcImxiVG90YWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLlBvc3RDb25zdHJ1Y3QsXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgUGFnaW5hdGlvbkNvbXAucHJvdG90eXBlLCBcInBvc3RDb25zdHJ1Y3RcIiwgbnVsbCk7XG4gICAgcmV0dXJuIFBhZ2luYXRpb25Db21wO1xufShjb21wb25lbnRfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuUGFnaW5hdGlvbkNvbXAgPSBQYWdpbmF0aW9uQ29tcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hZy1ncmlkL2Rpc3QvbGliL3Jvd01vZGVscy9wYWdpbmF0aW9uL3BhZ2luYXRpb25Db21wLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBhZy1ncmlkIC0gQWR2YW5jZWQgRGF0YSBHcmlkIC8gRGF0YSBUYWJsZSBzdXBwb3J0aW5nIEphdmFzY3JpcHQgLyBSZWFjdCAvIEFuZ3VsYXJKUyAvIFdlYiBDb21wb25lbnRzXG4gKiBAdmVyc2lvbiB2MTQuMC4xXG4gKiBAbGluayBodHRwOi8vd3d3LmFnLWdyaWQuY29tL1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByb3dOb2RlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvcm93Tm9kZVwiKTtcbnZhciBpbk1lbW9yeU5vZGVNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi4vcm93TW9kZWxzL2luTWVtb3J5L2luTWVtb3J5Tm9kZU1hbmFnZXJcIik7XG52YXIgZ3JpZE9wdGlvbnNXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JpZE9wdGlvbnNXcmFwcGVyXCIpO1xudmFyIGV2ZW50U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2V2ZW50U2VydmljZVwiKTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGNvbHVtbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9jb2x1bW5Db250cm9sbGVyL2NvbHVtbkNvbnRyb2xsZXJcIik7XG52YXIgUm93Tm9kZUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvd05vZGVGYWN0b3J5KCkge1xuICAgIH1cbiAgICBSb3dOb2RlRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gbmV3IHJvd05vZGVfMS5Sb3dOb2RlKCk7XG4gICAgICAgIHZhciBub2RlTWFuYWdlciA9IG5ldyBpbk1lbW9yeU5vZGVNYW5hZ2VyXzEuSW5NZW1vcnlOb2RlTWFuYWdlcihyb290Tm9kZSwgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIsIHRoaXMuY29udGV4dCwgdGhpcy5ldmVudFNlcnZpY2UsIHRoaXMuY29sdW1uQ29udHJvbGxlcik7XG4gICAgICAgIHRoaXMuY29udGV4dC53aXJlQmVhbihyb290Tm9kZSk7XG4gICAgICAgIG5vZGVNYW5hZ2VyLnNldFJvd0RhdGEoZGF0YSk7XG4gICAgICAgIHJldHVybiByb290Tm9kZTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdncmlkT3B0aW9uc1dyYXBwZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGdyaWRPcHRpb25zV3JhcHBlcl8xLkdyaWRPcHRpb25zV3JhcHBlcilcbiAgICBdLCBSb3dOb2RlRmFjdG9yeS5wcm90b3R5cGUsIFwiZ3JpZE9wdGlvbnNXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIFJvd05vZGVGYWN0b3J5LnByb3RvdHlwZSwgXCJldmVudFNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29udGV4dCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29udGV4dF8xLkNvbnRleHQpXG4gICAgXSwgUm93Tm9kZUZhY3RvcnkucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkF1dG93aXJlZCgnY29sdW1uQ29udHJvbGxlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29sdW1uQ29udHJvbGxlcl8xLkNvbHVtbkNvbnRyb2xsZXIpXG4gICAgXSwgUm93Tm9kZUZhY3RvcnkucHJvdG90eXBlLCBcImNvbHVtbkNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcbiAgICBSb3dOb2RlRmFjdG9yeSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQmVhbihcInJvd05vZGVGYWN0b3J5XCIpXG4gICAgXSwgUm93Tm9kZUZhY3RvcnkpO1xuICAgIHJldHVybiBSb3dOb2RlRmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLlJvd05vZGVGYWN0b3J5ID0gUm93Tm9kZUZhY3Rvcnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWctZ3JpZC9kaXN0L2xpYi9yb3dOb2Rlcy9yb3dOb2RlRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogYWctZ3JpZCAtIEFkdmFuY2VkIERhdGEgR3JpZCAvIERhdGEgVGFibGUgc3VwcG9ydGluZyBKYXZhc2NyaXB0IC8gUmVhY3QgLyBBbmd1bGFySlMgLyBXZWIgQ29tcG9uZW50c1xuICogQHZlcnNpb24gdjE0LjAuMVxuICogQGxpbmsgaHR0cDovL3d3dy5hZy1ncmlkLmNvbS9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jb250ZXh0XCIpO1xudmFyIGdyaWRPcHRpb25zV3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL2dyaWRPcHRpb25zV3JhcHBlclwiKTtcbnZhciBjaGFuZ2VkUGF0aF8xID0gcmVxdWlyZShcIi4uL3Jvd01vZGVscy9pbk1lbW9yeS9jaGFuZ2VkUGF0aFwiKTtcbnZhciByb3dSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uL3JlbmRlcmluZy9yb3dSZW5kZXJlclwiKTtcbnZhciBldmVudFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9ldmVudFNlcnZpY2VcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIGJlYW5TdHViXzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9iZWFuU3R1YlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi9ldmVudHNcIik7XG52YXIgQ2hhbmdlRGV0ZWN0aW9uU2VydmljZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENoYW5nZURldGVjdGlvblNlcnZpY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0aW9uU2VydmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDaGFuZ2VEZXRlY3Rpb25TZXJ2aWNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yb3dNb2RlbC5nZXRUeXBlKCkgPT09IGNvbnN0YW50c18xLkNvbnN0YW50cy5ST1dfTU9ERUxfVFlQRV9JTl9NRU1PUlkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5NZW1vcnlSb3dNb2RlbCA9IHRoaXMucm93TW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFNlcnZpY2UsIGV2ZW50c18xLkV2ZW50cy5FVkVOVF9DRUxMX1ZBTFVFX0NIQU5HRUQsIHRoaXMub25DZWxsVmFsdWVDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU2VydmljZS5wcm90b3R5cGUub25DZWxsVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZG9DaGFuZ2VEZXRlY3Rpb24oZXZlbnQubm9kZSwgZXZlbnQuY29sdW1uKTtcbiAgICB9O1xuICAgIENoYW5nZURldGVjdGlvblNlcnZpY2UucHJvdG90eXBlLmRvQ2hhbmdlRGV0ZWN0aW9uID0gZnVuY3Rpb24gKHJvd05vZGUsIGNvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNTdXBwcmVzc0NoYW5nZURldGVjdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RlcCAxIG9mIGNoYW5nZSBkZXRlY3Rpb24gaXMgdG8gdXBkYXRlIHRoZSBhZ2dyZWdhdGVkIHZhbHVlc1xuICAgICAgICBpZiAodGhpcy5pbk1lbW9yeVJvd01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZFBhdGggPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocm93Tm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25seUNoYW5nZWRDb2x1bW5zID0gdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNBZ2dyZWdhdGVPbmx5Q2hhbmdlZENvbHVtbnMoKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkUGF0aCA9IG5ldyBjaGFuZ2VkUGF0aF8xLkNoYW5nZWRQYXRoKG9ubHlDaGFuZ2VkQ29sdW1ucyk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZFBhdGguYWRkUGFyZW50Tm9kZShyb3dOb2RlLnBhcmVudCwgW2NvbHVtbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbk1lbW9yeVJvd01vZGVsLmRvQWdncmVnYXRlKGNoYW5nZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwIDIgb2YgY2hhbmdlIGRldGVjdGlvbiBpcyB0byByZWZyZXNoIHRoZSBjZWxsc1xuICAgICAgICB0aGlzLnJvd1JlbmRlcmVyLnJlZnJlc2hDZWxscygpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZ3JpZE9wdGlvbnNXcmFwcGVyXzEuR3JpZE9wdGlvbnNXcmFwcGVyKVxuICAgIF0sIENoYW5nZURldGVjdGlvblNlcnZpY2UucHJvdG90eXBlLCBcImdyaWRPcHRpb25zV3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuQXV0b3dpcmVkKCdyb3dNb2RlbCcpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENoYW5nZURldGVjdGlvblNlcnZpY2UucHJvdG90eXBlLCBcInJvd01vZGVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ3Jvd1JlbmRlcmVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCByb3dSZW5kZXJlcl8xLlJvd1JlbmRlcmVyKVxuICAgIF0sIENoYW5nZURldGVjdGlvblNlcnZpY2UucHJvdG90eXBlLCBcInJvd1JlbmRlcmVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbnRleHRfMS5BdXRvd2lyZWQoJ2V2ZW50U2VydmljZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXZlbnRTZXJ2aWNlXzEuRXZlbnRTZXJ2aWNlKVxuICAgIF0sIENoYW5nZURldGVjdGlvblNlcnZpY2UucHJvdG90eXBlLCBcImV2ZW50U2VydmljZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb250ZXh0XzEuUG9zdENvbnN0cnVjdCxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBDaGFuZ2VEZXRlY3Rpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJpbml0XCIsIG51bGwpO1xuICAgIENoYW5nZURldGVjdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29udGV4dF8xLkJlYW4oJ2NoYW5nZURldGVjdGlvblNlcnZpY2UnKVxuICAgIF0sIENoYW5nZURldGVjdGlvblNlcnZpY2UpO1xuICAgIHJldHVybiBDaGFuZ2VEZXRlY3Rpb25TZXJ2aWNlO1xufShiZWFuU3R1Yl8xLkJlYW5TdHViKSk7XG5leHBvcnRzLkNoYW5nZURldGVjdGlvblNlcnZpY2UgPSBDaGFuZ2VEZXRlY3Rpb25TZXJ2aWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FnLWdyaWQvZGlzdC9saWIvdmFsdWVTZXJ2aWNlL2NoYW5nZURldGVjdGlvblNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAncmVhY3QtcmVkdXgnO1xyXG5pbXBvcnQgeyByZW5kZXJUb1N0cmluZyB9IGZyb20gJ3JlYWN0LWRvbS9zZXJ2ZXInO1xyXG5pbXBvcnQgeyBTdGF0aWNSb3V0ZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuaW1wb3J0IHsgcmVwbGFjZSB9IGZyb20gJ3JlYWN0LXJvdXRlci1yZWR1eCc7XHJcbmltcG9ydCB7IGNyZWF0ZU1lbW9yeUhpc3RvcnkgfSBmcm9tICdoaXN0b3J5JztcclxuaW1wb3J0IHsgY3JlYXRlU2VydmVyUmVuZGVyZXIsIFJlbmRlclJlc3VsdCB9IGZyb20gJ2FzcG5ldC1wcmVyZW5kZXJpbmcnO1xyXG5pbXBvcnQgeyByb3V0ZXMgfSBmcm9tICcuL3JvdXRlcyc7XHJcbmltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tICcuL2NvbmZpZ3VyZVN0b3JlJztcclxuaW1wb3J0IENsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyIGZyb20gJy4vY29udGFpbmVycy9jbGllbnRDb21taXNzaW9uTGlzdENvbnRhaW5lci9jbGllbnRDb21taXNzaW9uTGlzdENvbnRhaW5lcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTZXJ2ZXJSZW5kZXJlcihwYXJhbXMgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFJlbmRlclJlc3VsdD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIC8vIFByZXBhcmUgUmVkdXggc3RvcmUgd2l0aCBpbi1tZW1vcnkgaGlzdG9yeSwgYW5kIGRpc3BhdGNoIGEgbmF2aWdhdGlvbiBldmVudFxyXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGluY29taW5nIFVSTFxyXG4gICAgICAgIGNvbnN0IGJhc2VuYW1lID0gcGFyYW1zLmJhc2VVcmwuc3Vic3RyaW5nKDAsIHBhcmFtcy5iYXNlVXJsLmxlbmd0aCAtIDEpOyAvLyBSZW1vdmUgdHJhaWxpbmcgc2xhc2hcclxuICAgICAgICBjb25zdCB1cmxBZnRlckJhc2VuYW1lID0gcGFyYW1zLnVybC5zdWJzdHJpbmcoYmFzZW5hbWUubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IGNvbmZpZ3VyZVN0b3JlKGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSk7XHJcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2gocmVwbGFjZSh1cmxBZnRlckJhc2VuYW1lKSk7XHJcblxyXG4gICAgICAgIC8vIFByZXBhcmUgYW4gaW5zdGFuY2Ugb2YgdGhlIGFwcGxpY2F0aW9uIGFuZCBwZXJmb3JtIGFuIGluaXRhbCByZW5kZXIgdGhhdCB3aWxsXHJcbiAgICAgICAgLy8gY2F1c2UgYW55IGFzeW5jIHRhc2tzIChlLmcuLCBkYXRhIGFjY2VzcykgdG8gYmVnaW5cclxuICAgICAgICBjb25zdCByb3V0ZXJDb250ZXh0OiBhbnkgPSB7fTtcclxuICAgICAgICBjb25zdCBhcHAgPSAoXHJcbiAgICAgICAgICAgIDxQcm92aWRlciBzdG9yZT17IHN0b3JlIH0+XHJcbiAgICAgICAgICAgICAgIDxDbGllbnRDb21taXNzaW9uTGlzdENvbnRhaW5lciAvPlxyXG4gICAgICAgICAgICA8L1Byb3ZpZGVyPlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmVuZGVyVG9TdHJpbmcoYXBwKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJlZGlyZWN0aW9uLCBqdXN0IHNlbmQgdGhpcyBpbmZvcm1hdGlvbiBiYWNrIHRvIHRoZSBob3N0IGFwcGxpY2F0aW9uXHJcbiAgICAgICAgaWYgKHJvdXRlckNvbnRleHQudXJsKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoeyByZWRpcmVjdFVybDogcm91dGVyQ29udGV4dC51cmwgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gT25jZSBhbnkgYXN5bmMgdGFza3MgYXJlIGRvbmUsIHdlIGNhbiBwZXJmb3JtIHRoZSBmaW5hbCByZW5kZXJcclxuICAgICAgICAvLyBXZSBhbHNvIHNlbmQgdGhlIHJlZHV4IHN0b3JlIHN0YXRlLCBzbyB0aGUgY2xpZW50IGNhbiBjb250aW51ZSBleGVjdXRpb24gd2hlcmUgdGhlIHNlcnZlciBsZWZ0IG9mZlxyXG4gICAgICAgIHBhcmFtcy5kb21haW5UYXNrcy50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICBodG1sOiByZW5kZXJUb1N0cmluZyhhcHApLFxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsczogeyBpbml0aWFsUmVkdXhTdGF0ZTogc3RvcmUuZ2V0U3RhdGUoKSB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIHJlamVjdCk7IC8vIEFsc28gcHJvcGFnYXRlIGFueSBlcnJvcnMgYmFjayBpbnRvIHRoZSBob3N0IGFwcGxpY2F0aW9uXHJcbiAgICB9KTtcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ib290LXNlcnZlci50c3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0ICdhZy1ncmlkL2Rpc3Qvc3R5bGVzL2FnLWdyaWQuY3NzJztcclxuaW1wb3J0ICdhZy1ncmlkL2Rpc3Qvc3R5bGVzL3RoZW1lLWZyZXNoLmNzcyc7XHJcbmltcG9ydCB7IEFnR3JpZFJlYWN0IH0gZnJvbSAnYWctZ3JpZC1yZWFjdCc7XHJcbmltcG9ydCB7IENvbHVtbkFwaSwgR3JpZEFwaSB9IGZyb20gXCJhZy1ncmlkXCI7XHJcbmludGVyZmFjZSBWYWxpY0dyaWRTdGF0ZSB7XHJcbiAgICByb3dEYXRhOiBhbnlbXSxcclxuICAgIGNvbHVtbkRlZnM6IGFueVtdXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xpZW50TGlzdENvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxhbnksIFZhbGljR3JpZFN0YXRlPnsgICBcclxuICAgIHByaXZhdGUgZ3JpZEFwaTogR3JpZEFwaTtcclxuICAgIHByaXZhdGUgY29sdW1uQXBpOiBDb2x1bW5BcGk7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogYW55KSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIC8vdGhpcy5wcm9wcy5yZWFjdENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICAgICAgICAvLyBjaGFuZ2UgdGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIGNvbnRhaW5pbmcgZGl2IHRvIGJlIHJlZFxyXG4gICAgICAgIC8vdGhpcy5wcm9wcy5yZWFjdENvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJlZFwiO1xyXG4gICAgICAgIHRoaXMub25HcmlkUmVhZHkgPSB0aGlzLm9uR3JpZFJlYWR5LmJpbmQodGhpcyk7XHJcbi8vICAgICAgICB0aGlzLmV4cG9ydERhdGFBc0V4Y2VsPSB0aGlzLmV4cG9ydERhdGFBc0V4Y2VsLmJpbmQodGhpcyk7XHJcbiAgICAgICAgLy90aGlzLmdldFJvd05vZGVJZCA9IHRoaXMuZ2V0Um93Tm9kZUlkLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgY29sdW1uRGVmczogdGhpcy5jcmVhdGVDb2x1bW5EZWZzKCksXHJcbiAgICAgICAgICAgIHJvd0RhdGE6IHRoaXMuY3JlYXRlUm93RGF0YSgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlQ29sdW1uRGVmcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7IGhlYWRlck5hbWU6IFwiTmFtZVwiLCBmaWVsZDogXCJtYWtlXCIgfSxcclxuICAgICAgICAgICAgeyBoZWFkZXJOYW1lOiBcIkNsaWVudCBJZFwiLCBmaWVsZDogXCJtb2RlbFwiIH0sXHJcbiAgICAgICAgICAgIHsgaGVhZGVyTmFtZTogXCJDbGllbnQgQXNzZXRzXCIsIGZpZWxkOiBcInByaWNlXCIgfSxcclxuICAgICAgICAgICAgeyBoZWFkZXJOYW1lOiBcIkFnZVwiLCBmaWVsZDogXCJtYWtlXCIgfSxcclxuICAgICAgICAgICAgeyBoZWFkZXJOYW1lOiBcIkJpcnRoIE1vbnRoXCIsIGZpZWxkOiBcIm1vZGVsXCIgfSxcclxuICAgICAgICAgICAgeyBoZWFkZXJOYW1lOiBcIkdlbmRlclwiLCBmaWVsZDogXCJwcmljZVwiIH0sXHJcbiAgICAgICAgICAgIHsgaGVhZGVyTmFtZTogXCJDbGllbnQgQWNxdWlzaXRpb24gRGF0ZVwiLCBmaWVsZDogXCJtYWtlXCIgfSxcclxuICAgICAgICAgICAgeyBoZWFkZXJOYW1lOiBcIkFkdmlzb3J5IFNlcnZpY2UgKEdQUyBNL0EpXCIsIGZpZWxkOiBcIm1vZGVsXCIgfSxcclxuICAgICAgICAgICAgeyBoZWFkZXJOYW1lOiBcIkNsaWVudCBSZXZpZXcgTW9udGhcIiwgZmllbGQ6IFwibW9kZWxcIiB9LFxyXG4gICAgICAgICAgICB7IGhlYWRlck5hbWU6IFwiTGFzdCBDbGllbnQgUmV2aWV3IERhdGVcIiwgZmllbGQ6IFwicHJpY2VcIiB9XHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVSb3dEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHsgbWFrZTogXCJUb3lvdGFcIiwgbW9kZWw6IFwiQ2VsaWNhXCIsIHByaWNlOiAzNTAwMCB9LFxyXG4gICAgICAgICAgICB7IG1ha2U6IFwiRm9yZFwiLCBtb2RlbDogXCJNb25kZW9cIiwgcHJpY2U6IDMyMDAwIH0sXHJcbiAgICAgICAgICAgIHsgbWFrZTogXCJQb3JzY2hlXCIsIG1vZGVsOiBcIkJveHRlclwiLCBwcmljZTogNzIwMDAgfSxcclxuICAgICAgICAgICAgeyBtYWtlOiBcIlRveW90YVwiLCBtb2RlbDogXCJDZWxpY2FcIiwgcHJpY2U6IDM1MDAwIH0sXHJcbiAgICAgICAgICAgIHsgbWFrZTogXCJGb3JkXCIsIG1vZGVsOiBcIk1vbmRlb1wiLCBwcmljZTogMzIwMDAgfSxcclxuICAgICAgICAgICAgeyBtYWtlOiBcIlBvcnNjaGVcIiwgbW9kZWw6IFwiQm94dGVyXCIsIHByaWNlOiA3MjAwMCB9LFxyXG4gICAgICAgICAgICB7IG1ha2U6IFwiVG95b3RhXCIsIG1vZGVsOiBcIkNlbGljYVwiLCBwcmljZTogMzUwMDAgfSxcclxuICAgICAgICAgICAgeyBtYWtlOiBcIkZvcmRcIiwgbW9kZWw6IFwiTW9uZGVvXCIsIHByaWNlOiAzMjAwMCB9LFxyXG4gICAgICAgICAgICB7IG1ha2U6IFwiUG9yc2NoZVwiLCBtb2RlbDogXCJCb3h0ZXJcIiwgcHJpY2U6IDcyMDAwIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgXHJcbiAgICBvbkdyaWRSZWFkeShwYXJhbXM6IGFueSkge1xyXG4gICAgICAgIC8vdGhpcy5hcGkgPSBwYXJhbXMuYXBpO1xyXG4gICAgICAgIC8vdGhpcy5jb2x1bW5BcGkgPSBwYXJhbXMuY29sdW1uQXBpO1xyXG4gICAgICAgIHRoaXMuZ3JpZEFwaSA9IHBhcmFtcy5hcGk7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5BcGkgPSBwYXJhbXMuY29sdW1uQXBpO1xyXG5cclxuICAgICAgICB0aGlzLmdyaWRBcGkuc2l6ZUNvbHVtbnNUb0ZpdCgpO1xyXG4gICAgICAgIHRoaXMuZ3JpZEFwaS5leHBvcnREYXRhQXNFeGNlbCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Um93Tm9kZUlkKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gZGF0YS5zeW1ib2w7XHJcbiAgICB9XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy9yZXR1cm4gKDxkaXYgY2xhc3NOYW1lPVwiYWctZnJlc2hcIj5cclxuICAgICAgICAvLyAgICA8QWdHcmlkUmVhY3RcclxuICAgICAgICAvLyAgICAgICAgY29sdW1uRGVmcz17dGhpcy5wcm9wcy5jb2x1bW5EZWZzfVxyXG4gICAgICAgIC8vICAgIHJvd0RhdGE9e3RoaXMucHJvcHMucm93RGF0YX0gcm93U2VsZWN0aW9uPVwibXVsdGlwbGVcIlxyXG4gICAgICAgIC8vICAgIGVuYWJsZVNvcnRpbmc9dHJ1ZVxyXG4gICAgICAgIC8vICAgIGVuYWJsZUZpbHRlcj10cnVlXHJcbiAgICAgICAgLy8gICAgcm93SGVpZ2h0PVwiMjJcIlxyXG4gICAgICAgIC8vICAgIGVuYWJsZUltbXV0YWJsZU1vZGU9XCJ0cnVlXCJcclxuICAgICAgICAvLyAgICBnZXRSb3dOb2RlSWQ9e3RoaXMuZ2V0Um93Tm9kZUlkfSBcclxuICAgICAgICAvLyAgICBvbkdyaWRSZWFkeT17dGhpcy5vbkdyaWRSZWFkeX0gLz4gPC9kaXY+KTtcclxuICAgICAgICBsZXQgY29udGFpbmVyU3R5bGUgPSB7XHJcbiAgICAgICAgICAgIGhlaWdodDogNTAwLFxyXG4gICAgICAgICAgICB3aWR0aDogODAwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17Y29udGFpbmVyU3R5bGV9IGNsYXNzTmFtZT1cImFnLWZyZXNoXCI+XHJcbiAgICAgICAgICAgICAgICA8aDE+Q2xpZW50IExpc3Q6PC9oMT5cclxuICAgICAgICAgICAgICAgIDxBZ0dyaWRSZWFjdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkRlZnM9e3RoaXMuc3RhdGUuY29sdW1uRGVmc31cclxuICAgICAgICAgICAgICAgICAgICByb3dEYXRhPXt0aGlzLnN0YXRlLnJvd0RhdGF9XHJcbmVuYWJsZUZpbHRlcj17dHJ1ZX1cclxuZW5hYmxlU29ydGluZz17dHJ1ZX0gXHJcbnJvd1NlbGVjdGlvbj17XCJNdWx0aXBsZVwifVxyXG5lbmFibGVDb2xSZXNpemUgPSB7dHJ1ZX0gXHJcbmFuaW1hdGVSb3dzPXt0cnVlfSBcclxuZW5hYmxlUmFuZ2VTZWxlY3Rpb249e3RydWV9XHJcbnBhZ2luYXRpb24gPXt0cnVlfVxyXG5wYWdpbmF0aW9uUGFnZVNpemUgPXs1fVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvbkdyaWRSZWFkeT17dGhpcy5vbkdyaWRSZWFkeX0+XHJcbiAgICAgICAgICAgICAgICA8L0FnR3JpZFJlYWN0PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9DbGllbnRMaXN0Q29tcG9uZW50L0NsaWVudExpc3RDb21wb25lbnQudHN4IiwiIGltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XHJcbmltcG9ydCB7IExpbmssIFJvdXRlQ29tcG9uZW50UHJvcHMgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcclxuaW1wb3J0ICcuL0NsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyLmNzcyc7XHJcbmltcG9ydCB7IEFwcGxpY2F0aW9uU3RhdGUgfSBmcm9tICcuLi8uLi9zdG9yZSc7XHJcbmltcG9ydCAqIGFzIExvYWRlclN0b3JlIGZyb20gJy4uLy4uL3N0b3JlL2xvYWRlcic7XHJcbmltcG9ydCB7Q2xpZW50TGlzdENvbnRhaW5lcn0gZnJvbSAnLi9DbGllbnRMaXN0Q29udGFpbmVyJztcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgQ2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXIgZXh0ZW5kcyBDb21wb25lbnQ8YW55LCBhbnk+IHtcclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIHRoaXMucHJvcHMuY29tcG9uZW50RGlkTW91bnQoKTtcclxuICAgIH0gIFxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcblx0XHQ8ZGl2PlxyXG4gICAgICAgICAgICA8Q2xpZW50TGlzdENvbnRhaW5lciAvPjwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlOiBBcHBsaWNhdGlvblN0YXRlKSA9PiAoeyAgIFxyXG4gICAgaXNMb2FkaW5nOiBzdGF0ZS5pc0xvYWRpbmdcclxufSlcclxuZXhwb3J0IGNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IChkaXNwYXRjaCkgPT4gKHtcclxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcclxuICAgIH1cclxufSlcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMpKENsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyKSBhcyB0eXBlb2YgQ2xpZW50Q29tbWlzc2lvbkxpc3RDb250YWluZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb250YWluZXJzL2NsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyL0NsaWVudENvbW1pc3Npb25MaXN0Q29udGFpbmVyLnRzeCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4oZnVuY3Rpb24oZikge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKHJlcXVpcmUoJ3JlYWN0JykpO1xuICAgIC8qIGdsb2JhbCBkZWZpbmUgKi9cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydyZWFjdCddLCBmKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZztcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGcgPSB3aW5kb3c7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZyA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZyA9IHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGcgPSB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZy5SZWFjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IEVycm9yKCdSZWFjdCBtb2R1bGUgc2hvdWxkIGJlIHJlcXVpcmVkIGJlZm9yZSBSZWFjdERPTUZhY3RvcmllcycpO1xuICAgIH1cblxuICAgIGcuUmVhY3RET01GYWN0b3JpZXMgPSBmKGcuUmVhY3QpO1xuICB9XG59KShmdW5jdGlvbihSZWFjdCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgSFRNTCB0YWcgZWxlbWVudHMuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVET01GYWN0b3J5KHR5cGUpIHtcbiAgICB2YXIgZmFjdG9yeSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gICAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gICAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gZmFjdG9yeTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAgICovXG4gIHZhciBSZWFjdERPTUZhY3RvcmllcyA9IHtcbiAgICBhOiBjcmVhdGVET01GYWN0b3J5KCdhJyksXG4gICAgYWJicjogY3JlYXRlRE9NRmFjdG9yeSgnYWJicicpLFxuICAgIGFkZHJlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ2FkZHJlc3MnKSxcbiAgICBhcmVhOiBjcmVhdGVET01GYWN0b3J5KCdhcmVhJyksXG4gICAgYXJ0aWNsZTogY3JlYXRlRE9NRmFjdG9yeSgnYXJ0aWNsZScpLFxuICAgIGFzaWRlOiBjcmVhdGVET01GYWN0b3J5KCdhc2lkZScpLFxuICAgIGF1ZGlvOiBjcmVhdGVET01GYWN0b3J5KCdhdWRpbycpLFxuICAgIGI6IGNyZWF0ZURPTUZhY3RvcnkoJ2InKSxcbiAgICBiYXNlOiBjcmVhdGVET01GYWN0b3J5KCdiYXNlJyksXG4gICAgYmRpOiBjcmVhdGVET01GYWN0b3J5KCdiZGknKSxcbiAgICBiZG86IGNyZWF0ZURPTUZhY3RvcnkoJ2JkbycpLFxuICAgIGJpZzogY3JlYXRlRE9NRmFjdG9yeSgnYmlnJyksXG4gICAgYmxvY2txdW90ZTogY3JlYXRlRE9NRmFjdG9yeSgnYmxvY2txdW90ZScpLFxuICAgIGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JvZHknKSxcbiAgICBicjogY3JlYXRlRE9NRmFjdG9yeSgnYnInKSxcbiAgICBidXR0b246IGNyZWF0ZURPTUZhY3RvcnkoJ2J1dHRvbicpLFxuICAgIGNhbnZhczogY3JlYXRlRE9NRmFjdG9yeSgnY2FudmFzJyksXG4gICAgY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnY2FwdGlvbicpLFxuICAgIGNpdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpdGUnKSxcbiAgICBjb2RlOiBjcmVhdGVET01GYWN0b3J5KCdjb2RlJyksXG4gICAgY29sOiBjcmVhdGVET01GYWN0b3J5KCdjb2wnKSxcbiAgICBjb2xncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnY29sZ3JvdXAnKSxcbiAgICBkYXRhOiBjcmVhdGVET01GYWN0b3J5KCdkYXRhJyksXG4gICAgZGF0YWxpc3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGFsaXN0JyksXG4gICAgZGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2RkJyksXG4gICAgZGVsOiBjcmVhdGVET01GYWN0b3J5KCdkZWwnKSxcbiAgICBkZXRhaWxzOiBjcmVhdGVET01GYWN0b3J5KCdkZXRhaWxzJyksXG4gICAgZGZuOiBjcmVhdGVET01GYWN0b3J5KCdkZm4nKSxcbiAgICBkaWFsb2c6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpYWxvZycpLFxuICAgIGRpdjogY3JlYXRlRE9NRmFjdG9yeSgnZGl2JyksXG4gICAgZGw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RsJyksXG4gICAgZHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2R0JyksXG4gICAgZW06IGNyZWF0ZURPTUZhY3RvcnkoJ2VtJyksXG4gICAgZW1iZWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2VtYmVkJyksXG4gICAgZmllbGRzZXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZWxkc2V0JyksXG4gICAgZmlnY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnZmlnY2FwdGlvbicpLFxuICAgIGZpZ3VyZTogY3JlYXRlRE9NRmFjdG9yeSgnZmlndXJlJyksXG4gICAgZm9vdGVyOiBjcmVhdGVET01GYWN0b3J5KCdmb290ZXInKSxcbiAgICBmb3JtOiBjcmVhdGVET01GYWN0b3J5KCdmb3JtJyksXG4gICAgaDE6IGNyZWF0ZURPTUZhY3RvcnkoJ2gxJyksXG4gICAgaDI6IGNyZWF0ZURPTUZhY3RvcnkoJ2gyJyksXG4gICAgaDM6IGNyZWF0ZURPTUZhY3RvcnkoJ2gzJyksXG4gICAgaDQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2g0JyksXG4gICAgaDU6IGNyZWF0ZURPTUZhY3RvcnkoJ2g1JyksXG4gICAgaDY6IGNyZWF0ZURPTUZhY3RvcnkoJ2g2JyksXG4gICAgaGVhZDogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZCcpLFxuICAgIGhlYWRlcjogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZGVyJyksXG4gICAgaGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdoZ3JvdXAnKSxcbiAgICBocjogY3JlYXRlRE9NRmFjdG9yeSgnaHInKSxcbiAgICBodG1sOiBjcmVhdGVET01GYWN0b3J5KCdodG1sJyksXG4gICAgaTogY3JlYXRlRE9NRmFjdG9yeSgnaScpLFxuICAgIGlmcmFtZTogY3JlYXRlRE9NRmFjdG9yeSgnaWZyYW1lJyksXG4gICAgaW1nOiBjcmVhdGVET01GYWN0b3J5KCdpbWcnKSxcbiAgICBpbnB1dDogY3JlYXRlRE9NRmFjdG9yeSgnaW5wdXQnKSxcbiAgICBpbnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucycpLFxuICAgIGtiZDogY3JlYXRlRE9NRmFjdG9yeSgna2JkJyksXG4gICAga2V5Z2VuOiBjcmVhdGVET01GYWN0b3J5KCdrZXlnZW4nKSxcbiAgICBsYWJlbDogY3JlYXRlRE9NRmFjdG9yeSgnbGFiZWwnKSxcbiAgICBsZWdlbmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xlZ2VuZCcpLFxuICAgIGxpOiBjcmVhdGVET01GYWN0b3J5KCdsaScpLFxuICAgIGxpbms6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmsnKSxcbiAgICBtYWluOiBjcmVhdGVET01GYWN0b3J5KCdtYWluJyksXG4gICAgbWFwOiBjcmVhdGVET01GYWN0b3J5KCdtYXAnKSxcbiAgICBtYXJrOiBjcmVhdGVET01GYWN0b3J5KCdtYXJrJyksXG4gICAgbWVudTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudScpLFxuICAgIG1lbnVpdGVtOiBjcmVhdGVET01GYWN0b3J5KCdtZW51aXRlbScpLFxuICAgIG1ldGE6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGEnKSxcbiAgICBtZXRlcjogY3JlYXRlRE9NRmFjdG9yeSgnbWV0ZXInKSxcbiAgICBuYXY6IGNyZWF0ZURPTUZhY3RvcnkoJ25hdicpLFxuICAgIG5vc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdub3NjcmlwdCcpLFxuICAgIG9iamVjdDogY3JlYXRlRE9NRmFjdG9yeSgnb2JqZWN0JyksXG4gICAgb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ29sJyksXG4gICAgb3B0Z3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGdyb3VwJyksXG4gICAgb3B0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdvcHRpb24nKSxcbiAgICBvdXRwdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ291dHB1dCcpLFxuICAgIHA6IGNyZWF0ZURPTUZhY3RvcnkoJ3AnKSxcbiAgICBwYXJhbTogY3JlYXRlRE9NRmFjdG9yeSgncGFyYW0nKSxcbiAgICBwaWN0dXJlOiBjcmVhdGVET01GYWN0b3J5KCdwaWN0dXJlJyksXG4gICAgcHJlOiBjcmVhdGVET01GYWN0b3J5KCdwcmUnKSxcbiAgICBwcm9ncmVzczogY3JlYXRlRE9NRmFjdG9yeSgncHJvZ3Jlc3MnKSxcbiAgICBxOiBjcmVhdGVET01GYWN0b3J5KCdxJyksXG4gICAgcnA6IGNyZWF0ZURPTUZhY3RvcnkoJ3JwJyksXG4gICAgcnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3J0JyksXG4gICAgcnVieTogY3JlYXRlRE9NRmFjdG9yeSgncnVieScpLFxuICAgIHM6IGNyZWF0ZURPTUZhY3RvcnkoJ3MnKSxcbiAgICBzYW1wOiBjcmVhdGVET01GYWN0b3J5KCdzYW1wJyksXG4gICAgc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdzY3JpcHQnKSxcbiAgICBzZWN0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdzZWN0aW9uJyksXG4gICAgc2VsZWN0OiBjcmVhdGVET01GYWN0b3J5KCdzZWxlY3QnKSxcbiAgICBzbWFsbDogY3JlYXRlRE9NRmFjdG9yeSgnc21hbGwnKSxcbiAgICBzb3VyY2U6IGNyZWF0ZURPTUZhY3RvcnkoJ3NvdXJjZScpLFxuICAgIHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3NwYW4nKSxcbiAgICBzdHJvbmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0cm9uZycpLFxuICAgIHN0eWxlOiBjcmVhdGVET01GYWN0b3J5KCdzdHlsZScpLFxuICAgIHN1YjogY3JlYXRlRE9NRmFjdG9yeSgnc3ViJyksXG4gICAgc3VtbWFyeTogY3JlYXRlRE9NRmFjdG9yeSgnc3VtbWFyeScpLFxuICAgIHN1cDogY3JlYXRlRE9NRmFjdG9yeSgnc3VwJyksXG4gICAgdGFibGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RhYmxlJyksXG4gICAgdGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rib2R5JyksXG4gICAgdGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RkJyksXG4gICAgdGV4dGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHRhcmVhJyksXG4gICAgdGZvb3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rmb290JyksXG4gICAgdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoJyksXG4gICAgdGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoZWFkJyksXG4gICAgdGltZTogY3JlYXRlRE9NRmFjdG9yeSgndGltZScpLFxuICAgIHRpdGxlOiBjcmVhdGVET01GYWN0b3J5KCd0aXRsZScpLFxuICAgIHRyOiBjcmVhdGVET01GYWN0b3J5KCd0cicpLFxuICAgIHRyYWNrOiBjcmVhdGVET01GYWN0b3J5KCd0cmFjaycpLFxuICAgIHU6IGNyZWF0ZURPTUZhY3RvcnkoJ3UnKSxcbiAgICB1bDogY3JlYXRlRE9NRmFjdG9yeSgndWwnKSxcbiAgICB2YXI6IGNyZWF0ZURPTUZhY3RvcnkoJ3ZhcicpLFxuICAgIHZpZGVvOiBjcmVhdGVET01GYWN0b3J5KCd2aWRlbycpLFxuICAgIHdicjogY3JlYXRlRE9NRmFjdG9yeSgnd2JyJyksXG5cbiAgICAvLyBTVkdcbiAgICBjaXJjbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpcmNsZScpLFxuICAgIGNsaXBQYXRoOiBjcmVhdGVET01GYWN0b3J5KCdjbGlwUGF0aCcpLFxuICAgIGRlZnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlZnMnKSxcbiAgICBlbGxpcHNlOiBjcmVhdGVET01GYWN0b3J5KCdlbGxpcHNlJyksXG4gICAgZzogY3JlYXRlRE9NRmFjdG9yeSgnZycpLFxuICAgIGltYWdlOiBjcmVhdGVET01GYWN0b3J5KCdpbWFnZScpLFxuICAgIGxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmUnKSxcbiAgICBsaW5lYXJHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgnbGluZWFyR3JhZGllbnQnKSxcbiAgICBtYXNrOiBjcmVhdGVET01GYWN0b3J5KCdtYXNrJyksXG4gICAgcGF0aDogY3JlYXRlRE9NRmFjdG9yeSgncGF0aCcpLFxuICAgIHBhdHRlcm46IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdHRlcm4nKSxcbiAgICBwb2x5Z29uOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5Z29uJyksXG4gICAgcG9seWxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlsaW5lJyksXG4gICAgcmFkaWFsR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3JhZGlhbEdyYWRpZW50JyksXG4gICAgcmVjdDogY3JlYXRlRE9NRmFjdG9yeSgncmVjdCcpLFxuICAgIHN0b3A6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0b3AnKSxcbiAgICBzdmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N2ZycpLFxuICAgIHRleHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHQnKSxcbiAgICB0c3BhbjogY3JlYXRlRE9NRmFjdG9yeSgndHNwYW4nKSxcbiAgfTtcblxuICAvLyBkdWUgdG8gd3JhcHBlciBhbmQgY29uZGl0aW9uYWxzIGF0IHRoZSB0b3AsIHRoaXMgd2lsbCBlaXRoZXIgYmVjb21lXG4gIC8vIGBtb2R1bGUuZXhwb3J0cyBSZWFjdERPTUZhY3Rvcmllc2AgaWYgdGhhdCBpcyBhdmFpbGFibGUsXG4gIC8vIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRlZmluZWQgdmlhIGBkZWZpbmUoWydyZWFjdCddLCBSZWFjdERPTUZhY3RvcmllcylgXG4gIC8vIGlmIHRoYXQgaXMgYXZhaWxhYmxlLFxuICAvLyBvdGhlcndpc2UgaXQgd2lsbCBiZSBkZWZpbmVkIGFzIGdsb2JhbCB2YXJpYWJsZS5cbiAgcmV0dXJuIFJlYWN0RE9NRmFjdG9yaWVzO1xufSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20tZmFjdG9yaWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vaW1wb3J0ICogYXMgV2VhdGhlckZvcmVjYXN0cyBmcm9tICcuL1dlYXRoZXJGb3JlY2FzdHMnO1xyXG4vL2ltcG9ydCAqIGFzIENvdW50ZXIgZnJvbSAnLi9Db3VudGVyJztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTG9hZGVyID0gcmVxdWlyZShcIi4vbG9hZGVyXCIpO1xyXG4vLyBXaGVuZXZlciBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCwgUmVkdXggd2lsbCB1cGRhdGUgZWFjaCB0b3AtbGV2ZWwgYXBwbGljYXRpb24gc3RhdGUgcHJvcGVydHkgdXNpbmdcclxuLy8gdGhlIHJlZHVjZXIgd2l0aCB0aGUgbWF0Y2hpbmcgbmFtZS4gSXQncyBpbXBvcnRhbnQgdGhhdCB0aGUgbmFtZXMgbWF0Y2ggZXhhY3RseSwgYW5kIHRoYXQgdGhlIHJlZHVjZXJcclxuLy8gYWN0cyBvbiB0aGUgY29ycmVzcG9uZGluZyBBcHBsaWNhdGlvblN0YXRlIHByb3BlcnR5IHR5cGUuXHJcbmV4cG9ydHMucmVkdWNlcnMgPSB7XHJcbiAgICBpc0xvYWRpbmc6IExvYWRlci5yZWR1Y2VyXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0b3JlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5hY3Rpb25DcmVhdG9ycyA9IHtcclxuICAgIGxvYWRlckJlZ2luOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyB0eXBlOiAnTE9BREVSX0JFR0lOJyB9KTsgfSxcclxuICAgIGxvYWRlckVuZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgdHlwZTogJ0xPQURFUl9FTkQnIH0pOyB9XHJcbn07XHJcbmV4cG9ydHMucmVkdWNlciA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnTE9BREVSX0JFR0lOJzpcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgY2FzZSAnTE9BREVSX0VORCc6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGxpbmUgZ3VhcmFudGVlcyB0aGF0IGV2ZXJ5IGFjdGlvbiBpbiB0aGUgS25vd25BY3Rpb24gdW5pb24gaGFzIGJlZW4gY292ZXJlZCBieSBhIGNhc2UgYWJvdmVcclxuICAgICAgICAgICAgdmFyIGV4aGF1c3RpdmVDaGVjayA9IGFjdGlvbjtcclxuICAgIH1cclxuICAgIC8vIEZvciB1bnJlY29nbml6ZWQgYWN0aW9ucyAob3IgaW4gY2FzZXMgd2hlcmUgYWN0aW9ucyBoYXZlIG5vIGVmZmVjdCksIG11c3QgcmV0dXJuIHRoZSBleGlzdGluZyBzdGF0ZVxyXG4gICAgLy8gIChvciBkZWZhdWx0IGluaXRpYWwgc3RhdGUgaWYgbm9uZSB3YXMgc3VwcGxpZWQpXHJcbiAgICByZXR1cm4gc3RhdGUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogc3RhdGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0b3JlL2xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMTQpKSgxNDIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9hZy1ncmlkL2Rpc3Qvc3R5bGVzL2FnLWdyaWQuY3NzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMTQpKSgxNDMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9hZy1ncmlkL2Rpc3Qvc3R5bGVzL3RoZW1lLWZyZXNoLmNzcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSkoMTQ4KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMTQpKSgxNTMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpKDcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMTQpKSg3NSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2xpYi9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9